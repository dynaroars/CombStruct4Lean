{"id": "CombStruct4Lean_0", "informal_problem": "## Problem 3\n\nOn a board there are $n$ nails each two connected by a string. Each string is colored in one of $n$ given distinct colors. For each three distinct colors, there exist three nails connected with strings in these three colors. Prove that $n$ can be 6.", "formal_statement": "import Mathlib\n\nstructure ColoredCompleteGraph (n : Nat) where\n  getColor : Fin n \u2192 Fin n \u2192 Fin n\n  edge_order : \u2200 v\u2081 v\u2082, v\u2081.val < v\u2082.val \u2192 getColor v\u2081 v\u2082 = getColor v\u2082 v\u2081\n\n/-- A coloring is valid if all edge colors are within [0,n) -/\ndef valid_coloring (g : ColoredCompleteGraph n) : Prop :=\n  \u2200 v\u2081 v\u2082, v\u2081.val < v\u2082.val \u2192 g.getColor v\u2081 v\u2082 < n\n\n/-- Check if three vertices form a triangle with given colors -/\ndef has_triangle (g : ColoredCompleteGraph n) (c\u2081 c\u2082 c\u2083 : Fin n) : Prop :=\n  \u2203 (v\u2081 v\u2082 v\u2083 : Fin n), \n    v\u2081.val < v\u2082.val \u2227 v\u2082.val < v\u2083.val \u2227\n    (g.getColor v\u2081 v\u2082 = c\u2081 \u2227\n     g.getColor v\u2082 v\u2083 = c\u2082 \u2227\n     g.getColor v\u2081 v\u2083 = c\u2083)\n\n/-- Three colors are distinct -/\ndef distinct_colors (c\u2081 c\u2082 c\u2083 : Fin n) : Prop :=\n  c\u2081.val \u2260 c\u2082.val \u2227 c\u2082.val \u2260 c\u2083.val \u2227 c\u2081.val \u2260 c\u2083.val\n\ntheorem nail_graph_existence_six : \n  \u2203 (g : ColoredCompleteGraph 6), valid_coloring g \u2227\n    \u2200 (c\u2081 c\u2082 c\u2083 : Fin 6), distinct_colors c\u2081 c\u2082 c\u2083 \u2192 has_triangle g c\u2081 c\u2082 c\u2083 := \n  sorry"}
{"id": "CombStruct4Lean_1", "informal_problem": "## Problem 3\n\nOn a board there are $n$ nails each two connected by a string. Each string is colored in one of $n$ given distinct colors. For each three distinct colors, there exist three nails connected with strings in these three colors. Prove that $n$ cannot be 7.", "formal_statement": "import Mathlib\n\nstructure ColoredCompleteGraph (n : Nat) where\n  getColor : Fin n \u2192 Fin n \u2192 Fin n\n  edge_order : \u2200 v\u2081 v\u2082, v\u2081.val < v\u2082.val \u2192 getColor v\u2081 v\u2082 = getColor v\u2082 v\u2081\n\n/-- A coloring is valid if all edge colors are within [0,n) -/\ndef valid_coloring (g : ColoredCompleteGraph n) : Prop :=\n  \u2200 v\u2081 v\u2082, v\u2081.val < v\u2082.val \u2192 g.getColor v\u2081 v\u2082 < n\n\n/-- Check if three vertices form a triangle with given colors -/\ndef has_triangle (g : ColoredCompleteGraph n) (c\u2081 c\u2082 c\u2083 : Fin n) : Prop :=\n  \u2203 (v\u2081 v\u2082 v\u2083 : Fin n), \n    v\u2081.val < v\u2082.val \u2227 v\u2082.val < v\u2083.val \u2227\n    (g.getColor v\u2081 v\u2082 = c\u2081 \u2227\n     g.getColor v\u2082 v\u2083 = c\u2082 \u2227\n     g.getColor v\u2081 v\u2083 = c\u2083)\n\n/-- Three colors are distinct -/\ndef distinct_colors (c\u2081 c\u2082 c\u2083 : Fin n) : Prop :=\n  c\u2081.val \u2260 c\u2082.val \u2227 c\u2082.val \u2260 c\u2083.val \u2227 c\u2081.val \u2260 c\u2083.val\n\ntheorem nail_graph_nonexistence_seven : \n  \u00ac\u2203 (g : ColoredCompleteGraph 7), valid_coloring g \u2227\n    \u2200 (c\u2081 c\u2082 c\u2083 : Fin 7), distinct_colors c\u2081 c\u2082 c\u2083 \u2192 has_triangle g c\u2081 c\u2082 c\u2083 := \n  sorry"}
{"id": "CombStruct4Lean_2", "informal_problem": "\nProblem 3. Alice and Bob play the following game: Alice picks a set $A=\\{1,2, \\ldots, n\\}$ for some natural number $n \\geqslant 2$. Then starting with Bob, they alternatively choose one number from the set $A$, according to the following conditions: initially Bob chooses any number he wants, afterwards the number chosen at each step should be distinct from all the already chosen numbers, and should differ by 1 from an already chosen number. The game ends when all numbers from the set $A$ are chosen. Alice wins if the sum of all of the numbers that she has chosen is composite. Otherwise Bob wins. Decide which player has a winning strategy.\n", "formal_statement": "import Mathlib\n\n/-- Players in the game -/\ninductive Player\n| alice\n| bob\nderiving Repr, DecidableEq\n\n/-- Game state representing the current position -/\nstructure GameState where\n  n : Nat                     -- Size of the game board\n  chosen : Finset Nat         -- All chosen numbers\n  aliceMoves : Finset Nat     -- Numbers chosen by Alice\n  moveNumber : Nat            -- Current move number\n  currentPlayer : Player      -- Current player to move\n  h_range : \u2200 x \u2208 chosen, 1 \u2264 x \u2227 x \u2264 n        -- Chosen numbers are in range\n  h_alice_subset : aliceMoves \u2286 chosen          -- Alice's moves are subset of chosen\n  h_move_count : chosen.card = moveNumber       -- Move count matches chosen numbers\n\n/-- The initial state of the game. -/\ndef initialGameState (n : Nat) : GameState where\n  n := n\n  chosen := \u2205\n  aliceMoves := \u2205\n  moveNumber := 0\n  currentPlayer := Player.bob -- Assuming Bob starts, adjust if needed\n  h_range := by simp\n  h_alice_subset := by simp\n  h_move_count := by simp\n\n/-- Check if a move is adjacent to any chosen number -/\ndef isAdjacentToChosen (chosen : Finset Nat) (move : Nat) : Prop :=\n  chosen.card = 0 \u2228 \u2203 prev \u2208 chosen, Int.natAbs (((move : Int) - (prev : Int))) = 1\n\n/-- Check if a move is valid in the current state -/\ndef isValidMove (state : GameState) (move : Nat) : Prop :=\n  1 \u2264 move \u2227                          -- Move is in range\n  move \u2264 state.n \u2227\n  move \u2209 state.chosen \u2227               -- Move hasn't been chosen\n  isAdjacentToChosen state.chosen move -- Move is adjacent to chosen number\n\n/-- Check if Alice's sum is composite (winning condition for Alice) -/\ndef isWinningForAlice (moves : Finset Nat) : Prop :=\n  let sum := Finset.sum moves id\n  sum > 1 \u2227 \u00acNat.Prime sum\n\n/-- Check if the game is finished -/\ndef isGameOver (state : GameState) : Prop :=\n  state.moveNumber = state.n\n\n/-- Bob has a winning strategy in the number choosing game -/\ntheorem bob_has_winning_strategy (n : Nat) (h : n \u2265 2) :\n  \u2203 (firstMove : Nat), isValidMove (initialGameState n) firstMove \u2227\n    \u2200 (game : GameState),\n      game.n = n \u2192\n      \u00acisGameOver game \u2192\n      game.currentPlayer = Player.bob \u2192\n      \u2203 (move : Nat),\n        isValidMove game move \u2227\n        \u00acisWinningForAlice (game.aliceMoves) :=\n  sorry"}
{"id": "CombStruct4Lean_3", "informal_problem": "\nC3. We have two piles with 2000 and 2017 coins respectively. Ann and Bob take alternate turns making the following moves: The player whose turn is to move picks a pile with at least two coins, removes from that pile $t$ coins for some $2 \\leqslant t \\leqslant 4$, and adds to the other pile 1 coin. The players can choose a different $t$ at each turn, and the player who cannot make a move loses. If Ann plays first determine which player has a winning strategy.\n", "formal_statement": "import Mathlib\n\n/-- Players in the game -/\ninductive Player where\n  | Ann\n  | Bob\n  deriving Repr, DecidableEq\n\n/-- Represents which pile a player can choose -/\ninductive Pile where\n  | One\n  | Two\n  deriving Repr, DecidableEq\n\n/-- Valid number of coins to remove (between 2 and 4) -/\nstructure ValidCoins where\n  n : Nat\n  h : 2 \u2264 n \u2227 n \u2264 4\n\n/-- A game state consists of two piles of coins and tracks whose turn it is -/\nstructure GameState where\n  pile1 : Nat\n  pile2 : Nat\n  turn : Player\n\n/-- A move in the game consists of choosing a pile and a valid number of coins to remove -/\nstructure Move where\n  pile : Pile\n  coins : ValidCoins\n\n/-- Measure function for termination proof -/\ndef gameSize (state : GameState) : Nat :=\n  state.pile1 + state.pile2\n\n/-- Represents a strategy for playing the game -/\ndef Strategy := GameState \u2192 Option Move\n\n/-- Predicate indicating if a move is valid in a given state -/\ndef isValidMove (state : GameState) (move : Move) : Prop :=\n  match move.pile with\n  | Pile.One => state.pile1 \u2265 move.coins.n\n  | Pile.Two => state.pile2 \u2265 move.coins.n\n\n/-- Apply a move to the current game state -/\ndef makeMove (state : GameState) (move : Move) : GameState :=\n  match move.pile with\n  | Pile.One => \u27e8\n      state.pile1 - move.coins.n,\n      state.pile2 + 1,\n      match state.turn with\n      | Player.Ann => Player.Bob\n      | Player.Bob => Player.Ann\n    \u27e9\n  | Pile.Two => \u27e8\n      state.pile1 + 1,\n      state.pile2 - move.coins.n,\n      match state.turn with\n      | Player.Ann => Player.Bob\n      | Player.Bob => Player.Ann\n    \u27e9\n\n/-- Predicate indicating if a strategy is winning for a player -/\ninductive IsWinningStrategy (player : Player) (strat : Strategy) : GameState \u2192 Prop where\n  | winning_move {state : GameState} (move : Move)\n    (h_valid : isValidMove state move)\n    (h_next : IsWinningStrategy player strat (makeMove state move))\n    : IsWinningStrategy player strat state\n  | opponent_loses {state : GameState}\n    (h_no_moves : \u2200 move, \u00acisValidMove state move)\n    : IsWinningStrategy player strat state\n\ntheorem ann_has_winning_strategy :\n  \u2203 (strat : Strategy),\n    IsWinningStrategy Player.Ann strat \u27e82000, 2017, Player.Ann\u27e9 :=\n  sorry"}
{"id": "CombStruct4Lean_4", "informal_problem": "\nC2. $n$ nails nailed on a board are connected by two via a string. Each string is colored in one of $n$ given colors. For any three colors there exist three nails conne.cted by two with strings in these three colors. Can $n$ be: (a) 6, (b) 7?\n", "formal_statement": "import Mathlib\n\nstructure ColoredGraph where\n  n : Nat                              -- number of nails\n  edges : Set (Fin n \u00d7 Fin n)         -- edges between nails\n  edge_coloring : Fin n \u00d7 Fin n \u2192 Option (Fin n)  -- coloring of edges\n  valid_coloring : \u2200 e, e \u2208 edges \u2194 (edge_coloring e).isSome\n  no_self_loops : \u2200 v, \u27e8v, v\u27e9 \u2209 edges\n  symmetric : \u2200 a b, \u27e8a, b\u27e9 \u2208 edges \u2192 \u27e8b, a\u27e9 \u2208 edges\n  color_surjective : \u2200 c : Fin n, \u2203 e \u2208 edges, edge_coloring e = some c\n  three_color_property : \u2200 (c\u2081 c\u2082 c\u2083 : Fin n), c\u2081 \u2260 c\u2082 \u2192 c\u2082 \u2260 c\u2083 \u2192 c\u2081 \u2260 c\u2083 \u2192\n    \u2203 (v\u2081 v\u2082 v\u2083 : Fin n), v\u2081 \u2260 v\u2082 \u2227 v\u2082 \u2260 v\u2083 \u2227 v\u2081 \u2260 v\u2083 \u2227\n    \u27e8v\u2081, v\u2082\u27e9 \u2208 edges \u2227 \u27e8v\u2082, v\u2083\u27e9 \u2208 edges \u2227\n    edge_coloring \u27e8v\u2081, v\u2082\u27e9 = some c\u2081 \u2227 \n    edge_coloring \u27e8v\u2082, v\u2083\u27e9 = some c\u2082\n\ntheorem no_colored_graph_six_seven : \n  \u2200 n : Nat, (n = 6 \u2228 n = 7) \u2192 \u00ac\u2203 (g : ColoredGraph), g.n = n :=\n  sorry"}
{"id": "CombStruct4Lean_5", "informal_problem": "\nC3. All possible pairs of $n$ apples are weighed and the results are given to us in an arbitrary order. Can we determine the weights of the apples if $n=4$?\n", "formal_statement": "import Mathlib\n\nstructure AppleWeighingSystem (n : Nat) where\n  -- Individual apple weights\n  weights : Fin n \u2192 \u211d\n  -- Function that gives the weight of any pair of apples\n  pairWeights : Fin n \u2192 Fin n \u2192 \u211d\n  -- The pair weights are the sums of individual weights\n  pairSum : \u2200 (i j : Fin n), i < j \u2192 pairWeights i j = weights i + weights j\n\n-- Definition for when a weighing system is uniquely determined by its pair weights\ndef isUniqueDetermination (n : Nat) (s\u2081 s\u2082 : AppleWeighingSystem n) : Prop :=\n  (\u2200 (i j : Fin n), i < j \u2192 s\u2081.pairWeights i j = s\u2082.pairWeights i j) \u2192 \n  (\u2200 (i : Fin n), s\u2081.weights i = s\u2082.weights i)\n\ntheorem apple_weighing_determination (n : Nat) (h : n \u2265 4) :\n (n = 4) \u2192\n  \u2200 (s\u2081 s\u2082 : AppleWeighingSystem n), isUniqueDetermination n s\u2081 s\u2082 :=\n  sorry"}
{"id": "CombStruct4Lean_6", "informal_problem": "\nC3. All possible pairs of $n$ apples are weighed and the results are given to us in an arbitrary order. Can we determine the weights of the apples if $n=5$?\n", "formal_statement": "import Mathlib\n\nstructure AppleWeighingSystem (n : Nat) where\n  -- Individual apple weights\n  weights : Fin n \u2192 \u211d\n  -- Function that gives the weight of any pair of apples\n  pairWeights : Fin n \u2192 Fin n \u2192 \u211d\n  -- The pair weights are the sums of individual weights\n  pairSum : \u2200 (i j : Fin n), i < j \u2192 pairWeights i j = weights i + weights j\n\n-- Definition for when a weighing system is uniquely determined by its pair weights\ndef isUniqueDetermination (n : Nat) (s\u2081 s\u2082 : AppleWeighingSystem n) : Prop :=\n  (\u2200 (i j : Fin n), i < j \u2192 s\u2081.pairWeights i j = s\u2082.pairWeights i j) \u2192 \n  (\u2200 (i : Fin n), s\u2081.weights i = s\u2082.weights i)\n\ntheorem apple_weighing_determination (n : Nat) (h : n \u2265 4) :\n  (n = 5) \u2192\n  \u2200 (s\u2081 s\u2082 : AppleWeighingSystem n), isUniqueDetermination n s\u2081 s\u2082 :=\n  sorry"}
{"id": "CombStruct4Lean_7", "informal_problem": "\nC3. All possible pairs of $n$ apples are weighed and the results are given to us in an arbitrary order. Can we determine the weights of the apples if $n=6$ ?\n", "formal_statement": "import Mathlib\n\nstructure AppleWeighingSystem (n : Nat) where\n  -- Individual apple weights\n  weights : Fin n \u2192 \u211d\n  -- Function that gives the weight of any pair of apples\n  pairWeights : Fin n \u2192 Fin n \u2192 \u211d\n  -- The pair weights are the sums of individual weights\n  pairSum : \u2200 (i j : Fin n), i < j \u2192 pairWeights i j = weights i + weights j\n\n-- Definition for when a weighing system is uniquely determined by its pair weights\ndef isUniqueDetermination (n : Nat) (s\u2081 s\u2082 : AppleWeighingSystem n) : Prop :=\n  (\u2200 (i j : Fin n), i < j \u2192 s\u2081.pairWeights i j = s\u2082.pairWeights i j) \u2192 \n  (\u2200 (i : Fin n), s\u2081.weights i = s\u2082.weights i)\n\ntheorem apple_weighing_determination (n : Nat) (h : n \u2265 4) :\n  (n = 6) \u2192\n  \u2200 (s\u2081 s\u2082 : AppleWeighingSystem n), isUniqueDetermination n s\u2081 s\u2082 :=\n  sorry"}
{"id": "CombStruct4Lean_8", "informal_problem": "\nC1 We call a tiling of an $m \\times n$ rectangle with corners (see figure below) \"regular\" if there is no sub-rectangle which is tiled with corners. Prove that if for some $m$ and $n$ there exists a \"regular\" tiling of the $m \\times n$ rectangular then there exists a \"regular\" tiling also for the $2 m \\times 2 n$ rectangle.", "formal_statement": "import Mathlib\n\n-- Corner orientation\ninductive Corner where\n  | NW | NE | SE | SW\n  deriving BEq, Repr\n\n-- Position in a rectangle with proper bounds\nstructure Pos (m n : \u2115) where\n  row : Fin m\n  col : Fin n\n\n-- Helper functions for position arithmetic\ndef Pos.toDoubled {m n : \u2115} (p : Pos m n) (hm : m > 0) (hn : n > 0) : Pos (2 * m) (2 * n) where\n  row := \u27e82 * p.row.val, by omega\u27e9\n  col := \u27e82 * p.col.val, by omega\u27e9\n\n-- Corner tile with bounded coordinates\nstructure CornerTile (m n : \u2115) where\n  center : Pos m n\n  orientation : Corner\n\n-- A subrectangle within m\u00d7n rectangle with proper bounds\nstructure Subrect (m n : \u2115) where\n  topLeft : Pos m n\n  botRight : Pos m n\n  valid : topLeft.row.val < botRight.row.val \u2227 topLeft.col.val < botRight.col.val\n\n-- Check if a position is within a subrectangle\ndef Subrect.contains {m n : \u2115} (s : Subrect m n) (p : Pos m n) : Prop :=\n  s.topLeft.row.val \u2264 p.row.val \u2227 p.row.val \u2264 s.botRight.row.val \u2227\n  s.topLeft.col.val \u2264 p.col.val \u2227 p.col.val \u2264 s.botRight.col.val\n\n-- A valid tiling of a rectangle\nstructure RectangleTiling (m n : \u2115) where\n  tiles : Finset (CornerTile m n)\n  -- Every position is covered exactly once\n  covers_once : \u2200 p : Pos m n, \u2203! t \u2208 tiles, \n    match t.orientation with\n    | Corner.NW => p = t.center \u2228 (p.row.val + 1 = t.center.row.val \u2227 p.col = t.center.col) \u2228\n                   (p.row = t.center.row \u2227 p.col.val + 1 = t.center.col.val)\n    | Corner.NE => p = t.center \u2228 (p.row.val + 1 = t.center.row.val \u2227 p.col = t.center.col) \u2228\n                   (p.row = t.center.row \u2227 p.col.val = t.center.col.val + 1)\n    | Corner.SE => p = t.center \u2228 (p.row.val = t.center.row.val + 1 \u2227 p.col = t.center.col) \u2228\n                   (p.row = t.center.row \u2227 p.col.val = t.center.col.val + 1)\n    | Corner.SW => p = t.center \u2228 (p.row.val = t.center.row.val + 1 \u2227 p.col = t.center.col) \u2228\n                   (p.row = t.center.row \u2227 p.col.val + 1 = t.center.col.val)\n  -- No subrectangle is fully tiled\n  regular : \u2200 s : Subrect m n, \u2203 p : Pos m n,\n    s.contains p \u2227 \u2200 t \u2208 tiles, t.center \u2260 p\n\ntheorem regular_tiling_double_size (m n : \u2115) (hm : m > 0) (hn : n > 0) :\n  (\u2203 t : RectangleTiling m n, True) \u2192 \n  (\u2203 t : RectangleTiling (2 * m) (2 * n), True) :=\n  sorry"}
{"id": "CombStruct4Lean_9", "informal_problem": "\nC 3. Alice and Bob play the following game: Alice begins by picking a natural number $n \\geqslant 2$. Then, with Bob starting first, they alternately choose one number from the set $A=\\{1,2, \\ldots, n\\}$ according to the following condition: The number chosen at each step should be distinct from all the already chosen numbers, and should differ by 1 from an already chosen number. (At the very first step Bob can choose any number he wants.) The game ends when all numbers from the set $A$ are chosen.\n\nFor example, if Alice picks $n=4$, then a valid game would be for Bob to choose 2, then Alice to choose 3, then Bob to choose 1, and then Alice to choose 4 .\n\nAlice wins if the sum $S$ of all of the numbers that she has chosen is composite. Otherwise Bob wins. (In the above example $S=7$, so Bob wins.)\n\nDecide which player has a winning strategy.\n", "formal_statement": "import Mathlib\n\ninductive Player\n  | Alice\n  | Bob\n  deriving Repr, DecidableEq\n\ninductive MoveError\n  | OutOfRange\n  | AlreadyUsed\n  | NoAdjacent\n  deriving Repr\n\nstructure Move where\n  player : Player\n  value : Nat\n  deriving Repr, DecidableEq\n\nstructure GameState where\n  n : Nat\n  h : n \u2265 2\n  moves : List Move\n  deriving Repr\n\ndef currentPlayer (state : GameState) : Player :=\n  if state.moves.length % 2 = 0 then Player.Bob else Player.Alice\n\ndef differsByOne (x y : Nat) : Bool :=\n  x + 1 = y \u2228 y + 1 = x\n\ndef isValidMove (state : GameState) (move : Nat) : Bool :=\n  let usedValues := state.moves.map Move.value\n  -- Move must be in range\n  (1 \u2264 move \u2227 move \u2264 state.n) &&\n  -- Move must not be already chosen\n  (!usedValues.contains move) &&\n  -- Move must differ by 1 from some chosen number (except first move)\n  (usedValues.isEmpty || usedValues.any (differsByOne move))\n\ndef playMove (state : GameState) (move : Nat) : Option GameState :=\n  if isValidMove state move then\n    some {\n      n := state.n,\n      h := state.h,\n      moves := \u27e8currentPlayer state, move\u27e9 :: state.moves\n    }\n  else none\n\ndef isGameComplete (state : GameState) : Bool :=\n  state.moves.length = state.n &&\n  (List.range state.n).all (fun i => \n    state.moves.map Move.value |>.contains (i + 1))\n\ndef aliceMoves (state : GameState) : List Nat :=\n  state.moves.filter (fun m => m.player = Player.Alice) |>.map Move.value\n\ndef isComposite (n : Nat) : Bool :=\n  if n \u2264 1 then false else\n  (List.range (n - 2)).any (fun i => \n    let k := i + 2\n    k < n && n % k = 0)\n\ndef Strategy := GameState \u2192 Option Nat\n\ntheorem number_game_winner (n : Nat) (h : n \u2265 2) :\n  let initialState := { n := n, h := h, moves := [] }\n  -- Either Bob has a winning strategy\n  (\u2203 (bobStrategy : Strategy),\n    -- Such that for any Alice strategy\n    \u2200 (aliceStrategy : Strategy),\n      -- If we follow these strategies to a complete game\n      \u2200 (finalState : GameState),\n      -- The final state is reachable through valid moves using these strategies\n      (\u2203 (gameTrace : List GameState),\n        gameTrace.head? = some initialState \u2227\n        isGameComplete finalState \u2227\n        -- Each move in the trace follows from the strategies\n        \u2200 state \u2208 gameTrace,\n          let nextMove := if currentPlayer state = Player.Bob\n                         then bobStrategy state\n                         else aliceStrategy state\n          nextMove.map (playMove state) = some (gameTrace.head?)) \u2192\n      -- Then Alice's sum is not composite (Bob wins)\n      !isComposite (List.sum (aliceMoves finalState)))\n  \u2228\n  -- Or Alice has a winning strategy (similar structure)\n  (\u2203 (aliceStrategy : Strategy),\n    \u2200 (bobStrategy : Strategy),\n      \u2200 (finalState : GameState),\n      (\u2203 (gameTrace : List GameState),\n        gameTrace.head? = some initialState \u2227\n        isGameComplete finalState \u2227\n        \u2200 state \u2208 gameTrace,\n          let nextMove := if currentPlayer state = Player.Bob\n                         then bobStrategy state\n                         else aliceStrategy state\n          nextMove.map (playMove state) = some (gameTrace.head?)) \u2192\n      isComposite (List.sum (aliceMoves finalState))) :=\n  sorry"}
{"id": "CombStruct4Lean_10", "informal_problem": "\nCOM 5. If $m$ is a number from the set $\\{1,2,3,4\\}$ and each point of the plane is painted in red or blue, prove that in the plane there exists at least an equilateral triangle with the vertices of the same colour and with length side $m$.\n", "formal_statement": "import Mathlib\n\n-- Define a color type\ninductive Color where\n  | Red : Color\n  | Blue : Color\n\n-- Define a coloring of the plane as a function from points to colors\ndef PlaneColoring := \u211d \u00d7 \u211d \u2192 Color\n\n-- Define what it means for three points to form an equilateral triangle of side length m\ndef IsEquilateralTriangle (p\u2081 p\u2082 p\u2083 : \u211d \u00d7 \u211d) (m : \u211d) : Prop :=\n  let dist := fun (x y : \u211d \u00d7 \u211d) => Real.sqrt ((x.1 - y.1)^2 + (x.2 - y.2)^2)\n  dist p\u2081 p\u2082 = m \u2227 dist p\u2082 p\u2083 = m \u2227 dist p\u2083 p\u2081 = m\n\n-- Define what it means for three points to have the same color under a coloring\ndef SameColor (c : PlaneColoring) (p\u2081 p\u2082 p\u2083 : \u211d \u00d7 \u211d) : Prop :=\n  c p\u2081 = c p\u2082 \u2227 c p\u2082 = c p\u2083\n\ntheorem exists_monochromatic_triangle (m : \u211d) (h : m \u2208 ({1, 2, 3, 4} : Set \u211d)) \n  (c : PlaneColoring) : \n  \u2203 (p\u2081 p\u2082 p\u2083 : \u211d \u00d7 \u211d), IsEquilateralTriangle p\u2081 p\u2082 p\u2083 m \u2227 SameColor c p\u2081 p\u2082 p\u2083 :=\n  sorry"}
{"id": "CombStruct4Lean_11", "informal_problem": "\n94.2. We call a finite plane set $S$ consisting of points with integer coefficients a twoneighbour set, if for each point $(p, q)$ of $S$ exactly two of the points $(p+1, q),(p, q+1)$, $(p-1, q),(p, q-1)$ belong to $S$. For which integers $n$ there exists a two-neighbour set which contains exactly $n$ points?\n", "formal_statement": "import Mathlib\n\ndef neighbors (p : Int \u00d7 Int) : Finset (Int \u00d7 Int) := \n  {(p.1 + 1, p.2), (p.1, p.2 + 1), (p.1 - 1, p.2), (p.1, p.2 - 1)}\n\nstructure TwoNeighbourSet where\n  points : Finset (Int \u00d7 Int)\n  two_neighbours : \u2200 p \u2208 points, (neighbors p \u2229 points).card = 2\n\ntheorem two_neighbour_set_existence (n : Nat) :\n  (\u2203 (S : TwoNeighbourSet), S.points.card = n) \u2194 n \u2265 4 :=\n  sorry"}
{"id": "CombStruct4Lean_12", "informal_problem": "\n03.1. Stones are placed on the squares of a chessboard having 10 rows and 14 columns. There is an odd number of stones on each row and each column. The squares are coloured black and white in the usual fashion. Show that the number of stones on black squares is even. Note that there can be more than one stone on a square.\n", "formal_statement": "import Mathlib\n\nstructure ChessboardConfig where\n  stones : Fin 10 \u2192 Fin 14 \u2192 Nat\n  row_odd : \u2200 i, Odd (\u2211 j : Fin 14, stones i j)\n  col_odd : \u2200 j, Odd (\u2211 i : Fin 10, stones i j)\n\n/-- Returns true if the square at position (i,j) is black on a standard checkerboard pattern -/\ndef isBlackSquare (i : Fin 10) (j : Fin 14) : Bool :=\n  (i.val + j.val) % 2 = 0\n\ndef stonesOnBlackSquares (config : ChessboardConfig) : Nat :=\n  \u2211 i : Fin 10, \u2211 j : Fin 14, if isBlackSquare i j then config.stones i j else 0\n\ntheorem stones_on_black_squares_even\n  (config : ChessboardConfig) :\n  Even (stonesOnBlackSquares config) :=\n  sorry"}
{"id": "CombStruct4Lean_13", "informal_problem": "\n06.4. The squares of a $100 \\times 100$ chessboard are painted with 100 different colours. Each square has only one colour and every colour is used exactly 100 times. Show that there exists a row or a column on the chessboard in which at least 10 colours are used.\n", "formal_statement": "import Mathlib\n\n/-- A 100\u00d7100 chessboard with 100 colors, each appearing exactly 100 times -/\nstructure ColoredBoard where\n  n : \u2115                           -- board size\n  k : \u2115                           -- number of colors\n  coloring : Fin n \u00d7 Fin n \u2192 Fin k\n  h_n : n = 100                   -- size constraint\n  h_k : k = 100                   -- colors constraint\n\n/-- Colors appearing in row i -/\ndef colors_in_row (board : ColoredBoard) (i : Fin board.n) : Finset (Fin board.k) :=\n  Finset.image (fun j \u21a6 board.coloring (i, j)) (Finset.univ)\n\n/-- Colors appearing in column j -/\ndef colors_in_col (board : ColoredBoard) (j : Fin board.n) : Finset (Fin board.k) :=\n  Finset.image (fun i \u21a6 board.coloring (i, j)) (Finset.univ)\n\n/-- In a 100\u00d7100 board with 100 colors each appearing exactly 100 times,\n    some row or column must contain at least 10 different colors -/\ntheorem chessboard_colors (board : ColoredBoard) :\n  (\u2203 i, (colors_in_row board i).card \u2265 10) \u2228 \n  (\u2203 j, (colors_in_col board j).card \u2265 10) :=\n  sorry"}
{"id": "CombStruct4Lean_14", "informal_problem": "XLII OM - II - Problem 5\n\n$ P_1, P_2, \\ldots, P_n $ are distinct two-element subsets of the set $ \\{1,2,\\ldots,n\\} $. Sets $ P_i $, $ P_j $ for $ i\\neq j $ have a common element if and only if the set $ \\{i,j\\} $ is one of the sets $ P_1, P_2, \\ldots, P_n $. Prove that each of the numbers $ 1,2,\\ldots,n $ is a common element of exactly two of the sets $ P_1, P_2, \\ldots, P_n $.", "formal_statement": "import Mathlib\n\nstructure SetSystem (n : \u2115) (h : 0 < n) where\n  sets : Fin n \u2192 Finset (Fin n)\n  two_elements : \u2200 i, (sets i).card = 2\n  distinct : Function.Injective sets\n  intersection_iff : \u2200 i j, i \u2260 j \u2192 \n    ((sets i \u2229 sets j).card > 0 \u2194 {i, j} \u2208 Finset.univ.image sets)\n\ntheorem common_elements_count {n : \u2115} (h : 0 < n) (sys : SetSystem n h) :\n  \u2200 k : Fin n, (Finset.filter (fun i => k \u2208 sys.sets i) Finset.univ).card = 2 :=\n  sorry"}
{"id": "CombStruct4Lean_15", "informal_problem": "XXXV OM - I - Problem 10\n\nIn the plane, there are $3n$ points, among which no three points are collinear. Prove that there exist $n$ disjoint triangles with vertices at the given points.", "formal_statement": "import Mathlib\n\nstructure Point where\n  x : \u211d \n  y : \u211d\n\n/-- A triangle defined by three points in the plane -/\nstructure Triangle where\n  p\u2081 : Point\n  p\u2082 : Point\n  p\u2083 : Point\n\n/-- Predicate indicating that three points are not collinear -/\ndef NonCollinear (p\u2081 p\u2082 p\u2083 : Point) : Prop :=\n  (p\u2082.x - p\u2081.x) * (p\u2083.y - p\u2081.y) \u2260 (p\u2083.x - p\u2081.x) * (p\u2082.y - p\u2081.y)\n\n/-- Predicate indicating that two triangles are disjoint (share no vertices) -/\ndef DisjointTriangles (t\u2081 t\u2082 : Triangle) : Prop :=\n  t\u2081.p\u2081 \u2260 t\u2082.p\u2081 \u2227 t\u2081.p\u2081 \u2260 t\u2082.p\u2082 \u2227 t\u2081.p\u2081 \u2260 t\u2082.p\u2083 \u2227\n  t\u2081.p\u2082 \u2260 t\u2082.p\u2081 \u2227 t\u2081.p\u2082 \u2260 t\u2082.p\u2082 \u2227 t\u2081.p\u2082 \u2260 t\u2082.p\u2083 \u2227\n  t\u2081.p\u2083 \u2260 t\u2082.p\u2081 \u2227 t\u2081.p\u2083 \u2260 t\u2082.p\u2082 \u2227 t\u2081.p\u2083 \u2260 t\u2082.p\u2083\n\ntheorem disjoint_triangles_exist (n : \u2115) (points : Fin (3 * n) \u2192 Point)\n    (h_noncollinear : \u2200 i j k, i \u2260 j \u2192 j \u2260 k \u2192 i \u2260 k \u2192 \n      NonCollinear (points i) (points j) (points k)) :\n    \u2203 (triangles : Fin n \u2192 Triangle),\n      (\u2200 i : Fin n, \u2203 j\u2081 j\u2082 j\u2083 : Fin (3 * n),\n        triangles i = \u27e8points j\u2081, points j\u2082, points j\u2083\u27e9) \u2227\n      (\u2200 i j : Fin n, i \u2260 j \u2192 DisjointTriangles (triangles i) (triangles j)) :=\n  sorry"}
{"id": "CombStruct4Lean_16", "informal_problem": "LIII OM - II - Problem 3\n\nIn an $ n $-person association, there are six committees. Each of them includes at least $ n/4 $ people. Prove that there exist two committees and a group of at least $ n/30 $ people, who belong to both of these committees.", "formal_statement": "import Mathlib\n\nstructure Association where\n  n : \u2115\n  committees : Fin 6 \u2192 Finset Nat\n  members : Finset Nat\n  n_pos : n > 0\n  size_bound : \u2200 i, (committees i).card \u2265 Nat.div n 4\n  valid_members : \u2200 i, committees i \u2286 members\n  total_size : members.card = n\n\ntheorem committee_intersection_bound (A : Association) :\n  \u2203 (i j : Fin 6) (S : Finset Nat), \n    i \u2260 j \u2227 \n    S \u2286 A.committees i \u2227 \n    S \u2286 A.committees j \u2227 \n    S.card \u2265 Nat.div A.n 30 :=\n  sorry"}
{"id": "CombStruct4Lean_17", "informal_problem": "XIX OM - I - Problem 5\n\nGiven a set of $ 2n $ ($ n \\geq 2 $) different numbers. How to divide this set into pairs so that the sum of the products of the numbers in each pair is the largest?", "formal_statement": "import Mathlib\n\nstructure PairPartition (n : \u2115) where\n  elements : Fin (2 * n) \u2192 \u211d\n  distinct : \u2200 i j, i \u2260 j \u2192 elements i \u2260 elements j\n  pairs : Fin n \u2192 (Fin (2 * n) \u00d7 Fin (2 * n))\n  valid_pairs : \u2200 i, \n    let (a, b) := pairs i\n    a \u2260 b \u2227 \n    a < 2 * n \u2227 \n    b < 2 * n\n  no_overlap : \u2200 i j, i \u2260 j \u2192 \n    let (a\u2081, b\u2081) := pairs i\n    let (a\u2082, b\u2082) := pairs j\n    a\u2081 \u2260 a\u2082 \u2227 a\u2081 \u2260 b\u2082 \u2227 b\u2081 \u2260 a\u2082 \u2227 b\u2081 \u2260 b\u2082\n  covers_all : \u2200 k, \u2203 i, \n    let (a, b) := pairs i\n    k = a \u2228 k = b\n\ndef pair_product_sum (n : \u2115) (p : PairPartition n) : \u211d :=\n  \u2211 i, let (a, b) := p.pairs i; (p.elements a) * (p.elements b)\n\ntheorem max_pair_products (n : \u2115) (h : n \u2265 2) :\n  \u2200 s : PairPartition n,\n  \u2203 (max_p : PairPartition n),\n    (\u2200 p : PairPartition n, pair_product_sum n p \u2264 pair_product_sum n max_p) :=\n  sorry"}
{"id": "CombStruct4Lean_18", "informal_problem": "XIX OM - I - Problem 5\n\nGiven a set of $ 2n $ ($ n \\geq 2 $) different numbers. How to divide this set into pairs so that the sum of the products of the numbers in each pair is the smallest?", "formal_statement": "import Mathlib\n\nstructure PairPartition (n : \u2115) where\n  elements : Fin (2 * n) \u2192 \u211d\n  distinct : \u2200 i j, i \u2260 j \u2192 elements i \u2260 elements j\n  pairs : Fin n \u2192 (Fin (2 * n) \u00d7 Fin (2 * n))\n  valid_pairs : \u2200 i, \n    let (a, b) := pairs i\n    a \u2260 b \u2227 \n    a < 2 * n \u2227 \n    b < 2 * n\n  no_overlap : \u2200 i j, i \u2260 j \u2192 \n    let (a\u2081, b\u2081) := pairs i\n    let (a\u2082, b\u2082) := pairs j\n    a\u2081 \u2260 a\u2082 \u2227 a\u2081 \u2260 b\u2082 \u2227 b\u2081 \u2260 a\u2082 \u2227 b\u2081 \u2260 b\u2082\n  covers_all : \u2200 k, \u2203 i, \n    let (a, b) := pairs i\n    k = a \u2228 k = b\n\ndef pair_product_sum (n : \u2115) (p : PairPartition n) : \u211d :=\n  \u2211 i, let (a, b) := p.pairs i; (p.elements a) * (p.elements b)\n\ntheorem min_pair_products (n : \u2115) (h : n \u2265 2) :\n  \u2200 s : PairPartition n,\n  \u2203 (min_p : PairPartition n),\n    (\u2200 p : PairPartition n, pair_product_sum n min_p \u2264 pair_product_sum n p) :=\n  sorry"}
{"id": "CombStruct4Lean_19", "informal_problem": "XXV OM - III - Task 5\n\nProve that if natural numbers $ n $, $ r $ satisfy the inequality $ r + 3 \\leq n $, then the numbers $ \\binom{n}{r} $, $ \\binom{n}{r+1} $, $ \\binom{n}{r+2} $, $ \\binom{n}{r+3} $ are not consecutive terms of any arithmetic sequence.", "formal_statement": "import Mathlib\n\ndef isArithmeticSequence (a\u2081 a\u2082 a\u2083 a\u2084 : \u2115) : Prop :=\n  (a\u2082 - a\u2081) = (a\u2083 - a\u2082) \u2227 (a\u2083 - a\u2082) = (a\u2084 - a\u2083)\n\ntheorem binomial_not_arithmetic {n r : \u2115} (h : r + 3 \u2264 n) :\n  \u00ac isArithmeticSequence (n.choose r) (n.choose (r + 1)) (n.choose (r + 2)) (n.choose (r + 3)) :=\n  sorry"}
{"id": "CombStruct4Lean_20", "informal_problem": "LIX OM - III - Task 1\n\nIn the fields of an $ n \\times n $ table, the numbers $ 1, 2, \\dots , n^2 $ are written, with the numbers $ 1, 2, \\dots , n $ being in the first row (from left to right), the numbers $ n +1, n +2, \\dots ,2n $ in the second row, and so on. \n$n$ fields of the table have been selected, such that no two lie in the same row or column. Let $ a_i $ be the number found in the selected field that lies in the row numbered $ i $. Prove that", "formal_statement": "import Mathlib\n\n-- Define a type for the n\u00d7n table with numbers 1 to n\u00b2\nstructure NumberTable (n : \u2115) where\n  -- The selected positions in the table, represented as pairs of row and column indices (1-based)\n  selections : Fin n \u2192 (Fin n \u00d7 Fin n)\n  -- Ensure no two selections share the same row or column\n  no_shared_rows : \u2200 i j : Fin n, i \u2260 j \u2192 (selections i).1 \u2260 (selections j).1\n  no_shared_cols : \u2200 i j : Fin n, i \u2260 j \u2192 (selections i).2 \u2260 (selections j).2\n\n-- Function to get the value at position (i,j) in the table\ndef getValue (n : \u2115) (i j : Fin n) : \u2115 :=\n  (i.val - 1) * n + j.val\n\ntheorem table_selection_sum_inequality {n : \u2115} (h : n > 0) (t : NumberTable n) :\n  \u2211 i : Fin n, getValue n i ((t.selections i).2) \u2265 \n  \u2211 i : Fin n, getValue n ((t.selections i).1) ((t.selections i).2) :=\n  sorry"}
{"id": "CombStruct4Lean_21", "informal_problem": "XVIII OM - III - Problem 3\n\nIn a room, there are 100 people, each of whom knows at least 67 others. Prove that there is a quartet of people in the room where every two people know each other. We assume that if person $A$ knows person $B$, then person $B$ also knows person $A$.", "formal_statement": "import Mathlib\n\nstructure AcquaintanceGraph (n : Nat) where\n  knows : Fin n \u2192 Fin n \u2192 Bool\n  knows_symmetric : \u2200 i j, knows i j = knows j i\n  no_self_knows : \u2200 i, knows i i = false\n  min_acquaintances : \u2200 i, (Finset.filter (fun j \u21a6 knows i j) (Finset.univ : Finset (Fin n))).card \u2265 67\n\ntheorem acquaintance_quartet_exists {g : AcquaintanceGraph 100} :\n  \u2203 (vertices : Fin 4 \u2192 Fin 100), \n    Function.Injective vertices \u2227 \n    \u2200 i j, i < j \u2192 g.knows (vertices i) (vertices j) :=\n  sorry"}
{"id": "CombStruct4Lean_22", "informal_problem": "XXVIII - I - Problem 8\n\nProve that the set $ \\{1, 2, \\ldots, 2^{s+1}\\} $ can be partitioned into two $ 2s $-element sets $ \\{x_1, x_2, \\ldots, x_{2^s}\\} $, $ \\{y_1, y_2, \\ldots, y_{2^s}\\} $, such that for every natural number $ j \\leq s $ the following equality holds", "formal_statement": "import Mathlib\n\ndef is_valid_partition (s : \u2115) (X Y : Finset \u2115) : Prop :=\n  -- Both sets have size 2^s\n  X.card = 2^s \u2227 Y.card = 2^s \u2227\n  -- Sets form a partition of {1,...,2^(s+1)}\n  X \u2229 Y = \u2205 \u2227\n  X \u222a Y = Finset.range (2^(s+1) + 1) \\ {0} \u2227\n  -- All elements are positive and at most 2^(s+1)\n  (\u2200 x \u2208 X, 0 < x \u2227 x \u2264 2^(s+1)) \u2227\n  (\u2200 y \u2208 Y, 0 < y \u2227 y \u2264 2^(s+1))\n\ntheorem partition_power_sum (s : \u2115) :\n  \u2203 (X Y : Finset \u2115), is_valid_partition s X Y \u2227\n    \u2200 j : \u2115, j \u2264 s \u2192\n      (\u2211 i in X, i^j) = (\u2211 i in Y, i^j) :=\n  sorry"}
{"id": "CombStruct4Lean_23", "informal_problem": "XVIII OM - II - Task 2\n\nIn a room, there are 100 people, each of whom knows at least 66 of the remaining 99 people. Prove that it is possible that in every quartet of these people, there are two who do not know each other. We assume that if person $ A $ knows person $ B $, then person $ B $ also knows person $ A $.", "formal_statement": "import Mathlib\n\nstructure AcquaintanceGraph (n : Nat) where\n  acquaintances : Fin n \u2192 Finset (Fin n)\n  symmetric : \u2200 i j, j \u2208 acquaintances i \u2194 i \u2208 acquaintances j\n  no_self : \u2200 i, i \u2209 acquaintances i\n  min_acquaintances : \u2200 i, (acquaintances i).card \u2265 66\n\ndef non_acquaintances {n : Nat} (g : AcquaintanceGraph n) (i : Fin n) : Finset (Fin n) :=\n  (Finset.univ.filter (fun j => j \u2209 g.acquaintances i))\n\ntheorem acquaintance_quartet_theorem (g : AcquaintanceGraph 100) :\n  \u2200 (s : Finset (Fin 100)), s.card = 4 \u2192 \n    \u2203 (x y : Fin 100), x \u2208 s \u2227 y \u2208 s \u2227 x \u2260 y \u2227 y \u2209 g.acquaintances x :=\n  sorry"}
{"id": "CombStruct4Lean_24", "informal_problem": "XXIV OM - I - Problem 7\n\nProve that among five segments lying on the same straight line, there are either three segments that have a common point or three segments that are pairwise disjoint.", "formal_statement": "import Mathlib\n\n/-- A line segment on the real line with ordered endpoints -/\nstructure LineSegment where\n  left : \u211d\n  right : \u211d\n  ordered : left \u2264 right\n\n/-- Whether a point lies in a line segment -/\ndef contains (s : LineSegment) (x : \u211d) : Prop :=\n  s.left \u2264 x \u2227 x \u2264 s.right\n\n/-- Two line segments intersect if they share at least one point -/\ndef intersect (s\u2081 s\u2082 : LineSegment) : Prop :=\n  \u2203 x : \u211d, contains s\u2081 x \u2227 contains s\u2082 x\n\n/-- Among five segments on a line, there are either three with a common point\n    or three that are pairwise disjoint -/\ntheorem segment_trichotomy (s : Fin 5 \u2192 LineSegment) :\n  (\u2203 i j k : Fin 5, i \u2260 j \u2227 j \u2260 k \u2227 i \u2260 k \u2227 \n    \u2203 x : \u211d, contains (s i) x \u2227 contains (s j) x \u2227 contains (s k) x) \u2228\n  (\u2203 i j k : Fin 5, i \u2260 j \u2227 j \u2260 k \u2227 i \u2260 k \u2227 \n    \u00ac(intersect (s i) (s j)) \u2227 \u00ac(intersect (s j) (s k)) \u2227 \u00ac(intersect (s i) (s k))) :=\n  sorry"}
{"id": "CombStruct4Lean_25", "informal_problem": "LI OM - II - Task 3\n\nOn an $ n \\times n $ chessboard, $ n^2 $ different integers are placed, one on each square. In each column, the square with the largest number is painted red. A set of $ n $ squares on the chessboard is called admissible if no two of these squares are in the same row or the same column. Among all admissible sets, the set for which the sum of the numbers placed on its squares is the largest is chosen.\nProve that in such a selected set, there is a red square.", "formal_statement": "import Mathlib\n\nstructure ChessBoard (n : \u2115) where\n  numbers : Fin n \u2192 Fin n \u2192 \u2124\n  different : \u2200 (i\u2081 j\u2081 i\u2082 j\u2082 : Fin n), \n    numbers i\u2081 j\u2081 = numbers i\u2082 j\u2082 \u2192 i\u2081 = i\u2082 \u2227 j\u2081 = j\u2082\n  redSquares : Fin n \u2192 Fin n  -- maps each column to its red square's row\n  red_is_max : \u2200 j k : Fin n, numbers k j \u2264 numbers (redSquares j) j\n  red_unique : \u2200 j i : Fin n, (\u2200 k : Fin n, numbers k j \u2264 numbers i j) \u2192 i = redSquares j\n\nstructure AdmissibleSet (n : \u2115) where\n  rowPerm : Equiv.Perm (Fin n)  -- represents row assignments\n  colPerm : Equiv.Perm (Fin n)  -- represents column assignments\n\ndef sumOfSet (n : \u2115) (board : ChessBoard n) (set : AdmissibleSet n) : \u2124 :=\n  Finset.univ.sum (\u03bb i : Fin n => board.numbers (set.rowPerm i) (set.colPerm i))\n\ntheorem max_admissible_set_has_red_square (n : \u2115) (h : n > 0) \n  (board : ChessBoard n) (maxSet : AdmissibleSet n)\n  (h_max : \u2200 other : AdmissibleSet n, sumOfSet n board other \u2264 sumOfSet n board maxSet) :\n  \u2203 i : Fin n, (maxSet.rowPerm i, maxSet.colPerm i) = (board.redSquares (maxSet.colPerm i), maxSet.colPerm i) :=\n  sorry"}
{"id": "CombStruct4Lean_26", "informal_problem": "XXXVII OM - II - Problem 2\n\nIn a chess tournament, 66 players participate, each playing one game against every other player, and the matches take place in four cities. Prove that there exists a trio of players who play all their games against each other in the same city.", "formal_statement": "import Mathlib\n\nstructure Tournament where\n  players : Finset Nat\n  num_players : players.card = 66\n  cities : Finset Nat\n  num_cities : cities.card = 4\n  game_location : Nat \u2192 Nat \u2192 Nat\n  valid_location : \u2200 p1 p2, p1 \u2208 players \u2192 p2 \u2208 players \u2192 p1 \u2260 p2 \u2192 game_location p1 p2 \u2208 cities\n\ntheorem tournament_trio_exists (t : Tournament) : \n  \u2203 (p1 p2 p3 : Nat) (c : Nat), \n    p1 \u2208 t.players \u2227 p2 \u2208 t.players \u2227 p3 \u2208 t.players \u2227 \n    p1 \u2260 p2 \u2227 p2 \u2260 p3 \u2227 p1 \u2260 p3 \u2227\n    c \u2208 t.cities \u2227\n    t.game_location p1 p2 = c \u2227 \n    t.game_location p2 p3 = c \u2227 \n    t.game_location p1 p3 = c :=\n  sorry"}
{"id": "CombStruct4Lean_27", "informal_problem": "LIX OM - III - Task 4\n\nEach point in the plane with both integer coordinates has been painted either white or black. Prove that from the set of all painted points, an infinite subset can be selected which has a center of symmetry and all of whose points have the same color.", "formal_statement": "import Mathlib\n\n-- Define a point in Z \u00d7 Z\nstructure IntPoint where\n  x : Int\n  y : Int\n\n-- Define a coloring of the integer lattice\ndef Coloring := IntPoint \u2192 Bool  -- Bool represents black (true) and white (false)\n\n-- Define center of symmetry for a set of points\ndef hasCenterOfSymmetry (S : Set IntPoint) : Prop :=\n  \u2203 c : IntPoint, \u2200 p \u2208 S, \n    let sym := IntPoint.mk (2 * c.x - p.x) (2 * c.y - p.y)\n    sym \u2208 S\n\n-- Define a monochromatic set\ndef isMonochromatic (S : Set IntPoint) (col : Coloring) : Prop :=\n  \u2203 b : Bool, \u2200 p \u2208 S, col p = b\n\ntheorem infinite_symmetric_monochromatic \n  (col : Coloring) : \n  \u2203 S : Set IntPoint, \n    Set.Infinite S \u2227 \n    hasCenterOfSymmetry S \u2227 \n    isMonochromatic S col :=\n  sorry"}
{"id": "CombStruct4Lean_28", "informal_problem": "XLV OM - I - Problem 9\n\nIn a conference, $2n$ people are participating. Each participant has at least $n$ acquaintances among the other participants. Prove that all participants of the conference can be accommodated in double rooms so that each participant shares a room with an acquaintance.", "formal_statement": "import Mathlib\n\nstructure Conference where\n  n : Nat\n  participants : Finset (Fin (2 * n))\n  acquaintance : Fin (2 * n) \u2192 Finset (Fin (2 * n))\n  card_participants : participants.card = 2 * n\n  enough_acquaintances : \u2200 p, p \u2208 participants \u2192 (acquaintance p).card \u2265 n\n  valid_acquaintance : \u2200 p\u2081 p\u2082, p\u2082 \u2208 acquaintance p\u2081 \u2194 p\u2081 \u2208 acquaintance p\u2082\n\n/-- A pairing represents a valid room assignment where each person shares with an acquaintance -/\ndef ValidPairing (c : Conference) (pairs : Finset (Fin (2 * c.n) \u00d7 Fin (2 * c.n))) : Prop :=\n  -- Each person appears exactly once in a pair\n  (\u2200 p \u2208 c.participants, \u2203! pair \u2208 pairs, p = pair.1 \u2228 p = pair.2) \u2227\n  -- Each pair consists of acquaintances\n  (\u2200 pair \u2208 pairs, pair.2 \u2208 c.acquaintance pair.1) \u2227\n  -- Number of pairs is n (double rooms)\n  pairs.card = c.n\n\ntheorem conference_room_assignment (c : Conference) : \u2203 pairs, ValidPairing c pairs :=\n  sorry"}
{"id": "CombStruct4Lean_29", "informal_problem": "XXXII - III - Task 4\n\nOn the table lie $ n $ tokens marked with integers. If among these tokens there are two marked with the same number, for example, the number $ k $, then we replace them with one token marked with the number $ k+1 $ and one with the number $ k-1 $. Prove that after a finite (non-negative) number of such changes, all tokens will be marked with different numbers.", "formal_statement": "import Mathlib\n\nstructure TokenState where\n  n : Nat                    -- number of tokens\n  marks : Fin n \u2192 Int       -- marks on each token\n\n/-- Function to check if all marks are different -/\ndef allDifferent (state : TokenState) : Prop :=\n  \u2200 i j : Fin state.n, i \u2260 j \u2192 state.marks i \u2260 state.marks j\n\n/-- Represents one step of replacing two equal tokens -/\ndef canReplace (state : TokenState) : Prop :=\n  \u2203 i j : Fin state.n, i \u2260 j \u2227 state.marks i = state.marks j\n\ntheorem token_game_terminates (n : Nat) (initial : TokenState) (h : n > 0) :\n  \u2203 final : TokenState, final.n = n \u2227 allDifferent final :=\n  sorry"}
{"id": "CombStruct4Lean_30", "informal_problem": "XXIV OM - III - Problem 4\n\nOn a line, a system of segments with a total length $ < 1 $ is given. Prove that any system of $ n $ points on the line can be moved along it by a vector of length $ \\leq \\frac{n}{2} $ so that after the move, none of the points lies on any of the given segments.", "formal_statement": "import Mathlib\n\nstructure SegmentSystem where\n  segments : List (\u211d \u00d7 \u211d) -- List of segments represented as pairs of endpoints\n  total_length : \u211d\n  length_bound : total_length < 1\n  valid_segments : \u2200 s \u2208 segments, s.1 \u2264 s.2 -- Ensure left endpoint \u2264 right endpoint\n\n/-- Predicate to check if a point lies on any segment in the system -/\ndef lies_on_segments (sys : SegmentSystem) (point : \u211d) : Prop :=\n  \u2203 seg \u2208 sys.segments, seg.1 \u2264 point \u2227 point \u2264 seg.2\n\ntheorem segment_avoidance_theorem\n  (sys : SegmentSystem)\n  (points : List \u211d)\n  (n : \u2115)\n  (h_points : points.length = n) :\n  \u2203 (shift : \u211d),\n    (|shift| \u2264 n/2) \u2227\n    (\u2200 p \u2208 points, \u00aclies_on_segments sys (p + shift)) :=\n  sorry"}
{"id": "CombStruct4Lean_31", "informal_problem": "XLIX OM - III - Problem 6\n\nWe consider unit squares on the plane, whose vertices have both integer coordinates. Let $ S $ be a chessboard whose fields are all unit squares contained in the circle defined by the inequality $ x^2+y^2 \\leq 1998^2 $. On all the fields of the chessboard, we write the number $ +1 $. We perform a sequence of operations, each of which consists of selecting any horizontal, vertical, or diagonal row and changing the signs of all numbers written on the fields of the selected row. (A diagonal row consists of all the fields of the chessboard $ S $ whose centers lie on a certain line intersecting the coordinate axes at an angle of $ 45^\\circ $.)\nDetermine whether it is possible to achieve a situation where one field has the number $ -1 $ written on it, and all the others have $ +1 $ written on them.", "formal_statement": "import Mathlib\n\n/-- A point in the integer grid -/\nabbrev Point := Int \u00d7 Int\n\n/-- Predicate for points within the circle x\u00b2 + y\u00b2 \u2264 1998\u00b2 -/\ndef inCircle (p : Point) : Prop :=\n  p.1^2 + p.2^2 \u2264 1998^2\n\n/-- The chessboard is a set of points within the circle -/\nstructure Board where\n  squares : Finset Point\n  valid : \u2200 p \u2208 squares, inCircle p\n\n/-- Types of lines that can be used for flipping signs -/\ninductive FlipLine\n  | horizontal (y : Int)\n  | vertical (x : Int)\n  | diagonal_pos (k : Int)  -- y = x + k\n  | diagonal_neg (k : Int)  -- y = -x + k\n\n/-- Check if a point lies on a flip line -/\ndef onLine (p : Point) (l : FlipLine) : Prop :=\n  match l with\n  | .horizontal y => p.2 = y\n  | .vertical x => p.1 = x\n  | .diagonal_pos k => p.2 = p.1 + k\n  | .diagonal_neg k => p.2 = -p.1 + k\n\n/-- A flip operation is valid if it intersects the board -/\ndef isValidFlip (l : FlipLine) (b : Board) : Prop :=\n  \u2203 p \u2208 b.squares, onLine p l\n\n/-- The state of signs on the board (+1 or -1) -/\nstructure BoardState where\n  board : Board\n  negativeSquares : Finset Point\n  valid : negativeSquares \u2286 board.squares\n\ntheorem single_negative_impossible (b : Board) (init : BoardState)\n    (h_init : init.board = b \u2227 init.negativeSquares = \u2205) :\n    \u00ac\u2203 (flips : List FlipLine) (final : BoardState),\n      (\u2200 l \u2208 flips, isValidFlip l b) \u2227\n      final.board = b \u2227\n      final.negativeSquares.card = 1 :=\n  sorry"}
{"id": "CombStruct4Lean_32", "informal_problem": "XXIX OM - III - Task 2\n\nOn a plane, there are points with integer coordinates, at least one of which is not divisible by A. Prove that these points cannot be paired in such a way that the distance between the points of each pair is equal to 1; this means that an infinite chessboard with fields cut out at coordinates divisible by 4 cannot be covered with domino tiles.", "formal_statement": "import Mathlib\n\ndef IntPoint := Int \u00d7 Int\n\ndef hasNonDivisibleCoordinate (p : IntPoint) (A : Int) : Prop :=\n  \u00ac(A \u2223 Prod.fst p) \u2228 \u00ac(A \u2223 Prod.snd p)\n\nnoncomputable def distance (p\u2081 p\u2082 : IntPoint) : \u211d :=\n  Real.sqrt (((Prod.fst p\u2081 - Prod.fst p\u2082 : Int) : \u211d)^2 + \n             ((Prod.snd p\u2081 - Prod.snd p\u2082 : Int) : \u211d)^2)\n\ndef isValidPoint (p : IntPoint) (A : Int) : Prop :=\n  \u00ac(A \u2223 Prod.fst p \u2227 A \u2223 Prod.snd p)\n\ndef validPointSet (points : Set IntPoint) (A : Int) : Prop :=\n  \u2200 p : IntPoint, isValidPoint p A \u2194 p \u2208 points\n\ndef isPairing (pairs : Set (IntPoint \u00d7 IntPoint)) (points : Set IntPoint) : Prop :=\n  -- Each point appears in exactly one pair\n  (\u2200 p \u2208 points, \u2203! q, (p, q) \u2208 pairs \u2228 (q, p) \u2208 pairs) \u2227\n  -- All paired points are from our set\n  (\u2200 p\u2081 p\u2082, (p\u2081, p\u2082) \u2208 pairs \u2192 p\u2081 \u2208 points \u2227 p\u2082 \u2208 points)\n\ntheorem no_unit_distance_pairing (A : Int) (h\u2081 : A \u2265 4) :\n  \u2200 (points : Set IntPoint),\n  validPointSet points A \u2192\n  \u00ac\u2203 pairs : Set (IntPoint \u00d7 IntPoint),\n    isPairing pairs points \u2227\n    (\u2200 p\u2081 p\u2082, (p\u2081, p\u2082) \u2208 pairs \u2192 distance p\u2081 p\u2082 = 1) :=\n  sorry"}
{"id": "CombStruct4Lean_33", "informal_problem": "LI OM - I - Problem 11\n\nGiven a positive integer $ n $ and a set $ M $, consisting of $ n^2 + 1 $ different positive integers and having the following property: among any $ n+1 $ numbers chosen from the set $ M $, there is a pair of numbers, one of which divides the other. Prove that in the set $ M $ there exist distinct numbers $ a_1, a_2, \\ldots, a_{n+1} $ satisfying the condition: for $ i = 1,2,\\ldots,n $, the number $ a_i $ divides $ a_{i+1} $.", "formal_statement": "import Mathlib\n\nstructure DivisibilityChain (n : \u2115) where\n  M : Finset \u2115\n  size_cond : M.card = n^2 + 1\n  div_property : \u2200 S : Finset \u2115, S \u2286 M \u2192 S.card = n + 1 \u2192 \n    \u2203 x y, x \u2208 S \u2227 y \u2208 S \u2227 x \u2260 y \u2227 x \u2223 y\n\ntheorem exists_divisibility_chain (n : \u2115) (h : n > 0) (M : DivisibilityChain n) :\n  \u2203 (a : Fin (n+1) \u2192 \u2115),\n    (\u2200 i, a i \u2208 M.M) \u2227\n    (\u2200 i j, i.val < j.val \u2192 a i \u2223 a j) \u2227\n    (\u2200 i j, i \u2260 j \u2192 a i \u2260 a j) :=\n  sorry"}
{"id": "CombStruct4Lean_34", "informal_problem": "XXXIII OM - I - Problem 5\n\nIn a certain workplace, each employee is a member of exactly one of 100 trade unions. The employees are to elect a director from among two candidates. Members of each union agree on whether to abstain from voting or which of the two candidates they will vote for. Prove that there exists a union such that if its members abstain from voting, and members of all other unions vote for one of the two candidates, the candidates for director will not receive an equal number of votes.", "formal_statement": "import Mathlib\n\ninductive VoteChoice\n  | abstain\n  | candidate1\n  | candidate2\n  deriving Repr, DecidableEq\n\nstructure VotingSystem where\n  unionSize : Fin 100 \u2192 Nat\n  votingChoice : Fin 100 \u2192 VoteChoice\n  size_pos : \u2200 i, unionSize i > 0\n  total_finite : (Finset.univ.sum unionSize) > 0\n\n/-- Predicate indicating if a voting configuration is valid:\n    all unions except possibly one must vote for a candidate -/\ndef isValidConfig (vs : VotingSystem) (abstaining : Option (Fin 100)) : Prop :=\n  \u2200 i : Fin 100, \n    if abstaining = some i \n    then vs.votingChoice i = VoteChoice.abstain\n    else vs.votingChoice i = VoteChoice.candidate1 \u2228 \n         vs.votingChoice i = VoteChoice.candidate2\n\n/-- Count votes for a specific candidate in a voting configuration -/\ndef countVotes (vs : VotingSystem) (c : VoteChoice) : Nat :=\n  Finset.sum Finset.univ fun i => \n    if vs.votingChoice i = c then vs.unionSize i else 0\n\ntheorem exists_decisive_union (vs : VotingSystem) :\n  \u2203 (k : Fin 100),\n    \u2200 (new_vs : VotingSystem),\n      isValidConfig new_vs (some k) \u2192\n      (\u2200 i \u2260 k, vs.unionSize i = new_vs.unionSize i) \u2192\n      countVotes new_vs VoteChoice.candidate1 \u2260 \n      countVotes new_vs VoteChoice.candidate2 :=\n  sorry"}
{"id": "CombStruct4Lean_35", "informal_problem": "XXX OM - III - Task 3\n\nThe experiment consists of performing $ n $ independent trials. The probability of a positive outcome in the $ i $-th trial is $ p_i $. Let $ r_k $ be the probability that exactly $ k $ trials yield a positive result. Prove that", "formal_statement": "import Mathlib\n\nopen BigOperators Finset Real Fintype\n\ndef probability_k_successes (n : \u2115) (p : Fin n \u2192 \u211d) (k : Fin (n + 1)) : \u211d :=\n  Finset.sum (Finset.filter (fun S => S.card = k.val) (powerset (Finset.univ : Finset (Fin n)))) fun S =>\n    (\u220f i in S, p i) * (\u220f i in (Finset.univ \\ S), (1 - p i))\n\ntheorem probability_sum_one (n : \u2115) (p : Fin n \u2192 \u211d) \n    (h_prob : \u2200 i : Fin n, 0 \u2264 p i \u2227 p i \u2264 1) :\n  Finset.sum (Finset.univ : Finset (Fin (n + 1))) (probability_k_successes n p) = 1 :=\n  sorry"}
{"id": "CombStruct4Lean_36", "informal_problem": "LX OM - III - Task 4\n\nLet $ x_1,x_2,\\cdots ,x_n $ be non-negative numbers whose sum is 1. Prove that there exist\nnumbers $ a1,a2,\\cdots ,an \\in \\{0, 1, 2, 3, 4\\} $ such that $ (a_1,a_2,\\cdots ,a_n) \\neq (2, 2,\\cdots , 2) $ and", "formal_statement": "import Mathlib\n\ndef validCoefficients (n : \u2115) : Set (Fin n \u2192 \u2115) :=\n  { a | (\u2200 i, a i \u2264 4) \u2227 \u2203 i, a i \u2260 2 }\n\ntheorem exists_valid_coefficients (n : \u2115) (x : Fin n \u2192 \u211d)\n  (hx_nonneg : \u2200 i, x i \u2265 0)\n  (hx_sum : (\u2211 i, x i) = 1) :\n  \u2203 a \u2208 validCoefficients n,\n    (\u2211 i, (a i : \u211d) * x i) = 2 :=\n  sorry"}
{"id": "CombStruct4Lean_37", "informal_problem": "XLVI OM - I - Problem 4\n\nIn a certain school, 64 students participate in five subject olympiads. In each of these olympiads, at least 19 students from this school participate; none of them participate in more than three olympiads. Prove that if any three olympiads have a common participant, then some two of them have at least five participants in common.", "formal_statement": "import Mathlib\n\nstructure OlympiadParticipation where\n  participation : Finset (Fin 64 \u00d7 Fin 5)\n  total_valid : (participation.image Prod.fst).card = 64\n  min_participation : \u2200 o : Fin 5, (participation.filter (fun p => p.2 = o)).card \u2265 19\n  max_olympiads : \u2200 s : Fin 64, (participation.filter (fun p => p.1 = s)).card \u2264 3\n\ndef participants (p : OlympiadParticipation) (o : Fin 5) : Finset (Fin 64) :=\n  (p.participation.filter (fun x => x.2 = o)).image Prod.fst\n\ndef common_participants (p : OlympiadParticipation) (o\u2081 o\u2082 : Fin 5) : Finset (Fin 64) :=\n  participants p o\u2081 \u2229 participants p o\u2082\n\ntheorem olympiad_intersection_size \n  (p : OlympiadParticipation)\n  (h : \u2203 s : Fin 64, \u2203 i j k : Fin 5, i \u2260 j \u2227 j \u2260 k \u2227 i \u2260 k \u2227 \n    s \u2208 participants p i \u2227 s \u2208 participants p j \u2227 s \u2208 participants p k) :\n  \u2203 i j : Fin 5, i \u2260 j \u2227 (common_participants p i j).card \u2265 5 :=\n  sorry"}
{"id": "CombStruct4Lean_38", "informal_problem": "XXXI - I - Problem 10\n\nA plane is divided into congruent squares by two families of parallel lines. $ S $ is a set consisting of $ n $ such squares. Prove that there exists a subset of the set $ S $, in which the number of squares is no less than $ \\frac{n}{4} $ and no two squares have a common vertex.", "formal_statement": "import Mathlib\n\n/-- A square in a grid with integer coordinates -/\nstructure GridSquare where\n  x : Int\n  y : Int\n  deriving Repr, DecidableEq\n\n/-- Two squares share a vertex if they have coordinates that differ by at most 1 in both dimensions -/\ndef sharesVertex (s1 s2 : GridSquare) : Prop :=\n  Int.natAbs (s1.x - s2.x) \u2264 1 \u2227 Int.natAbs (s1.y - s2.y) \u2264 1\n\n/-- A set of grid squares is independent if no two squares share a vertex -/\ndef isIndependent (squares : Finset GridSquare) : Prop :=\n  \u2200 s1 s2, s1 \u2208 squares \u2192 s2 \u2208 squares \u2192 s1 \u2260 s2 \u2192 \u00acsharesVertex s1 s2\n\ntheorem grid_squares_independent_subset \n  (S : Finset GridSquare) (n : \u2115) (h\u2081 : n > 0) (h\u2082 : S.card = n) :\n  \u2203 (T : Finset GridSquare), T \u2286 S \u2227 isIndependent T \u2227 T.card \u2265 n / 4 :=\n  sorry"}
{"id": "CombStruct4Lean_39", "informal_problem": "LIV OM - I - Task 10\n\nWe have a deck of 52 cards. Shuffling will be called the execution of the following actions: an arbitrary division of the deck into an upper and a lower part, and then an arbitrary mixing of the cards while maintaining the order within each part. Formally, shuffling is any mixing of the cards where the $i$-th card from the top moves to position $p_i$, with the condition that there exists some $m \\in \\{1, 2, 3, \\ldots, 51\\}$ such that $p_i < p_{i+1}$ for $i < m$ and for $i > m$.\nDetermine whether, starting from a fixed initial ordering of the cards, any other ordering can be achieved by performing five shuffles.", "formal_statement": "import Mathlib\nopen Equiv Fin\n\nstructure Shuffle where\n  perm : Perm (Fin 52)\n  split_point : Fin 52\n  lower_ordered : \u2200 i j : Fin 52, i < j \u2192 j < split_point \u2192 perm i < perm j\n  upper_ordered : \u2200 i j : Fin 52, split_point \u2264 i \u2192 i < j \u2192 perm i < perm j\n\n/-- Verifies that a sequence of 5 shuffles transforms the initial arrangement into the target -/\ndef ValidShuffleSequence (initial target : Perm (Fin 52)) (shuffles : List Shuffle) : Prop :=\n  shuffles.length = 5 \u2227\n  (shuffles.foldr (fun s acc => acc.trans s.perm) initial) = target\n\ntheorem five_shuffles_reach_all (initial target : Perm (Fin 52)) :\n  \u2203 shuffles : List Shuffle, ValidShuffleSequence initial target shuffles :=\n  sorry"}
{"id": "CombStruct4Lean_40", "informal_problem": "XLVIII OM - III - Problem 6\n\nOn a circle of radius $ 1 $, there are $ n $ different points ($ n \\geq 2 $). Let $ q $ be the number of segments with endpoints at these points and length greater than $ \\sqrt{2} $. Prove that $ 3q \\leq n^2 $.", "formal_statement": "import Mathlib\n\nstructure CirclePoints where\n  n : \u2115\n  h_size : n \u2265 2\n  points : Fin n \u2192 \u211d \u00d7 \u211d\n  on_circle : \u2200 i, (points i).1 ^ 2 + (points i).2 ^ 2 = 1\n  distinct : Function.Injective points\n\nnoncomputable def distance (p\u2081 p\u2082 : \u211d \u00d7 \u211d) : \u211d :=\n  Real.sqrt ((p\u2081.1 - p\u2082.1)^2 + (p\u2081.2 - p\u2082.2)^2)\n\nnoncomputable def long_segments (cp : CirclePoints) : \u2115 :=\n  Finset.card {p : Fin cp.n \u00d7 Fin cp.n | \n    p.1 < p.2 \u2227 \n    distance (cp.points p.1) (cp.points p.2) > Real.sqrt 2}.toFinset\n\ntheorem circle_points_long_segments (cp : CirclePoints) :\n  3 * long_segments cp \u2264 cp.n ^ 2 := sorry"}
{"id": "CombStruct4Lean_41", "informal_problem": "XXXV OM - III - Task 6\n\nThe towns $ P_1, \\ldots, P_{1025} $ are served by the airlines $ A_1, \\ldots, A_{10} $, such that for any towns $ P_k $ and $ P_m $ ($ k \\neq m $) there exists an airline whose planes fly directly from $ P_k $ to $ P_m $ and directly from $ P_m $ to $ P_k $. Prove that one of these airlines can offer a trip with an odd number of landings starting and ending in the same town.", "formal_statement": "import Mathlib\n\nstructure AirlineGraph where\n  carrier : SimpleGraph (Fin 1025)\n\n/-- A system of airlines where each pair of distinct cities is connected\n    by at least one airline in both directions -/\nstructure AirlineSystem where\n  airlines : Fin 10 \u2192 AirlineGraph\n  complete : \u2200 (i j : Fin 1025), i \u2260 j \u2192\n    \u2203 (a : Fin 10), (airlines a).carrier.Adj i j \u2227 (airlines a).carrier.Adj j i\n\n/-- A cycle in an airline's route network with specified length -/\ndef hasOddCycle (g : SimpleGraph (Fin 1025)) :=\n  \u2203 (n : \u2115) (c : Fin (2 * n + 1) \u2192 Fin 1025),\n    (\u2200 i : Fin (2 * n), g.Adj (c i) (c (i.succ))) \u2227\n    c 0 = c (Fin.last (2 * n + 1))\n\ntheorem exists_airline_with_odd_cycle (sys : AirlineSystem) :\n  \u2203 (a : Fin 10), hasOddCycle (sys.airlines a).carrier :=\n  sorry"}
{"id": "CombStruct4Lean_42", "informal_problem": "XXXVII OM - III - Problem 5\n\nIn a chess tournament, $2n$ ($n > 1$) players participate, and any two of them play at most one game against each other. Prove that such a tournament, in which no three players play three games among themselves, is possible if and only if the total number of games played in the tournament does not exceed $n^2$.", "formal_statement": "import Mathlib\n\nstructure ChessTournament (n : \u2115) where\n  games : Finset (Fin (2*n) \u00d7 Fin (2*n))\n  -- No player plays against themselves\n  no_self : \u2200 p \u2208 games, (Prod.fst p \u2260 Prod.snd p)\n  -- Games are symmetric (if (i,j) is in games, then (j,i) is too)\n  symmetric : \u2200 i j, (i, j) \u2208 games \u2194 (j, i) \u2208 games\n  -- No three players play three games among themselves\n  no_triangle : \u2200 i j k, \u00ac((i, j) \u2208 games \u2227 (j, k) \u2208 games \u2227 (k, i) \u2208 games)\n\ntheorem chess_tournament_characterization (n : \u2115) (h : n > 1) :\n  (\u2203 (t : ChessTournament n), (t.games.card / 2) \u2264 n^2) \u2194\n  (\u2203 (t : ChessTournament n), t.games.card \u2264 2 * n^2) :=\n  sorry"}
{"id": "CombStruct4Lean_43", "informal_problem": "5. Is it possible to color each $1 \\times 1$ cell of a $1000 \\times 1000$ square in one of three colors: red, blue, and green, such that each red cell has two adjacent blue cells, each blue cell has two adjacent green cells, and each green cell has two adjacent red cells? Cells are considered adjacent if they share a common side.", "formal_statement": "import Mathlib\n\ninductive Color where\n  | red : Color\n  | blue : Color\n  | green : Color\n  deriving BEq, Repr\n\nstructure Grid where\n  n : Nat\n  coloring : Fin n \u2192 Fin n \u2192 Color\n\ndef adjacent (n : Nat) (i j i' j' : Fin n) : Bool :=\n  (i = i' \u2227 (j.val + 1 = j'.val \u2228 j.val = j'.val + 1)) \u2228\n  (j = j' \u2227 (i.val + 1 = i'.val \u2228 i.val = i'.val + 1))\n\ndef validColoring (g : Grid) : Prop :=\n  \u2200 (i j : Fin g.n),\n    match g.coloring i j with\n    | Color.red => \u2203 (i\u2081 j\u2081 i\u2082 j\u2082 : Fin g.n),\n        adjacent g.n i j i\u2081 j\u2081 \u2227 adjacent g.n i j i\u2082 j\u2082 \u2227\n        g.coloring i\u2081 j\u2081 = Color.blue \u2227 g.coloring i\u2082 j\u2082 = Color.blue\n    | Color.blue => \u2203 (i\u2081 j\u2081 i\u2082 j\u2082 : Fin g.n),\n        adjacent g.n i j i\u2081 j\u2081 \u2227 adjacent g.n i j i\u2082 j\u2082 \u2227\n        g.coloring i\u2081 j\u2081 = Color.green \u2227 g.coloring i\u2082 j\u2082 = Color.green\n    | Color.green => \u2203 (i\u2081 j\u2081 i\u2082 j\u2082 : Fin g.n),\n        adjacent g.n i j i\u2081 j\u2081 \u2227 adjacent g.n i j i\u2082 j\u2082 \u2227\n        g.coloring i\u2081 j\u2081 = Color.red \u2227 g.coloring i\u2082 j\u2082 = Color.red\n\ntheorem no_valid_coloring_1000 :\n  \u00ac\u2203 (g : Grid), g.n = 1000 \u2227 validColoring g :=\n  sorry"}
{"id": "CombStruct4Lean_44", "informal_problem": "4. (13 points) In a large online chess tournament, each player had exactly three friends among the participants. Each player played one game with all the participants except for their three friends. Could exactly 404 games have been played?", "formal_statement": "import Mathlib\n\n/- Structure representing a chess tournament where each player has exactly 3 friends -/\nstructure ChessTournament where\n  n : Nat\n  /- Set of friends for each player -/\n  friends : Fin n \u2192 Finset (Fin n)\n  /- Each player has exactly 3 friends -/\n  three_friends : \u2200 p, (friends p).card = 3\n  /- Friendship relation is symmetric -/\n  symmetric : \u2200 p q, q \u2208 friends p \u2194 p \u2208 friends q\n  /- Players cannot be friends with themselves -/\n  not_self_friend : \u2200 p, p \u2209 friends p\n  /- Number of players must be at least 4 -/\n  min_players : n \u2265 4\n\n/-- Total number of possible games between n players -/\ndef total_possible_games (n : Nat) : Nat := (n * (n - 1))/2\n\n/-- Total number of friend pairs in the tournament -/\ndef total_friend_pairs (t : ChessTournament) : Nat := (3 * t.n)/2\n\ntheorem chess_tournament_404_possible : \u2203 (t : ChessTournament),\n  total_possible_games t.n - total_friend_pairs t = 404 :=\n  sorry"}
{"id": "CombStruct4Lean_45", "informal_problem": "9.5. There are 64 checkers of three colors, divided into pairs such that the colors of the checkers in each pair are different. Prove that all the checkers can be arranged on a chessboard so that the checkers in each two-square rectangle are of different colors.", "formal_statement": "import Mathlib\n\ndef isAdjacent (p\u2081 p\u2082 : Fin 8 \u00d7 Fin 8) : Prop := \n  let (i\u2081, j\u2081) := p\u2081\n  let (i\u2082, j\u2082) := p\u2082\n  (i\u2081 = i\u2082 \u2227 j\u2082.val = j\u2081.val + 1) \u2228 \n  (j\u2081 = j\u2082 \u2227 i\u2082.val = i\u2081.val + 1)\n\n@[ext]\nstructure CheckerBoard where\n  color : (i j : Fin 8) \u2192 Fin 3\n  pairs : Finset ((Fin 8 \u00d7 Fin 8) \u00d7 (Fin 8 \u00d7 Fin 8))\n  pairs_valid : \n    -- Each position appears in exactly one pair\n    (\u2200 pos : Fin 8 \u00d7 Fin 8, \u2203! p \u2208 pairs, \n      pos = p.1 \u2228 pos = p.2) \u2227\n    -- Pairs have different colors\n    (\u2200 p \u2208 pairs, color p.1.1 p.1.2 \u2260 color p.2.1 p.2.2) \u2227\n    -- Total number of pairs is 32 (64/2)\n    Finset.card pairs = 32\n\ntheorem checker_arrangement_exists : \n  \u2203 (board : CheckerBoard),\n    \u2200 p\u2081 p\u2082 : Fin 8 \u00d7 Fin 8,\n      isAdjacent p\u2081 p\u2082 \u2192\n      board.color p\u2081.1 p\u2081.2 \u2260 board.color p\u2082.1 p\u2082.2 :=\n  sorry"}
{"id": "CombStruct4Lean_46", "informal_problem": "Problem 5. In a physics competition, 17 schoolchildren are participating. The participants were offered 12 problems. As a result, each problem was solved correctly by more than half of the participants. Prove that there will definitely be three schoolchildren who, together, have solved all the problems.", "formal_statement": "import Mathlib\n\nstructure PhysicsCompetition where\n  n_students : Nat\n  n_problems : Nat\n  solutions : Fin n_students \u2192 Fin n_problems \u2192 Bool\n  more_than_half_solved : \u2200 p : Fin n_problems,\n    2 * (Finset.univ.filter (fun s => solutions s p)).card > n_students\nderiving Repr\n\ntheorem physics_competition_three_cover \n  (comp : PhysicsCompetition)\n  (h1 : comp.n_students = 17)\n  (h2 : comp.n_problems = 12) :\n  \u2203 (s1 s2 s3 : Fin comp.n_students),\n    \u2200 p : Fin comp.n_problems,\n      comp.solutions s1 p \u2228 comp.solutions s2 p \u2228 comp.solutions s3 p :=\n  sorry"}
{"id": "CombStruct4Lean_47", "informal_problem": "10.5. There are 64 checkers of several colors, paired such that the colors of the checkers in each pair are different. Prove that all the checkers can be arranged on a chessboard so that the checkers in each two-square rectangle are of different colors.", "formal_statement": "import Mathlib\n\nstructure CheckerArrangement where\n  n : Nat                              -- number of colors\n  colors : Fin 64 \u2192 Fin n             -- color assignment for each checker\n  pairs : Fin 32 \u2192 Fin 64 \u00d7 Fin 64    -- the given pairs of checkers\n  positions : Fin 64 \u2192 Fin 8 \u00d7 Fin 8   -- position of each checker on the board\n\n-- Predicate to check if two positions form a 2\u00d71 or 1\u00d72 rectangle\ndef isRectangle (p1 p2 : Fin 8 \u00d7 Fin 8) : Bool :=\n  let (x1, y1) := p1\n  let (x2, y2) := p2\n  (x1 = x2 && y1.val + 1 = y2.val) ||    -- vertical rectangle\n  (y1 = y2 && x1.val + 1 = x2.val)       -- horizontal rectangle\n\ntheorem checker_arrangement_exists : \u2203 (arr : CheckerArrangement), \n  -- Pairs have different colors\n  (\u2200 i : Fin 32, let (c1, c2) := arr.pairs i; arr.colors c1 \u2260 arr.colors c2) \u2227\n  -- Checkers in rectangles have different colors\n  (\u2200 i j : Fin 64, isRectangle (arr.positions i) (arr.positions j) \u2192 \n    arr.colors i \u2260 arr.colors j) :=\n  sorry"}
{"id": "CombStruct4Lean_48", "informal_problem": "3. There are 288 visually identical coins weighing 7 and 8 grams (both types are present). On the scales, 144 coins were placed on each pan such that the scales are in balance. In one operation, you can take any two groups of the same number of coins from the pans and swap their places. Prove that it is possible to make the scales unbalanced in no more than 11 operations.", "formal_statement": "import Mathlib\n\nstructure CoinConfiguration where\n  leftEights : Nat    -- 8g coins in left pan\n  leftSevens : Nat    -- 7g coins in left pan\n  rightEights : Nat   -- 8g coins in right pan\n  rightSevens : Nat   -- 7g coins in right pan\n\ndef panWeight (eights sevens : Nat) : Nat :=\n  8 * eights + 7 * sevens\n\ndef isValidConfiguration (conf : CoinConfiguration) : Prop :=\n  conf.leftEights + conf.leftSevens = 144 \u2227\n  conf.rightEights + conf.rightSevens = 144 \u2227\n  conf.leftEights + conf.leftSevens + conf.rightEights + conf.rightSevens = 288\n\ndef isBalanced (conf : CoinConfiguration) : Prop :=\n  panWeight conf.leftEights conf.leftSevens = \n  panWeight conf.rightEights conf.rightSevens\n\ndef swapGroups (conf : CoinConfiguration) (countEights countSevens : Nat) : CoinConfiguration :=\n  { leftEights := conf.leftEights - countEights + countEights\n    leftSevens := conf.leftSevens - countSevens + countSevens\n    rightEights := conf.rightEights + countEights - countEights\n    rightSevens := conf.rightSevens + countSevens - countSevens }\n\ntheorem coin_balance_problem (initial : CoinConfiguration) \n    (h\u2081 : isValidConfiguration initial) \n    (h\u2082 : isBalanced initial) :\n  \u2203 (operations : List (Nat \u00d7 Nat)), \n    operations.length \u2264 11 \u2227 \n    let final := operations.foldl (fun conf op => swapGroups conf op.1 op.2) initial\n    isValidConfiguration final \u2227 \u00acisBalanced final :=\n  sorry"}
{"id": "CombStruct4Lean_49", "informal_problem": "8.4. At the Olympiad, 300 students from no fewer than 4 schools arrived. Prove that they can be divided into teams of 3 people each, so that in each team either all three students are from the same school, or all three are from different schools.", "formal_statement": "import Mathlib\n\n/-- Setup for the Olympiad problem with students and schools -/\nstructure OlympiadSetup where\n  numStudents : Nat\n  numSchools : Nat\n  students : Fin numStudents \u2192 Fin numSchools  -- maps each student to their school\n  exactly300 : numStudents = 300\n  atLeast4Schools : numSchools \u2265 4\n  schoolsNotEmpty : \u2200 s : Fin numSchools, \u2203 t : Fin numStudents, students t = s\n\n/-- A team of three students -/\nstructure Team (setup : OlympiadSetup) where\n  student1 : Fin setup.numStudents\n  student2 : Fin setup.numStudents\n  student3 : Fin setup.numStudents\n  distinct : student1 \u2260 student2 \u2227 student2 \u2260 student3 \u2227 student1 \u2260 student3\n\n/-- All students in the team are from the same school -/\ndef allSameSchool (setup : OlympiadSetup) (team : Team setup) : Prop :=\n  setup.students team.student1 = setup.students team.student2 \u2227\n  setup.students team.student2 = setup.students team.student3\n\n/-- All students in the team are from different schools -/\ndef allDifferentSchools (setup : OlympiadSetup) (team : Team setup) : Prop :=\n  setup.students team.student1 \u2260 setup.students team.student2 \u2227\n  setup.students team.student2 \u2260 setup.students team.student3 \u2227\n  setup.students team.student1 \u2260 setup.students team.student3\n\n/-- A team is valid if either all students are from the same school\n    or all students are from different schools -/\ndef isValidTeam (setup : OlympiadSetup) (team : Team setup) : Prop :=\n  allSameSchool setup team \u2228 allDifferentSchools setup team\n\ntheorem olympiad_team_division (setup : OlympiadSetup) :\n  \u2203 (teams : Fin 100 \u2192 Team setup),\n    (\u2200 t, isValidTeam setup (teams t)) \u2227 \n    (\u2200 s : Fin setup.numStudents, \u2203! t : Fin 100, \n      s = (teams t).student1 \u2228 s = (teams t).student2 \u2228 s = (teams t).student3) :=\n  sorry"}
{"id": "CombStruct4Lean_50", "informal_problem": "Problem 5. At the court, 50 musketeers serve. Every day they split into pairs and conduct training duels. Is it true that after 24 days, there will be three musketeers who have not participated in training duels with each other?", "formal_statement": "import Mathlib\n\nstructure DuelSchedule where\n  edges : Fin 50 \u2192 Fin 50 \u2192 Option (Fin 24)  -- None means no duel scheduled\n  valid : \u2200 i j, i \u2260 j \u2192 edges i j = edges j i  -- symmetry\n  no_self_duels : \u2200 i, edges i i = none\n  one_per_day : \u2200 d i, (\u2203 j, edges i j = some d) \u2192 \n                       (\u2200 k \u2260 j, edges i k \u2260 some d)\n  daily_pairs : \u2200 i d, \u2203 j, edges i j = some d \u2228 edges j i = some d  -- everyone duels each day\n\ntheorem musketeer_pairs_ramsey :\n  \u2200 (schedule : DuelSchedule),\n  \u2203 (m1 m2 m3 : Fin 50), \n    m1 \u2260 m2 \u2227 m2 \u2260 m3 \u2227 m1 \u2260 m3 \u2227\n    schedule.edges m1 m2 = none \u2227\n    schedule.edges m2 m3 = none \u2227\n    schedule.edges m1 m3 = none :=\n  sorry"}
{"id": "CombStruct4Lean_51", "informal_problem": "4. On an $8 \\times 8$ chessboard, 8 rooks are placed such that no rook attacks another. Passing by the board, Vitya noticed three rooks standing on white squares. Prove that there is at least one more rook, also standing on a white square.", "formal_statement": "import Mathlib\n\n/-- A valid rook placement is a set of exactly 8 positions where no two rooks share a row or column -/\nstructure ChessBoard where\n  positions : Finset (Fin 8 \u00d7 Fin 8)\n  size_eight : positions.card = 8\n  no_row_attacks : \u2200 p q, p \u2208 positions \u2192 q \u2208 positions \u2192 p \u2260 q \u2192 p.1 \u2260 q.1\n  no_col_attacks : \u2200 p q, p \u2208 positions \u2192 q \u2208 positions \u2192 p \u2260 q \u2192 p.2 \u2260 q.2\n\n/-- A square is white if the sum of its coordinates is even -/\ndef isWhiteSquare (pos : Fin 8 \u00d7 Fin 8) : Bool :=\n  (pos.1.val + pos.2.val) % 2 = 0\n\n/-- Count the number of rooks on white squares -/\ndef whiteSquareCount (board : ChessBoard) : \u2115 :=\n  (board.positions.filter (fun pos => isWhiteSquare pos)).card\n\ntheorem rooks_on_white_squares (board : ChessBoard) :\n  whiteSquareCount board \u2265 3 \u2192 whiteSquareCount board \u2265 4 :=\n  sorry"}
{"id": "CombStruct4Lean_52", "informal_problem": "2. Each of the 8 squirrels threw a pine cone at some other squirrel, independently of the others. Prove that there will always be a group of three squirrels who did not throw a pine cone at a squirrel from this group.", "formal_statement": "import Mathlib\n\nabbrev Squirrel := Fin 8\n\nstructure PineConeThrows where\n  throws : Squirrel \u2192 Squirrel\n  no_self_throws : \u2200 i, throws i \u2260 i\n\n/-- Returns true if squirrel i throws a pine cone at any squirrel in the given set -/\ndef throws_into_set (throws : PineConeThrows) (i : Squirrel) (s : Finset Squirrel) : Prop :=\n  throws.throws i \u2208 s\n\ntheorem pine_cone_triangle (throws : PineConeThrows) :\n  \u2203 s : Finset Squirrel, s.card = 3 \u2227 \n    \u2200 i \u2208 s, \u00acthrows_into_set throws i s :=\n  sorry"}
{"id": "CombStruct4Lean_53", "informal_problem": "9. In a class consisting of 21 students, any three students have done homework together exactly once, either in mathematics or in Russian language. Can we assert that in this class there exists a quartet of students, any three of whom have done homework together in the same subject?", "formal_statement": "import Mathlib\n\ninductive Subject where\n  | Mathematics\n  | Russian\n\nstructure HomeworkGroup (n : \u2115) where\n  students : Finset (Fin n)\n  subject : Subject\n\ndef isValidGroup {n : \u2115} (g : HomeworkGroup n) : Prop :=\n  g.students.card = 3\n\ndef hasUniqueHomework {n : \u2115} (groups : Finset (HomeworkGroup n)) : Prop :=\n  \u2200 s\u2081 s\u2082 s\u2083 : Fin n,\n    s\u2081 \u2260 s\u2082 \u2192 s\u2082 \u2260 s\u2083 \u2192 s\u2081 \u2260 s\u2083 \u2192\n    \u2203! g \u2208 groups, g.students = {s\u2081, s\u2082, s\u2083}\n\ndef validConfiguration {n : \u2115} (groups : Finset (HomeworkGroup n)) : Prop :=\n  (\u2200 g \u2208 groups, isValidGroup g) \u2227\n  hasUniqueHomework groups\n\ntheorem homework_problem\n  (groups : Finset (HomeworkGroup 21))\n  (h_valid : validConfiguration groups) :\n  \u2203 S : Finset (Fin 21),\n    S.card = 4 \u2227\n    \u2203 subj : Subject,\n      \u2200 T \u2286 S, T.card = 3 \u2192\n        \u2200 g \u2208 groups, g.students = T \u2192 g.subject = subj :=\n  sorry"}
{"id": "CombStruct4Lean_54", "informal_problem": "2. At a round table, 40 people are sitting. Could it happen that any two of them, between whom an even number of people sit, have a common acquaintance at the table, while any two, between whom an odd number of people sit, do not have a common acquaintance? (A. Shapovalov)", "formal_statement": "import Mathlib\n\nstructure RoundTable where\n  n : Nat                                     -- number of people\n  acquaintance : Fin n \u2192 Fin n \u2192 Bool         -- acquaintance relation\n  common_acquaintance (i j : Fin n) : Bool :=\n    \u2203 k : Fin n, k \u2260 i \u2227 k \u2260 j \u2227 acquaintance i k \u2227 acquaintance j k\n\ndef distance_between (n : Nat) (i j : Fin n) : Nat :=\n  min (((j.val + n) - i.val) % n) (((i.val + n) - j.val) % n)\n\ntheorem round_table_acquaintance (t : RoundTable) (h : t.n = 40) :\n  \u00ac(\u2200 (i j : Fin t.n),\n    (distance_between t.n i j % 2 = 0 \u2192 t.common_acquaintance i j) \u2227\n    (distance_between t.n i j % 2 = 1 \u2192 \u00act.common_acquaintance i j)) :=\n  sorry"}
{"id": "CombStruct4Lean_55", "informal_problem": "2. In each of the 111 families, there are three people: a father, a mother, and a child. All 333 people lined up in a row. It turned out that the parents of each child are standing on different sides of the child (but not necessarily next to the child). Prove that among the central 111 people in this row, there is at least one child.", "formal_statement": "import Mathlib\n\ninductive Role\n  | father\n  | mother\n  | child\n  deriving Inhabited, DecidableEq\n\nstructure Family where\n  father : Fin 333\n  mother : Fin 333\n  child : Fin 333\n  distinct : father \u2260 mother \u2227 father \u2260 child \u2227 mother \u2260 child\n\n/-- Predicate to check if a position is in the middle section (111 to 221 inclusive) -/\ndef is_middle_position (pos : Fin 333) : Prop :=\n  111 \u2264 Fin.val pos \u2227 Fin.val pos \u2264 221\n\n/-- A valid arrangement of people in line -/\nstructure Arrangement where\n  positions : Fin 333 \u2192 Fin 333\n  injective : Function.Injective positions\n  families : Fin 111 \u2192 Family\n  valid_family_positions : \u2200 (f : Fin 111),\n    let fam := families f\n    (Fin.val (positions fam.father) < Fin.val (positions fam.child) \u2227 \n     Fin.val (positions fam.child) < Fin.val (positions fam.mother)) \u2228\n    (Fin.val (positions fam.mother) < Fin.val (positions fam.child) \u2227 \n     Fin.val (positions fam.child) < Fin.val (positions fam.father))\n\ntheorem child_in_middle (arr : Arrangement) : \n  \u2203 (f : Fin 111), is_middle_position (arr.positions (arr.families f).child) :=\n  sorry"}
{"id": "CombStruct4Lean_56", "informal_problem": "7. Given a circle of length 90. Is it possible to mark 10 points on it so that among the arcs with endpoints at these points there are arcs of all integer lengths from 1 to 89? (K. Knop)", "formal_statement": "import Mathlib\n\n-- Points are represented as natural numbers from 0 to 89\nstructure CircleMarking where\n  points : Finset \u2115\n  -- Each point is in [0,89]\n  points_in_range : \u2200 p \u2208 points, p < 90\n  -- There are exactly 10 points\n  card_eq : points.card = 10\n\n/-- Compute arc length between two points on a circle of length 90.\n    Points are represented as natural numbers from 0 to 89. -/\ndef arcLength (x y : \u2115) : \u2115 :=\n  let diff := Int.natAbs (x - y)\n  Nat.min diff (90 - diff)\n\n/-- Predicate indicating that a marking contains arcs of all lengths from 1 to 89 -/\ndef hasAllLengths (m : CircleMarking) : Prop :=\n  \u2200 k : \u2115, 1 \u2264 k \u2227 k \u2264 89 \u2192\n    \u2203 x \u2208 m.points, \u2203 y \u2208 m.points, x \u2260 y \u2227 arcLength x y = k\n\ntheorem circle_marking_possible : \n  \u2203 (m : CircleMarking), hasAllLengths m :=\n  sorry"}
{"id": "CombStruct4Lean_57", "informal_problem": "2. In Shvambania, some cities are connected by two-way non-stop flights. The flights are divided among three airlines, and if one airline serves a route between cities A and B, then planes of other airlines do not fly between these cities. It is known that from each city, flights of all three airlines depart. Prove that it is possible to fly out of some city and return to it, using flights of all three airlines along the way without visiting any of the intermediate cities more than once. (C. Berlov)", "formal_statement": "import Mathlib\n\ninductive Airline\n  | one\n  | two\n  | three\nderiving DecidableEq\n\nstructure FlightNetwork (u : Type) where\n  flights : u \u2192 u \u2192 Airline \u2192 Prop\n  -- Flights are bidirectional\n  sym : \u2200 c1 c2 a, flights c1 c2 a \u2194 flights c2 c1 a\n  -- Airlines are exclusive on routes\n  exclusive : \u2200 c1 c2 a1 a2, \n    flights c1 c2 a1 \u2192 a1 \u2260 a2 \u2192 \u00acflights c1 c2 a2\n  -- From each city, all three airlines depart to different cities\n  all_airlines_distinct : \u2200 c, \u2203 d1 d2 d3,\n    d1 \u2260 d2 \u2227 d2 \u2260 d3 \u2227 d1 \u2260 d3 \u2227\n    flights c d1 Airline.one \u2227\n    flights c d2 Airline.two \u2227\n    flights c d3 Airline.three\n  -- At least one city exists\n  nonempty : Nonempty u\n\ntheorem shvambania_cycle {u : Type} [Finite u] (n : FlightNetwork u) :\n  \u2203 (k : Nat) (path : Fin (k + 1) \u2192 u) (airlines : Fin k \u2192 Airline),\n    -- First and last cities are the same (cycle)\n    path 0 = path \u27e8k, by simp\u27e9 \u2227\n    -- Each consecutive pair is connected by the corresponding airline\n    (\u2200 i : Fin k, n.flights (path i) (path \u27e8i.val + 1, by simp [i.isLt]\u27e9) (airlines i)) \u2227\n    -- No intermediate city appears twice\n    (\u2200 i j : Fin k, i \u2260 j \u2192 path i \u2260 path j) \u2227\n    -- All three airlines are used\n    (\u2203 i\u2081 i\u2082 i\u2083 : Fin k,\n      airlines i\u2081 = Airline.one \u2227\n      airlines i\u2082 = Airline.two \u2227\n      airlines i\u2083 = Airline.three) :=\n  sorry"}
{"id": "CombStruct4Lean_58", "informal_problem": "5. Can a rectangle $1000 \\times 2016$ be cut into rectangles $1 \\times 2015$ and three-cell \"corners\" so that both types of figures are present? (E. Bakayev)", "formal_statement": "import Mathlib\n\nstructure Corner where\n  -- A three-cell corner is a shape made of three unit squares in an L shape\n  pos : \u2115 \u00d7 \u2115  -- position of the top-left cell\n\nstructure RectangleTiling where\n  width : \u2115 \n  height : \u2115\n  -- List of positions of 1\u00d72015 rectangles (top-left corner position)\n  strips : List (\u2115 \u00d7 \u2115)\n  -- List of corner positions (top-left position)\n  corners : List Corner\n  -- The tiling must be valid (no overlaps and covers the whole rectangle)\n  valid : Bool\n\ntheorem rectangle_tiling_existence : \n  \u2203 (t : RectangleTiling), \n    t.width = 1000 \u2227 \n    t.height = 2016 \u2227 \n    t.valid = true \u2227 \n    t.strips.length > 0 \u2227 \n    t.corners.length > 0 :=\n  sorry"}
{"id": "CombStruct4Lean_59", "informal_problem": "5. On a circle, 2013 points are marked and each is connected to its two neighbors. Also, the center of the circle is marked and connected to all other marked points. Is it possible to paint 1007 of the marked points red and the other 1007 blue so that each red point is connected to an odd number of blue points, and each blue point is connected to an even number of blue points? (I. Rubanov)", "formal_statement": "import Mathlib\n\nstructure CircleGraph where\n  n : Nat                      -- number of points on circle\n  center : Fin (n + 1)        -- center point has index n\n  h_center : center = \u27e8n, by simp\u27e9  -- center is the last point\n\ndef Coloring (g : CircleGraph) := Fin (g.n + 1) \u2192 Bool\n\ndef isNeighbor (g : CircleGraph) (i j : Fin (g.n + 1)) : Bool :=\n  if i = g.center \u2228 j = g.center then\n    i \u2260 j  -- center connected to all other points\n  else if i.val < g.n \u2227 j.val < g.n then\n    -- points on circle connected to adjacent points\n    (i.val + 1) % g.n = j.val \u2228 (j.val + 1) % g.n = i.val\n  else\n    false\n\ndef blueNeighborCount (g : CircleGraph) (c : Coloring g) (v : Fin (g.n + 1)) : Nat :=\n  (Finset.filter (fun i => isNeighbor g v i \u2227 !c i) Finset.univ).card\n\ntheorem circle_coloring_impossible (g : CircleGraph) (h1 : g.n = 2013) : \n  \u00ac\u2203 (c : Coloring g),\n    -- Equal number of red and blue points\n    (Finset.filter (fun i => c i) Finset.univ).card = 1007 \u2227\n    (Finset.filter (fun i => !c i) Finset.univ).card = 1007 \u2227\n    -- Red points connected to odd number of blue points\n    (\u2200 v, c v \u2192 Odd (blueNeighborCount g c v)) \u2227\n    -- Blue points connected to even number of blue points\n    (\u2200 v, !c v \u2192 Even (blueNeighborCount g c v)) :=\n  sorry"}
{"id": "CombStruct4Lean_60", "informal_problem": "3. In a football tournament where each team played against each other once, 16 teams participated. Three points were awarded for a win, one point for a draw, and zero points for a loss. After the tournament, it was found that each team won at least a third of their matches and lost at least a third of their matches. Prove that some two teams scored the same number of points.", "formal_statement": "import Mathlib\n\nstructure TournamentResult where\n  numTeams : Nat\n  scores : Fin numTeams \u2192 Nat\n  wins : Fin numTeams \u2192 Nat\n  draws : Fin numTeams \u2192 Nat\n  losses : Fin numTeams \u2192 Nat\n  -- Each match results in exactly one outcome\n  matches_sum : \u2200 t, wins t + draws t + losses t = numTeams - 1\n  -- At least one third of matches are wins\n  min_wins : \u2200 t, 3 * wins t \u2265 numTeams - 1\n  -- At least one third of matches are losses\n  min_losses : \u2200 t, 3 * losses t \u2265 numTeams - 1\n  -- Score calculation (3 points for win, 1 for draw)\n  score_calc : \u2200 t, scores t = 3 * wins t + draws t\n\ntheorem tournament_equal_scores : \n  \u2200 (t : TournamentResult), t.numTeams = 16 \u2192 \n  \u2203 i j : Fin t.numTeams, i \u2260 j \u2227 t.scores i = t.scores j :=\n  sorry"}
{"id": "CombStruct4Lean_61", "informal_problem": "6. Prove that for any non-negative integer $k$ not exceeding $\\frac{2022 \\cdot 2021}{2}$, there exist 2022 numbers such that all their $\\frac{2022 \\cdot 2021}{2}$ pairwise sums are distinct and exactly $k$ of these sums are positive. (I. Rubanov, S. Berlov, L. Samoilov)", "formal_statement": "import Mathlib\n\n/-- Total number of pairs from 2022 elements -/\ndef totalPairs : \u2115 := (2022 * 2021) / 2\n\n/-- Count the number of positive pairwise sums -/\ndef countPositivePairwiseSums (nums : Fin 2022 \u2192 \u2124) : \u2115 :=\n  Finset.sum Finset.univ fun i =>\n    Finset.sum (Finset.filter (fun j => i < j) Finset.univ) fun j =>\n      if nums i + nums j > 0 then 1 else 0\n\n/-- Property that all pairwise sums are distinct -/\ndef hasPairwiseDistinctSums (nums : Fin 2022 \u2192 \u2124) : Prop :=\n  \u2200 i j k l : Fin 2022, (i \u2260 k \u2228 j \u2260 l) \u2192 \n    (i < j \u2227 k < l) \u2192 nums i + nums j \u2260 nums k + nums l\n\ntheorem exists_nums_with_k_positive_sums \n  (k : \u2115) (h\u2081 : k \u2265 0) (h\u2082 : k \u2264 totalPairs) :\n  \u2203 nums : Fin 2022 \u2192 \u2124,\n    hasPairwiseDistinctSums nums \u2227\n    countPositivePairwiseSums nums = k :=\n  sorry"}
{"id": "CombStruct4Lean_62", "informal_problem": "8. In the club, there are 42 people, any two of whom have at least ten common friends among the club members. Prove that there will be two people who have at least twelve common friends among the club members. (M. Antipov)", "formal_statement": "import Mathlib\n\nstructure Club where\n  members : Finset Nat\n  size_eq : members.card = 42\n  friendship : Nat \u2192 Nat \u2192 Bool\n  friendship_symmetric : \u2200 x y, friendship x y = friendship y x\n  common_friends : Nat \u2192 Nat \u2192 Nat\n  common_friends_def : \u2200 x y, common_friends x y = \n    (members.filter (fun z \u21a6 friendship x z \u2227 friendship y z)).card\n  min_common_friends : \u2200 x y, x \u2208 members \u2192 y \u2208 members \u2192 x \u2260 y \u2192 \n    common_friends x y \u2265 10\n\ntheorem exists_twelve_common_friends (c : Club) : \n  \u2203 x y, x \u2208 c.members \u2227 y \u2208 c.members \u2227 x \u2260 y \u2227 c.common_friends x y \u2265 12 :=\n  sorry"}
{"id": "CombStruct4Lean_63", "informal_problem": "9. There are 70 switches and 15 lamps. Each lamp is connected to 35 switches. No two switches are connected to the same set of lamps. Pressing a switch changes the state of all the lamps it is connected to (turning on the off ones and vice versa). Initially, all lamps are off. Prove that it is possible to press some 19 switches in such a way that at least eight lamps are turned on. (S. Berlov)", "formal_statement": "import Mathlib\n\nstructure SwitchSystem where\n  switches : Fin 70 \u2192 Finset (Fin 15)  -- Each switch maps to the set of lamps it controls\n  switch_size : \u2200 s, (switches s).card = 35  -- Each switch controls 35 lamps\n  different_sets : \u2200 s\u2081 s\u2082, s\u2081 \u2260 s\u2082 \u2192 switches s\u2081 \u2260 switches s\u2082  -- No two switches control same set\n\n/-- Given a set of switches that are pressed, compute which lamps are on -/\ndef lampsOn (sys : SwitchSystem) (pressed : Finset (Fin 70)) (l : Fin 15) : Bool :=\n  Odd (Finset.filter (fun s => l \u2208 sys.switches s) pressed).card\n\ntheorem switch_problem (sys : SwitchSystem) :\n  \u2203 pressed : Finset (Fin 70),\n    (pressed.card = 19) \u2227\n    ((Finset.filter (fun l => lampsOn sys pressed l) (Finset.univ : Finset (Fin 15))).card \u2265 8) :=\n  sorry"}
{"id": "CombStruct4Lean_64", "informal_problem": "5. Igor wants to cut out $1 \\times 6$ grid rectangles from a grid square of size $11 \\times 1117$. Is it possible to mark one cell in the square so that it will definitely remain uncut, no matter how hard Igor tries?", "formal_statement": "import Mathlib\n\nstructure Rectangle where\n  x : Nat\n  y : Nat\n  width : Nat\n  height : Nat\n  valid : width = 1 \u2227 height = 6 \u2228 width = 6 \u2227 height = 1\n\nstructure GridCovering (w h : Nat) where\n  rectangles : List Rectangle\n  marked : Fin w \u00d7 Fin h\n\ntheorem exists_uncovered_cell : \n  \u2203 (pos : Fin 11 \u00d7 Fin 1117), \n    \u2200 (covering : List Rectangle),\n      \u2200 (r : Rectangle), r \u2208 covering \u2192\n        \u00ac(Nat.le r.x pos.1.val \u2227 pos.1.val < r.x + r.width \u2227\n          Nat.le r.y pos.2.val \u2227 pos.2.val < r.y + r.height) :=\n  sorry"}
{"id": "CombStruct4Lean_65", "informal_problem": "5. A six-digit number $N$ coincides with each of the five six-digit numbers $A, B, C, D, E$ in three digits. Prove that among the numbers $A, B, C, D, E$ there will be two that coincide in at least two digits.", "formal_statement": "import Mathlib\n\n-- Represent a six-digit number as a function from Fin 6 to Fin 10\ndef SixDigitNum := Fin 6 \u2192 Fin 10\n\n-- Count matching digits between two numbers\ndef matchingDigits (n1 n2 : SixDigitNum) : Nat :=\n  (List.range 6).filter (fun i => n1 i = n2 i) |>.length\n\n-- Definition for when two numbers match in k positions\ndef matchesInK (n1 n2 : SixDigitNum) (k : Nat) : Prop :=\n  matchingDigits n1 n2 = k\n\ntheorem digit_matching_problem\n  (N A B C D E : SixDigitNum)\n  (hA : matchesInK N A 3)\n  (hB : matchesInK N B 3)\n  (hC : matchesInK N C 3)\n  (hD : matchesInK N D 3)\n  (hE : matchesInK N E 3) :\n  \u2203 (x y : SixDigitNum), x \u2208 [A, B, C, D, E] \u2227 y \u2208 [A, B, C, D, E] \u2227 x \u2260 y \u2227\n    matchingDigits x y \u2265 2 :=\n  sorry"}
{"id": "CombStruct4Lean_66", "informal_problem": "5. On the board, 8 non-intersecting circles were drawn, and from each one, an arrow was drawn to those of the other seven that are not larger than it. In total, 33 arrows were obtained. Prove that among the circles drawn on the board, there are three equal ones.", "formal_statement": "import Mathlib\n\nstructure CircleSystem where\n  circles : Fin 8 \u2192 \u2115\n  arrows : Finset (Fin 8 \u00d7 Fin 8)\n  -- If there's an arrow from i to j, then circle j is not larger than circle i\n  arrow_valid : \u2200 {i j}, (i, j) \u2208 arrows \u2192 circles j \u2264 circles i\n  -- No self-arrows\n  no_self_arrows : \u2200 i, (i, i) \u2209 arrows\n  -- Total number of arrows is 33\n  total_arrows : arrows.card = 33\n  -- If circle j is not larger than circle i, there must be an arrow from i to j\n  arrow_complete : \u2200 {i j}, circles j \u2264 circles i \u2192 (i, j) \u2208 arrows\n\ntheorem circle_equality_exists (sys : CircleSystem) :\n  \u2203 (i j k : Fin 8), i \u2260 j \u2227 j \u2260 k \u2227 i \u2260 k \u2227 \n    sys.circles i = sys.circles j \u2227 sys.circles j = sys.circles k :=\n  sorry"}
{"id": "CombStruct4Lean_67", "informal_problem": "2. From a chessboard of size $13 \\times 13$, two opposite corner cells have been cut out. On the remaining part of the board, several cells have been marked. Prove that it is possible to place chess kings on the marked cells such that the total number of kings does not exceed 47, and they attack all the empty marked cells. Recall that a chess king attacks all cells adjacent to it vertically, horizontally, and diagonally. (S. Berlov)", "formal_statement": "import Mathlib\n\n-- Valid position on the modified chessboard (corners removed)\nstructure ValidPos where\n  row : Fin 13\n  col : Fin 13\n  not_corner : \u00ac((row = 0 \u2227 col = 0) \u2228 (row = 12 \u2227 col = 12))\n\n-- The chessboard with marked cells\nstructure ChessBoard where\n  marked : ValidPos \u2192 Bool\n\n-- Helper function to check if a king at position i,j attacks position x,y\ndef attacks (i j x y : Fin 13) : Bool :=\n  let di := if i \u2265 x then i - x else x - i\n  let dj := if j \u2265 y then j - y else y - j\n  di \u2264 1 \u2227 dj \u2264 1 \u2227 \u00ac(i = x \u2227 j = y)\n\n-- Predicate to check if a set of kings attacks all marked cells\ndef coversAllMarked (board : ChessBoard) (kings : Finset ValidPos) : Prop :=\n  \u2200 pos : ValidPos, board.marked pos \u2192 \n    pos \u2208 kings \u2228 \n    \u2203 k \u2208 kings, attacks k.row k.col pos.row pos.col\n\n-- Predicate to ensure kings are only placed on marked cells\ndef kingsOnMarked (board : ChessBoard) (kings : Finset ValidPos) : Prop :=\n  \u2200 k \u2208 kings, board.marked k\n\ntheorem kings_placement_exists (board : ChessBoard) :\n  \u2203 (kings : Finset ValidPos),\n    kings.card \u2264 47 \u2227\n    kingsOnMarked board kings \u2227\n    coversAllMarked board kings :=\n  sorry"}
{"id": "CombStruct4Lean_68", "informal_problem": "2. On the way to the museum, a group of kindergarteners lined up in pairs, with the number of pairs of two boys being three times the number of pairs of two girls. On the way back, the same group lined up such that the number of pairs of two boys was four times the number of pairs of two girls. Prove that the same group can be lined up so that the number of pairs of two boys is seven times the number of pairs of two girls. (I. Bogdanov)", "formal_statement": "import Mathlib\n\nstructure KindergartenGroup where\n  boys : Nat\n  girls : Nat\n  \n/-- Number of possible pairs of two children of the same gender -/\ndef samePairs (n : Nat) : Nat := n * (n - 1) / 2\n\n/-- Given a group of children, returns the number of boy-boy pairs -/\ndef boyPairs (g : KindergartenGroup) : Nat := samePairs g.boys\n\n/-- Given a group of children, returns the number of girl-girl pairs -/\ndef girlPairs (g : KindergartenGroup) : Nat := samePairs g.girls\n\ntheorem kindergarten_pairs_existence (g : KindergartenGroup)\n  (h1 : boyPairs g = 3 * girlPairs g)  -- first arrangement\n  (h2 : boyPairs g = 4 * girlPairs g)  -- second arrangement\n  : boyPairs g = 7 * girlPairs g :=    -- desired arrangement\n  sorry"}
{"id": "CombStruct4Lean_69", "informal_problem": "2. In the country of Euleria, there are 101 cities. Every two cities are connected by a two-way non-stop flight of one of 99 airlines. It is known that from each city, flights of all 99 companies depart. We will call a triangle three cities that are pairwise connected by flights of the same company. Prove that in Euleria there is no more than one triangle. (I. Bogdanov, D. Karpov)", "formal_statement": "import Mathlib\n\nstructure FlightNetwork where\n  -- Number of cities (101)\n  n : Nat\n  -- Number of airlines (99)\n  k : Nat\n  -- Flight assignment: given two cities and an airline, returns whether that airline connects those cities\n  flights : Fin n \u2192 Fin n \u2192 Fin k \u2192 Bool\n  -- Every two cities are connected by exactly one airline\n  unique_connection : \u2200 (i j : Fin n), i \u2260 j \u2192 \u2203! (a : Fin k), flights i j a\n  -- Flights are bidirectional\n  symmetric : \u2200 (i j : Fin n) (a : Fin k), flights i j a = flights j i a\n  -- From each city, flights of all companies depart\n  all_airlines : \u2200 (i : Fin n) (a : Fin k), \u2203 (j : Fin n), flights i j a\n\n-- A triangle is three cities connected by the same airline\ndef isTriangle (net : FlightNetwork) (i j l : Fin net.n) (a : Fin net.k) : Prop :=\n  i \u2260 j \u2227 j \u2260 l \u2227 i \u2260 l \u2227\n  net.flights i j a \u2227 net.flights j l a \u2227 net.flights i l a\n\ntheorem euleria_unique_triangle\n  (net : FlightNetwork)\n  (h1 : net.n = 101)\n  (h2 : net.k = 99) :\n  \u2200 (t1 t2 : Fin net.n \u00d7 Fin net.n \u00d7 Fin net.n \u00d7 Fin net.k),\n    isTriangle net t1.1 t1.2.1 t1.2.2.1 t1.2.2.2 \u2192\n    isTriangle net t2.1 t2.2.1 t2.2.2.1 t2.2.2.2 \u2192\n    (t1.1 = t2.1 \u2227 t1.2.1 = t2.2.1 \u2227 t1.2.2.1 = t2.2.2.1 \u2227 t1.2.2.2 = t2.2.2.2) :=\n  sorry"}
{"id": "CombStruct4Lean_70", "informal_problem": "3. In a box, there are balls of 10 colors. It is known that you can take out 100 balls from the box so that the remaining balls of all 10 colors are equal. Prove that you can add 900 balls to the box so that the number of balls of all colors becomes equal.", "formal_statement": "import Mathlib\n\nstructure ColoredBalls where\n  initial : Fin 10 \u2192 Nat\n  removed : Fin 10 \u2192 Nat\n  removed_sum : (\u2211 i, removed i) = 100\n  removed_possible : \u2200 i, removed i \u2264 initial i\n  equal_after_removal : \u2200 i j : Fin 10,\n    initial i - removed i = initial j - removed j\n  remainingBalls : Fin 10 \u2192 Nat := fun i => initial i - removed i\n\ntheorem balls_equalization {b : ColoredBalls} :\n  \u2203 (added : Fin 10 \u2192 Nat),\n    (\u2211 i, added i = 900) \u2227\n    \u2203 (target : Nat), \u2200 i : Fin 10,\n      b.remainingBalls i + added i = target :=\n  sorry"}
{"id": "CombStruct4Lean_71", "informal_problem": "3. In each cell of a $2012 \\times 2012$ table, either a zero or a one is written, with the condition that in each column and each row there are both zeros and ones. Prove that in this table, there exist two rows and two columns such that at the ends of one of the diagonals of the rectangle they form, there are zeros, and on the other diagonal, there are ones. (I. Rubanov + jury)", "formal_statement": "import Mathlib\n\n-- Type representing a binary table with zeros and ones\nstructure BinaryTable (n : Nat) where\n  -- The table as a function from row and column indices to Bool\n  -- where true represents 1 and false represents 0\n  entries : Fin n \u2192 Fin n \u2192 Bool\n  -- Property ensuring each row has both zeros and ones\n  row_mixed : \u2200 i : Fin n, \u2203 j k : Fin n, \n    entries i j = false \u2227 entries i k = true\n  -- Property ensuring each column has both zeros and ones\n  col_mixed : \u2200 j : Fin n, \u2203 i k : Fin n, \n    entries i j = false \u2227 entries k j = true\n\ntheorem binary_table_diagonal_pattern (table : BinaryTable 2012) :\n  \u2203 (i\u2081 i\u2082 j\u2081 j\u2082 : Fin 2012),\n    i\u2081 \u2260 i\u2082 \u2227 j\u2081 \u2260 j\u2082 \u2227\n    ((table.entries i\u2081 j\u2081 = false \u2227 table.entries i\u2082 j\u2082 = false \u2227\n      table.entries i\u2081 j\u2082 = true \u2227 table.entries i\u2082 j\u2081 = true) \u2228\n     (table.entries i\u2081 j\u2081 = true \u2227 table.entries i\u2082 j\u2082 = true \u2227\n      table.entries i\u2081 j\u2082 = false \u2227 table.entries i\u2082 j\u2081 = false)) :=\n  sorry"}
{"id": "CombStruct4Lean_72", "informal_problem": "2. In each cell of a 100 x 100 table, one of the numbers 1 or -1 is written. Could it be that the sums of the numbers are negative in exactly 99 rows and positive in exactly 99 columns? (D. Nenashov)", "formal_statement": "import Mathlib\n\nstructure Table100 where\n  -- Each cell contains either 1 or -1\n  cells : Fin 100 \u2192 Fin 100 \u2192 Int\n  cell_values : \u2200 i j, cells i j = 1 \u2228 cells i j = -1\n\ndef row_sum (t : Table100) (i : Fin 100) : Int :=\n  (Finset.univ.sum fun j => t.cells i j)\n\ndef col_sum (t : Table100) (j : Fin 100) : Int :=\n  (Finset.univ.sum fun i => t.cells i j)\n\ndef negative_row_count (t : Table100) : Nat :=\n  (Finset.filter (fun i => row_sum t i < 0) Finset.univ).card\n\ndef positive_col_count (t : Table100) : Nat :=\n  (Finset.filter (fun j => col_sum t j > 0) Finset.univ).card\n\ntheorem table_possibility : \u2203 (t : Table100),\n    negative_row_count t = 99 \u2227 positive_col_count t = 99 :=\n  sorry"}
{"id": "CombStruct4Lean_73", "informal_problem": "# Task 1.\n\nMaximum 10 points\n\nIn the city of N, there is a correctional facility where there are 100 guards for every 1000 prisoners. Deputy Ivanov, in his pre-election campaign, promised to reduce the number of guards by exactly half, redirecting the freed-up resources to retraining personnel and developing agriculture in the region. According to his proposed scheme, the quality of supervision would not suffer. That is, with 50 guards, each prisoner would still be watched by at least one of them (a guard).\n\nThe proposed scheme: guards are assigned numbers from 00 to 99, and their subordinates from 000 to 999. A prisoner is watched by those guards whose numbers can be obtained by deleting one digit from the prisoner's number (for example, a prisoner with the number 146 is watched by guards 14, 16, 46).\n\na) Will Deputy Ivanov be able to fulfill his promise? Justify your answer.\n\nb) If the answer to the previous question is \"Yes,\" is it possible to further reduce the number of guards without compromising the quality of supervision? If the answer to the question in part (a) is \"No,\" is it possible in principle to reduce the number of guards relative to the initial number without compromising the quality of supervision?", "formal_statement": "import Mathlib\n\n/-- Represents a three-digit number as three separate digits -/\nstructure ThreeDigits where\n  d1 : Fin 10\n  d2 : Fin 10\n  d3 : Fin 10\n\n/-- Represents a two-digit number as two separate digits -/\nstructure TwoDigits where\n  d1 : Fin 10\n  d2 : Fin 10\n\n/-- Convert a prisoner number (0-999) to its digit representation -/\ndef toThreeDigits (n : Fin 1000) : ThreeDigits :=\n  let d3 := n % 10\n  let n' := n / 10\n  let d2 := n' % 10\n  let d1 := n' / 10\n  \u27e8d1, d2, d3\u27e9\n\n/-- Convert a guard number (0-99) to its digit representation -/\ndef toTwoDigits (n : Fin 100) : TwoDigits :=\n  let d2 := n % 10\n  let d1 := n / 10\n  \u27e8d1, d2\u27e9\n\n/-- Determines if a guard watches a prisoner based on digit removal rules -/\ndef guardWatches (guard : Fin 100) (prisoner : Fin 1000) : Prop :=\n  let pDigits := toThreeDigits prisoner\n  let gDigits := toTwoDigits guard\n  -- Guard's number can be obtained by removing one digit from prisoner's number\n  (pDigits.d1 = gDigits.d1 \u2227 pDigits.d2 = gDigits.d2) \u2228  -- Remove d3\n  (pDigits.d1 = gDigits.d1 \u2227 pDigits.d3 = gDigits.d2) \u2228  -- Remove d2\n  (pDigits.d2 = gDigits.d1 \u2227 pDigits.d3 = gDigits.d2)    -- Remove d1\n\nstructure PrisonSystem where\n  guards : Finset (Fin 100)\n  isWatched (prisoner : Fin 1000) : Prop :=\n    \u2203 g \u2208 guards, guardWatches g prisoner\n\ntheorem prison_system_optimization :\n  -- There exists a valid guard assignment with exactly 50 guards\n  \u2203 (system : PrisonSystem), \n    system.guards.card = 50 \u2227 \n    (\u2200 (p : Fin 1000), system.isWatched p) :=\n  sorry"}
{"id": "CombStruct4Lean_74", "informal_problem": "# Task 1.\n\nMaximum 10 points\n\nIn the Dark Dungeon, 1000 kind gnomes are held captive by 100 orcs. The chief orc has devised a scheme: orcs are assigned numbers from 00 to 99, and gnomes are assigned numbers from 000 to 999. An orc is assigned to watch a gnome if the orc's number can be obtained by deleting one digit from the gnome's number (for example, the orc with the number 14 watches the gnome with the number 146, as well as the orcs with the numbers 16 and 46).\n\nThe chief orc claims that only 50 orcs are needed to watch the gnomes, and that every gnome will still be watched by at least one orc. The rest of the orcs should be sent to conquer new cities.\n\na) Is the chief orc correct, and will 50 orcs be enough to ensure that no gnome goes unnoticed if they try to escape? Justify your answer.\n\nb) If the answer to the first question is \"Yes,\" is it possible to free more orcs? If the answer to the first question is \"No,\" is it possible to reduce the number of orcs watching the gnomes at all? Justify your answer.", "formal_statement": "import Mathlib\n\n-- Helper function to check if a number can be obtained by removing one digit from another\ndef canObtainByRemovingDigit (orc : Fin 100) (gnome : Fin 1000) : Prop :=\n  let orcNum := orc.val\n  let gnomeNum := gnome.val\n  -- Check if removing any digit from gnome can give orc\n  \u2203 (d : Nat), d < 10 \u2227 \u2203 (pos : Nat), pos < 3 \u2227\n    (gnomeNum = d * (10 ^ pos) + (gnomeNum / (10 ^ (pos + 1))) * (10 ^ (pos + 1)) +\n                (gnomeNum % (10 ^ pos)) \u2227\n     orcNum = (gnomeNum / (10 ^ (pos + 1))) * (10 ^ pos) + (gnomeNum % (10 ^ pos)))\n\nstructure DungeonSystem where\n  (orcs : Finset (Fin 100))\n  (gnomes : Finset (Fin 1000))\n  (isValid : Prop := \u2200 g \u2208 gnomes, \u2203 o \u2208 orcs, canObtainByRemovingDigit o g)\n\ntheorem min_orcs_required :\n  \u2200 (sys : DungeonSystem),\n    sys.gnomes = Finset.filter (fun n => n.val \u2265 0 \u2227 n.val \u2264 999) (Finset.univ) \u2192\n    sys.isValid \u2192\n    sys.orcs.card \u2265 67 :=\n  sorry"}
{"id": "CombStruct4Lean_75", "informal_problem": "5. Each cell of an $m \\times n$ board is painted either black or white. It is known that for any cell of the board, the number of cells that share a side with it and have the same color is odd. Find all pairs of natural numbers $m$ and $n$ for which this is possible.", "formal_statement": "import Mathlib\n\n/-- Color enumeration for the board cells -/\ninductive Color where\n  | black\n  | white\n  deriving Repr, DecidableEq\n\n/-- A board is an m \u00d7 n grid where each cell has a color -/\nstructure Board (m n : Nat) where\n  coloring : Fin m \u2192 Fin n \u2192 Color\n\n/-- Predicate indicating if two positions on the board are adjacent -/\ndef isAdjacent {m n : Nat} (p\u2081 p\u2082 : Fin m \u00d7 Fin n) : Bool :=\n  let (i\u2081, j\u2081) := p\u2081\n  let (i\u2082, j\u2082) := p\u2082\n  (i\u2081.val = i\u2082.val \u2227 (j\u2081.val + 1 = j\u2082.val \u2228 j\u2082.val + 1 = j\u2081.val)) \u2228\n  (j\u2081.val = j\u2082.val \u2227 (i\u2081.val + 1 = i\u2082.val \u2228 i\u2082.val + 1 = i\u2081.val))\n\n/-- Count of adjacent cells with the same color for a given position -/\ndef sameColorNeighbors {m n : Nat} (board : Board m n) (pos : Fin m \u00d7 Fin n) : Nat :=\n  (Finset.univ.filter (fun p => \n    isAdjacent pos p \u2227 \n    board.coloring pos.1 pos.2 = board.coloring p.1 p.2\n  )).card\n\ntheorem odd_adjacent_same_color_characterization (m n : Nat) :\n  (\u2203 (board : Board m n), \u2200 (i : Fin m) (j : Fin n), \n    Odd (sameColorNeighbors board (i, j))) \u2194 \n  m = 1 \u2227 n = 1 :=\n  sorry"}
{"id": "CombStruct4Lean_76", "informal_problem": "1. Can different integers be arranged in a $35 \\times 35$ table so that the values in cells sharing a side differ by no more than 18?", "formal_statement": "import Mathlib\nopen Matrix\n\ndef adjacent (n : Nat) (i j i' j' : Fin n) : Prop :=\n  (i = i' \u2227 |((j.val : Int) - (j'.val : Int))| = 1) \u2228 \n  (j = j' \u2227 |((i.val : Int) - (i'.val : Int))| = 1)\n\ndef valid_difference (x y : Int) : Prop :=\n  |x - y| \u2264 18\n\ndef all_different {n : Nat} (m : Matrix (Fin n) (Fin n) Int) : Prop :=\n  \u2200 i j i' j', (i \u2260 i' \u2228 j \u2260 j') \u2192 m i j \u2260 m i' j'\n\ntheorem exists_valid_35_table : \n  \u2203 (m : Matrix (Fin 35) (Fin 35) Int),\n    (\u2200 i j i' j', adjacent 35 i j i' j' \u2192 \n      valid_difference (m i j) (m i' j')) \u2227\n    all_different m :=\n  sorry"}
{"id": "CombStruct4Lean_77", "informal_problem": "8. (40 points) $B$ In the 8-A class, there are $n$ students ( $n \\geq 2$ ). For them, clubs are organized, each of which is attended by at least two students. Any two clubs that have at least two students in common differ in the number of participants. Prove that the number of clubs is no more than $(n-1)^{2}$.", "formal_statement": "import Mathlib\n\nstructure SchoolClubs (n : Nat) where\n  clubs : Finset (Finset (Fin n))\n  h_nonempty : clubs.Nonempty\n  h_min_size : \u2200 c \u2208 clubs, 2 \u2264 c.card\n  h_diff_size_of_common : \u2200 c\u2081 c\u2082, c\u2081 \u2208 clubs \u2192 c\u2082 \u2208 clubs \u2192 \n    2 \u2264 (c\u2081 \u2229 c\u2082).card \u2192 c\u2081.card \u2260 c\u2082.card\n\ntheorem school_clubs_bound {n : Nat} (h_n : 2 \u2264 n) (sc : SchoolClubs n) :\n  sc.clubs.card \u2264 (n - 1)^2 := sorry"}
{"id": "CombStruct4Lean_78", "informal_problem": "8. (40 points) $B$ In the 8-A class, there are $n$ students ( $n \\geq 2$ ). For them, clubs are organized, each of which is attended by at least two students. Any two clubs that have at least two common students differ in the number of participants. Prove that the number of clubs is no more than $(n-1)^{2}$.", "formal_statement": "import Mathlib\n\nstructure Club (n : Nat) : Type where\n  members : Finset (Fin n)\n  size_ge_2 : members.card \u2265 2\n\nstructure ClubSystem (n : Nat) : Type where\n  clubs : Finset (Club n)\n\n/-- Predicate indicating that a club system satisfies the size difference property -/\ndef hasSizeDiffProperty (n : Nat) (cs : ClubSystem n) : Prop :=\n  \u2200 (c\u2081 c\u2082 : Club n), c\u2081 \u2208 cs.clubs \u2192 c\u2082 \u2208 cs.clubs \u2192 c\u2081 \u2260 c\u2082 \u2192 \n    (c\u2081.members \u2229 c\u2082.members).card \u2265 2 \u2192 c\u2081.members.card \u2260 c\u2082.members.card\n\ntheorem club_system_bound (n : Nat) (cs : ClubSystem n) \n    (hn : n > 1)\n    (hprop : hasSizeDiffProperty n cs) :\n  cs.clubs.card \u2264 (n - 1) ^ 2 := sorry"}
{"id": "CombStruct4Lean_79", "informal_problem": "5. A running track represents a circle with a length of 2 km. Along an arc, which is 100 m long, spectator stands are built. Is it possible to launch 20 runners on this track in the same direction, moving at constant speeds of 10, 11, ..., 29 km/h, so that at any moment in time at least one of the runners is running in front of the stands? (The starting position of each runner can be designated at any point, independently of the other runners.)", "formal_statement": "import Mathlib\n\nstructure RunnerConfig where\n  -- Track length in meters\n  trackLength : \u211d := 2000\n  -- Stand length in meters\n  standLength : \u211d := 100\n  -- Number of runners\n  numRunners : \u2115 := 20\n  -- Initial positions of runners (in meters from arbitrary starting point)\n  initialPos : Fin numRunners \u2192 \u211d\n  -- Speeds of runners in meters per hour\n  speeds : Fin numRunners \u2192 \u211d\n\n/-- Checks if a runner is in front of the stands at a given time -/\ndef isInFrontOfStands (cfg : RunnerConfig) (runnerIdx : Fin cfg.numRunners) (time : \u211d) : Prop :=\n  let pos := (cfg.initialPos runnerIdx + cfg.speeds runnerIdx * time) % cfg.trackLength\n  pos \u2264 cfg.standLength\n\n/-- Checks if at least one runner is in front of the stands at a given time -/\ndef someRunnerInFrontOfStands (cfg : RunnerConfig) (time : \u211d) : Prop :=\n  \u2203 i : Fin cfg.numRunners, isInFrontOfStands cfg i time\n\ntheorem runners_coverage_possible : \u2203 (cfg : RunnerConfig), \n  (\u2200 i : Fin cfg.numRunners, cfg.speeds i = (10000 + i.val * 1000)) \u2192 -- Speeds from 10 to 29 km/h\n  (\u2200 t : \u211d, t \u2265 0 \u2192 someRunnerInFrontOfStands cfg t) :=\n  sorry"}
{"id": "CombStruct4Lean_80", "informal_problem": "5. For a parallelepiped $a \\times b \\times c$ with faces divided into unit cells, there is also a large number of five-cell strips, which can be bent along the cell boundaries. For which $a, b$, and $c$ can the three faces of the parallelepiped, sharing a common vertex, be completely covered by the strips without overlaps and gaps, such that the cells of the faces and the strips coincide?", "formal_statement": "import Mathlib\n\nstructure Parallelepiped where\n  a : Nat\n  b : Nat\n  c : Nat\n\n/-- A strip is a sequence of 5 connected unit cells that can be bent along cell boundaries -/\nstructure Strip where\n  cells : Fin 5 \u2192 (Nat \u00d7 Nat)  -- Coordinates of cells in the strip\n\n/-- Represents a covering of three faces of a parallelepiped meeting at a vertex -/\nstructure FaceCovering (p : Parallelepiped) where\n  strips : List Strip\n  -- Each cell in the three faces is covered exactly once\n  covers_exactly : \u2200 (x y : Nat), \n    (x < p.a \u2227 y < b) \u2228 \n    (x < p.a \u2227 y < c) \u2228 \n    (x < p.b \u2227 y < c) \u2192 \n    \u2203! s \u2208 strips, \u2203 i : Fin 5, s.cells i = (x, y)\n\ntheorem parallelepiped_strip_covering_exists (p : Parallelepiped) \n  (ha : p.a > 0) (hb : p.b > 0) (hc : p.c > 0) :\n  (\u2203 covering : FaceCovering p, True) \u2194 \n  (p.a * p.b + p.b * p.c + p.a * p.c) % 5 = 0 :=\n  sorry"}
{"id": "CombStruct4Lean_81", "informal_problem": "10. (40 points) At a ball, 100 boys and 100 girls, numbered from 1 to 100, arrived. Sometimes boys and girls danced (in a dance, pairs of a boy and a girl participated). After all the dances, it turned out that for each girl, all the boys could be divided into two groups such that the girl danced with the boys from the first group as many times in total as with the boys from the second group. Prove that for some $k$, boy $k$ danced with girl $k$ no more than half of all his dances.", "formal_statement": "import Mathlib\n\nstructure DanceData where\n  n : Nat\n  h : 0 < n\n  h100 : n = 100\n  danceCount : Fin n \u2192 Fin n \u2192 Nat    -- boy \u2192 girl \u2192 count\n  totalDancesFor (b : Fin n) : Nat := \u2211 g : Fin n, danceCount b g\n\n  -- For each girl, boys can be split into two equal-sum groups\n  split_property : \u2200 g : Fin n, \u2203 s : Finset (Fin n),\n    (\u2211 b in s, danceCount b g) = (\u2211 b in (Finset.univ \\ s), danceCount b g)\n\ntheorem exists_boy_with_limited_dances (d : DanceData) :\n  \u2203 k : Fin d.n, d.danceCount k k * 2 < d.totalDancesFor k := sorry"}
{"id": "CombStruct4Lean_82", "informal_problem": "9. (50 points) In the kindergarten's dressing room, in the lost items basket, there are 30 mittens, of which 10 are blue, 10 are green, 10 are red, 15 are right-handed, and 15 are left-handed. Is it always possible to form sets of right and left mittens of the same color for 5 children?", "formal_statement": "import Mathlib\n\nstructure Mitten where\n  color : Fin 3  -- 0 for blue, 1 for green, 2 for red\n  isRight : Bool -- true for right-handed, false for left-handed\n\n/-- A collection of mittens with counts for each color and handedness -/\nstructure MittenCollection where\n  mittens : List Mitten\n  blue_count : Nat\n  green_count : Nat\n  red_count : Nat\n  right_count : Nat\n  left_count : Nat\n  h_blue : blue_count = 10\n  h_green : green_count = 10\n  h_red : red_count = 10\n  h_right : right_count = 15\n  h_left : left_count = 15\n  h_total : mittens.length = 30\n\n/-- A valid pair of mittens consists of a right and left mitten of the same color -/\ndef isValidPair (m1 m2 : Mitten) : Bool :=\n  m1.color = m2.color \u2227 m1.isRight \u2260 m2.isRight\n\ntheorem kindergarten_mittens (mc : MittenCollection) :\n  \u2203 (pairs : List (Mitten \u00d7 Mitten)), \n    pairs.length = 5 \u2227 \n    (\u2200 p \u2208 pairs, isValidPair p.1 p.2) \u2227\n    (\u2200 m \u2208 pairs.map Prod.fst ++ pairs.map Prod.snd, m \u2208 mc.mittens) :=\n  sorry"}
{"id": "CombStruct4Lean_83", "informal_problem": "5. Around the edge of a round table, there are $n$ empty glasses ($n \\geqslant 3$). Petya and Vasya take turns (starting with Petya) filling them with drinks: Petya - kvass, Vasya - morse. In one move, a player can fill one empty glass of their choice so that after their move, no two adjacent glasses contain the same drink. If all glasses are filled as a result of the players' actions, the game ends in a draw. Otherwise, the player who cannot make a move loses. For which $n$ does Petya win regardless of Vasya's actions?", "formal_statement": "import Mathlib\n\ninductive Drink : Type\n  | Kvass\n  | Morse\n  | Empty\nderiving DecidableEq\n\nstructure GameState (n : Nat) where\n  glasses : Fin n \u2192 Drink\n  h : n \u2265 3\n\ndef valid_state {n : Nat} (state : GameState n) : Prop :=\n  \u2200 i : Fin n, let j := (i.val + 1) % n\n    state.glasses i \u2260 Drink.Empty \u2192\n    state.glasses i \u2260 state.glasses \u27e8j, Nat.mod_lt _ (Nat.zero_lt_of_lt state.h)\u27e9\n\ndef make_move {n : Nat} (state : GameState n) (pos : Fin n) (drink : Drink) : GameState n :=\n  \u27e8\u03bb i => if i = pos then drink else state.glasses i, state.h\u27e9\n\ndef is_valid_move {n : Nat} (state : GameState n) (pos : Fin n) (drink : Drink) : Prop :=\n  state.glasses pos = Drink.Empty \u2227\n  let next := \u27e8(pos.val + 1) % n, Nat.mod_lt _ (Nat.zero_lt_of_lt state.h)\u27e9\n  let prev := \u27e8(pos.val + n - 1) % n, Nat.mod_lt _ (Nat.zero_lt_of_lt state.h)\u27e9\n  drink \u2260 state.glasses next \u2227\n  drink \u2260 state.glasses prev\n\ndef is_terminal {n : Nat} (state : GameState n) : Prop :=\n  \u2200 pos : Fin n, state.glasses pos \u2260 Drink.Empty\n\ndef winning_position {n : Nat} (state : GameState n) (is_petya : Bool) : Prop :=\n  \u2203 (move : Fin n), is_valid_move state move (if is_petya then Drink.Kvass else Drink.Morse) \u2227\n    \u2200 (opp_move : Fin n), \n      let new_state := make_move state move (if is_petya then Drink.Kvass else Drink.Morse)\n      \u00acis_valid_move new_state opp_move (if is_petya then Drink.Morse else Drink.Kvass)\n\ntheorem petya_wins_mod_three {n : Nat} (h : n \u2265 3) :\n  n % 3 = 0 \u2194 winning_position (GameState.mk (\u03bb _ => Drink.Empty) h) true :=\n  sorry"}
{"id": "CombStruct4Lean_84", "informal_problem": "8. (40 points) At the beginning of each physical education class, 30 students are divided into 3 teams of 10 each. Prove that there will be two students who were on the same team for three consecutive classes.", "formal_statement": "import Mathlib\n\n/-- Fixed constants for the problem -/\nabbrev NumStudents : Nat := 30\nabbrev NumTeams : Nat := 3\nabbrev TeamSize : Nat := 10\nabbrev Student := Fin NumStudents\nabbrev Team := Fin NumTeams\nabbrev ClassNumber := \u2115\n\n/-- Represents a sequence of team assignments across classes -/\nstructure TeamAssignment where\n  /-- For each class, assigns each student to a team -/\n  assignment : ClassNumber \u2192 Student \u2192 Team\n  /-- Teams form a partition (each student is in exactly one team) -/\n  is_partition : \u2200 (c : ClassNumber),\n    \u2200 (s : Student), \u2203! (t : Team), assignment c s = t\n\n/-- Two students are on the same team in a given class -/\ndef same_team (a : TeamAssignment) (s1 s2 : Student) (c : ClassNumber) : Prop :=\n  a.assignment c s1 = a.assignment c s2\n\ntheorem pigeonhole_teams (a : TeamAssignment) :\n  \u2203 (s1 s2 : Student) (c\u2081 c\u2082 c\u2083 : ClassNumber),\n    s1 \u2260 s2 \u2227\n    c\u2081 < c\u2082 \u2227 c\u2082 < c\u2083 \u2227\n    same_team a s1 s2 c\u2081 \u2227\n    same_team a s1 s2 c\u2082 \u2227\n    same_team a s1 s2 c\u2083 :=\n  sorry"}
{"id": "CombStruct4Lean_85", "informal_problem": "1. (3 points) Given 10 different natural numbers, each not exceeding 23. Prove that there exist four different numbers $a, b, c, d$ among them, such that $\\frac{a+b}{2}=\\frac{c+d}{2}$.", "formal_statement": "import Mathlib\n\nstructure NumberSet where\n  nums : Finset \u2115\n  distinct : nums.card = 10\n  bounded : \u2200 n \u2208 nums, n \u2264 23\n\ntheorem exists_equal_averages (S : NumberSet) :\n  \u2203 (a b c d : \u2115),\n    a \u2208 S.nums \u2227 b \u2208 S.nums \u2227 c \u2208 S.nums \u2227 d \u2208 S.nums \u2227\n    a \u2260 b \u2227 a \u2260 c \u2227 a \u2260 d \u2227 b \u2260 c \u2227 b \u2260 d \u2227 c \u2260 d \u2227\n    (a + b : \u211a) / 2 = (c + d : \u211a) / 2 :=\n  sorry"}
{"id": "CombStruct4Lean_86", "informal_problem": "1. (3 points) Given 11 different natural numbers, each not exceeding 27. Prove that there exist four different numbers $a, b, c, d$ among them, such that $\\frac{a+b}{5}=\\frac{c+d}{5}$.", "formal_statement": "import Mathlib\n\ndef IsDifferent (a b c d : \u2115) : Prop :=\n  a \u2260 b \u2227 a \u2260 c \u2227 a \u2260 d \u2227 b \u2260 c \u2227 b \u2260 d \u2227 c \u2260 d\n\ndef HasEqualSumPairsDivByFive (nums : Finset \u2115) : Prop :=\n  \u2203 (a b c d : \u2115), a \u2208 nums \u2227 b \u2208 nums \u2227 c \u2208 nums \u2227 d \u2208 nums \u2227\n    IsDifferent a b c d \u2227\n    (a + b : \u2115) = (c + d : \u2115)\n\ntheorem equal_sum_pairs_div_five\n  (nums : Finset \u2115)\n  (h_size : nums.card = 11)\n  (h_bound : \u2200 n \u2208 nums, n \u2264 27) :\n  HasEqualSumPairsDivByFive nums :=\n  sorry"}
{"id": "CombStruct4Lean_87", "informal_problem": "8. We have $n$ integers $0,1,2, \\ldots, n-1$. By rearranging these numbers in a random order, we obtain some permutation $\\left(i_{1}, i_{2}, \\ldots, i_{n}\\right)$. From the original set of numbers $(0,1,2, \\ldots, n-1)$ and this permutation $\\left(i_{1}, i_{2}, \\ldots, i_{n}\\right)$, we obtain a new set of numbers $\\left(a_{1}, a_{2}, \\ldots, a_{n}\\right)$ according to the rule: $a_{1}=r_{n}\\left(0+i_{1}\\right), a_{2}=r_{n}\\left(1+i_{2}\\right), \\ldots, a_{n}=r_{n}\\left((n-1)+i_{n}\\right)$, where $r_{n}(m)$ is the remainder of the division of the number $m$ by the number $n$. (For example, let $n=3$. Then, from the original set $(0,1,2)$ and the permutation $\\left(i_{1}, i_{2}, i_{3}\\right)=$ $(1,2,0)$, we get the set $\\left(a_{1}, a_{2}, a_{3}\\right)=(1,0,2)$, since $r_{3}(0+1)=1, r_{3}(1+2)=0, r_{3}(2+0)=2$. $)$\n\nProve that if $n=6$, then no matter what permutation $\\left(i_{1}, i_{2}, \\ldots, i_{6}\\right)$ we take, there will be identical numbers in the set $\\left(a_{1}, a_{2}, \\ldots, a_{6}\\right)$.", "formal_statement": "import Mathlib\nopen Equiv Fin Function\n\ndef computeSequence (n : \u2115) (h : 0 < n) (p : Perm (Fin n)) (i : Fin n) : Fin n :=\n  \u27e8(i.val + p i).mod n, Nat.mod_lt _ h\u27e9\n\ndef allDistinct (n : \u2115) (f : Fin n \u2192 Fin n) : Prop :=\n  Injective f\n\ntheorem no_distinct_remainder_when_six {n : \u2115} (h : 0 < n) (h6 : n = 6) :\n  \u2200 p : Perm (Fin n), \u00ac(allDistinct n (computeSequence n h p)) :=\n  sorry"}
{"id": "CombStruct4Lean_88", "informal_problem": "3. [5] On a line, 2022 points are marked such that every two adjacent points are at the same distance from each other. Half of the points are painted red, and the other half are painted blue. Can the sum of the lengths of all possible segments where the left endpoint is red and the right endpoint is blue equal the sum of the lengths of all segments where the left endpoint is blue and the right endpoint is red? (The endpoints of the considered segments do not necessarily have to be adjacent marked points.)\n\n(A. Hrybalko)", "formal_statement": "import Mathlib\n\ninductive PointColor where\n  | Red\n  | Blue\n  deriving Repr, DecidableEq\n\nstructure ColoredPoints where\n  n : Nat                            -- total number of points\n  d : \u211d                             -- fixed distance between adjacent points\n  colors : Fin n \u2192 PointColor       -- color assignment for each point\n  d_pos : d > 0                     -- distance is positive\n  n_even : Even n                   -- number of points must be even\n  half_red [DecidableEq PointColor] : \n    (Finset.univ.filter (fun i => colors i = PointColor.Red)).card = n / 2\n\n/-- Position of a point on the line given its index -/\ndef position_of (points : ColoredPoints) (i : Fin points.n) : \u211d :=\n  points.d * i.val\n\n/-- Length of segment between two points -/\ndef segment_length (points : ColoredPoints) (i j : Fin points.n) : \u211d :=\n  points.d * |((j.val : Int) - (i.val : Int))|\n\n/-- Sum of lengths of segments from red points to blue points -/\ndef red_to_blue_sum [DecidableEq PointColor] \n    (points : ColoredPoints) \n    [\u2200 (p : Fin points.n \u00d7 Fin points.n), Decidable (p.1.val < p.2.val)] : \u211d :=\n  Finset.sum (Finset.filter \n    (fun p => p.1.val < p.2.val \u2227 \n              points.colors p.1 = PointColor.Red \u2227 \n              points.colors p.2 = PointColor.Blue)\n    (Finset.product Finset.univ Finset.univ))\n    (fun p => segment_length points p.1 p.2)\n\n/-- Sum of lengths of segments from blue points to red points -/\ndef blue_to_red_sum [DecidableEq PointColor] \n    (points : ColoredPoints)\n    [\u2200 (p : Fin points.n \u00d7 Fin points.n), Decidable (p.1.val < p.2.val)] : \u211d :=\n  Finset.sum (Finset.filter \n    (fun p => p.1.val < p.2.val \u2227 \n              points.colors p.1 = PointColor.Blue \u2227 \n              points.colors p.2 = PointColor.Red)\n    (Finset.product Finset.univ Finset.univ))\n    (fun p => segment_length points p.1 p.2)\n\ntheorem colored_segments_sum_equal [DecidableEq PointColor]\n    (points : ColoredPoints)\n    [\u2200 (p : Fin points.n \u00d7 Fin points.n), Decidable (p.1.val < p.2.val)]\n    (h : points.n = 2022) : \n    red_to_blue_sum points = blue_to_red_sum points :=\n  sorry"}
{"id": "CombStruct4Lean_89", "informal_problem": "6. A row of $N$ boxes, numbered consecutively $1,2, \\ldots, N$, stands from left to right. Some of these boxes, standing in a row, will have a ball placed in them, leaving the others empty.\n\nThe instruction consists of a sequence of commands of the form \"swap the contents of box \u2116 $i$ and box \u2116 $j$\", where $i$ and $j$ are numbers. For each $N$, does there exist an instruction with no more than $100 \\mathrm{~N}$ commands, such that for any initial arrangement of the specified type, one can, by deleting some commands from the instruction, obtain an instruction that, after execution, will have all the boxes with balls to the left of the boxes without balls?\n\nI. Mitrofanov", "formal_statement": "import Mathlib\n\n/-- A configuration of N boxes with balls, represented as a function from positions to presence of balls -/\ndef BoxConfig (N : \u2115) := Fin N \u2192 Bool\n\n/-- Swap the contents of two positions in a configuration -/\ndef swap {N : \u2115} (cfg : BoxConfig N) (i j : Fin N) : BoxConfig N := fun k =>\n  if k = i then cfg j\n  else if k = j then cfg i\n  else cfg k\n\n/-- Apply a sequence of swaps to a configuration -/\ndef applySwaps {N : \u2115} (cfg : BoxConfig N) (swaps : List (Fin N \u00d7 Fin N)) : BoxConfig N :=\n  swaps.foldl (fun c \u27e8i, j\u27e9 => swap c i j) cfg\n\n/-- A configuration is sorted if there exists a position k where\n    all positions before k contain balls and all positions after k are empty -/\ndef isSorted {N : \u2115} (cfg : BoxConfig N) : Prop :=\n  \u2203 k : Fin (N + 1), \u2200 i j : Fin N, i.val < j.val \u2192 \n    (i.val < k \u2192 cfg i = true) \u2227 \n    (k \u2264 j.val \u2192 cfg j = false)\n\ntheorem mitrofanov_box_sorting (N : \u2115) :\n  \u2203 (instruction : List (Fin N \u00d7 Fin N)), \n    instruction.length \u2264 N * 100 \u2227\n    \u2200 (initial : BoxConfig N),\n      \u2203 (subseq : List (Fin N \u00d7 Fin N)), \n        List.Sublist subseq instruction \u2227\n        isSorted (applySwaps initial subseq) :=\n  sorry"}
{"id": "CombStruct4Lean_90", "informal_problem": "2. [7] On a line, there are 2019 grasshoppers sitting at points. In one move, one of the grasshoppers jumps over another so that it ends up at the same distance from the other. By jumping only to the right, the grasshoppers can achieve that some two of them are exactly 1 mm apart. Prove that the grasshoppers can achieve the same by jumping only to the left from the initial position.\n\nS. Dorichenko", "formal_statement": "import Mathlib\n\n/-- State of 2019 grasshoppers on a line, tracking their positions -/\nstructure GrasshopperState where\n  positions : Fin 2019 \u2192 \u211d\n\n/-- Create a new state after a grasshopper jumps to a new position -/\ndef GrasshopperState.jump (s : GrasshopperState) (i : Fin 2019) (newPos : \u211d) : GrasshopperState where\n  positions := Function.update s.positions i newPos\n\n/-- Predicate indicating if a jump is valid: the new position must be at the same distance\n    from the grasshopper being jumped over as the original position -/\ndef isValidJump (s : GrasshopperState) (i j : Fin 2019) (newPos : \u211d) : Prop :=\n  |newPos - s.positions j| = |s.positions i - s.positions j| \u2227\n  newPos \u2260 s.positions j\n\n/-- Predicate indicating if any two grasshoppers are exactly 1mm apart -/\ndef hasUnitDistance (s : GrasshopperState) : Prop :=\n  \u2203 i j : Fin 2019, i \u2260 j \u2227 |s.positions i - s.positions j| = 1\n\n/-- Inductive definition of states reachable by right jumps only -/\ninductive ReachableByRightJumps : GrasshopperState \u2192 GrasshopperState \u2192 Prop where\n  | refl (s : GrasshopperState) : ReachableByRightJumps s s\n  | jump (s\u2081 s\u2082 s\u2083 : GrasshopperState) (i j : Fin 2019) :\n      ReachableByRightJumps s\u2081 s\u2082 \u2192\n      (i.val < j.val) \u2192  -- jumping right\n      isValidJump s\u2082 i j (s\u2082.positions j + |s\u2082.positions j - s\u2082.positions i|) \u2192\n      s\u2083 = s\u2082.jump i (s\u2082.positions j + |s\u2082.positions j - s\u2082.positions i|) \u2192\n      ReachableByRightJumps s\u2081 s\u2083\n\n/-- Inductive definition of states reachable by left jumps only -/\ninductive ReachableByLeftJumps : GrasshopperState \u2192 GrasshopperState \u2192 Prop where\n  | refl (s : GrasshopperState) : ReachableByLeftJumps s s\n  | jump (s\u2081 s\u2082 s\u2083 : GrasshopperState) (i j : Fin 2019) :\n      ReachableByLeftJumps s\u2081 s\u2082 \u2192\n      (i.val > j.val) \u2192  -- jumping left\n      isValidJump s\u2082 i j (s\u2082.positions j - |s\u2082.positions j - s\u2082.positions i|) \u2192\n      s\u2083 = s\u2082.jump i (s\u2082.positions j - |s\u2082.positions j - s\u2082.positions i|) \u2192\n      ReachableByLeftJumps s\u2081 s\u2083\n\ntheorem grasshopper_symmetry (initial : GrasshopperState)\n  (h_ordered : \u2200 i j : Fin 2019, i.val < j.val \u2192 initial.positions i < initial.positions j)\n  (h_distinct : \u2200 i j : Fin 2019, i \u2260 j \u2192 initial.positions i \u2260 initial.positions j)\n  (h_right : \u2203 final, ReachableByRightJumps initial final \u2227 hasUnitDistance final) :\n  \u2203 final, ReachableByLeftJumps initial final \u2227 hasUnitDistance final :=\n  sorry"}
{"id": "CombStruct4Lean_91", "informal_problem": "Problem 10. A club has 10 members, some of whom are friends with each other. Is it possible that in this club one member is friends with 9 others, one member - with 7 others, one member - with 6 others, two members - with 5 others each, two members - with 3 others each, one member - with 2 others, two members - with 1 other each?", "formal_statement": "import Mathlib\n\nstructure FriendshipGraph (n : Nat) where\n  edges : Finset (Fin n \u00d7 Fin n)\n  symm : \u2200 {i j}, (i, j) \u2208 edges \u2194 (j, i) \u2208 edges\n  no_self : \u2200 i, (i, i) \u2209 edges\n\ndef degree {n : Nat} (g : FriendshipGraph n) (v : Fin n) : Nat :=\n  Finset.card (Finset.filter (fun i => (v, i) \u2208 g.edges) (Finset.univ : Finset (Fin n)))\n\ndef hasValidDegrees (g : FriendshipGraph 10) (f : Fin 10 \u2192 Nat) : Prop :=\n  \u2200 v, degree g v = f v\n\ndef degreeSequence : Fin 10 \u2192 Nat\n  | \u27e80, _\u27e9 => 9  -- one vertex of degree 9\n  | \u27e81, _\u27e9 => 7  -- one vertex of degree 7\n  | \u27e82, _\u27e9 => 6  -- one vertex of degree 6\n  | \u27e83, _\u27e9 => 5  -- first vertex of degree 5\n  | \u27e84, _\u27e9 => 5  -- second vertex of degree 5\n  | \u27e85, _\u27e9 => 3  -- first vertex of degree 3\n  | \u27e86, _\u27e9 => 3  -- second vertex of degree 3\n  | \u27e87, _\u27e9 => 2  -- one vertex of degree 2\n  | \u27e88, _\u27e9 => 1  -- first vertex of degree 1\n  | \u27e89, _\u27e9 => 1  -- second vertex of degree 1\n\ntheorem friendship_degree_sequence_possible :\n  \u2203 (g : FriendshipGraph 10), hasValidDegrees g degreeSequence :=\n  sorry"}
{"id": "CombStruct4Lean_92", "informal_problem": "Task 10. In the squad, there are 10 people. Each day, two of them need to be chosen as duty officers (with the same pair not being able to serve twice). Could it be that after several days, one person has been on duty 9 times, two people - 8 times each, two people - 5 times each, four people - 3 times each, and one person - 1 time?", "formal_statement": "import Mathlib\n\nstructure DutyPattern where\n  person_nine : Fin 10\n  people_eight_1 : Fin 10\n  people_eight_2 : Fin 10\n  people_five_1 : Fin 10\n  people_five_2 : Fin 10\n  people_three_1 : Fin 10\n  people_three_2 : Fin 10\n  people_three_3 : Fin 10\n  people_three_4 : Fin 10\n  person_one : Fin 10\n  all_distinct : List.Nodup [person_nine, people_eight_1, people_eight_2,\n                            people_five_1, people_five_2,\n                            people_three_1, people_three_2, people_three_3, people_three_4,\n                            person_one]\n\nstructure DutySchedule where\n  days : Nat\n  days_eq : days = 24\n  duties : Fin days \u2192 Fin 10 \u00d7 Fin 10\n  no_repeat : \u2200 i j, i < j \u2192 duties i \u2260 duties j\n  no_self_duty : \u2200 d, (duties d).1 \u2260 (duties d).2\n  duty_count (person : Fin 10) : Nat :=\n    Finset.sum (Finset.univ : Finset (Fin days)) (fun day \u21a6 \n      if (duties day).1 = person \u2228 (duties day).2 = person\n      then 1 else 0)\n  sum_constraint : \u2211 p : Fin 10, duty_count p = 2 * days\n\ntheorem duty_distribution_possible : \n  \u2203 (pattern : DutyPattern) (schedule : DutySchedule),\n    schedule.duty_count pattern.person_nine = 9 \u2227\n    schedule.duty_count pattern.people_eight_1 = 8 \u2227\n    schedule.duty_count pattern.people_eight_2 = 8 \u2227\n    schedule.duty_count pattern.people_five_1 = 5 \u2227\n    schedule.duty_count pattern.people_five_2 = 5 \u2227\n    schedule.duty_count pattern.people_three_1 = 3 \u2227\n    schedule.duty_count pattern.people_three_2 = 3 \u2227\n    schedule.duty_count pattern.people_three_3 = 3 \u2227\n    schedule.duty_count pattern.people_three_4 = 3 \u2227\n    schedule.duty_count pattern.person_one = 1 :=\n  sorry"}
{"id": "CombStruct4Lean_93", "informal_problem": "Task 10. In a country, there are 10 cities, some of which are connected by roads (each road connects exactly two cities, there is no more than one road between any two cities, and you can only switch from one road to another in a city). Is it possible that from one city 9 roads lead out, from one - 8, from two - 7 each, from two - 6 each, from two - 4 each, from one - 2, and from one - 1?", "formal_statement": "import Mathlib\n\nstructure RoadNetwork where\n  -- Number of cities is fixed at 10\n  roads : Finset (Fin 10 \u00d7 Fin 10)\n  -- Each road connects different cities\n  different_cities : \u2200 (e : Fin 10 \u00d7 Fin 10), e \u2208 roads \u2192 e.1 \u2260 e.2\n  -- Roads are undirected (if a-b is a road, b-a is the same road)\n  symmetric : \u2200 (a b : Fin 10), (a, b) \u2208 roads \u2194 (b, a) \u2208 roads\n  -- No duplicate roads\n  no_duplicates : \u2200 (a b : Fin 10), (a, b) \u2208 roads \u2192 (b, a) \u2208 roads \u2192 (a, b) = (b, a)\n\n/-- The degree (number of roads) connected to a city -/\ndef city_degree (n : RoadNetwork) (city : Fin 10) : Nat :=\n  (n.roads.filter (fun e => e.1 = city)).card\n\ntheorem road_network_possible : \u2203 (n : RoadNetwork),\n  -- One city with degree 9\n  (\u2203! (c\u2081 : Fin 10), city_degree n c\u2081 = 9) \u2227\n  -- One city with degree 8\n  (\u2203! (c\u2082 : Fin 10), city_degree n c\u2082 = 8) \u2227\n  -- Two cities with degree 7\n  (\u2203 (c\u2083 c\u2084 : Fin 10), c\u2083 \u2260 c\u2084 \u2227 \n    city_degree n c\u2083 = 7 \u2227 city_degree n c\u2084 = 7 \u2227\n    (\u2200 c, city_degree n c = 7 \u2192 c = c\u2083 \u2228 c = c\u2084)) \u2227\n  -- Two cities with degree 6\n  (\u2203 (c\u2085 c\u2086 : Fin 10), c\u2085 \u2260 c\u2086 \u2227 \n    city_degree n c\u2085 = 6 \u2227 city_degree n c\u2086 = 6 \u2227\n    (\u2200 c, city_degree n c = 6 \u2192 c = c\u2085 \u2228 c = c\u2086)) \u2227\n  -- Two cities with degree 4\n  (\u2203 (c\u2087 c\u2088 : Fin 10), c\u2087 \u2260 c\u2088 \u2227 \n    city_degree n c\u2087 = 4 \u2227 city_degree n c\u2088 = 4 \u2227\n    (\u2200 c, city_degree n c = 4 \u2192 c = c\u2087 \u2228 c = c\u2088)) \u2227\n  -- One city with degree 2\n  (\u2203! (c\u2089 : Fin 10), city_degree n c\u2089 = 2) \u2227\n  -- One city with degree 1\n  (\u2203! (c\u2081\u2080 : Fin 10), city_degree n c\u2081\u2080 = 1) :=\n  sorry"}
{"id": "CombStruct4Lean_94", "informal_problem": "7.1. In the bakery, there are pies with two fillings (apple and cherry) and of two types (fried and baked). Prove that it is possible to buy two pies that will differ both in filling and in the method of preparation.", "formal_statement": "import Mathlib\n\nstructure Pie where\n  filling : Bool  -- false for apple, true for cherry\n  baked : Bool   -- false for fried, true for baked\n\ndef different_filling (p1 p2 : Pie) : Bool :=\n  p1.filling \u2260 p2.filling\n\ndef different_preparation (p1 p2 : Pie) : Bool :=\n  p1.baked \u2260 p2.baked\n\ntheorem bakery_pigeonhole : \u2203 (p1 p2 : Pie), \n  p1 \u2260 p2 \u2227 different_filling p1 p2 \u2227 different_preparation p1 p2 :=\n  sorry"}
{"id": "CombStruct4Lean_95", "informal_problem": "8.5. In a certain Italian city, 20 mafia clans are conducting their dark affairs, and it is known that each clan is at odds with at least 14 others. Will there always be 4 clans, each pair of which are at odds with each other?", "formal_statement": "import Mathlib\n\nstructure MafiaCity where\n  -- A simple undirected graph where vertices are clans (Fin 20) and edges represent conflicts\n  -- SimpleGraph ensures the graph is undirected and has no self-loops\n  conflicts : SimpleGraph (Fin 20)\n  [fintype_neighbors : \u2200 v, Fintype (conflicts.neighborSet v)]\n  -- Each clan has at least 14 conflicts with other clans\n  min_conflicts : \u2200 v : Fin 20, conflicts.degree v \u2265 14\n\ntheorem mafia_clique (M : MafiaCity) :\n  \u2203 S : Finset (Fin 20), S.card = 4 \u2227 M.conflicts.IsClique S :=\n  sorry"}
{"id": "CombStruct4Lean_96", "informal_problem": "7.1. Is it possible that 1000 participants in the olympiad will solve this problem correctly, and among them, there will be 43 more boys than girls?", "formal_statement": "import Mathlib\n\n-- No additional structures needed\n\ntheorem olympiad_participants_parity \n  (total : Nat) (diff : Nat) (h1 : total = 1000) (h2 : diff = 43) :\n  \u00ac(\u2203 (boys girls : Nat), \n    boys + girls = total \u2227 \n    boys - girls = diff) :=\n  sorry"}
{"id": "CombStruct4Lean_97", "informal_problem": "7.3. Anna has a 2015 by 2015 grid, in which she wrote real numbers. It turned out that in any three cells forming a corner (see the figure, the corner can be rotated), the sum of the numbers is 3. Prove that Anna put 1 in all cells.", "formal_statement": "import Mathlib\n\nstructure Grid2015 where\n  value : Fin 2015 \u2192 Fin 2015 \u2192 \u211d\n\n/-- Predicate that checks if three cells form a corner in the grid -/\ndef isCorner (i\u2081 j\u2081 i\u2082 j\u2082 i\u2083 j\u2083 : Fin 2015) : Prop :=\n  (i\u2081 = i\u2082 \u2227 j\u2081 = j\u2083) \u2228  -- horizontal-vertical corner\n  (i\u2081 = i\u2083 \u2227 j\u2081 = j\u2082) \u2228  -- vertical-horizontal corner\n  (i\u2082 = i\u2083 \u2227 j\u2082 = j\u2081)    -- another possible corner orientation\n\ntheorem grid_corner_sum_three_implies_all_ones \n  (g : Grid2015)\n  (h : \u2200 i\u2081 j\u2081 i\u2082 j\u2082 i\u2083 j\u2083, isCorner i\u2081 j\u2081 i\u2082 j\u2082 i\u2083 j\u2083 \u2192 \n    g.value i\u2081 j\u2081 + g.value i\u2082 j\u2082 + g.value i\u2083 j\u2083 = 3) :\n  \u2200 i j, g.value i j = 1 :=\n  sorry"}
{"id": "CombStruct4Lean_98", "informal_problem": "9.5. On an 8x8 chessboard, 8 rooks are arranged in such a way that none of them can attack each other. Prove that each of them can be simultaneously moved to one of the diagonally adjacent cells in such a way that none of them will be able to attack each other after the move. Recall that a chess rook attacks all cells in the row and column it occupies.", "formal_statement": "import Mathlib\n\n-- Represents a position on the 8x8 chessboard\nstructure Position where\n  row : Fin 8\n  col : Fin 8\n\n-- Represents a rook on the chessboard\nstructure Rook where\n  pos : Position\n\n-- Checks if two positions are diagonally adjacent\ndef isDiagonallyAdjacent (p1 p2 : Position) : Bool :=\n  let rowDiff := (p1.row.val : Int) - (p2.row.val : Int)\n  let colDiff := (p1.col.val : Int) - (p2.col.val : Int)\n  abs rowDiff = 1 && abs colDiff = 1\n\n-- Checks if two positions are in the same row or column (attacking position)\ndef isAttacking (p1 p2 : Position) : Bool :=\n  p1.row = p2.row || p1.col = p2.col\n\n-- Represents a configuration of 8 rooks\ndef RookConfiguration := Fin 8 \u2192 Rook\n\n-- Checks if a configuration is valid (no rooks attacking each other)\ndef isValidConfiguration (config : RookConfiguration) : Prop :=\n  \u2200 i j : Fin 8, i \u2260 j \u2192 \u00ac(isAttacking (config i).pos (config j).pos)\n\ntheorem rooks_diagonal_move_exists (initial : RookConfiguration) \n  (h : isValidConfiguration initial) :\n  \u2203 (final : RookConfiguration),\n    -- The final configuration is valid\n    isValidConfiguration final \u2227\n    -- Each rook moves to a diagonally adjacent square\n    (\u2200 i : Fin 8, isDiagonallyAdjacent (initial i).pos (final i).pos) :=\n  sorry"}
{"id": "CombStruct4Lean_99", "informal_problem": "7.5. Given an empty $3 \\times 3$ grid. In one move, it is allowed to choose any three cells forming an L-shape (oriented in any direction) and place one checker in each of them. Can it happen after several moves that each cell contains the same non-zero number of checkers? (Justify your answer.)", "formal_statement": "import Mathlib\n\n-- Position on 3x3 grid\nstructure Pos where\n  row : Fin 3\n  col : Fin 3\nderiving Repr, DecidableEq\n\n-- Define what makes three positions form an L-shape\ndef IsLShape (p1 p2 p3 : Pos) : Prop :=\n  (p1.row = p2.row \u2227 p2.col = p3.col \u2227 \n   ((p1.col = p2.col + 1 \u2228 p2.col = p1.col + 1) \u2227 \n    (p2.row = p3.row + 1 \u2228 p3.row = p2.row + 1))) \u2228\n  (p1.col = p2.col \u2227 p2.row = p3.row \u2227 \n   ((p1.row = p2.row + 1 \u2228 p2.row = p1.row + 1) \u2227 \n    (p2.col = p3.col + 1 \u2228 p3.col = p2.col + 1)))\n\n-- A move is a valid L-shape placement\nstructure Move where\n  pos1 : Pos\n  pos2 : Pos\n  pos3 : Pos\n  valid : IsLShape pos1 pos2 pos3\n\n-- Grid state tracks number of checkers in each position\ndef GridState := Pos \u2192 Nat\n\n-- Apply a move to a grid state\ndef applyMove (state : GridState) (move : Move) : GridState := fun pos =>\n  if pos = move.pos1 \u2228 pos = move.pos2 \u2228 pos = move.pos3\n  then state pos + 1\n  else state pos\n\ntheorem grid_equal_checkers_impossible :\n  \u00ac\u2203 (moves : List Move) (n : Nat),\n    n > 0 \u2227\n    let finalState := moves.foldl applyMove (fun _ => 0)\n    \u2200 pos, finalState pos = n :=\n  sorry"}
{"id": "CombStruct4Lean_100", "informal_problem": "7.5. TikTok-House represents a $3 \\times 3$ square of nine rooms, each inhabited by a blogger. On Monday, the bloggers randomly swapped rooms, after which every two people who ended up in adjacent rooms recorded a collaborative TikTok. On Tuesday, the bloggers again swapped rooms and recorded TikToks according to the same rule as the previous day. The same thing happened on Wednesday. Prove that some two bloggers did not record a collaborative TikTok.", "formal_statement": "import Mathlib\n\nstructure TikTokHouse where\n  -- Each day's arrangement is represented as a permutation of bloggers (1-9)\n  monday : Fin 9 \u2192 Fin 9\n  tuesday : Fin 9 \u2192 Fin 9\n  wednesday : Fin 9 \u2192 Fin 9\n  \n-- Define when two positions are adjacent in a 3x3 grid\ndef isAdjacent (p1 p2 : Fin 9) : Bool :=\n  let row1 := p1 / 3\n  let col1 := p1 % 3\n  let row2 := p2 / 3\n  let col2 := p2 % 3\n  (row1 = row2 \u2227 (col1 = col2 + 1 \u2228 col2 = col1 + 1)) \u2228\n  (col1 = col2 \u2227 (row1 = row2 + 1 \u2228 row2 = row1 + 1))\n\n-- Define when two bloggers made a TikTok together on a given day\ndef madeTikTok (arrangement : Fin 9 \u2192 Fin 9) (blogger1 blogger2 : Fin 9) : Bool :=\n  isAdjacent (arrangement blogger1) (arrangement blogger2)\n\ntheorem some_pair_no_tiktok (house : TikTokHouse) : \n  \u2203 (b1 b2 : Fin 9), b1 \u2260 b2 \u2227 \n    \u00ac(madeTikTok house.monday b1 b2 \u2228 \n      madeTikTok house.tuesday b1 b2 \u2228 \n      madeTikTok house.wednesday b1 b2) :=\n  sorry"}
{"id": "CombStruct4Lean_101", "informal_problem": "7.2. A square with a side of 6 cells is cut along the grid lines into 8 rectangles. Prove that some two of these rectangles are equal in area.", "formal_statement": "import Mathlib\n\nstructure Rectangle where\n  width : Nat\n  height : Nat\n  x_pos : Nat  -- x coordinate of bottom-left corner\n  y_pos : Nat  -- y coordinate of bottom-left corner\n  h_width : width \u2264 6\n  h_height : height \u2264 6\n  h_pos_x : x_pos + width \u2264 6\n  h_pos_y : y_pos + height \u2264 6\n\ndef area (r : Rectangle) : Nat :=\n  r.width * r.height\n\ndef valid_partition (rects : List Rectangle) : Prop :=\n  rects.length = 8 \u2227  -- exactly 8 rectangles\n  (\u2200 p : Nat \u00d7 Nat, p.1 < 6 \u2227 p.2 < 6 \u2192  -- each point belongs to exactly one rectangle\n    \u2203! r \u2208 rects, r.x_pos \u2264 p.1 \u2227 p.1 < r.x_pos + r.width \u2227\n                   r.y_pos \u2264 p.2 \u2227 p.2 < r.y_pos + r.height)\n\ntheorem square_partition_equal_areas :\n  \u2200 rects : List Rectangle,\n    valid_partition rects \u2192\n    \u2203 r1 r2 : Rectangle, r1 \u2208 rects \u2227 r2 \u2208 rects \u2227 r1 \u2260 r2 \u2227 area r1 = area r2 :=\n  sorry"}
{"id": "CombStruct4Lean_102", "informal_problem": "7.5. A chessboard with a side of 100 cells was cut along the grid lines into squares with odd sides (not necessarily equal), and then the central cell was marked in each of the resulting squares. Prove that an equal number of white and black cells were marked.", "formal_statement": "import Mathlib\n\nstructure ChessboardPartition where\n  squares : List (Nat \u00d7 Nat \u00d7 Nat) -- (x, y, side_length) for each square\n  is_valid : \u2200 s \u2208 squares, s.2.2 % 2 = 1 -- odd side lengths\n  covers_board : \u2200 (i j : Fin 100), \u2203! s \u2208 squares, \n    i.val \u2265 s.1 \u2227 i.val < s.1 + s.2.2 \u2227 \n    j.val \u2265 s.2.1 \u2227 j.val < s.2.1 + s.2.2\n  within_bounds : \u2200 s \u2208 squares,\n    s.1 + s.2.2 \u2264 100 \u2227 s.2.1 + s.2.2 \u2264 100\n\n/-- Returns true if a cell is white on a chessboard (assuming (0,0) is white) -/\ndef isWhiteCell (x y : Nat) : Bool :=\n  (x + y) % 2 = 0\n\n/-- Returns the center coordinates of a square given its top-left corner and side length -/\ndef centerCell (x y side : Nat) : Nat \u00d7 Nat :=\n  (x + side / 2, y + side / 2)\n\ntheorem chessboard_partition_centers_balanced \n  (p : ChessboardPartition) : \n  let centers := p.squares.map (fun s => centerCell s.1 s.2.1 s.2.2)\n  (centers.filter (fun c => isWhiteCell c.1 c.2)).length = \n  (centers.filter (fun c => !isWhiteCell c.1 c.2)).length :=\n  sorry"}
{"id": "CombStruct4Lean_103", "informal_problem": "8.5. In a large aviary, there are a hundred parakeets. At some point, it turned out that each of them had pecked exactly five other parakeets from this aviary during their lifetime. Prove that it is possible to release ten such parakeets into the wild, so that none of them had pecked each other.", "formal_statement": "import Mathlib\n\nstructure Aviary where\n  pecking : Fin 100 \u2192 Finset (Fin 100)  -- Set of parakeets pecked by each parakeet\n  pecks_count : \u2200 i, (pecking i).card = 5\n  no_self_peck : \u2200 i, i \u2209 pecking i\n\ntheorem parakeet_release (av : Aviary) : \n  \u2203 (S : Finset (Fin 100)), \n    S.card = 10 \u2227 \n    \u2200 i \u2208 S, \u2200 j \u2208 S, i \u2260 j \u2192 j \u2209 av.pecking i :=\n  sorry"}
{"id": "CombStruct4Lean_104", "informal_problem": "7.2. Can a plane be painted in 2016 colors in such a way that among the vertices of any triangle, there will be at least two different colors?", "formal_statement": "import Mathlib\n\n/-- A coloring of the plane using n colors -/\nstructure ColoredPlane (n : \u2115) where\n  coloring : \u211d \u00d7 \u211d \u2192 Fin n\n\n/-- Three points form a triangle if they are distinct and not collinear -/\ndef isTriangle (p1 p2 p3 : \u211d \u00d7 \u211d) : Prop :=\n  p1 \u2260 p2 \u2227 p2 \u2260 p3 \u2227 p1 \u2260 p3 \u2227 \n  \u00ac(\u2203 (t : \u211d), (\n    ((1 - t) * p1.1 + t * p2.1 = p3.1) \u2227 \n    ((1 - t) * p1.2 + t * p2.2 = p3.2)))\n\ntheorem plane_coloring_exists : \n  \u2203 (c : ColoredPlane 2016), \n    \u2200 (p1 p2 p3 : \u211d \u00d7 \u211d), isTriangle p1 p2 p3 \u2192 \n      c.coloring p1 \u2260 c.coloring p2 \u2228 \n      c.coloring p2 \u2260 c.coloring p3 \u2228 \n      c.coloring p1 \u2260 c.coloring p3 :=\n  sorry"}
{"id": "CombStruct4Lean_105", "informal_problem": "5. For which natural numbers $n$ can a board of size $n$ by $n$ cells be divided along the grid lines into dominoes of size 1 by 2 cells so that there are an equal number of vertical and horizontal dominoes", "formal_statement": "import Mathlib\n\nstructure Domino (n : Nat) where\n  start : Fin n \u00d7 Fin n\n  isHorizontal : Bool\n  valid : if isHorizontal \n    then start.2.val + 1 < n  -- horizontal domino must fit within board width\n    else start.1.val + 1 < n  -- vertical domino must fit within board height\n\nstructure DominoTiling (n : Nat) where\n  dominoes : Finset (Domino n)\n  equal_counts : (dominoes.filter (\u00b7.isHorizontal)).card = \n                 (dominoes.filter (fun d => !d.isHorizontal)).card\n  covers_once : \u2200 (i j : Fin n),\n    -- Each cell is covered exactly once\n    (dominoes.filter (fun d => \n      if d.isHorizontal then\n        (d.start.1 = i && d.start.2 = j) || \n        (d.start.1 = i && d.start.2.val + 1 = j.val)\n      else\n        (d.start.1 = i && d.start.2 = j) || \n        (d.start.1.val + 1 = i.val && d.start.2 = j)\n    )).card = 1\n\ntheorem domino_tiling_characterization (n : Nat) (h : n > 0) :\n  (\u2203 t : DominoTiling n, True) \u2194 n % 2 = 0 :=\n  sorry"}
{"id": "CombStruct4Lean_106", "informal_problem": "7.5. Ten girls each had ten envelopes. Each girl signed and sent some envelopes to other girls (an envelope cannot be signed twice). As a result, each girl ended up with a different number of envelopes. Prove that at least one girl ended up with more envelopes than she sent out.", "formal_statement": "import Mathlib\n\nstructure EnvelopeExchange (n : Nat) where\n  sent : Fin n \u2192 Nat\n  received : Fin n \u2192 Nat\n  /-- Each girl starts with n envelopes and can't send more than that -/\n  initial_bound : \u2200 i, sent i \u2264 n\n  /-- Each girl receives a different number of envelopes -/\n  distinct_received : \u2200 i j, i \u2260 j \u2192 received i \u2260 received j\n  /-- Conservation of envelopes: total sent equals total received -/\n  conservation : (\u2211 i, sent i) = (\u2211 i, received i)\n\ntheorem envelope_distribution_inequality {n : Nat} (h : n = 10) (e : EnvelopeExchange n) :\n  \u2203 i, e.received i > e.sent i :=\n  sorry"}
{"id": "CombStruct4Lean_107", "informal_problem": "7.5. In a club, 50 schoolchildren attended, who sometimes came to classes. It turned out that any two schoolchildren met at some class exactly once. In addition, it is known that not all schoolchildren came to any class at the same time. Prove that there is a schoolchild who attended at least 8 classes.", "formal_statement": "import Mathlib\n\nstructure SchoolMeetings where\n  n : Nat                                     -- total number of children\n  pos_n : 0 < n                              -- number of children is positive\n  classes : Finset (Finset (Fin n))          -- set of classes (finite)\n  nonempty_classes : \u2200 c \u2208 classes, \n    \u2203 i j : Fin n, i \u2260 j \u2227 i \u2208 c \u2227 j \u2208 c    -- each class has at least 2 students\n  meets_once : \u2200 (i j : Fin n), i \u2260 j \u2192 \n    \u2203! c \u2208 classes, i \u2208 c \u2227 j \u2208 c           -- any two children meet exactly once\n  not_all_together : \u2200 c \u2208 classes, \n    \u2203 (i : Fin n), i \u2209 c                     -- not all children attend any single class\n\n/-- Number of classes a student attends -/\ndef attendance_count (s : SchoolMeetings) (i : Fin s.n) : Nat :=\n  (s.classes.filter (fun c => i \u2208 c)).card\n\ntheorem school_meetings_min_attendance \n  (s : SchoolMeetings) (h : s.n = 50) :\n  \u2203 (i : Fin s.n), attendance_count s i \u2265 8 :=\n  sorry"}
{"id": "CombStruct4Lean_108", "informal_problem": "8.5. After a successful train robbery, 102 bandits divided the obtained rubies, sapphires, and emeralds in such a way that each of them received exactly 100 precious stones in total. Prove that at least one of the following two statements is true:\n\n- There are two bandits who have the same number of rubies, sapphires, and emeralds;\n- There are two bandits who have a different number of rubies, sapphires, and emeralds.", "formal_statement": "import Mathlib\n\nstructure Bandit where\n  rubies : Nat\n  sapphires : Nat\n  emeralds : Nat\n  total_is_100 : rubies + sapphires + emeralds = 100\n\n/-- Returns true if two bandits have exactly the same distribution of stones -/\ndef same_distribution (b1 b2 : Bandit) : Bool :=\n  b1.rubies = b2.rubies \u2227 b1.sapphires = b2.sapphires \u2227 b1.emeralds = b2.emeralds\n\n/-- Returns true if two bandits have completely different distributions of stones -/\ndef different_distribution (b1 b2 : Bandit) : Bool :=\n  b1.rubies \u2260 b2.rubies \u2227 b1.sapphires \u2260 b2.sapphires \u2227 b1.emeralds \u2260 b2.emeralds\n\ntheorem bandit_distribution_property (bandits : Fin 102 \u2192 Bandit) :\n  (\u2203 i j : Fin 102, i \u2260 j \u2227 same_distribution (bandits i) (bandits j)) \u2228\n  (\u2203 i j : Fin 102, i \u2260 j \u2227 different_distribution (bandits i) (bandits j)) :=\n  sorry"}
{"id": "CombStruct4Lean_109", "informal_problem": "9. Two friendly series (from 8th grade, 2 points). Two football teams A and B play football equally well. The coaches agreed on two friendly matches. A team is awarded 2 points for a win, 1 point for a draw, and 0 points for a loss. The probability of a draw in each match is the same and equal to $p$.\n\nThe following year, a similar friendly series of two matches took place. The teams played with the same lineup, they were still equally strong, but the probability $p$ increased. Can we assert that the probability that the teams will score the same number of points has increased?", "formal_statement": "import Mathlib\n\n/-- Represents the outcome from one team's perspective -/\ninductive MatchOutcome\n  | Win \n  | Draw\n  | Loss\n\n/-- Points awarded for each match outcome -/\ndef matchPoints (result : MatchOutcome) : Real :=\n  match result with\n  | MatchOutcome.Win => 2\n  | MatchOutcome.Draw => 1\n  | MatchOutcome.Loss => 0\n\n/-- Represents a series of two matches from one team's perspective -/\nstructure TwoMatchSeries where\n  match1 : MatchOutcome\n  match2 : MatchOutcome\n\n/-- Total points for a team in a series -/\ndef totalPoints (series : TwoMatchSeries) : Real :=\n  matchPoints series.match1 + matchPoints series.match2\n\n/-- Probability of equal points given draw probability p -/\nnoncomputable def equalPointsProb (p : Real) : Real :=\n  let drawProb := p\n  let winProb := (1 - p) / 2\n  -- Probability of two draws\n  p * p +\n  -- Probability of win-loss or loss-win (both give equal points)\n  2 * winProb * winProb\n\ntheorem equal_points_prob_decreasing_exists\n  {p\u2081 p\u2082 : Real} (h\u2081 : 0 \u2264 p\u2081) (h\u2082 : p\u2081 < p\u2082) (h\u2083 : p\u2082 \u2264 1) :\n  equalPointsProb p\u2082 < equalPointsProb p\u2081 :=\n  sorry"}
{"id": "CombStruct4Lean_110", "informal_problem": "6. Drawing Lots. In a deck of 36 playing cards of four suits, from six to ace. Vasya and Masha each draw one card. Vasya draws first, and then Masha. Masha wins if she draws a card higher than Vasya's. Otherwise, Vasya wins.\n\nProve that the lot is unfair.", "formal_statement": "import Mathlib\n\n/-- Rank of a playing card from 6 through ace -/\ninductive Rank\n| Six | Seven | Eight | Nine | Ten | Jack | Queen | King | Ace\nderiving DecidableEq, Fintype, Ord\n\n/-- A playing card with suit and rank -/\nstructure Card where\n  suit : Fin 4\n  rank : Rank\n  deriving DecidableEq, Fintype\n\n/-- Convert rank to natural number for comparison (Ace is highest) -/\ndef Rank.toNat : Rank \u2192 Nat\n| Six => 0 | Seven => 1 | Eight => 2 | Nine => 3 | Ten => 4\n| Jack => 5 | Queen => 6 | King => 7 | Ace => 8\n\n/-- Compare two cards by rank -/\ndef Card.rankLt (c1 c2 : Card) : Bool :=\n  Rank.toNat c1.rank < Rank.toNat c2.rank\n\n/-- The deck of cards excluding drawn cards -/\nstructure Deck where\n  cards : Finset Card\n  valid : cards.card = 36 \u2228 cards.card = 35  -- Initial deck or after one draw\n\ntheorem drawing_lots_unfair :\n  let initial_deck : Finset Card := Finset.univ\n  let total_outcomes : Nat := 36 * 35  -- Total possible combinations of draws\n  let masha_winning_outcomes : Nat := (36 * 35) / 2 - 36  -- Outcomes where Masha wins\n  (masha_winning_outcomes : \u211a) / total_outcomes < 1/2 :=\n  sorry"}
{"id": "CombStruct4Lean_111", "informal_problem": "4. A city is considered a millionaire city if it has a population of more than one million people. Which event has a higher probability:\n\n$$\nA=\\{\\text { a randomly chosen city dweller lives in a millionaire city }\\}\n$$\n\n$$\nB=\\{\\text { a randomly chosen city is a millionaire city }\\} ?\n$$", "formal_statement": "import Mathlib\n\nstructure City where\n  population : \u2115\n  isMillionaireCity : Bool := population > 1000000\n\n/-- Distribution of cities with their populations -/\nstructure CityDistribution where\n  cities : Finset City\n  populationDist : City \u2192 \u211d  -- Probability distribution over cities\n  dwellerDist : City \u2192 \u211d    -- Probability distribution for a random dweller\n  populationDistNonneg : \u2200 c, populationDist c \u2265 0\n  dwellerDistNonneg : \u2200 c, dwellerDist c \u2265 0\n  populationDistSum : (cities.sum populationDist) = 1\n  dwellerDistSum : (cities.sum dwellerDist) = 1\n\ntheorem millionaire_city_probability_comparison \n  (dist : CityDistribution) :\n  let probA := (dist.cities.filter (\u00b7.isMillionaireCity)).sum dist.dwellerDist\n  let probB := (dist.cities.filter (\u00b7.isMillionaireCity)).sum dist.populationDist\n  probA \u2265 probB :=\n  sorry"}
{"id": "CombStruct4Lean_112", "informal_problem": "2. Seven children met. Some of them gave gifts to some others (one could not give more than one gift to another). Could it have turned out that everyone received an equal number of gifts, even though they all gave different numbers of gifts (including possibly someone giving no gifts at all)?", "formal_statement": "import Mathlib\nopen Matrix\n\nstructure GiftExchange where\n  n : Nat\n  gifts : Matrix (Fin n) (Fin n) Bool\n\ndef valid_exchange (ge : GiftExchange) : Prop :=\n  \u2200 i : Fin ge.n, ge.gifts i i = false  -- no self-gifts\n\ndef gifts_given (ge : GiftExchange) (i : Fin ge.n) : Nat :=\n  Finset.sum Finset.univ fun j => if ge.gifts i j then 1 else 0\n\ndef gifts_received (ge : GiftExchange) (j : Fin ge.n) : Nat :=\n  Finset.sum Finset.univ fun i => if ge.gifts i j then 1 else 0\n\ndef all_received_equal (ge : GiftExchange) : Prop :=\n  \u2200 i j : Fin ge.n, gifts_received ge i = gifts_received ge j\n\ndef all_gave_different (ge : GiftExchange) : Prop :=\n  \u2200 i j : Fin ge.n, i \u2260 j \u2192 gifts_given ge i \u2260 gifts_given ge j\n\ntheorem gift_exchange_possible : \u2203 (ge : GiftExchange), \n  ge.n = 7 \u2227 \n  valid_exchange ge \u2227\n  all_received_equal ge \u2227\n  all_gave_different ge :=\n  sorry"}
{"id": "CombStruct4Lean_113", "informal_problem": "3. A chess championship is being held at a rural club: each participant must play one game with each other. The club has only one board, so two games cannot take place simultaneously. According to the championship regulations, at any time, the number of games already played by different participants should not differ by more than 1. The first few games of the championship were played in compliance with the regulations. Can the championship always be completed while adhering to the regulations?", "formal_statement": "import Mathlib\n\nstructure ChessChampionship where\n  n : Nat                             -- number of participants\n  games : Finset (Fin n \u00d7 Fin n)      -- played games as pairs of player indices\n  valid_pairs : \u2200 (p : Fin n \u00d7 Fin n), p \u2208 games \u2192 p.1 \u2260 p.2  -- no self-games\n  symmetric : \u2200 (i j : Fin n), (i, j) \u2208 games \u2194 (j, i) \u2208 games  -- each game counted once\n  balanced : \u2200 (i j : Fin n), \n    (games.filter (\u03bb p => p.1 = i \u2228 p.2 = i)).card \u2264 \n    (games.filter (\u03bb p => p.1 = j \u2228 p.2 = j)).card + 1  -- balance condition\n\ntheorem chess_championship_completion \n  (c : ChessChampionship) : \n  \u2203 (final : Finset (Fin c.n \u00d7 Fin c.n)), \n    -- final state contains all initial games\n    c.games \u2286 final\n    -- all pairs of distinct players are included\n    \u2227 \u2200 (i j : Fin c.n), i \u2260 j \u2192 (i, j) \u2208 final\n    -- maintains the balanced games property\n    \u2227 \u2200 (i j : Fin c.n),\n      (final.filter (\u03bb p => p.1 = i \u2228 p.2 = i)).card \u2264 \n      (final.filter (\u03bb p => p.1 = j \u2228 p.2 = j)).card + 1 :=\n  sorry"}
{"id": "CombStruct4Lean_114", "informal_problem": "5. In the cells of a $9 \\times 9$ table, odd integers are written. It is allowed to simultaneously change the sign of all numbers in some row or some column. Prove that using several such operations, one can arrive at a table where the sums of the numbers in any row and any column are positive.", "formal_statement": "import Mathlib\n\nstructure SignChangeTable where\n  -- The table is represented as a 9\u00d79 matrix of integers\n  entries : Matrix (Fin 9) (Fin 9) Int\n  -- All entries are odd numbers\n  odd_entries : \u2200 i j, Odd (entries i j)\n\n/-- Represents a sequence of row and column sign changes -/\nstructure SignChanges where\n  -- For each row/column, true means we flip signs, false means we don't\n  row_changes : Fin 9 \u2192 Bool\n  col_changes : Fin 9 \u2192 Bool\n\n/-- Apply sign changes to a table -/\ndef applyChanges (t : SignChangeTable) (changes : SignChanges) : Matrix (Fin 9) (Fin 9) Int :=\n  fun i j => \n    let sign := if changes.row_changes i = changes.col_changes j then 1 else -1\n    sign * t.entries i j\n\n/-- Sum of numbers in a row after applying changes -/\ndef rowSum (t : SignChangeTable) (changes : SignChanges) (i : Fin 9) : Int :=\n  (Finset.univ.sum fun j => (applyChanges t changes i j))\n\n/-- Sum of numbers in a column after applying changes -/\ndef colSum (t : SignChangeTable) (changes : SignChanges) (j : Fin 9) : Int :=\n  (Finset.univ.sum fun i => (applyChanges t changes i j))\n\ntheorem exists_positive_sums (t : SignChangeTable) : \n  \u2203 (changes : SignChanges),\n    (\u2200 i : Fin 9, rowSum t changes i > 0) \u2227 \n    (\u2200 j : Fin 9, colSum t changes j > 0) :=\n  sorry"}
{"id": "CombStruct4Lean_115", "informal_problem": "5. In a regular 2015-gon, 64 vertices are marked. Prove that among them there exist four points that are the vertices of some trapezoid.", "formal_statement": "import Mathlib\n\n/-- A point in 2D space -/\nstructure Point where\n  x : \u211d \n  y : \u211d\n\n/-- A regular polygon with marked vertices -/\nstructure RegularPolygon where\n  n : \u2115 \n  vertices : Fin n \u2192 Point\n  marked : Finset (Fin n)\n  is_regular : \u2200 i j : Fin n,\n    -- All vertices are equidistant from origin\n    (vertices i).x ^ 2 + (vertices i).y ^ 2 = \n    (vertices j).x ^ 2 + (vertices j).y ^ 2\n    \n/-- Determines if four points form a trapezoid by checking if at least one pair\n    of opposite sides is parallel (using slope equality) -/\ndef FormsTrapezoid (p\u2081 p\u2082 p\u2083 p\u2084 : Point) : Prop :=\n  let slope (p q : Point) := (q.y - p.y) / (q.x - p.x)\n  slope p\u2081 p\u2082 = slope p\u2083 p\u2084 \u2228 slope p\u2081 p\u2084 = slope p\u2082 p\u2083\n\ntheorem marked_vertices_form_trapezoid \n  (p : RegularPolygon)\n  (h\u2081 : p.n = 2015)\n  (h\u2082 : p.marked.card = 64) :\n  \u2203 (v\u2081 v\u2082 v\u2083 v\u2084 : Fin p.n),\n    v\u2081 \u2208 p.marked \u2227 v\u2082 \u2208 p.marked \u2227 v\u2083 \u2208 p.marked \u2227 v\u2084 \u2208 p.marked \u2227\n    FormsTrapezoid (p.vertices v\u2081) (p.vertices v\u2082) (p.vertices v\u2083) (p.vertices v\u2084) :=\n  sorry"}
{"id": "CombStruct4Lean_116", "informal_problem": "4. Can rectangular parallelepipeds of size $2 \\times 2 \\times 1$ be used to form a rectangular parallelepiped of size $3 \\times 4 \\times 5$? Don't forget to justify your answer.", "formal_statement": "import Mathlib\n\nstructure Block where\n  width : Nat\n  length : Nat\n  height : Nat\n\n/-- A tiling represents a way to fill a larger block with smaller blocks -/\nstructure Tiling where\n  target : Block  -- The block we want to fill\n  piece : Block   -- The block we use for filling\n  possible : Bool -- Whether such tiling exists\n\ntheorem rectangular_parallelepiped_tiling_impossible : \n  let small_block := Block.mk 2 2 1\n  let large_block := Block.mk 3 4 5\n  let tiling := Tiling.mk large_block small_block false\n  tiling.possible = false :=\n  sorry"}
{"id": "CombStruct4Lean_117", "informal_problem": "5. Thirteen girls and thirteen boys participated in a math competition. Each participant solved no more than four problems. For any girl and boy, there is at least one problem solved by both. Prove that there was a problem solved by no fewer than three girls and no fewer than three boys.", "formal_statement": "import Mathlib\n\nstructure Competition (n : \u2115) where\n  girlSolved : Fin 13 \u2192 Finset (Fin n)\n  boySolved : Fin 13 \u2192 Finset (Fin n)\n  atMostFour : \u2200 x : Fin 13, (girlSolved x).card \u2264 4 \u2227 (boySolved x).card \u2264 4\n  commonProblem : \u2200 (g b : Fin 13), \u2203 p : Fin n, p \u2208 girlSolved g \u2229 boySolved b\n\ntheorem competition_problem {n : \u2115} (comp : Competition n) :\n  \u2203 p : Fin n, \n    (Finset.filter (fun g => p \u2208 comp.girlSolved g) (Finset.univ : Finset (Fin 13))).card \u2265 3 \u2227 \n    (Finset.filter (fun b => p \u2208 comp.boySolved b) (Finset.univ : Finset (Fin 13))).card \u2265 3 :=\n  sorry"}
{"id": "CombStruct4Lean_118", "informal_problem": "7.2 In the class, there are 33 students, and the sum of their ages is 430 years. Prove that there are 20 students in the class whose sum of ages is greater than 260 years.", "formal_statement": "import Mathlib\n\nstructure ClassInfo where\n  students : Finset Nat\n  ages : Nat \u2192 Nat\n  student_count : students.card = 33\n  total_age : (\u2211 i in students, ages i) = 430\n\ntheorem exists_twenty_students_sum_over_260 (c : ClassInfo) :\n  \u2203 (subset : Finset Nat), subset \u2286 c.students \u2227 subset.card = 20 \u2227 \n    (\u2211 i in subset, c.ages i) > 260 :=\n  sorry"}
{"id": "CombStruct4Lean_119", "informal_problem": "3. Potatoes and beets are transported on 79 trucks, not necessarily identical, with each truck loaded either with potatoes or beets. Prove that it is possible to select 40 trucks from these such that they transport no less than $50 \\%$ of all the potatoes and no less than $50 \\%$ of all the beets.", "formal_statement": "import Mathlib\n\nstructure TruckLoad where\n  isPotato : Bool  -- true if truck carries potatoes, false if beets\n  amount : \u211d       -- amount of cargo\n  amount_pos : amount > 0\n\n/-- Total amount of potatoes in a collection of trucks -/\ndef totalPotatoes (trucks : List TruckLoad) : \u211d :=\n  (trucks.filter (\u00b7.isPotato)).map (\u00b7.amount) |>.sum\n\n/-- Total amount of beets in a collection of trucks -/\ndef totalBeets (trucks : List TruckLoad) : \u211d :=\n  (trucks.filter (fun t \u21a6 !t.isPotato)).map (\u00b7.amount) |>.sum\n\ntheorem truck_selection_exists (trucks : List TruckLoad) \n  (h_count : trucks.length = 79) :\n  \u2203 (selected : List TruckLoad),\n    selected.length = 40 \u2227 \n    selected.Subset trucks \u2227\n    totalPotatoes selected \u2265 (totalPotatoes trucks) / 2 \u2227\n    totalBeets selected \u2265 (totalBeets trucks) / 2 :=\n  sorry"}
{"id": "CombStruct4Lean_120", "informal_problem": "5. Each point of the plane is painted in one of three colors, and all three colors are used. Is it true that for any such coloring, one can choose a circle on which there are points of all three colors?", "formal_statement": "import Mathlib\n\n-- Define a coloring of the plane as a function from \u211d \u00d7 \u211d to a three-element type\nstructure ThreeColoring where\n  color : \u211d \u00d7 \u211d \u2192 Fin 3\n  all_colors_used : \u2200 (i : Fin 3), \u2203 (p : \u211d \u00d7 \u211d), color p = i\n\n-- Define what it means for a point to lie on a circle\ndef OnCircle (p : \u211d \u00d7 \u211d) (center : \u211d \u00d7 \u211d) (radius : \u211d) : Prop :=\n  (p.1 - center.1)^2 + (p.2 - center.2)^2 = radius^2\n\ntheorem three_color_circle_existence (coloring : ThreeColoring) :\n  \u2203 (center : \u211d \u00d7 \u211d) (radius : \u211d),\n    \u2200 (i : Fin 3), \u2203 (p : \u211d \u00d7 \u211d), \n      OnCircle p center radius \u2227 coloring.color p = i :=\n  sorry"}
{"id": "CombStruct4Lean_121", "informal_problem": "9.3. Can a $12 \\times 12$ checkerboard be divided into corners made of three adjacent cells $\\square$ such that each horizontal and each vertical row of cells on the board intersects the same number of corners? (A row intersects a corner if it contains at least one of its cells.)", "formal_statement": "import Mathlib\n\n/-- Represents the four possible orientations of a corner -/\ninductive CornerOrientation\n  | TopLeft    -- \u231c\n  | TopRight   -- \u231d\n  | BottomLeft -- \u231e\n  | BottomRight -- \u231f\n\n/-- A corner on the 12\u00d712 checkerboard consisting of three adjacent cells -/\nstructure Corner where\n  x : Fin 12      -- x-coordinate of the base cell\n  y : Fin 12      -- y-coordinate of the base cell\n  orientation : CornerOrientation\n\n/-- Predicate indicating whether a given position is part of the corner -/\ndef isInCorner (c : Corner) (x y : Fin 12) : Bool :=\n  match c.orientation with\n  | CornerOrientation.TopLeft => \n      (x = c.x && y = c.y) || \n      (x = c.x && y = c.y + 1) || \n      (x = c.x + 1 && y = c.y)\n  | CornerOrientation.TopRight => \n      (x = c.x && y = c.y) || \n      (x = c.x && y = c.y + 1) || \n      (x = c.x - 1 && y = c.y)\n  | CornerOrientation.BottomLeft => \n      (x = c.x && y = c.y) || \n      (x = c.x && y = c.y - 1) || \n      (x = c.x + 1 && y = c.y)\n  | CornerOrientation.BottomRight => \n      (x = c.x && y = c.y) || \n      (x = c.x && y = c.y - 1) || \n      (x = c.x - 1 && y = c.y)\n\n/-- A valid corner placement is a set of corners that forms a partition -/\ndef isValidPlacement (corners : Finset Corner) : Bool :=\n  -- Every cell belongs to exactly one corner\n  (\u2200 x y : Fin 12, (corners.filter (fun c \u21a6 isInCorner c x y)).card = 1)\n\n/-- Number of corners intersecting a row -/\ndef rowIntersections (corners : Finset Corner) (row : Fin 12) : Nat :=\n  (corners.filter (fun c \u21a6 \u2203 x : Fin 12, isInCorner c x row)).card\n\n/-- Number of corners intersecting a column -/\ndef colIntersections (corners : Finset Corner) (col : Fin 12) : Nat :=\n  (corners.filter (fun c \u21a6 \u2203 y : Fin 12, isInCorner c col y)).card\n\ntheorem checkerboard_corner_partition_impossible :\n  \u00ac\u2203 (corners : Finset Corner),\n    isValidPlacement corners \u2227\n    \u2203 k : \u2115, \n      (\u2200 row : Fin 12, rowIntersections corners row = k) \u2227\n      (\u2200 col : Fin 12, colIntersections corners col = k) :=\n  sorry"}
{"id": "CombStruct4Lean_122", "informal_problem": "10.4. Can the set of all natural numbers be partitioned into non-intersecting finite subsets $A_{1}, A_{2}, A_{3}, \\ldots$ such that for any natural number $k$, the sum of all numbers in the subset $A_{k}$ equals $k+2013$?\n\n(R. Zhenodarov)", "formal_statement": "import Mathlib\n\nstructure PartitionSolution where\n  -- Returns the finite set of elements in partition k\n  getPartition : \u2115 \u2192 Finset \u2115\n  -- Partitions are disjoint\n  disjoint : \u2200 i j, i \u2260 j \u2192 Disjoint (getPartition i) (getPartition j)\n  -- Every natural number appears in some partition\n  covers : \u2200 n, \u2203 k, n \u2208 getPartition k\n  -- Sum property\n  sumProperty : \u2200 k, (getPartition k).sum id = k + 2013\n\ntheorem no_partition_solution : \u00ac \u2203 p : PartitionSolution, True :=\n  sorry"}
{"id": "CombStruct4Lean_123", "informal_problem": "6. Vasya has 19950 chips, painted in 200 different colors. He arranged them in a circle. Prove that there is such a pair of colors that the chips of these colors do not stand next to each other.", "formal_statement": "import Mathlib\n\nstructure ColoredChips where\n  numColors : Nat\n  totalChips : Nat\n  arrangement : Fin totalChips \u2192 Fin numColors\n  isCircular : True  -- Represents that chips are arranged in a circle\n\n/-- Two positions in the circular arrangement are adjacent -/\ndef areAdjacent (n : Nat) (i j : Fin n) : Bool :=\n  i.val + 1 = j.val \u2228 (i.val = n - 1 \u2227 j.val = 0)\n\ntheorem colored_chips_not_adjacent \n  (chips : ColoredChips)\n  (h1 : chips.totalChips = 19950)\n  (h2 : chips.numColors = 200) :\n  \u2203 (c1 c2 : Fin chips.numColors), \n    \u2200 (i j : Fin chips.totalChips), \n      areAdjacent chips.totalChips i j \u2192 \n        \u00ac(chips.arrangement i = c1 \u2227 chips.arrangement j = c2) :=\n  sorry"}
{"id": "CombStruct4Lean_124", "informal_problem": "9.4. 10,000 children arrived at the camp, each of whom is friends with exactly 11 other children in the camp (friendship is mutual). Each child wears a T-shirt of one of the seven colors of the rainbow, and any two friends have different colors. The counselors demanded that some children (at least one) change the color of their T-shirts (to one of the same seven colors). A survey showed that 100 children are not willing to change their color. Prove that some of the other children can still change the colors of their T-shirts so that any two friends still have different colors.\n\n(A. Magazinov)", "formal_statement": "import Mathlib\n\nopen Finset\n\nstructure CampSituation (n : Nat) where\n  children : Type\n  [fintype : Fintype children]\n  [decidableEq : DecidableEq children]\n  friends : children \u2192 children \u2192 Prop\n  [decidableFriends : DecidableRel friends]\n  initialColor : children \u2192 Fin 7\n  unwillingToChange : Finset children\n  -- Properties\n  friend_symmetric : \u2200 x y, friends x y \u2194 friends y x\n  friend_irrefl : \u2200 x, \u00acfriends x x\n  friend_count : \u2200 x, ({y | friends x y}).toFinset.card = 11\n  friend_diff_color : \u2200 x y, friends x y \u2192 initialColor x \u2260 initialColor y\n  unwilling_size : unwillingToChange.card = 100\n\ntheorem exists_valid_recoloring {n : Nat} (c : CampSituation n) :\n  \u2203 (newColor : c.children \u2192 Fin 7),\n    (\u2200 x \u2208 c.unwillingToChange, newColor x = c.initialColor x) \u2227\n    (\u2200 x y, c.friends x y \u2192 newColor x \u2260 newColor y) :=\n  sorry"}
{"id": "CombStruct4Lean_125", "informal_problem": "7.5. Prove that from any set of 15 positive integers, each of which does not exceed 2020, it is always possible to select two non-intersecting subsets with the same sums of the numbers in these subsets.", "formal_statement": "import Mathlib\n\nstructure DisjointSubsetsWithEqualSum (S : Finset Nat) where\n  subset1 : Finset Nat\n  subset2 : Finset Nat\n  nonempty1 : subset1.Nonempty\n  nonempty2 : subset2.Nonempty\n  disjoint : Disjoint subset1 subset2\n  subsets_valid : subset1 \u2286 S \u2227 subset2 \u2286 S\n  sums_equal : subset1.sum id = subset2.sum id\n\ntheorem exists_disjoint_equal_sum_subsets \n  (S : Finset Nat) \n  (card_S : S.card = 15)\n  (bounded : \u2200 n \u2208 S, n \u2264 2020) :\n  \u2203 (d : DisjointSubsetsWithEqualSum S), True :=\n  sorry"}
{"id": "CombStruct4Lean_126", "informal_problem": "10.3. In city $\\mathrm{N}$, 50 city olympiads in different subjects were held, with exactly 30 schoolchildren participating in each of these olympiads, but there were no two olympiads with the same set of participants. It is known that for any 30 olympiads, there is a schoolchild who participated in all these 30 olympiads. Prove that there is a schoolchild who participated in all 50 olympiads.\n\n(V. Dolnikov)", "formal_statement": "import Mathlib\n\nstructure OlympiadSystem where\n  numStudents : Nat\n  participants : Fin 50 \u2192 Finset (Fin numStudents)\n  -- Each olympiad has exactly 30 participants\n  size_constraint : \u2200 o : Fin 50, (participants o).card = 30\n  -- No two olympiads have the same set of participants\n  distinct_sets : \u2200 (o\u2081 o\u2082 : Fin 50), o\u2081 \u2260 o\u2082 \u2192 participants o\u2081 \u2260 participants o\u2082\n  -- For any 30 olympiads, there exists a student who participated in all of them\n  thirty_coverage : \u2200 (subset : Finset (Fin 50)), subset.card = 30 \u2192\n    \u2203 s : Fin numStudents, \u2200 o \u2208 subset, s \u2208 participants o\n\ntheorem olympiad_coverage (sys : OlympiadSystem) :\n  \u2203 s : Fin sys.numStudents, \u2200 o : Fin 50, s \u2208 sys.participants o :=\n  sorry"}
{"id": "CombStruct4Lean_127", "informal_problem": "9.1. In a round-robin chess tournament, six people participated: two boys and four girls. Could the boys have scored twice as many points as the girls by the end of the tournament? (In a round-robin chess tournament, each player plays one game against each of the others. A win earns 1 point, a draw 0.5, and a loss 0 points.)", "formal_statement": "import Mathlib\n\n/-- Tournament size -/\ndef n : Nat := 6\n/-- Number of boys -/\ndef num_boys : Nat := 2\n/-- Number of girls -/\ndef num_girls : Nat := 4\n\n/-- Player type enumeration -/\ninductive PlayerType where\n  | Boy\n  | Girl\nderiving Repr, DecidableEq\n\n/-- Core tournament data structure -/\nstructure TournamentData where\n  results : Fin n \u00d7 Fin n \u2192 Rat\n  player_type : Fin n \u2192 PlayerType\n\n/-- Predicate for valid tournament scores (0, 0.5, or 1) -/\ndef valid_scores (t : TournamentData) : Prop :=\n  \u2200 i j, t.results (i, j) = 0 \u2228 t.results (i, j) = (1/2) \u2228 t.results (i, j) = 1\n\n/-- Each pair plays exactly one game with total score 1 -/\ndef valid_games (t : TournamentData) : Prop :=\n  \u2200 i j, t.results (i, j) + t.results (j, i) = 1\n\n/-- No self-play allowed -/\ndef no_self_play (t : TournamentData) : Prop :=\n  \u2200 i, t.results (i, i) = 0\n\n/-- Correct number of players of each type -/\ndef valid_player_counts (t : TournamentData) : Prop :=\n  (Finset.filter (fun i => t.player_type i = PlayerType.Boy) (Finset.univ)).card = num_boys \u2227\n  (Finset.filter (fun i => t.player_type i = PlayerType.Girl) (Finset.univ)).card = num_girls\n\n/-- Combined tournament validity predicate -/\ndef is_valid_tournament (t : TournamentData) : Prop :=\n  valid_scores t \u2227 valid_games t \u2227 no_self_play t \u2227 valid_player_counts t\n\n/-- Calculate score for a specific player type -/\ndef player_score (t : TournamentData) (ptype : PlayerType) : Rat :=\n  Finset.sum (Finset.filter (fun i => t.player_type i = ptype) Finset.univ) fun i =>\n    Finset.sum Finset.univ fun j => t.results (i, j)\n\n/-- In a 6-player round-robin tournament with 2 boys and 4 girls,\n    it's impossible for boys to score exactly twice as many points as girls -/\ntheorem chess_tournament_impossible :\n  \u00ac\u2203 (t : TournamentData), is_valid_tournament t \u2227 \n    player_score t PlayerType.Boy = 2 * player_score t PlayerType.Girl :=\n  sorry"}
{"id": "CombStruct4Lean_128", "informal_problem": "9.6. From a chessboard of size $8 \\times 8$, a square of size $2 \\times 2$ was cut out such that the remaining board could be divided into rectangles of size $1 \\times 3$. Determine which square could have been cut out. (List all possible options and prove that there are no others.)", "formal_statement": "import Mathlib\n\n/-- Orientation of a 1\u00d73 rectangle on the board -/\ninductive RectangleOrientation where\n  | horizontal\n  | vertical\n\n/-- Position of the 2\u00d72 cutout on the board -/\nstructure ChessboardCutout where\n  x : Fin 7\n  y : Fin 7\n\n/-- A 1\u00d73 rectangle placement on the board -/\nstructure Rectangle where\n  x : Fin 8\n  y : Fin 8\n  orientation : RectangleOrientation\n  valid : match orientation with\n    | RectangleOrientation.horizontal => x.val + 2 < 8\n    | RectangleOrientation.vertical => y.val + 2 < 8\n\n/-- Checks if a position is within the 2\u00d72 cutout -/\ndef isInCutout (pos : Fin 8 \u00d7 Fin 8) (cutout : ChessboardCutout) : Bool :=\n  let (px, py) := pos\n  let cx := cutout.x.val\n  let cy := cutout.y.val\n  (px.val \u2265 cx \u2227 px.val < cx + 2) \u2227 (py.val \u2265 cy \u2227 py.val < cy + 2)\n\n/-- Checks if a position is covered by a rectangle -/\ndef isPositionCovered (pos : Fin 8 \u00d7 Fin 8) (rect : Rectangle) : Bool :=\n  let (px, py) := pos\n  match rect.orientation with\n  | RectangleOrientation.horizontal =>\n    py.val = rect.y.val \u2227 px.val \u2265 rect.x.val \u2227 px.val < rect.x.val + 3\n  | RectangleOrientation.vertical =>\n    px.val = rect.x.val \u2227 py.val \u2265 rect.y.val \u2227 py.val < rect.y.val + 3\n\n/-- Checks if two rectangles overlap -/\ndef rectanglesOverlap (r1 r2 : Rectangle) : Bool :=\n  \u2203 pos : Fin 8 \u00d7 Fin 8, isPositionCovered pos r1 \u2227 isPositionCovered pos r2\n\n/-- Determines if a cutout position is valid according to the modulo conditions -/\ndef isValidCutoutPosition (x y : Fin 7) : Bool :=\n  (x.val % 3 = 1 \u2227 y.val % 3 = 1) \u2228\n  (x.val % 3 = 1 \u2227 y.val % 3 = 4) \u2228\n  (x.val % 3 = 4 \u2227 y.val % 3 = 1) \u2228\n  (x.val % 3 = 4 \u2227 y.val % 3 = 4)\n\ntheorem chessboard_cutout_tiling_exists (cutout : ChessboardCutout) :\n  (\u2203 (rectangles : List Rectangle),\n    -- List contains exactly 20 rectangles (as (64-4)/3 = 20)\n    rectangles.length = 20 \u2227\n    -- All rectangles are valid and don't overlap with cutout\n    (\u2200 r, r \u2208 rectangles \u2192 \u00acisInCutout (r.x, r.y) cutout) \u2227\n    -- No rectangles overlap with each other\n    (\u2200 r1 r2, r1 \u2208 rectangles \u2192 r2 \u2208 rectangles \u2192 r1 \u2260 r2 \u2192 \u00acrectanglesOverlap r1 r2) \u2227\n    -- Every non-cutout square is covered by exactly one rectangle\n    (\u2200 pos : Fin 8 \u00d7 Fin 8, \u00acisInCutout pos cutout \u2192\n      (\u2203 r, r \u2208 rectangles \u2227 isPositionCovered pos r) \u2227\n      (\u2200 r1 r2, r1 \u2208 rectangles \u2192 r2 \u2208 rectangles \u2192 \n        isPositionCovered pos r1 \u2192 isPositionCovered pos r2 \u2192 r1 = r2))) \u2194\n  -- The cutout position is one of the valid positions\n  isValidCutoutPosition cutout.x cutout.y :=\n  sorry"}
{"id": "CombStruct4Lean_129", "informal_problem": "3. Is it possible to color the cells of an 8 x 8 square in 16 colors so that for any two colors, there are cells of these colors that share a side?", "formal_statement": "import Mathlib\n\nstructure ColoredGrid where\n  -- A coloring is a function from positions to colors (represented as Fin 16)\n  coloring : Fin 8 \u00d7 Fin 8 \u2192 Fin 16\n\n-- Two positions are adjacent if they share a side\ndef adjacent (p\u2081 p\u2082 : Fin 8 \u00d7 Fin 8) : Bool :=\n  (p\u2081.1 = p\u2082.1 \u2227 (p\u2081.2.val + 1 = p\u2082.2.val \u2228 p\u2082.2.val + 1 = p\u2081.2.val)) \u2228\n  (p\u2081.2 = p\u2082.2 \u2227 (p\u2081.1.val + 1 = p\u2082.1.val \u2228 p\u2082.1.val + 1 = p\u2081.1.val))\n\n-- Property that for any two colors, there exist adjacent cells with these colors\ndef hasAllColorPairs (grid : ColoredGrid) : Prop :=\n  \u2200 c\u2081 c\u2082 : Fin 16, \u2203 p\u2081 p\u2082 : Fin 8 \u00d7 Fin 8,\n    adjacent p\u2081 p\u2082 \u2227 \n    grid.coloring p\u2081 = c\u2081 \u2227 \n    grid.coloring p\u2082 = c\u2082\n\ntheorem exists_16_coloring : \u2203 (grid : ColoredGrid), hasAllColorPairs grid :=\n  sorry"}
{"id": "CombStruct4Lean_130", "informal_problem": "9.8. Given an $n \\times n$ square. Initially, its cells are painted in white and black in a checkerboard pattern, with at least one of the corner cells being black. In one move, it is allowed to simultaneously repaint the four cells in some $2 \\times 2$ square according to the following rule: each white cell is repainted black, each black cell is repainted green, and each green cell is repainted white. For which $n$ can one obtain a checkerboard pattern where black and white colors have swapped places after several moves?\n\n(B. Truhin)", "formal_statement": "import Mathlib\n\ninductive Color where\n  | White\n  | Black\n  | Green\n  deriving Repr, DecidableEq\n\ndef nextColor : Color \u2192 Color\n  | Color.White => Color.Black\n  | Color.Black => Color.Green\n  | Color.Green => Color.White\n\nstructure Board (n : Nat) (h : n \u2265 2) where\n  cells : Fin n \u00d7 Fin n \u2192 Color\n\nstructure ValidMove (n : Nat) (h : n \u2265 2) where\n  row : Fin (n-1)\n  col : Fin (n-1)\n\ndef isCheckerboard (n : Nat) (h : n \u2265 2) (b : Board n h) (isSwapped : Bool := false) : Prop :=\n  \u2200 (i j : Fin n), b.cells (i, j) = \n    if (i.val + j.val) % 2 = 0 then \n      (if isSwapped then Color.Black else Color.White)\n    else \n      (if isSwapped then Color.White else Color.Black)\n\ndef hasBlackCorner (n : Nat) (h : n \u2265 2) (b : Board n h) : Prop :=\n  \u2203 (i j : Fin n), ((i.val = 0 \u2228 i.val = n-1) \u2227 (j.val = 0 \u2228 j.val = n-1)) \u2227\n    b.cells (i, j) = Color.Black\n\ndef inSquare (i j : Nat) (topLeft : Fin (n-1) \u00d7 Fin (n-1)) : Bool :=\n  i \u2265 topLeft.1.val \u2227 i < topLeft.1.val + 2 \u2227 \n  j \u2265 topLeft.2.val \u2227 j < topLeft.2.val + 2\n\ndef applyMove (n : Nat) (h : n \u2265 2) (b : Board n h) (m : ValidMove n h) : Board n h :=\n  \u27e8fun (pos : Fin n \u00d7 Fin n) => \n    if inSquare pos.1.val pos.2.val (m.row, m.col)\n    then nextColor (b.cells pos)\n    else b.cells pos\u27e9\n\ntheorem checkerboard_swap_possible (n : Nat) (h : n \u2265 2) :\n  (\u2203 (b\u2080 : Board n h), isCheckerboard n h b\u2080 \u2227 hasBlackCorner n h b\u2080 \u2227\n   \u2203 (moves : List (ValidMove n h)), \n    let b\u2081 := moves.foldl (fun b m => applyMove n h b m) b\u2080\n    isCheckerboard n h b\u2081 true) \u2194 \n  n % 3 \u2260 0 :=\n  sorry"}
{"id": "CombStruct4Lean_131", "informal_problem": "11.8. Two players are playing a card game. They have a deck of $n$ pairwise distinct cards. For any two cards in the deck, it is known which one beats the other (however, if $A$ beats $B$, and $B$ beats $C$, it can happen that $C$ beats $A$). The deck is distributed between the players in an arbitrary manner. On each turn, the players reveal the top card from their decks, and the player whose card beats the other player's card takes both cards and places them at the bottom of their deck in any order they choose. Prove that, for any initial deal, the players can, knowing the arrangement of the cards, agree and act in such a way that one of the players ends up with no cards. (E. Lakhtanov)", "formal_statement": "import Mathlib\n\nstructure CardGame where\n  n : Nat                             -- number of cards\n  beats : Fin n \u2192 Fin n \u2192 Bool        -- beats i j means card i beats card j\n  deck1 : List (Fin n)                -- cards in player 1's deck\n  deck2 : List (Fin n)                -- cards in player 2's deck\n  valid_decks : deck1.toFinset \u222a deck2.toFinset = Finset.univ\n  no_duplicates : deck1.Nodup \u2227 deck2.Nodup\n\n/-- A game state represents a single turn in the game -/\nstructure GameState where\n  n : Nat\n  beats : Fin n \u2192 Fin n \u2192 Bool\n  deck1 : List (Fin n)\n  deck2 : List (Fin n)\n  \n/-- A strategy represents how players place cards at bottom of deck after winning -/\nstructure Strategy where\n  n : Nat\n  place_cards : Fin n \u2192 Fin n \u2192 List (Fin n)  -- how to place two cards at bottom\n\ntheorem exists_winning_strategy (g : CardGame) : \n  \u2203 (strat : Strategy), \u2203 (final : GameState),\n    final.deck1 = [] \u2228 final.deck2 = [] :=\n  sorry"}
{"id": "CombStruct4Lean_132", "informal_problem": "5. In a regular 9-gon, all sides and diagonals are painted either red or blue. It turned out that there are no three vertices of the 9-gon connected by segments forming a red triangle. Prove that there will be 4 vertices of the 9-gon forming a quadrilateral, all sides and diagonals of which are painted blue.\n\n#", "formal_statement": "import Mathlib\n\nstructure ColoredRegularPolygon where\n  n : Nat                                    -- number of vertices\n  colors : Fin n \u00d7 Fin n \u2192 Bool             -- True for blue, False for red\n  is_valid_edge (i j : Fin n) : Bool :=     -- checks if i,j form valid edge/diagonal\n    i \u2260 j                                    -- vertices must be different\n  \ndef has_red_triangle (p : ColoredRegularPolygon) : Bool :=\n  \u2203 (i j k : Fin p.n), \n    p.is_valid_edge i j \u2227 p.is_valid_edge j k \u2227 p.is_valid_edge k i \u2227\n    (!p.colors (i, j)) \u2227 (!p.colors (j, k)) \u2227 (!p.colors (k, i))\n\ndef has_blue_quadrilateral (p : ColoredRegularPolygon) : Bool :=\n  \u2203 (i j k l : Fin p.n), \n    i \u2260 j \u2227 j \u2260 k \u2227 k \u2260 l \u2227 l \u2260 i \u2227        -- all vertices different\n    p.colors (i, j) \u2227 p.colors (j, k) \u2227     -- all edges and diagonals blue\n    p.colors (k, l) \u2227 p.colors (l, i) \u2227\n    p.colors (i, k) \u2227 p.colors (j, l)\n\ntheorem nonagon_ramsey \n  (p : ColoredRegularPolygon) \n  (h1 : p.n = 9)                            -- 9-gon\n  (h2 : \u00achas_red_triangle p)                -- no red triangles\n  : has_blue_quadrilateral p := \n  sorry"}
{"id": "CombStruct4Lean_133", "informal_problem": "5. It is known that on a chessboard, 8 rooks can be placed so that they do not attack each other. Schoolboy Pete does not like the chessboard coloring, and he colored the board in 32 colors, so that there are exactly two cells of each color. Will he now be able to place 8 rooks so that they do not attack each other and stand on cells of different colors?\n\n#", "formal_statement": "import Mathlib\n\nstructure ChessboardColoring where\n  coloring : Fin 8 \u00d7 Fin 8 \u2192 Fin 32\n  two_per_color : \u2200 c : Fin 32, \n    (List.filter (fun pos => coloring pos = c) \n      (List.product (List.finRange 8) (List.finRange 8))).length = 2\n\n/-- A rook placement is valid if no two rooks share the same column -/\ndef IsValidRookPlacement (f : Fin 8 \u2192 Fin 8) : Prop :=\n  Function.Injective f\n\n/-- Predicate stating that all rooks are on different colors -/\ndef HasDifferentColors (c : ChessboardColoring) (f : Fin 8 \u2192 Fin 8) : Prop :=\n  \u2200 i j : Fin 8, i \u2260 j \u2192 c.coloring (i, f i) \u2260 c.coloring (j, f j)\n\ntheorem petes_colored_rooks_possible (c : ChessboardColoring) :\n  \u2203 f : Fin 8 \u2192 Fin 8, \n    IsValidRookPlacement f \u2227 \n    HasDifferentColors c f :=\n  sorry"}
{"id": "CombStruct4Lean_134", "informal_problem": "5. Is it possible to color all natural numbers either red or blue so that in any infinite arithmetic progression consisting of natural numbers, there are numbers of both colors? (To color the numbers means to assign each number one of two colors: either red or blue.) Justify your answer.\n\n#", "formal_statement": "import Mathlib\n\n-- A coloring is a function from natural numbers to Bool (True = red, False = blue)\ndef Coloring := \u2115 \u2192 Bool\n\n-- An arithmetic progression is defined by its first term and common difference\nstructure ArithmeticProgression where\n  first : \u2115\n  diff : \u2115\n  diff_pos : diff > 0\n\n-- Function to get the nth term of an arithmetic progression\ndef ArithmeticProgression.nthTerm (ap : ArithmeticProgression) (n : \u2115) : \u2115 :=\n  ap.first + n * ap.diff\n\n-- Predicate to check if an arithmetic progression is monochromatic under a coloring\ndef isMonochromatic (c : Coloring) (ap : ArithmeticProgression) : Prop :=\n  \u2200 n m : \u2115, c (ap.nthTerm n) = c (ap.nthTerm m)\n\ntheorem no_valid_coloring :\n  \u00ac \u2203 (c : Coloring), \u2200 (ap : ArithmeticProgression),\n    \u2203 (n m : \u2115), c (ap.nthTerm n) \u2260 c (ap.nthTerm m) :=\n  sorry"}
{"id": "CombStruct4Lean_135", "informal_problem": "6. In one company, among any 11 people, there are two people who know each other. Prove that in this company, there will be a group of ten people such that each of the others knows someone in this group.", "formal_statement": "import Mathlib\n\n-- Define a type for representing the acquaintance relation\ndef AcquaintanceGraph (n : \u2115) := Fin n \u2192 Fin n \u2192 Bool\n\n-- Property that two people know each other\ndef knows (g : AcquaintanceGraph n) (i j : Fin n) : Prop :=\n  g i j = true\n\n-- Property that in any group of 11 people, there are two who know each other\ndef has_acquaintance_in_11 (g : AcquaintanceGraph n) : Prop :=\n  \u2200 (s : Finset (Fin n)), s.card = 11 \u2192 \n    \u2203 (i j : Fin n), i \u2208 s \u2227 j \u2208 s \u2227 i \u2260 j \u2227 knows g i j\n\n-- Property that a person knows someone in a given group\ndef knows_someone_in_group (g : AcquaintanceGraph n) (p : Fin n) (group : Finset (Fin n)) : Prop :=\n  \u2203 q \u2208 group, knows g p q\n\ntheorem acquaintance_theorem {n : \u2115} (h : n > 10) (g : AcquaintanceGraph n)\n  (h_11 : has_acquaintance_in_11 g) :\n  \u2203 (group : Finset (Fin n)), group.card = 10 \u2227\n    \u2200 p : Fin n, p \u2209 group \u2192 knows_someone_in_group g p group :=\n  sorry"}
{"id": "CombStruct4Lean_136", "informal_problem": "9.1. In a quiz, 10 students participated and gave a total of 42 correct answers. Prove that at least 2 students gave the same number of correct answers (possibly zero).", "formal_statement": "import Mathlib\n\n-- No additional structures needed\n\ntheorem quiz_pigeonhole \n  (students : Finset Nat) \n  (answers : Nat \u2192 Nat)  -- maps student ID to their number of correct answers\n  (h_students : students.card = 10)\n  (h_total : (\u2211 i in students, answers i) = 42) :\n  \u2203 i j : Nat, i \u2208 students \u2227 j \u2208 students \u2227 i \u2260 j \u2227 answers i = answers j :=\n  sorry"}
{"id": "CombStruct4Lean_137", "informal_problem": "10.3. Pasha chose 2017 (not necessarily distinct) natural numbers $a_{1}, a_{2}, \\ldots, a_{2017}$ and plays the following game with himself. Initially, he has an unlimited supply of stones and 2017 large empty boxes. In one move, Pasha adds $a_{1}$ stones to any box (of his choice), $a_{2}$ stones to any of the remaining boxes (of his choice), ..., and finally, $a_{2017}$ stones to the remaining box. Pasha's goal is to achieve a state where, after some move, all the boxes have the same number of stones. Could he have chosen the numbers in such a way that the goal can be achieved in 43 moves, but not in a smaller non-zero number of moves?\n\n(I. Bogdanov)", "formal_statement": "import Mathlib\n\nstructure StoneGame where\n  numbers : Fin 2017 \u2192 Nat\n  boxes : Fin 2017 \u2192 Nat\n  move : Fin 2017 \u2192 Fin 2017 \u2192 Nat\n  -- move i j represents putting numbers[i] stones in box j during a move\n\ndef is_valid_move (g : StoneGame) (m : Fin 2017 \u2192 Fin 2017) : Bool :=\n  Function.Injective m\n\ndef apply_move (g : StoneGame) (m : Fin 2017 \u2192 Fin 2017) : Fin 2017 \u2192 Nat :=\n  fun i => g.boxes i + g.numbers (m i)\n\ndef boxes_equal (boxes : Fin 2017 \u2192 Nat) : Prop :=\n  \u2200 i j : Fin 2017, boxes i = boxes j\n\ndef can_achieve_equal_in_k_moves (g : StoneGame) (k : Nat) : Prop :=\n  \u2203 moves : Fin k \u2192 (Fin 2017 \u2192 Fin 2017),\n    (\u2200 i, is_valid_move g (moves i)) \u2227\n    \u2203 final_boxes, boxes_equal final_boxes\n\ntheorem stone_game_exact_moves : \n  \u2203 g : StoneGame,\n    (can_achieve_equal_in_k_moves g 43) \u2227\n    (\u2200 k : Nat, 0 < k \u2227 k < 43 \u2192 \u00accan_achieve_equal_in_k_moves g k) :=\n  sorry"}
{"id": "CombStruct4Lean_138", "informal_problem": "5. In a round-robin football tournament (where each team plays every other team once), 12 teams participated. The tournament was not yet completed by November. Could it be that one team played exactly 11 games, three teams played exactly 9 games each, two teams played exactly 6 games each, four teams played exactly 4 games each, and the remaining two teams played exactly one game each?", "formal_statement": "import Mathlib\n\nstructure TournamentState where\n  n : Nat                    -- number of teams\n  gamesPlayed : Fin n \u2192 Nat  -- number of games played by each team\n  isValid : Bool            -- whether this represents a valid partial tournament state\n  \ndef isValidTournamentState (t : TournamentState) : Prop :=\n  -- Each pair of teams contributes exactly one game to both teams' counts\n  \u2200 i j : Fin t.n, i \u2260 j \u2192 \n    (t.gamesPlayed i + t.gamesPlayed j \u2264 1)  -- teams i and j have played at most one game\n    \u2227 (\u2200 k : Fin t.n, t.gamesPlayed k \u2264 t.n - 1) -- no team plays more than n-1 games\n\ntheorem tournament_state_impossible : \u00ac \u2203 (t : TournamentState), \n  t.n = 12 \u2227 \n  isValidTournamentState t \u2227\n  (\u2203 (teams : Fin 12 \u2192 Nat),\n    -- One team played 11 games\n    (\u2203! i, t.gamesPlayed i = 11) \u2227\n    -- Three teams played 9 games each\n    (\u2203 i\u2081 i\u2082 i\u2083, i\u2081 \u2260 i\u2082 \u2227 i\u2082 \u2260 i\u2083 \u2227 i\u2081 \u2260 i\u2083 \u2227 \n      t.gamesPlayed i\u2081 = 9 \u2227 t.gamesPlayed i\u2082 = 9 \u2227 t.gamesPlayed i\u2083 = 9) \u2227\n    -- Two teams played 6 games each\n    (\u2203 i\u2081 i\u2082, i\u2081 \u2260 i\u2082 \u2227 t.gamesPlayed i\u2081 = 6 \u2227 t.gamesPlayed i\u2082 = 6) \u2227\n    -- Four teams played 4 games each\n    (\u2203 i\u2081 i\u2082 i\u2083 i\u2084, i\u2081 \u2260 i\u2082 \u2227 i\u2082 \u2260 i\u2083 \u2227 i\u2083 \u2260 i\u2084 \u2227 i\u2081 \u2260 i\u2083 \u2227 i\u2081 \u2260 i\u2084 \u2227 i\u2082 \u2260 i\u2084 \u2227\n      t.gamesPlayed i\u2081 = 4 \u2227 t.gamesPlayed i\u2082 = 4 \u2227 \n      t.gamesPlayed i\u2083 = 4 \u2227 t.gamesPlayed i\u2084 = 4) \u2227\n    -- Two teams played 1 game each\n    (\u2203 i\u2081 i\u2082, i\u2081 \u2260 i\u2082 \u2227 t.gamesPlayed i\u2081 = 1 \u2227 t.gamesPlayed i\u2082 = 1)) :=\n  sorry"}
{"id": "CombStruct4Lean_139", "informal_problem": "10.3. A group of 25 children from kindergarten returned from a walk. To dry, the children laid out all their 50 mittens in a row on the radiator. The group's teacher noticed that the mittens of each child were not next to each other. Moreover, it turned out that between the mittens of any child, there lay a prime number of mittens of other children. Prove that there will be a child whose mittens have exactly two other mittens between them.\n\n#", "formal_statement": "import Mathlib\n\nopen Nat Finset\n\ndef mittensBetween (n : \u2115) (p\u2081 p\u2082 : Fin (2 * n)) : \u2115 :=\n  Int.natAbs ((p\u2081.val : \u2124) - p\u2082.val) - 1\n\nstructure MittenArrangement (n : \u2115) where\n  positions : Fin (2 * n) \u2192 Fin n\n  h_all_present : \u2200 i : Fin n,\n    (univ.filter (\u03bb j => positions j = i)).card = 2\n  h_not_adjacent : \u2200 i j : Fin (2 * n),\n    Int.natAbs ((i.val : \u2124) - j.val) = 1 \u2192\n    positions i \u2260 positions j\n  h_prime_between : \u2200 i : Fin n,\n    \u2200 p\u2081 p\u2082 : Fin (2 * n),\n    positions p\u2081 = i \u2192\n    positions p\u2082 = i \u2192\n    p\u2081 \u2260 p\u2082 \u2192\n    Nat.Prime (mittensBetween n p\u2081 p\u2082)\n\ntheorem mitten_arrangement_has_gap_two\n  {n : \u2115} (h_n : n = 25) (arr : MittenArrangement n) :\n  \u2203 (i : Fin n) (p\u2081 p\u2082 : Fin (2 * n)),\n    arr.positions p\u2081 = i \u2227\n    arr.positions p\u2082 = i \u2227\n    p\u2081 \u2260 p\u2082 \u2227\n    mittensBetween n p\u2081 p\u2082 = 2 :=\n  sorry"}
{"id": "CombStruct4Lean_140", "informal_problem": "10.2. Pasha and Vova are playing the following game, taking turns. Pasha starts. Initially, the boys have a large piece of plasticine in front of them. On his turn, Pasha can cut any of the existing pieces of plasticine into three parts (not necessarily equal). Vova, on his turn, chooses two pieces and combines them. Pasha wins if at some point there are 100 pieces of the same mass among the existing pieces of plasticine. Can Vova prevent Pasha from winning?\n\n(J. Efremov, D. Belov)", "formal_statement": "import Mathlib\n\ninductive Player where\n  | Pasha\n  | Vova\n  deriving Repr, DecidableEq\n\nstructure GameState where\n  total_mass : \u2115\n  pieces : Multiset \u2115\n  turn : Player\n\ndef valid_state (g : GameState) : Prop :=\n  g.pieces.sum = g.total_mass \u2227\n  \u2200 p \u2208 g.pieces, p > 0\n\ninductive move_step : GameState \u2192 GameState \u2192 Prop where\n  | split {g : GameState} {orig p\u2081 p\u2082 p\u2083 : \u2115} \n      (h_turn : g.turn = Player.Pasha)\n      (h_orig : orig \u2208 g.pieces)\n      (h_pos : p\u2081 > 0 \u2227 p\u2082 > 0 \u2227 p\u2083 > 0)\n      (h_sum : p\u2081 + p\u2082 + p\u2083 = orig) :\n    move_step g \u27e8g.total_mass, g.pieces.erase orig + {p\u2081, p\u2082, p\u2083}, Player.Vova\u27e9\n  | combine {g : GameState} {p\u2081 p\u2082 : \u2115}\n      (h_turn : g.turn = Player.Vova)\n      (h_in : p\u2081 \u2208 g.pieces \u2227 p\u2082 \u2208 g.pieces)\n      (h_distinct : g.pieces.count p\u2081 + g.pieces.count p\u2082 \u2265 2) :\n    move_step g \u27e8g.total_mass, g.pieces.erase p\u2081 - {p\u2082} + {p\u2081 + p\u2082}, Player.Pasha\u27e9\n\ninductive reachable : GameState \u2192 GameState \u2192 Prop where\n  | refl : \u2200 g, reachable g g\n  | step : \u2200 g\u2081 g\u2082 g\u2083, move_step g\u2081 g\u2082 \u2192 reachable g\u2082 g\u2083 \u2192 reachable g\u2081 g\u2083\n\ndef winning_position (g : GameState) : Prop :=\n  \u2203 x, g.pieces.count x \u2265 100\n\ntheorem vova_has_winning_strategy (init : GameState) \n    (h_init : init.pieces = {init.total_mass})\n    (h_valid : valid_state init) :\n  \u00ac\u2203 final : GameState, reachable init final \u2227 winning_position final :=\n  sorry"}
{"id": "CombStruct4Lean_141", "informal_problem": "9.3. Kolya and Dima are playing a game on an $8 \\times 8$ board, taking turns, with Dima starting. Kolya draws crosses in the cells, while Dima covers pairs of adjacent cells (by sides) with $1 \\times 2$ rectangles (dominoes). On his turn, Kolya must place one cross in any empty cell (i.e., a cell that does not yet have a cross and is not covered by a domino). Dima, on his turn, must cover two adjacent cells (not yet covered by other dominoes) with a domino, where the total number of crosses in these two cells is even (0 or 2). The player who cannot make a move loses. Who has the winning strategy?\n\n(M. Diden)", "formal_statement": "import Mathlib\n\ninductive Cell\n  | empty\n  | cross\n  | domino (id : Nat)\n\nstructure CrossMove where\n  pos : Fin 8 \u00d7 Fin 8\n\nstructure DominoMove where\n  pos1 : Fin 8 \u00d7 Fin 8\n  pos2 : Fin 8 \u00d7 Fin 8\n\ninductive Move\n  | cross (m : CrossMove)\n  | domino (m : DominoMove)\n\nstructure GameState where\n  board : Matrix (Fin 8) (Fin 8) Cell\n  turn : Bool  -- true for Kolya (crosses), false for Dima (dominoes)\n  nextDominoId : Nat\n\ndef getCell (state : GameState) (pos : Fin 8 \u00d7 Fin 8) : Cell :=\n  state.board pos.1 pos.2\n\ndef isAdjacent (pos1 pos2 : Fin 8 \u00d7 Fin 8) : Bool :=\n  (pos1.1 = pos2.1 \u2227 (pos1.2.val + 1 = pos2.2.val \u2228 pos2.2.val + 1 = pos1.2.val)) \u2228\n  (pos1.2 = pos2.2 \u2227 (pos1.1.val + 1 = pos2.1.val \u2228 pos2.1.val + 1 = pos1.1.val))\n\ndef countCrosses (state : GameState) (pos1 pos2 : Fin 8 \u00d7 Fin 8) : Nat :=\n  let count (pos : Fin 8 \u00d7 Fin 8) : Nat :=\n    match getCell state pos with\n    | Cell.cross => 1\n    | _ => 0\n  count pos1 + count pos2\n\ndef isValidMove (state : GameState) (move : Move) : Prop :=\n  match move with\n  | Move.cross m =>\n      state.turn \u2227 \n      getCell state m.pos = Cell.empty\n  | Move.domino m =>\n      \u00acstate.turn \u2227\n      isAdjacent m.pos1 m.pos2 \u2227\n      getCell state m.pos1 = Cell.empty \u2227\n      getCell state m.pos2 = Cell.empty \u2227\n      countCrosses state m.pos1 m.pos2 % 2 = 0\n\ntheorem domino_cross_game_has_winner :\n  \u2203 (winner : Bool), \u2200 (state : GameState),\n    (state.turn = winner \u2192 \n      \u2203 (move : Move),\n        isValidMove state move) :=\n  sorry"}
{"id": "CombStruct4Lean_142", "informal_problem": "9.1. In the country, some pairs of cities are connected by one-way direct flights (there is no more than one flight between any two cities). We say that city $A$ is accessible from city $B$ if it is possible to fly from $B$ to $A$, possibly with layovers. It is known that for any two cities $P$ and $Q$, there exists a city $R$ such that both $P$ and $Q$ are accessible from $R$. Prove that there exists a city from which all cities in the country are accessible. (It is assumed that it is possible to fly from a city to itself.) (V. Dolnikov)", "formal_statement": "import Mathlib\n\nstructure FlightNetwork (\u03b1 : Type u) where\n  -- The directed edge relation representing direct flights between cities\n  hasDirectFlight : \u03b1 \u2192 \u03b1 \u2192 Prop\n  -- At most one direct flight between any ordered pair of cities\n  unique : \u2200 {a b : \u03b1}, hasDirectFlight a b \u2192 hasDirectFlight a b \u2192 a = b\n  -- Every city has a flight to itself (reflexivity)\n  refl : \u2200 (c : \u03b1), hasDirectFlight c c\n  -- Accessibility relation: can reach through sequence of flights\n  isAccessible : \u03b1 \u2192 \u03b1 \u2192 Prop := fun a b => \n    TC hasDirectFlight a b\n\ntheorem exists_universal_source {\u03b1 : Type u} [Nonempty \u03b1] (G : FlightNetwork \u03b1)\n  (h : \u2200 (p q : \u03b1), \u2203 (r : \u03b1), G.isAccessible r p \u2227 G.isAccessible r q) :\n  \u2203 (source : \u03b1), \u2200 (dest : \u03b1), G.isAccessible source dest :=\n  sorry"}
{"id": "CombStruct4Lean_143", "informal_problem": "5. Is it possible to color the cells of an 8 x 8 board in three colors: 21 cells in white, 21 cells in blue, 22 cells in red - so that no diagonal (not only the two main diagonals, but all those parallel to them) contains cells of all three colors simultaneously?", "formal_statement": "import Mathlib\n\n/-- Determines if a position (row,col) lies on a diagonal starting at (start_row, start_col) -/\ndef is_on_diagonal (start_row start_col row col : Fin 8) : Prop :=\n  (row.val : \u2124) - (col.val : \u2124) = (start_row.val : \u2124) - (start_col.val : \u2124)\n\n/-- Count the number of cells of a given color -/\ndef count_cells (coloring : Fin 8 \u2192 Fin 8 \u2192 Fin 3) (c : Fin 3) : \u2115 :=\n  Finset.sum (Finset.univ : Finset (Fin 8)) fun i =>\n    Finset.card (Finset.filter (fun j => coloring i j = c) Finset.univ)\n\n/-- A valid three-coloring of an 8x8 board -/\nstructure BoardColoring where\n  color : Fin 8 \u2192 Fin 8 \u2192 Fin 3\n  white_count : count_cells color 0 = 21\n  blue_count : count_cells color 1 = 21\n  red_count : count_cells color 2 = 22\n\n/-- Checks if a diagonal contains all three colors -/\ndef has_all_colors (coloring : Fin 8 \u2192 Fin 8 \u2192 Fin 3) (start_row start_col : Fin 8) : Prop :=\n  \u2203 (i\u2081 i\u2082 i\u2083 j\u2081 j\u2082 j\u2083 : Fin 8), \n    (is_on_diagonal start_row start_col i\u2081 j\u2081 \u2227 coloring i\u2081 j\u2081 = 0) \u2227\n    (is_on_diagonal start_row start_col i\u2082 j\u2082 \u2227 coloring i\u2082 j\u2082 = 1) \u2227\n    (is_on_diagonal start_row start_col i\u2083 j\u2083 \u2227 coloring i\u2083 j\u2083 = 2)\n\ntheorem three_color_board_possible : \n  \u2203 (board : BoardColoring), \n    \u2200 (start_row start_col : Fin 8), \u00ac(has_all_colors board.color start_row start_col) :=\n  sorry"}
{"id": "CombStruct4Lean_144", "informal_problem": "3. In a volleyball tournament, 6 teams participated. Prove that after one round of games (each team played with each other exactly once), there will be a team that won at least $3$ games (there are no draws in volleyball).", "formal_statement": "import Mathlib\n\nstructure VolleyballTournament where\n  n : Nat\n  -- results i j = true means i won against j\n  results : Fin n \u2192 Fin n \u2192 Bool\n  -- No team plays against itself\n  irrefl : \u2200 i, results i i = false\n  -- For each pair of teams, exactly one is the winner\n  antisymm : \u2200 i j, results i j = !(results j i)\n\ntheorem volleyball_tournament_winner (t : VolleyballTournament) (h : t.n = 6) :\n  \u2203 team : Fin t.n, (Finset.sum (Finset.univ.erase team) \n    (fun opponent => if t.results team opponent then 1 else 0)) \u2265 3 :=\n  sorry"}
{"id": "CombStruct4Lean_145", "informal_problem": "3. Can an infinite sheet of graph paper be divided into dominoes $1 \\times 2$ cells in such a way that every line running along the grid lines cuts only a finite number of dominoes in half?", "formal_statement": "import Mathlib\n\n/-- A domino is defined by its top-left corner position and orientation -/\nstructure Domino where\n  pos : \u2124 \u00d7 \u2124  -- position of the top-left corner\n  isHorizontal : Bool -- true for horizontal, false for vertical\n\n/-- The set of cells covered by a domino -/\ndef domino_cells (d : Domino) : Set (\u2124 \u00d7 \u2124) :=\n  if d.isHorizontal then \n    Set.insert d.pos (Set.singleton (d.pos.1 + 1, d.pos.2))\n  else \n    Set.insert d.pos (Set.singleton (d.pos.1, d.pos.2 + 1))\n\n/-- A grid line is either horizontal (y = k) or vertical (x = k) -/\ninductive GridLine where\n  | vertical (x : \u2124) : GridLine\n  | horizontal (y : \u2124) : GridLine\n\n/-- Determines if a grid line intersects a domino through its interior -/\ndef line_cuts_domino (l : GridLine) (d : Domino) : Prop :=\n  match l with\n  | GridLine.vertical k => \n      d.isHorizontal \u2227 d.pos.1 < k \u2227 k < d.pos.1 + 1\n  | GridLine.horizontal k => \n      \u00acd.isHorizontal \u2227 d.pos.2 < k \u2227 k < d.pos.2 + 1\n\n/-- A tiling is a collection of dominoes that covers the plane without overlaps -/\nstructure DominoTiling where\n  dominoes : Set Domino\n  covers_plane : \u2200 (x y : \u2124), \u2203 (d : Domino), d \u2208 dominoes \u2227 (x, y) \u2208 domino_cells d\n  no_overlaps : \u2200 (d\u2081 d\u2082 : Domino), d\u2081 \u2208 dominoes \u2192 d\u2082 \u2208 dominoes \u2192 d\u2081 \u2260 d\u2082 \u2192 \n                domino_cells d\u2081 \u2229 domino_cells d\u2082 = \u2205\n\n/-- The set of dominoes cut by a grid line -/\ndef cut_dominoes (t : DominoTiling) (l : GridLine) : Set Domino :=\n  { d : Domino | d \u2208 t.dominoes \u2227 line_cuts_domino l d }\n\ntheorem no_finite_cuts_tiling :\n  \u2200 (t : DominoTiling), \u2203 (l : GridLine), \u00acFinite (cut_dominoes t l) :=\n  sorry"}
{"id": "CombStruct4Lean_146", "informal_problem": "# 6. CONDITION\n\nCan 2005 non-zero vectors be drawn on a plane such that from any ten of them, three can be chosen with a zero sum?", "formal_statement": "import Mathlib\nopen EuclideanSpace\n\ndef hasZeroSumTriple (s : Finset (EuclideanSpace \u211d (Fin 2))) : Prop :=\n  \u2203 (v\u2081 v\u2082 v\u2083 : EuclideanSpace \u211d (Fin 2)), \n    v\u2081 \u2208 s \u2227 v\u2082 \u2208 s \u2227 v\u2083 \u2208 s \u2227 \n    v\u2081 \u2260 v\u2082 \u2227 v\u2082 \u2260 v\u2083 \u2227 v\u2081 \u2260 v\u2083 \u2227\n    v\u2081 + v\u2082 + v\u2083 = 0\n\ndef isNonzeroVector (v : EuclideanSpace \u211d (Fin 2)) : Prop :=\n  \u2016v\u2016 \u2260 0\n\ntheorem plane_vectors_condition :\n  \u2203 (vectors : Finset (EuclideanSpace \u211d (Fin 2))),\n    vectors.card = 2005 \u2227\n    (\u2200 v \u2208 vectors, isNonzeroVector v) \u2227\n    (\u2200 subset : Finset (EuclideanSpace \u211d (Fin 2)),\n      subset \u2286 vectors \u2192 subset.card = 10 \u2192 hasZeroSumTriple subset) :=\n  sorry"}
{"id": "CombStruct4Lean_147", "informal_problem": "Task 3. Can positive numbers (not necessarily integers) be placed in a $6 \\times 6$ table so that the product of all numbers in any row, any column, and any $2 \\times 2$ square equals two?", "formal_statement": "import Mathlib\n\nstructure Table where\n  -- entries is a 6\u00d76 matrix of positive real numbers\n  entries : Fin 6 \u2192 Fin 6 \u2192 \u211d\n  -- all entries are positive\n  all_positive : \u2200 i j, entries i j > 0\n  -- product of each row equals 2\n  row_product : \u2200 i, (\u220f j, entries i j) = 2\n  -- product of each column equals 2\n  col_product : \u2200 j, (\u220f i, entries i j) = 2\n  -- product of each 2\u00d72 square equals 2\n  square_product : \u2200 i j, i + 1 < 6 \u2192 j + 1 < 6 \u2192\n    entries i j * entries i (j+1) * entries (i+1) j * entries (i+1) (j+1) = 2\n\ntheorem table_exists : \u2203 t : Table, True :=\n  sorry"}
{"id": "CombStruct4Lean_148", "informal_problem": "4. Is it possible to arrange 10 black and several white chips in a circle such that each black chip has a diametrically opposite white chip and no two white chips are adjacent?", "formal_statement": "import Mathlib\n\nstructure ChipArrangement where\n  n : Nat                     -- Total number of positions (diameter)\n  black_positions : Finset Nat -- Positions of black chips\n  white_positions : Finset Nat -- Positions of white chips\n  valid_positions : black_positions \u222a white_positions \u2286 Finset.range n\n  no_overlap : black_positions \u2229 white_positions = \u2205\n  black_count : black_positions.card = 10\n  opposite_exists : \u2200 p \u2208 black_positions, \n    ((p + n/2) % n) \u2208 white_positions\n  no_adjacent_whites : \u2200 p \u2208 white_positions, \n    ((p + 1) % n) \u2209 white_positions\n\ntheorem circle_arrangement_exists : \u2203 (arr : ChipArrangement), True :=\n  sorry"}
{"id": "CombStruct4Lean_149", "informal_problem": "6.2. The sixth-grade students went to a party. Each boy had 5 balloons, and each girl had 4 balloons. On the way, the children started to play and pop each other's balloons. (Of course, they did not pop their own balloons.) In the end, each girl popped exactly one balloon, and each boy popped exactly two balloons. Dima counted all the surviving balloons and got 100. Prove that Dima was wrong.", "formal_statement": "import Mathlib\n\nstructure PartySetup where\n  boys : Nat      -- number of boys\n  girls : Nat     -- number of girls\n  \ndef initial_balloons (p : PartySetup) : Nat :=\n  5 * p.boys + 4 * p.girls\n\ndef popped_balloons (p : PartySetup) : Nat :=\n  2 * p.boys + p.girls\n\ndef surviving_balloons (p : PartySetup) : Nat :=\n  initial_balloons p - popped_balloons p\n\ntheorem party_balloon_count_impossible :\n  \u00ac\u2203 (p : PartySetup), surviving_balloons p = 100 :=\n  sorry"}
{"id": "CombStruct4Lean_150", "informal_problem": "11.2. In each cell of a $1001 \\times 1001$ table, a 0 or 1 was placed. It turned out that in any column, there are more zeros than ones. Is it necessarily true that there will be two columns such that the number of rows where the intersections with these two columns contain only zeros is greater than the number of rows where the intersections with these two columns contain only ones?\n\n(I. Bogdanov)", "formal_statement": "import Mathlib\n\nstructure BinaryTable where\n  size : Nat\n  entries : Fin size \u2192 Fin size \u2192 Bool  -- True represents 1, False represents 0\n  more_zeros_in_columns : \u2200 j, \n    (Finset.filter (fun i \u21a6 !entries i j) (Finset.univ : Finset (Fin size))).card > \n    (Finset.filter (fun i \u21a6 entries i j) (Finset.univ : Finset (Fin size))).card\n\ntheorem two_columns_more_zeros (t : BinaryTable) (h : t.size = 1001) :\n  \u2203 j\u2081 j\u2082, j\u2081 \u2260 j\u2082 \u2227 \n    (Finset.filter (fun i \u21a6 !t.entries i j\u2081 \u2227 !t.entries i j\u2082) (Finset.univ : Finset (Fin t.size))).card >\n    (Finset.filter (fun i \u21a6 t.entries i j\u2081 \u2227 t.entries i j\u2082) (Finset.univ : Finset (Fin t.size))).card :=\n  sorry"}
{"id": "CombStruct4Lean_151", "informal_problem": "2. Numbers from 1 to 8 were arranged in some order in a circle, and then the sums of adjacent numbers were recorded. Could it be that 8 consecutive numbers (in some order) were obtained?", "formal_statement": "import Mathlib\n\nstructure CircularArrangement where\n  -- The arrangement of numbers from 1 to 8 in a circle\n  nums : Fin 8 \u2192 Fin 8\n  -- Ensure it's a permutation (bijective)\n  is_perm : Function.Bijective nums\n\n-- Function to get the sum of adjacent numbers at position i\ndef adjacent_sums (arr : CircularArrangement) (i : Fin 8) : Nat :=\n  -- Convert Fin 8 values to Nat and add 1 since we want numbers 1-8\n  (arr.nums i).val + 1 + (arr.nums ((i.val + 1) % 8)).val + 1\n\ntheorem no_consecutive_sums (arr : CircularArrangement) :\n  \u00ac\u2203 (start : Nat), \u2200 (i : Fin 8),\n    (adjacent_sums arr i) = start + i.val :=\n  sorry"}
{"id": "CombStruct4Lean_152", "informal_problem": "11.5. Can one choose a number $n \\geqslant 3$ and fill an $n \\times (n+3)$ table (with $n$ rows and $n+3$ columns) with distinct natural numbers from 1 to $n(n+3)$ in such a way that in each row there are three numbers, one of which is the product of the other two?", "formal_statement": "import Mathlib\n\nstructure TableFilling (n : Nat) where\n  -- The table entries as a function from row and column indices\n  entries : Fin n \u2192 Fin (n + 3) \u2192 Nat\n  -- All entries are distinct and between 1 and n(n+3)\n  distinct : \u2200 i j i' j', entries i j = entries i' j' \u2192 i = i' \u2227 j = j'\n  valid_range : \u2200 i j, 1 \u2264 entries i j \u2227 entries i j \u2264 n * (n + 3)\n  -- In each row, there exist three positions where one number is product of other two\n  product_property : \u2200 i, \u2203 j\u2081 j\u2082 j\u2083, \n    j\u2081 \u2260 j\u2082 \u2227 j\u2081 \u2260 j\u2083 \u2227 j\u2082 \u2260 j\u2083 \u2227 \n    entries i j\u2081 = entries i j\u2082 * entries i j\u2083\n\ntheorem no_valid_filling (n : Nat) (h : n \u2265 3) : \n  \u00ac\u2203 (filling : TableFilling n), True :=\n  sorry"}
{"id": "CombStruct4Lean_153", "informal_problem": "5. In an internet community of 20 participants, there are friends. Any two participants A and B are either friends themselves or there exists a chain\n\n$\\mathrm{A}-\\mathrm{C}_{1}-\\ldots-\\mathrm{C}_{\\mathrm{k}}-\\mathrm{B}$\n\nwhere adjacent participants in the chain are friends, that is, $\\mathrm{C}_{1}$ is a friend of $\\mathrm{A}, \\mathrm{C}_{2}$ is a friend of $\\mathrm{C}_{1}, \\ldots$ and B is a friend of $\\mathrm{C}_{\\mathrm{k}}$. Prove that it is possible to select 6 participants from the community such that any of the remaining fourteen is either a friend or a friend of a friend of someone among these six.", "formal_statement": "import Mathlib\nopen SimpleGraph\n\nstructure Community where\n  friendship : SimpleGraph (Fin 20)\n  connected : friendship.Connected\n\n/-- A participant is reachable in two steps from a set if they are either:\n    1. In the set\n    2. A direct neighbor of someone in the set\n    3. A neighbor of a neighbor of someone in the set -/\ndef twoStepReachable (c : Community) (selected : Finset (Fin 20)) (p : Fin 20) : Prop :=\n  p \u2208 selected \u2228 \n  (\u2203 s \u2208 selected, c.friendship.Adj s p) \u2228\n  (\u2203 s \u2208 selected, \u2203 f, c.friendship.Adj s f \u2227 c.friendship.Adj f p)\n\ntheorem community_selection_exists (c : Community) :\n  \u2203 selected : Finset (Fin 20),\n    selected.card = 6 \u2227 \n    \u2200 p : Fin 20, twoStepReachable c selected p :=\n  sorry"}
{"id": "CombStruct4Lean_154", "informal_problem": "4. In a $25 \\times 25$ table, integers from 1 to 25 are arranged, and in each row, the entire set of numbers appears. The table is symmetric with respect to the diagonal running from the top left to the bottom right. Prove that on this diagonal, all numbers from 1 to 25 also appear.", "formal_statement": "import Mathlib\n\nstructure SymmetricTable where\n  n : Nat\n  entries : Fin n \u2192 Fin n \u2192 Fin n\n  all_rows_complete : \u2200 i : Fin n, Function.Surjective (entries i)\n  symmetric : \u2200 (i j : Fin n), entries i j = entries j i\n\ntheorem diagonal_complete {t : SymmetricTable} (h : t.n = 25) :\n  Function.Surjective (fun i => t.entries i i) :=\n  sorry"}
{"id": "CombStruct4Lean_155", "informal_problem": "10.2. In a chess tournament, each of the 10 players played one game against each other, and Petya came in last place (scored fewer points than any other participant). Then one player was disqualified, and all points earned in matches against him were annulled, and this player was removed from the table. Could Petya have become the winner of the tournament (scored more points than any other participant) as a result?", "formal_statement": "import Mathlib\n\nstructure ChessTournament where\n  n : Nat                                    -- number of players\n  scores : Fin n \u2192 Nat                       -- scores of each player\n  disqualified : Fin n                       -- the player who got disqualified\n  original_scores : Fin n \u2192 Nat              -- scores before disqualification\n  petya : Fin n                              -- Petya's player number\n  h_petya_last : \u2200 i : Fin n, i \u2260 petya \u2192 original_scores petya < original_scores i\n  h_scores_valid : \u2200 i : Fin n, scores i = if i = disqualified then 0 \n    else original_scores i - (if original_scores i > original_scores disqualified then 1 else 0)\n\ntheorem chess_tournament_petya_winner \n  : \u2203 (t : ChessTournament), t.n = 10 \u2227 \n    (\u2200 i : Fin t.n, i \u2260 t.petya \u2192 i \u2260 t.disqualified \u2192 t.scores t.petya > t.scores i) :=\n  sorry"}
{"id": "CombStruct4Lean_156", "informal_problem": "11.5. Natural numbers from 1 to 9 are colored in two colors. Prove that there will be three different numbers of the same color forming an arithmetic progression.", "formal_statement": "import Mathlib\n\ndef isArithmeticProgression (a b c : \u2115) : Prop :=\n  b - a = c - b\n\ndef hasMonochromaticAP (coloring : \u2115 \u2192 Bool) : Prop :=\n  \u2203 (a b c : \u2115), \n    1 \u2264 a \u2227 a < b \u2227 b < c \u2227 c \u2264 9 \u2227\n    isArithmeticProgression a b c \u2227\n    coloring a = coloring b \u2227 coloring b = coloring c\n\ntheorem monochromatic_AP_exists : \n  \u2200 (coloring : \u2115 \u2192 Bool), hasMonochromaticAP coloring :=\n  sorry"}
{"id": "CombStruct4Lean_157", "informal_problem": "10.5. In a tournament, 50 chess players participated. At a certain point in the tournament, 61 games had been played, with each participant having played either two games or three (and no one played the same opponent twice). Could it have been the case that no two players who played three games each played against each other?", "formal_statement": "import Mathlib\n\nstructure ChessTournament where\n  n : Nat                             -- number of players\n  games_played : Nat                  -- total number of games played\n  played_games : Fin n \u2192 Nat          -- number of games each player played\n  opponents : Fin n \u2192 Fin n \u2192 Bool    -- adjacency matrix of who played whom\n\n  player_games : \u2200 i, played_games i = 2 \u2228 played_games i = 3  -- each player played 2 or 3 games\n  no_self_games : \u2200 i, \u00acopponents i i                         -- no self-games\n  symmetric : \u2200 i j, opponents i j = opponents j i            -- symmetry of games\n  count_correct : games_played = (\u2211 i, played_games i) / 2    -- total games count matches\n  no_repeats : \u2200 i j, opponents i j \u2192 (\u2200 k, opponents i k \u2192 k = j) -- no repeated games\n\ntheorem chess_tournament_possible (n : Nat) (h : n = 50) (games : Nat) (h2 : games = 61) :\n  \u00ac\u2203 (t : ChessTournament), \n    t.n = n \u2227 \n    t.games_played = games \u2227 \n    (\u2200 i j, t.played_games i = 3 \u2192 t.played_games j = 3 \u2192 \u00act.opponents i j) :=\n  sorry"}
{"id": "CombStruct4Lean_158", "informal_problem": "11.1. Can a rectangle, each side of which is greater than 1, be formed from all rectangles of sizes $1 \\times 1, 1 \\times 3, 1 \\times 5, \\ldots, 1 \\times 2019$, taken exactly once?", "formal_statement": "import Mathlib\n\n-- Define a list of rectangles with dimensions 1 \u00d7 (2k-1) for k from 1 to 1010\ndef rectanglesList : List (Nat \u00d7 Nat) :=\n  List.map (fun k => (1, 2 * k - 1)) (List.range 1010)\n\n-- A function to check if a list of rectangles can form a larger rectangle\ndef canFormRectangle (rectangles : List (Nat \u00d7 Nat)) : Prop :=\n  \u2203 (W H : Nat), \n    W > 1 \u2227 H > 1 \u2227  -- The resulting rectangle should have sides > 1\n    W * H = (rectangles.map (fun r => r.1 * r.2)).sum  -- Total area should match\n\ntheorem rectangle_formation_impossible : \n  \u00ac(canFormRectangle rectanglesList) :=\n  sorry"}
{"id": "CombStruct4Lean_159", "informal_problem": "11.8. Petya placed several chips on a $50 \\times 50$ board, with no more than one chip in each cell. Prove that Vasya can place no more than 99 new chips (possibly none) on the free cells of the same board so that there is still no more than one chip in each cell, and each row and each column of the board has an even number of chips.\n\n(S. Berlov)", "formal_statement": "import Mathlib\n\ndef count_row (n : Nat) (i : Fin n) (initial added : Fin n \u00d7 Fin n \u2192 Bool) : Nat :=\n  Finset.card (Finset.filter (fun j => initial (i, j) \u2228 added (i, j)) (Finset.univ : Finset (Fin n)))\n\ndef count_col (n : Nat) (j : Fin n) (initial added : Fin n \u00d7 Fin n \u2192 Bool) : Nat :=\n  Finset.card (Finset.filter (fun i => initial (i, j) \u2228 added (i, j)) (Finset.univ : Finset (Fin n)))\n\ndef count_total (n : Nat) (added : Fin n \u00d7 Fin n \u2192 Bool) : Nat :=\n  Finset.card (Finset.filter (fun p => added p) (Finset.univ : Finset (Fin n \u00d7 Fin n)))\n\ntheorem chip_placement_bound {n : Nat} (h : n = 50) (initial : Fin n \u00d7 Fin n \u2192 Bool) :\n  \u2203 (added : Fin n \u00d7 Fin n \u2192 Bool),\n    (\u2200 i j : Fin n, \u00ac(initial (i, j) \u2227 added (i, j))) \u2227 \n    (\u2200 i : Fin n, Even (count_row n i initial added)) \u2227\n    (\u2200 j : Fin n, Even (count_col n j initial added)) \u2227\n    count_total n added \u2264 99 :=\n  sorry"}
{"id": "CombStruct4Lean_160", "informal_problem": "5. On the coordinate plane, 2017 points with integer coordinates $(x, y)$ were marked arbitrarily, where $1 \\leq x \\leq 2016$ and $1 \\leq y \\leq 2016$. Prove that there will always be two different segments with endpoints among these points, having the same length.", "formal_statement": "import Mathlib\n\nstructure Point where\n  x : Int\n  y : Int\n  x_bound : 1 \u2264 x \u2227 x \u2264 2016\n  y_bound : 1 \u2264 y \u2227 y \u2264 2016\n\ndef distance_squared (p\u2081 p\u2082 : Point) : Int :=\n  (p\u2081.x - p\u2082.x)^2 + (p\u2081.y - p\u2082.y)^2\n\nstructure Segment where\n  p\u2081 : Point\n  p\u2082 : Point\n  distinct : p\u2081 \u2260 p\u2082\n\ntheorem equal_length_segments_exist (points : Finset Point) \n    (h_size : points.card = 2017)\n    (h_valid : \u2200 p \u2208 points, 1 \u2264 p.x \u2227 p.x \u2264 2016 \u2227 1 \u2264 p.y \u2227 p.y \u2264 2016) :\n    \u2203 (s\u2081 s\u2082 : Segment),\n      s\u2081.p\u2081 \u2208 points \u2227 s\u2081.p\u2082 \u2208 points \u2227\n      s\u2082.p\u2081 \u2208 points \u2227 s\u2082.p\u2082 \u2208 points \u2227\n      s\u2081 \u2260 s\u2082 \u2227\n      distance_squared s\u2081.p\u2081 s\u2081.p\u2082 = distance_squared s\u2082.p\u2081 s\u2082.p\u2082 :=\n  sorry"}
{"id": "CombStruct4Lean_161", "informal_problem": "5. Given $n+1$ pairwise distinct natural numbers, all less than $2n$ ($n>1$). Prove that among them, there exist three numbers such that the sum of two of them equals the third.", "formal_statement": "import Mathlib\n\nstructure NumberSet (n : \u2115) where\n  elements : Finset \u2115\n  size : elements.card = n + 1\n  distinct : elements.card = elements.toSet.toFinset.card\n  bound : \u2200 x \u2208 elements, x < 2 * n\n\ntheorem exists_sum_equals_third {n : \u2115} (h : n > 1) (S : NumberSet n) :\n  \u2203 (a b c : \u2115), a \u2208 S.elements \u2227 b \u2208 S.elements \u2227 c \u2208 S.elements \u2227\n    a \u2260 b \u2227 b \u2260 c \u2227 a \u2260 c \u2227 a + b = c :=\n  sorry"}
{"id": "CombStruct4Lean_162", "informal_problem": "# Problem 11.2\n\nIn each cell of a $2021 \\cdot 2021$ square table, one of the numbers 1 or -1 is written arbitrarily. Below each column, the product of all numbers in that column is written. To the right of each row, the product of all numbers in that row is written. Prove that the sum of the 4042 written products cannot be zero.\n\n## Number of points 7", "formal_statement": "import Mathlib\n\nstructure SignedTable where\n  size : Nat\n  entries : Fin size \u2192 Fin size \u2192 Int\n  -- Constraint that entries are only 1 or -1\n  entries_valid : \u2200 (i j : Fin size), entries i j = 1 \u2228 entries i j = -1\n\ndef rowProduct (t : SignedTable) (i : Fin t.size) : Int :=\n  (Finset.univ.prod fun j => t.entries i j)\n\ndef colProduct (t : SignedTable) (j : Fin t.size) : Int :=\n  (Finset.univ.prod fun i => t.entries i j)\n\ndef sumOfProducts (t : SignedTable) : Int :=\n  (Finset.univ.sum fun i => rowProduct t i) + \n  (Finset.univ.sum fun j => colProduct t j)\n\ntheorem table_products_nonzero : \n  \u2200 (t : SignedTable), t.size = 2021 \u2192 sumOfProducts t \u2260 0 :=\n  sorry"}
{"id": "CombStruct4Lean_163", "informal_problem": "8.4. In the cells of a $15 \\times 15$ table, the numbers $1, 2, \\ldots, 15$ are written. In each row and each column, each of these numbers appears exactly once. In cells symmetric with respect to the main diagonal of the table (running from the top left to the bottom right), the same numbers are written. Prove that all numbers are represented on the main diagonal.", "formal_statement": "import Mathlib\n\nstructure SymmetricLatinSquare (n : Nat) where\n  -- The table is represented as a function from pairs of indices to numbers\n  table : Fin n \u2192 Fin n \u2192 Fin n\n  -- Each row contains each number exactly once\n  row_latin : \u2200 i k : Fin n, \u2203! j : Fin n, table i j = k\n  -- Each column contains each number exactly once\n  col_latin : \u2200 j k : Fin n, \u2203! i : Fin n, table i j = k\n  -- Symmetry across main diagonal\n  symmetric : \u2200 i j : Fin n, table i j = table j i\n\ntheorem symmetric_latin_square_diagonal_complete :\n  \u2200 (s : SymmetricLatinSquare 15),\n  \u2200 k : Fin 15, \u2203 i : Fin 15, s.table i i = k :=\n  sorry"}
{"id": "CombStruct4Lean_164", "informal_problem": "5. In the cells of a table with 10 rows and 10 columns, the numbers +1 and -1 are placed. The products of the numbers in each column and each row are taken. Prove that the sum of these 20 products cannot be equal to two.\n\n#", "formal_statement": "import Mathlib\n\nstructure Grid where\n  values : Matrix (Fin 10) (Fin 10) Int\n  valid  : \u2200 i j, values i j = 1 \u2228 values i j = -1\n\ndef rowProduct (g : Grid) (i : Fin 10) : Int :=\n  Finset.univ.prod (fun j => g.values i j)\n\ndef colProduct (g : Grid) (j : Fin 10) : Int :=\n  Finset.univ.prod (fun i => g.values i j)\n\ndef totalProductSum (g : Grid) : Int :=\n  Finset.univ.sum (fun i => rowProduct g i) +\n  Finset.univ.sum (fun j => colProduct g j)\n\ntheorem grid_products_not_two (g : Grid) : \n  totalProductSum g \u2260 2 :=\n  sorry"}
{"id": "CombStruct4Lean_165", "informal_problem": "3. A hexagon is formed from 3 yellow and 3 blue sticks, such that the colors of the sticks alternate along its perimeter. From any three consecutive sticks, a triangle can be formed. Prove that a triangle can also be formed from the sticks of one of the colors.", "formal_statement": "import Mathlib\n\ninductive StickColor\n| yellow\n| blue\nderiving Repr, DecidableEq\n\nstructure ColoredStick where\n  length : \u211d\n  length_pos : length > 0\n  color : StickColor\n\ndef forms_triangle (s\u2081 s\u2082 s\u2083 : \u211d) : Prop :=\n  s\u2081 + s\u2082 > s\u2083 \u2227 s\u2082 + s\u2083 > s\u2081 \u2227 s\u2083 + s\u2081 > s\u2082\n\nstructure AlternatingHexagon where\n  sticks : Fin 6 \u2192 ColoredStick\n  lengths_pos : \u2200 i, (sticks i).length > 0\n  alternating : \u2200 i : Fin 6, \n    (sticks i).color = if i.val % 2 = 0 then StickColor.yellow else StickColor.blue\n  consecutive_triangle : \u2200 i : Fin 6, \n    forms_triangle \n      (sticks i).length\n      (sticks \u27e8(i.val + 1) % 6, by exact Nat.mod_lt _ (by norm_num)\u27e9).length\n      (sticks \u27e8(i.val + 2) % 6, by exact Nat.mod_lt _ (by norm_num)\u27e9).length\n\ntheorem monochromatic_triangle_exists (h : AlternatingHexagon) :\n  \u2203 (s\u2081 s\u2082 s\u2083 : ColoredStick),\n    s\u2081 \u2208 Set.range h.sticks \u2227\n    s\u2082 \u2208 Set.range h.sticks \u2227\n    s\u2083 \u2208 Set.range h.sticks \u2227\n    s\u2081.color = s\u2082.color \u2227\n    s\u2082.color = s\u2083.color \u2227\n    forms_triangle s\u2081.length s\u2082.length s\u2083.length :=\n  sorry"}
{"id": "CombStruct4Lean_166", "informal_problem": "11.2. Each of 100 schoolchildren has a stack of 101 cards numbered from 0 to 100. The first schoolchild shuffles the stack, then takes one card from the top of the resulting stack, and each time a card is taken (including the first time), writes on the board the arithmetic mean of the numbers on all the cards taken by him at that moment. Thus, he writes down 100 numbers, and when only one card is left in the stack, he returns the cards to the stack, and the next schoolchild, starting with shuffling the stack, does the same, then the third, and so on. Prove that among the 10000 numbers written on the board, there will be two identical numbers.\n\n(A. Gribalko)", "formal_statement": "import Mathlib\n\n/-- Number of cards (0 to 100 inclusive) -/\ndef NUM_CARDS : Nat := 101\n/-- Number of students -/\ndef NUM_STUDENTS : Nat := 100\n\n/-- A stack of cards with values 0 to 100 -/\nstructure CardStack where\n  cards : Fin NUM_CARDS \u2192 Nat\n  valid : \u2200 i, cards i \u2264 100\n  perm : Function.Bijective cards\n\n/-- Sequence of draws for one student, tracking running sum for mean calculation -/\nstructure StudentDraws where\n  draws : Vector Nat 100  -- exactly 100 draws\n  from_valid_stack : \u2200 i, draws.get i \u2264 100\n  all_different : \u2200 i j, i \u2260 j \u2192 draws.get i \u2260 draws.get j\n  running_means : Vector \u211a 100  -- means after each draw\n  means_valid : \u2200 k, running_means.get k = \n    ((draws.toList.take (k+1)).sum : \u211a) / (k+1)\n\ntheorem means_have_duplicate :\n  \u2200 (draws : Fin NUM_STUDENTS \u2192 StudentDraws),\n  \u2203 (i j : Fin NUM_STUDENTS) (k l : Fin 100),\n    (i \u2260 j \u2228 k \u2260 l) \u2227 \n    (draws i).running_means.get k = (draws j).running_means.get l :=\n  sorry"}
{"id": "CombStruct4Lean_167", "informal_problem": "2. Given a $6 \\times 3$ table. Each cell is filled with a number 0 or 1. If at the intersection of any two rows and any two columns all four numbers are the same, then the table is considered to be filled unsuccessfully. Is it possible to fill the table in such a way to avoid this phenomenon?", "formal_statement": "import Mathlib\n\ndef Table := Fin 6 \u2192 Fin 3 \u2192 Bool\n\ndef is_successful_filling (t : Table) : Prop :=\n  \u2200 (r\u2081 r\u2082 : Fin 6) (c\u2081 c\u2082 : Fin 3),\n    r\u2081 \u2260 r\u2082 \u2192 c\u2081 \u2260 c\u2082 \u2192\n    \u00ac(t r\u2081 c\u2081 = t r\u2081 c\u2082 \u2227 \n      t r\u2081 c\u2081 = t r\u2082 c\u2081 \u2227 \n      t r\u2081 c\u2081 = t r\u2082 c\u2082)\n\ntheorem exists_successful_filling : \n  \u2203 (t : Table), is_successful_filling t :=\n  sorry"}
{"id": "CombStruct4Lean_168", "informal_problem": "5. Can a $5 \\times 5$ square be cut into two types of rectangles: $1 \\times 4$ and $1 \\times 3$, so that exactly 8 rectangles are obtained?\n\n7 points are awarded for a complete solution to each problem\n\nThe maximum total score is 35", "formal_statement": "import Mathlib\n\n-- Define valid rectangle types\ninductive RectType where\n  | long  : RectType  -- 1\u00d74 rectangle\n  | short : RectType  -- 1\u00d73 rectangle\n\nstructure PlacedRectangle where\n  rect_type : RectType\n  pos_x : Fin 5\n  pos_y : Fin 5\n  is_valid : pos_y.val + (match rect_type with \n    | RectType.long => 4 \n    | RectType.short => 3) \u2264 5\n\ndef PlacedRectangle.height (r : PlacedRectangle) : Nat :=\n  match r.rect_type with\n  | RectType.long  => 4\n  | RectType.short => 3\n\ndef PlacedRectangle.covers (r : PlacedRectangle) (x y : Fin 5) : Prop :=\n  x = r.pos_x \u2227 \n  y.val \u2265 r.pos_y.val \u2227 \n  y.val < r.pos_y.val + r.height\n\nstructure RectangleTiling where\n  pieces : List PlacedRectangle\n  piece_count : pieces.length = 8\n  covers_all : \u2200 x y : Fin 5, \u2203 p, p \u2208 pieces \u2227 p.covers x y\n  no_overlap : \u2200 p\u2081 p\u2082, p\u2081 \u2208 pieces \u2192 p\u2082 \u2208 pieces \u2192 p\u2081 \u2260 p\u2082 \u2192 \n    \u2200 x y : Fin 5, \u00ac(p\u2081.covers x y \u2227 p\u2082.covers x y)\n\ntheorem five_by_five_tiling_exists : \u2203 t : RectangleTiling, t.pieces \u2260 [] :=\n  sorry"}
{"id": "CombStruct4Lean_169", "informal_problem": "4. The King of Beasts, the Lion, announced a volleyball tournament. Several volleyball teams consisting of different animals have gathered. In the tournament, each team plays against each other. Prove that after each game, there will be two teams that have played the same number of matches by this point.", "formal_statement": "import Mathlib\n\nstructure Tournament where\n  teams : Nat              -- number of teams\n  matches_played : Nat \u2192 Nat   -- function mapping team index to number of matches played\n  h_valid_matches : \u2200 t, matches_played t \u2264 (teams - 1)  -- max matches per team is (teams-1)\n  h_teams_positive : teams > 0\n\ntheorem pigeonhole_volleyball {n : Nat} (t : Tournament) (h : t.teams = n) (h_teams : n > 1) :\n  \u2203 i j, i < t.teams \u2227 j < t.teams \u2227 i \u2260 j \u2227 t.matches_played i = t.matches_played j :=\n  sorry"}
{"id": "CombStruct4Lean_170", "informal_problem": "3. At the Olympiad, 64 participants arrived. It turned out that each of them had no more than 8 acquaintances among the participants. Prove that there will be 8 participants who are pairwise unfamiliar with each other.", "formal_statement": "import Mathlib\n\nstructure OlympiadParticipants where\n  n : Nat\n  knows : Fin n \u2192 Fin n \u2192 Prop\n  [decKnows : DecidableRel knows]\n  h_size : n \u2265 64\n  knows_symm : \u2200 i j, knows i j \u2194 knows j i\n  knows_irrefl : \u2200 i, \u00acknows i i\n  max_acquaintances : \u2200 i, (Finset.filter (fun j => knows i j) Finset.univ).card \u2264 8\n\ntheorem olympiad_independent_set (p : OlympiadParticipants) (h : p.n = 64) :\n  \u2203 S : Finset (Fin p.n), S.card = 8 \u2227 \n    \u2200 (i j : Fin p.n), i \u2208 S \u2192 j \u2208 S \u2192 i \u2260 j \u2192 \u00acp.knows i j :=\n  sorry"}
{"id": "CombStruct4Lean_171", "informal_problem": "7.5. At the vertices of a cube, 8 numbers: $1, 2, \\ldots, 8$ were arranged in some order, and then for each of the 12 edges of the cube, the sum of the two numbers at its ends was calculated. Prove that among these sums there are coinciding ones.", "formal_statement": "import Mathlib\n\n/-- The fixed set of edges in a cube, represented as pairs of vertices -/\ndef cubeEdges : List (Fin 8 \u00d7 Fin 8) := [\n  (0, 1), (1, 2), (2, 3), (3, 0),  -- front face\n  (4, 5), (5, 6), (6, 7), (7, 4),  -- back face\n  (0, 4), (1, 5), (2, 6), (3, 7)   -- connecting edges\n]\n\n/-- A valid labeling of cube vertices with numbers 1 through 8 -/\nstructure CubeLabeling where\n  label : Fin 8 \u2192 Nat\n  valid : \u2200 i, 1 \u2264 label i \u2227 label i \u2264 8\n  distinct : \u2200 i j, i \u2260 j \u2192 label i \u2260 label j\n\n/-- Computes the sum of labels at the endpoints of an edge -/\ndef edgeSum (l : CubeLabeling) (e : Fin 8 \u00d7 Fin 8) : Nat :=\n  l.label e.1 + l.label e.2\n\ntheorem cube_edge_sums_not_distinct (l : CubeLabeling) :\n  \u2203 (e\u2081 e\u2082 : Fin 8 \u00d7 Fin 8), \n    e\u2081 \u2208 cubeEdges \u2227 \n    e\u2082 \u2208 cubeEdges \u2227 \n    e\u2081 \u2260 e\u2082 \u2227\n    edgeSum l e\u2081 = edgeSum l e\u2082 :=\n  sorry"}
{"id": "CombStruct4Lean_172", "informal_problem": "4. All cells of an infinite grid plane are squares with a side length of 1. Each node of this grid is painted in one of two colors, and there is a node of each color. Prove that there will be two nodes of different colors, the distance between which is 5.", "formal_statement": "import Mathlib\n\n-- A point in the infinite grid is represented by integer coordinates\nstructure GridPoint where\n  x : Int\n  y : Int\n  deriving Repr\n\n-- Basic operations for GridPoint\ndef GridPoint.add (p\u2081 p\u2082 : GridPoint) : GridPoint :=\n  \u27e8p\u2081.x + p\u2082.x, p\u2081.y + p\u2082.y\u27e9\n\ndef GridPoint.sub (p\u2081 p\u2082 : GridPoint) : GridPoint :=\n  \u27e8p\u2081.x - p\u2082.x, p\u2081.y - p\u2082.y\u27e9\n\n-- A coloring of the grid assigns a boolean value to each point\n-- true and false represent the two colors\ndef GridColoring := GridPoint \u2192 Bool\n\n-- Squared distance between two grid points (returns Int)\ndef gridDistanceSquared (p\u2081 p\u2082 : GridPoint) : Int :=\n  let diff := p\u2081.sub p\u2082\n  diff.x * diff.x + diff.y * diff.y\n\ntheorem exists_distance_five_diff_colors \n  (c : GridColoring)\n  (h\u2081 : \u2203 p\u2081, c p\u2081 = true)\n  (h\u2082 : \u2203 p\u2082, c p\u2082 = false) :\n  \u2203 (p\u2081 p\u2082 : GridPoint), \n    c p\u2081 \u2260 c p\u2082 \u2227 \n    gridDistanceSquared p\u2081 p\u2082 = 25 :=\n  sorry"}
{"id": "CombStruct4Lean_173", "informal_problem": "10.4. A cube of size $5 \\times 5 \\times 5$ cells is divided into $1 \\times 1 \\times 1$ cubes, each of which contains a grasshopper. At some moment, each grasshopper moves to an adjacent cube (up, down, left, or right, provided that the cube exists). Will there be a cube that does not contain any grasshopper?", "formal_statement": "import Mathlib\n\n/-- Position in a 5\u00d75\u00d75 cube using zero-based indices -/\nstructure Position where\n  x : Fin 5\n  y : Fin 5\n  z : Fin 5\n\n/-- Checks if two positions are adjacent in the cube -/\ndef isAdjacent (p\u2081 p\u2082 : Position) : Bool :=\n  let dx := (p\u2081.x.val : \u2124) - (p\u2082.x.val : \u2124)\n  let dy := (p\u2081.y.val : \u2124) - (p\u2082.y.val : \u2124)\n  let dz := (p\u2081.z.val : \u2124) - (p\u2082.z.val : \u2124)\n  abs dx + abs dy + abs dz = 1\n\n/-- Represents the movement of all grasshoppers in one step -/\nstructure MovementConfig where\n  final_position : Position \u2192 Position  -- Where each grasshopper moves to\n  moves_adjacent : \u2200 p : Position, isAdjacent p (final_position p) = true\n\n/-- After all grasshoppers move to adjacent positions, there must be at least one empty position -/\ntheorem grasshopper_movement_theorem :\n  \u2200 (config : MovementConfig), \u2203 (p : Position), \n    (\u2200 q : Position, config.final_position q \u2260 p) :=\n  sorry"}
{"id": "CombStruct4Lean_174", "informal_problem": "5. There are 12 positive real numbers. It is known that the ratio of any two numbers from this set does not exceed the number 2. Prove that they can be divided into six pairs such that if the sums of the numbers in each pair are calculated, the ratio of any two of the resulting six sums will not exceed $\\frac{3}{2}$.", "formal_statement": "import Mathlib\n\nstructure NumberPairing where\n  numbers : Fin 12 \u2192 \u211d\n  all_positive : \u2200 i, numbers i > 0\n  ratio_bound : \u2200 i j, numbers i / numbers j \u2264 2\n\ndef pair_sum (p : NumberPairing) (pair : Fin 6) (pairing : Fin 6 \u2192 Fin 12 \u00d7 Fin 12) : \u211d :=\n  p.numbers (pairing pair).1 + p.numbers (pairing pair).2\n\ntheorem exists_bounded_pair_sums (p : NumberPairing) :\n  \u2203 (pairing : Fin 6 \u2192 Fin 12 \u00d7 Fin 12),\n    -- Each number appears exactly once in a pair\n    (\u2200 i : Fin 12, \u2203! j : Fin 6, (pairing j).1 = i \u2228 (pairing j).2 = i) \u2227\n    -- The ratio of any two pair sums does not exceed 3/2\n    (\u2200 i j : Fin 6, pair_sum p i pairing / pair_sum p j pairing \u2264 3/2) :=\n  sorry"}
{"id": "CombStruct4Lean_175", "informal_problem": "3. In the chess tournament for the cup of the city of Krasnoyarsk, boys and girls from schools in the city participated. Each player played one game with each other, 1 point was awarded for a win, 0.5 for a draw, and 0 for a loss. At the end of the tournament, it turned out that each participant scored exactly half of their points in games against boys. Prove that the number of participants in the tournament is a square of an integer.", "formal_statement": "import Mathlib\n\nstructure ChessTournament where\n  n : Nat                     -- total number of participants\n  boys : Finset (Fin n)      -- set of boys\n  girls : Finset (Fin n)     -- set of girls\n  scores : Fin n \u2192 Rat       -- scores of each player\n  results : Fin n \u2192 Fin n \u2192 Rat  -- game results between players (1, 0.5, or 0)\n  \n  boys_girls_partition : boys \u222a girls = Finset.univ \u2227 boys \u2229 girls = \u2205  -- boys and girls partition all players\n  valid_results : \u2200 i j, results i j \u2208 ({1, 0.5, 0} : Set Rat)         -- valid game scores\n  antisymmetric_results : \u2200 i j, results i j + results j i = 1         -- one wins, other loses\n  no_self_play : \u2200 i, results i i = 0                                  -- no self-play\n  \n  scores_sum : \u2200 i, scores i = (Finset.univ.filter (\u00b7 \u2260 i)).sum (results i)  -- total score computation\n  boys_half_points : \u2200 i, 2 * (boys.filter (\u00b7 \u2260 i)).sum (results i) = scores i  -- half points against boys\n\ntheorem krasnoyarsk_tournament_square_participants (t : ChessTournament) :\n  \u2203 k : Nat, t.n = k * k :=\n  sorry"}
{"id": "CombStruct4Lean_176", "informal_problem": "11.3. In a volleyball tournament, 110 teams participated, each playing exactly one game against each of the others (there are no ties in volleyball). It turned out that in any group of 55 teams, there is one team that lost to no more than four of the other 54 teams in this group. Prove that in the entire tournament, there is a team that lost to no more than four of the other 109 teams.", "formal_statement": "import Mathlib\n\nstructure VolleyballTournament where\n  n : \u2115\n  result : Fin n \u2192 Fin n \u2192 Bool\n  no_self_games : \u2200 i, \u00acresult i i\n  complete : \u2200 i j, i \u2260 j \u2192 \n    (result i j \u2227 \u00acresult j i) \u2228 (\u00acresult i j \u2227 result j i)\n\ninstance : Coe VolleyballTournament \u2115 where\n  coe t := t.n\n\ndef countLosses (t : VolleyballTournament) (team : Fin t.n) (group : Finset (Fin t.n)) : \u2115 :=\n  (group.filter (fun opponent => t.result opponent team)).card\n\ntheorem volleyball_tournament_winner \n  (t : VolleyballTournament) \n  (h1 : t.n = 110)\n  (h2 : \u2200 (group : Finset (Fin t.n)), group.card = 55 \u2192 \n        \u2203 team \u2208 group, countLosses t team group \u2264 4) :\n  \u2203 team : Fin t.n, countLosses t team (Finset.univ) \u2264 4 :=\n  sorry"}
{"id": "CombStruct4Lean_177", "informal_problem": "9.5. On the table, there is a pile of 2013 coins. One coin is removed from it and the pile is divided into two (not necessarily equal). Then, from any pile containing more than one coin, one coin is removed again and the pile is divided into two. And so on. Is it possible to leave only piles consisting of three coins on the table after several moves?", "formal_statement": "import Mathlib\n\nstructure GameState where\n  piles : List Nat\n  deriving Repr\n\ndef is_valid_move (s : GameState) (i : Nat) (split : Nat) : Bool :=\n  if h : i < s.piles.length then\n    let pile := (s.piles.get \u27e8i, h\u27e9)\n    pile > 1 \u2227 split > 0 \u2227 split < pile - 1\n  else\n    false\n\ndef make_move (s : GameState) (i : Nat) (split : Nat) : GameState :=\n  if h : i < s.piles.length \u2227 is_valid_move s i split then\n    let pile := (s.piles.get \u27e8i, h.1\u27e9)\n    let new_piles := s.piles.eraseIdx i\n    let split_piles := [split, pile - 1 - split]\n    { piles := new_piles ++ split_piles }\n  else\n    s\n\ndef all_piles_are_three (s : GameState) : Bool :=\n  s.piles.all (\u00b7 = 3)\n\ntheorem coin_splitting_puzzle : \u00ac\u2203 (moves : List (Nat \u00d7 Nat)),\n  let initial := GameState.mk [2013]\n  let final := moves.foldl (fun state (move : Nat \u00d7 Nat) =>\n    make_move state move.1 move.2) initial\n  all_piles_are_three final :=\n  sorry"}
{"id": "CombStruct4Lean_178", "informal_problem": "5. There are 30 students in the class. They sit at 15 desks such that exactly half of all the girls in the class sit with boys. Prove that it is impossible to rearrange them (at the same 15 desks) so that exactly half of all the boys in the class sit with girls.", "formal_statement": "import Mathlib\n\nstructure ClassSeating where\n  numGirls : Nat\n  numBoys : Nat\n  seating : Fin 30 \u2192 Fin 15  -- assigns each student to a desk\n  isGirl : Fin 30 \u2192 Bool     -- true if student is a girl\n  total_count : numGirls + numBoys = 30\n  girls_with_boys_count : Nat  -- number of girls sitting with boys\n  boys_with_girls_count : Nat  -- number of boys sitting with girls\n\n  -- Two students sit together if they share the same desk\n  sit_together (s1 s2 : Fin 30) : Bool :=\n    seating s1 = seating s2\n\n  -- Conditions for the initial arrangement\n  initial_girls_condition : girls_with_boys_count = numGirls / 2\n\ntheorem impossible_rearrangement (c : ClassSeating) :\n  \u00ac\u2203 (new_seating : Fin 30 \u2192 Fin 15),\n    let new_boys_with_girls := c.boys_with_girls_count\n    new_boys_with_girls = c.numBoys / 2 :=\n  sorry"}
{"id": "CombStruct4Lean_179", "informal_problem": "7.5. On each cell of a chessboard, there is a stack of several chips. In one move, one of the two operations is allowed:\n\n- remove one chip from each stack in any vertical column;\n- double the number of chips in each stack in any horizontal row.\n\nIs it possible to clear the entire board of chips in some number of such operations?", "formal_statement": "import Mathlib\n\nstructure ChessboardState where\n  -- Represents the number of chips in each cell (8x8 matrix)\n  chips : Matrix (Fin 8) (Fin 8) Nat\n\n-- Operation to remove one chip from each stack in a column\ndef removeFromColumn (state : ChessboardState) (col : Fin 8) : ChessboardState where\n  chips := fun i j => if j = col then state.chips i j - 1 else state.chips i j\n\n-- Operation to double chips in a row\ndef doubleRow (state : ChessboardState) (row : Fin 8) : ChessboardState where\n  chips := fun i j => if i = row then 2 * state.chips i j else state.chips i j\n\n-- Predicate to check if board is cleared\ndef isCleared (state : ChessboardState) : Prop :=\n  \u2200 i j, state.chips i j = 0\n\ntheorem chessboard_clearing_impossible (initial : ChessboardState) \n  (h : \u2200 i j, initial.chips i j > 0) : \n  \u00ac \u2203 (moves : List (Sum (Fin 8) (Fin 8))), \n    let final := moves.foldl \n      (fun state move => match move with\n        | Sum.inl col => removeFromColumn state col\n        | Sum.inr row => doubleRow state row) \n      initial\n    isCleared final :=\n  sorry"}
{"id": "CombStruct4Lean_180", "informal_problem": "1. There are 20 apples, and the weight difference between any two apples does not exceed 40 grams. Prove that these apples can be divided into two piles of 10 apples each, such that the weight difference between these piles does not exceed 40 grams.", "formal_statement": "import Mathlib\n\nstructure AppleCollection where\n  weights : Vector \u211d 20\n  (weights_nonneg : \u2200 i, weights.get i \u2265 0)\n  (weight_diff_bound : \u2200 i j, |weights.get i - weights.get j| \u2264 40)\n\ndef pile_weight (weights : Vector \u211d 20) (pile : Fin 20 \u2192 Bool) : \u211d :=\n  Finset.sum Finset.univ (fun i => if pile i then weights.get i else 0)\n\ndef is_valid_partition (weights : Vector \u211d 20) (pile : Fin 20 \u2192 Bool) : Prop :=\n  (Finset.sum Finset.univ (fun i => if pile i then 1 else 0) = 10) \u2227\n  |pile_weight weights pile - pile_weight weights (fun i => !pile i)| \u2264 40\n\ntheorem apple_division_exists (apples : AppleCollection) :\n  \u2203 (pile : Fin 20 \u2192 Bool), is_valid_partition apples.weights pile :=\n  sorry"}
{"id": "CombStruct4Lean_181", "informal_problem": "10.1. In the National Basketball Association, there are 30 teams, each of which plays 82 games with other teams in the regular season. Can the Association's management divide the teams (not necessarily equally) into Eastern and Western Conferences and create a schedule such that games between teams from different conferences make up exactly half of the total number of games?\n\n(A. Gribalko)", "formal_statement": "import Mathlib\n\n-- A game is a pair of distinct teams\nstructure Game (n : Nat) where\n  team1 : Fin n\n  team2 : Fin n\n  distinct : team1 \u2260 team2\n\n-- NBA Schedule with conference division\nstructure NBASchedule (n : Nat) (g : Nat) where\n  -- Conference assignment (true for East, false for West)\n  conference : Fin n \u2192 Bool\n  -- List of all games in the schedule\n  games : List (Game n)\n  -- Each team appears in exactly g games\n  games_per_team : \u2200 t : Fin n,\n    (games.filter (\u03bb game => game.team1 = t \u2228 game.team2 = t)).length = g\n  -- Conferences are non-empty\n  valid_conferences : \u2203 t1 t2 : Fin n, conference t1 \u2260 conference t2\n\ntheorem nba_conference_schedule_exists :\n  \u2203 (s : NBASchedule 30 82),\n    -- Number of inter-conference games equals half of total games\n    let interConfGames := s.games.filter (\u03bb g => s.conference g.team1 \u2260 s.conference g.team2)\n    interConfGames.length = (30 * 82) / 2 :=\n  sorry"}
{"id": "CombStruct4Lean_182", "informal_problem": "5. In the company, 11 people gathered. It turned out that each person is friends with at least six of those present. Prove that in this company, there will be three friends (each is friends with the other two).", "formal_statement": "import Mathlib\n\n/-- A simple graph with n vertices represented by adjacency sets -/\nstructure FriendshipGraph (n : Nat) where\n  adj : Fin n \u2192 Finset (Fin n)\n  symm : \u2200 i j, j \u2208 adj i \u2194 i \u2208 adj j\n  no_loops : \u2200 i, i \u2209 adj i\n\n/-- The degree of a vertex in the graph is the size of its adjacency set -/\ndef degree {n : Nat} (G : FriendshipGraph n) (v : Fin n) : Nat :=\n  G.adj v |>.card\n\n/-- A triangle in a graph is a set of three mutually connected vertices -/\ndef hasTriangle {n : Nat} (G : FriendshipGraph n) : Prop :=\n  \u2203 (i j k : Fin n), i \u2260 j \u2227 j \u2260 k \u2227 i \u2260 k \u2227\n    j \u2208 G.adj i \u2227 k \u2208 G.adj j \u2227 k \u2208 G.adj i\n\ntheorem friendship_triangle (G : FriendshipGraph 11)\n    (h_min_degree : \u2200 v, degree G v \u2265 6) : hasTriangle G :=\n  sorry"}
{"id": "CombStruct4Lean_183", "informal_problem": "11.5. In a mathematics class, there are 36 students. Exactly one of them recently became a winner of a mathematics olympiad. Each of his classmates has exactly five friends in common with him. Prove that there is a student in the class with an odd number of friends.\n\n#", "formal_statement": "import Mathlib\n\nstructure MathClass where\n  students : Finset (Fin 36)  -- The set of all students\n  winner : Fin 36            -- The olympiad winner\n  friends : Fin 36 \u2192 Finset (Fin 36)  -- For each student, their set of friends\n  friend_symm : \u2200 i j, i \u2208 friends j \u2194 j \u2208 friends i  -- Friendship is symmetric\n  common_with_winner : \u2200 i, i \u2260 winner \u2192 (friends i \u2229 friends winner).card = 5  -- Each non-winner has 5 friends in common with winner\n\ntheorem exists_odd_friends (c : MathClass) : \n  \u2203 i, (c.friends i).card % 2 = 1 :=\n  sorry"}
{"id": "CombStruct4Lean_184", "informal_problem": "2. At a mathematics olympiad, each of the 11 seventh-grade students solved 3 problems. It is known that for any two of them, there is a problem that one of them solved and the other did not. Prove that they were offered no fewer than 6 problems.", "formal_statement": "import Mathlib\n\nstructure OlympiadSolutions where\n  numStudents : Nat\n  numProblems : Nat\n  solutions : Fin numStudents \u2192 Finset (Fin numProblems)\n  eachSolvedThree : \u2200 s, (solutions s).card = 3\n  differentSolutions : \u2200 s\u2081 s\u2082, s\u2081 \u2260 s\u2082 \u2192 \n    \u2203 p, (p \u2208 solutions s\u2081 \u2227 p \u2209 solutions s\u2082) \u2228 \n         (p \u2209 solutions s\u2081 \u2227 p \u2208 solutions s\u2082)\n\ntheorem olympiad_min_problems : \n  \u00ac\u2203 (sol : OlympiadSolutions), sol.numStudents = 11 \u2227 sol.numProblems < 6 :=\n  sorry"}
{"id": "CombStruct4Lean_185", "informal_problem": "3. Seryozha cut a square birthday cake weighing 900 g with two straight cuts parallel to one pair of sides, and two cuts parallel to the other pair of sides, into 9 rectangular pieces. Prove that Petya can choose such three pieces of cake that do not share any sides and their total weight is not less than 300 g.", "formal_statement": "import Mathlib\n\nopen Finset Real\n\n/-- A 3x3 cake grid with weights that sum to 900g -/\nstructure CakeGrid where\n  weights : Fin 3 \u2192 Fin 3 \u2192 \u211d\n  total_weight : (\u2211 i : Fin 3, \u2211 j : Fin 3, weights i j) = 900\n  pos_weights : \u2200 i j, weights i j > 0\n\n/-- Two positions are adjacent if they share a side (Manhattan distance = 1) -/\ndef are_adjacent (p1 p2 : Fin 3 \u00d7 Fin 3) : Prop :=\n  let d\u2081 := Int.natAbs (p1.1.val - p2.1.val)\n  let d\u2082 := Int.natAbs (p1.2.val - p2.2.val)\n  (d\u2081 = 1 \u2227 d\u2082 = 0) \u2228 (d\u2081 = 0 \u2227 d\u2082 = 1)\n\n/-- A valid selection is three pieces that don't share any sides -/\ndef ValidSelection (s : Finset (Fin 3 \u00d7 Fin 3)) : Prop :=\n  s.card = 3 \u2227 \u2200 p1 \u2208 s, \u2200 p2 \u2208 s, p1 \u2260 p2 \u2192 \u00acare_adjacent p1 p2\n\n/-- The weight of a piece at a given position -/\ndef piece_weight (cake : CakeGrid) (pos : Fin 3 \u00d7 Fin 3) : \u211d :=\n  cake.weights pos.1 pos.2\n\ntheorem cake_pieces_exist (cake : CakeGrid) :\n  \u2203 s : Finset (Fin 3 \u00d7 Fin 3), \n    ValidSelection s \u2227 \n    (\u2211 p in s, piece_weight cake p) \u2265 300 :=\n  sorry"}
{"id": "CombStruct4Lean_186", "informal_problem": "5. On cards, Petya wrote down three natural numbers, each from 1 to 20. Moreover, there are no two cards with the same set of numbers. Prove that there will be two cards having exactly one common number, if it is known that Petya filled out 21 cards.", "formal_statement": "import Mathlib\n\nstructure Card where\n  nums : Finset Nat\n  h_size : nums.card = 3\n  h_range : \u2200 n \u2208 nums, 1 \u2264 n \u2227 n \u2264 20\n\ndef has_one_common (c1 c2 : Card) : Prop :=\n  (c1.nums \u2229 c2.nums).card = 1\n\ndef are_distinct (c1 c2 : Card) : Prop := \n  c1.nums \u2260 c2.nums\n\ndef is_valid_card (c : Card) : Prop := \n  c.nums.card = 3 \u2227 (\u2200 n \u2208 c.nums, 1 \u2264 n \u2227 n \u2264 20)\n\ntheorem petya_cards_common_number \n  (cards : Finset Card)\n  (h_card_count : cards.card = 21)\n  (h_valid : \u2200 c \u2208 cards, is_valid_card c)\n  (h_distinct : \u2200 (c1 c2 : Card), c1 \u2208 cards \u2192 c2 \u2208 cards \u2192 c1 \u2260 c2 \u2192 are_distinct c1 c2) :\n  \u2203 c1 c2, c1 \u2208 cards \u2227 c2 \u2208 cards \u2227 c1 \u2260 c2 \u2227 has_one_common c1 c2 := sorry"}
{"id": "CombStruct4Lean_187", "informal_problem": "9.5. Is it possible to write ones in some cells of an 8 x 8 table and zeros in the others, so that the sums in all columns are different, and the sums in all rows are the same?", "formal_statement": "import Mathlib\n\n-- A binary table is represented as a function from pairs of indices to Bool\nstructure BinaryTable where\n  entries : Fin 8 \u2192 Fin 8 \u2192 Bool\n\n-- Sum of a column in the table\ndef columnSum (t : BinaryTable) (j : Fin 8) : Nat :=\n  (Finset.range 8).sum fun i => if t.entries i j then 1 else 0\n\n-- Sum of a row in the table\ndef rowSum (t : BinaryTable) (i : Fin 8) : Nat :=\n  (Finset.range 8).sum fun j => if t.entries i j then 1 else 0\n\ntheorem binary_table_special_sums : \u00ac\u2203 (t : BinaryTable),\n  -- All column sums are different\n  (\u2200 j\u2081 j\u2082 : Fin 8, j\u2081 \u2260 j\u2082 \u2192 columnSum t j\u2081 \u2260 columnSum t j\u2082) \u2227\n  -- All row sums are equal\n  (\u2200 i\u2081 i\u2082 : Fin 8, rowSum t i\u2081 = rowSum t i\u2082) :=\n  sorry"}
{"id": "CombStruct4Lean_188", "informal_problem": "8.2 On a chessboard, 8 rooks were placed so that they do not attack each other. Prove that in any \"square\" rectangle of size $4 \\times 5$ (cells) there is at least one rook.", "formal_statement": "import Mathlib\n\n/-- A 4\u00d75 rectangle on the chessboard is determined by its top-left corner -/\nstructure Rectangle where\n  row : Fin 5  -- allows for 4 rows starting from this position (0-based)\n  col : Fin 4  -- allows for 5 columns starting from this position (0-based)\n\n/-- Predicate checking if a position lies within a given rectangle -/\ndef in_rectangle (rect : Rectangle) (r c : Fin 8) : Prop :=\n  (r.val \u2265 rect.row.val) \u2227 \n  (r.val < rect.row.val + 4) \u2227\n  (c.val \u2265 rect.col.val) \u2227 \n  (c.val < rect.col.val + 5)\n\n/-- For any permutation representing non-attacking rooks and any 4\u00d75 rectangle,\n    there exists a rook within that rectangle -/\ntheorem rook_in_rectangle (rooks : Equiv.Perm (Fin 8)) (rect : Rectangle) :\n  \u2203 r : Fin 8, in_rectangle rect r (rooks r) :=\n  sorry"}
{"id": "CombStruct4Lean_189", "informal_problem": "10.6. In the cells of a $9 \\times 9$ table, all natural numbers from 1 to 81 were placed. The products of the numbers in each row of the table were calculated, resulting in a set of nine numbers. Then, the products of the numbers in each column of the table were calculated, also resulting in a set of nine numbers. Could the obtained sets be the same?", "formal_statement": "import Mathlib\n\n-- Define a 9x9 table filled with numbers 1 to 81\nstructure Table where\n  entries : Fin 9 \u2192 Fin 9 \u2192 Fin 81\n  all_distinct : \u2200 i j i' j', entries i j = entries i' j' \u2192 i = i' \u2227 j = j'\n  all_numbers : \u2200 n : Fin 81, \u2203 i j, entries i j = n\n\n-- Helper function to calculate product of numbers in a row\ndef row_product (t : Table) (i : Fin 9) : Nat :=\n  (Finset.univ.prod fun j => (t.entries i j).val + 1)\n\n-- Helper function to calculate product of numbers in a column\ndef col_product (t : Table) (j : Fin 9) : Nat :=\n  (Finset.univ.prod fun i => (t.entries i j).val + 1)\n\n-- Function to get the multiset of row products\ndef row_products (t : Table) : Multiset Nat :=\n  Finset.univ.val.map (row_product t)\n\n-- Function to get the multiset of column products\ndef col_products (t : Table) : Multiset Nat :=\n  Finset.univ.val.map (col_product t)\n\ntheorem nine_by_nine_products_not_equal :\n  \u2200 t : Table, row_products t \u2260 col_products t :=\n  sorry"}
{"id": "CombStruct4Lean_190", "informal_problem": "2. In the class, there are 39 students, all of whom were born in 2009. Is there a month in the year in which at least 4 students from this class celebrate their birthday?", "formal_statement": "import Mathlib\n\n-- No additional structures needed as we can use existing types\n\ntheorem birthday_problem \n  (students : Finset \u2115) \n  (months : Fin 12 \u2192 Finset \u2115) \n  (h1 : students.card = 39) -- total number of students\n  (h2 : \u2200 i : \u2115, i \u2208 students \u2192 \u2203 m : Fin 12, i \u2208 months m) -- each student has a birth month\n  (h3 : \u2200 i : \u2115, i \u2208 students \u2192 \u2200 m1 m2 : Fin 12, i \u2208 months m1 \u2192 i \u2208 months m2 \u2192 m1 = m2) -- each student has exactly one birth month\n  : \u2203 m : Fin 12, (months m).card \u2265 4 :=\n  sorry"}
{"id": "CombStruct4Lean_191", "informal_problem": "11.5. Given a natural number $K>2$ and a set of $N$ cards, on which positive numbers are written. It turned out that from them one can choose several cards (possibly one) with the sum of numbers $K$, several cards with the sum of numbers $K^{2}, \\ldots$, several cards with the sum of numbers $K^{K}$. Could it be that $N<K$?", "formal_statement": "import Mathlib\n\nstructure CardSet where\n  cards : Finset Nat        -- the set of card values\n  K : Nat                   -- given number K\n  hK : K > 2               -- condition K > 2\n  hPos : \u2200 n \u2208 cards, n > 0  -- all values are positive\n  hSums : \u2200 i : Nat, i \u2265 1 \u2192 i \u2264 K \u2192 \n    \u2203 subset : Finset Nat, \n      subset \u2286 cards \u2227 \n      (\u2211 x in subset, x) = K^i\n\ntheorem card_set_size_bound {cs : CardSet} : cs.cards.card \u2265 cs.K :=\n  sorry"}
{"id": "CombStruct4Lean_192", "informal_problem": "7. Airline \"Vpered\" served 50 airports, and there was at least one route from each. Due to a reduction in the number of aircraft, the airline has to cancel some routes. To avoid passenger dissatisfaction, it is required that at least one route remains from each airport. Prove that regardless of the initial route scheme, the routes can be reduced in such a way that there are at least 30 airports from which there is only one route.", "formal_statement": "import Mathlib\n\nstructure AirlineNetwork where\n  routes : Finset (Fin 50 \u00d7 Fin 50)\n  has_route : \u2200 a : Fin 50, \u2203 b, (a, b) \u2208 routes\n\n/-- Count of routes from a given airport in a network -/\ndef routeCount (net : AirlineNetwork) (a : Fin 50) : Nat :=\n  (net.routes.filter (fun p => p.1 = a)).card\n\n/-- The set of airports that have exactly one route in the network -/\ndef singleRouteAirports (net : AirlineNetwork) : Finset (Fin 50) :=\n  Finset.filter (fun a => routeCount net a = 1) Finset.univ\n\n/-- A valid route reduction maintains at least one route from each airport -/\ndef IsValidReduction (original reduced : AirlineNetwork) : Prop :=\n  reduced.routes \u2286 original.routes \u2227\n  \u2200 a : Fin 50, \u2203 b, (a, b) \u2208 reduced.routes\n\ntheorem airline_route_reduction (original : AirlineNetwork) :\n  \u2203 reduced : AirlineNetwork,\n    IsValidReduction original reduced \u2227\n    (singleRouteAirports reduced).card \u2265 30 :=\n  sorry"}
{"id": "CombStruct4Lean_193", "informal_problem": "4. In the nodes of a grid plane, 5 points are marked. Prove that there are two of them, the midpoint of the segment between which also falls on a node.", "formal_statement": "import Mathlib\n\nstructure GridPoint where\n  x : Int\n  y : Int\n\ndef is_midpoint (a b c : GridPoint) : Prop :=\n  2 * c.x = a.x + b.x \u2227 2 * c.y = a.y + b.y\n\ntheorem grid_points_midpoint_exists \n  (points : Fin 5 \u2192 GridPoint) : \n  \u2203 (i j : Fin 5) (h : i \u2260 j), \n    \u2203 (m : GridPoint), is_midpoint (points i) (points j) m :=\n  sorry"}
{"id": "CombStruct4Lean_194", "informal_problem": "3. Each node of an infinite grid is painted in one of four colors such that the vertices of each square with side 1 are painted in different colors. Is it true that the nodes of one of the grid lines are painted in only two colors? (The grid is formed by horizontal and vertical lines. The distance between adjacent parallel lines is 1.)", "formal_statement": "import Mathlib\n\n-- Define a coloring of the infinite grid\nstructure GridColoring where\n  -- A coloring maps each point (x,y) to one of four colors (0,1,2,3)\n  color : \u2124 \u00d7 \u2124 \u2192 Fin 4\n  -- Property: adjacent vertices of any unit square have different colors\n  valid_square : \u2200 (x y : \u2124), \n    color (x, y) \u2260 color (x + 1, y) \u2227 \n    color (x, y) \u2260 color (x, y + 1) \u2227 \n    color (x + 1, y) \u2260 color (x + 1, y + 1) \u2227 \n    color (x, y + 1) \u2260 color (x + 1, y + 1) \u2227\n    color (x, y) \u2260 color (x + 1, y + 1) \u2227\n    color (x + 1, y) \u2260 color (x, y + 1)\n\n-- Define what it means for a line to use only two colors\ndef uses_two_colors (c : GridColoring) (horizontal : Bool) (k : \u2124) : Prop :=\n  \u2203 (c\u2081 c\u2082 : Fin 4), \u2200 (t : \u2124),\n    c.color (if horizontal then (t, k) else (k, t)) \u2208 ({c\u2081, c\u2082} : Set (Fin 4))\n\ntheorem grid_coloring_two_colors :\n  \u2200 (c : GridColoring), \n  (\u2203 (k : \u2124), uses_two_colors c true k) \u2228 \n  (\u2203 (k : \u2124), uses_two_colors c false k) :=\n  sorry"}
{"id": "CombStruct4Lean_195", "informal_problem": "3. Points on a line are colored in two colors (each color is present, each point has exactly one color). Prove that there will be three points of the same color, such that one lies exactly in the middle between the other two.", "formal_statement": "import Mathlib\n\nstructure ColoredLine where\n  points : Set \u211d              -- Set of points on the real line\n  color : \u211d \u2192 Bool           -- Coloring function (True/False representing two colors)\n  nonempty_colors : \u2203 p\u2081 p\u2082, p\u2081 \u2208 points \u2227 p\u2082 \u2208 points \u2227 color p\u2081 \u2260 color p\u2082\n  all_colored : \u2200 p \u2208 points, color p = true \u2228 color p = false\n\ntheorem monochromatic_midpoint (L : ColoredLine) : \n  \u2203 (x y z : \u211d), x \u2208 L.points \u2227 y \u2208 L.points \u2227 z \u2208 L.points \u2227 \n    L.color x = L.color y \u2227 L.color y = L.color z \u2227\n    y = (x + z) / 2 :=\n  sorry"}
{"id": "CombStruct4Lean_196", "informal_problem": "10.5. Given an infinite grid plane. A teacher and a class of 30 students play a game, taking turns - first the teacher, then each of the students in turn, then the teacher again, and so on. In one move, a player can paint a unit segment that is a boundary between two adjacent cells. Segments cannot be painted more than once. The teacher wins if after one of the 31 players' moves, there is a grid rectangle $1 \\times 2$ or $2 \\times 1$ such that its entire boundary is painted, but the unit segment inside it is not painted. Prove that the teacher can win. (M. Diden, A. Kuznetsov)", "formal_statement": "import Mathlib\n\n-- Players can be either teacher or one of 30 students\ninductive Player where\n  | teacher\n  | student (n : Fin 30)\n  deriving Repr, DecidableEq\n\n-- A segment on the grid can be either horizontal or vertical\ninductive Segment where\n  | horizontal : \u2124 \u00d7 \u2124 \u2192 Segment  -- from (x,y) to (x+1,y)\n  | vertical : \u2124 \u00d7 \u2124 \u2192 Segment    -- from (x,y) to (x,y+1)\n  deriving Repr, DecidableEq\n\n-- Game state tracks painted segments, current player, and move count\nstructure GameState where\n  painted_segments : Set Segment\n  current_player : Player\n  move_count : Nat\n\n-- A rectangle is defined by its bottom-left corner and orientation\nstructure Rectangle where\n  corner : \u2124 \u00d7 \u2124\n  is_horizontal : Bool\n\ndef Rectangle.boundary_segments (rect : Rectangle) : Set Segment :=\n  if rect.is_horizontal then\n    -- 1\u00d72 rectangle segments\n    {Segment.horizontal rect.corner,                            -- bottom\n     Segment.horizontal (rect.corner.1, rect.corner.2 + 1),    -- top\n     Segment.vertical rect.corner,                             -- left\n     Segment.vertical (rect.corner.1 + 1, rect.corner.2),      -- middle\n     Segment.vertical (rect.corner.1 + 2, rect.corner.2)}      -- right\n  else\n    -- 2\u00d71 rectangle segments\n    {Segment.vertical rect.corner,                             -- left\n     Segment.vertical (rect.corner.1 + 1, rect.corner.2),      -- right\n     Segment.horizontal rect.corner,                           -- bottom\n     Segment.horizontal (rect.corner.1, rect.corner.2 + 1),    -- middle\n     Segment.horizontal (rect.corner.1, rect.corner.2 + 2)}    -- top\n\ndef Rectangle.internal_segment (rect : Rectangle) : Segment :=\n  if rect.is_horizontal then\n    Segment.vertical (rect.corner.1 + 1, rect.corner.2)        -- middle vertical segment\n  else\n    Segment.horizontal (rect.corner.1, rect.corner.2 + 1)      -- middle horizontal segment\n\ntheorem teacher_has_winning_strategy :\n  \u2203 (strategy : GameState \u2192 Segment),\n    \u2200 (student_moves : GameState \u2192 Segment),\n    \u2203 (final_state : GameState) (rect : Rectangle),\n    -- The final state contains a rectangle with painted boundary but unpainted internal segment\n    (\u2200 s \u2208 rect.boundary_segments, s \u2208 final_state.painted_segments) \u2227\n    rect.internal_segment \u2209 final_state.painted_segments \u2227\n    -- The game follows valid rules\n    (\u2200 s \u2208 final_state.painted_segments, \n      -- Each painted segment was added in a valid turn\n      \u2203 (prev_state : GameState),\n      prev_state.move_count < final_state.move_count \u2227\n      prev_state.painted_segments \u2286 final_state.painted_segments) :=\n  sorry"}
{"id": "CombStruct4Lean_197", "informal_problem": "9.4 In a company of $2 n+1$ people, for any $n$ people, there is a person different from them who is acquainted with each of them. Prove that there is a person in this company who knows everyone.", "formal_statement": "import Mathlib\n\n-- Define the acquaintance relation\nstructure AcquaintanceGraph where\n  n : Nat  -- half of (total people - 1)\n  knows : Fin (2 * n + 1) \u2192 Fin (2 * n + 1) \u2192 Bool  -- acquaintance relation\n  symm : \u2200 i j, knows i j = knows j i  -- symmetry of acquaintance\n  irrefl : \u2200 i, knows i i = false  -- no one knows themselves\n\ntheorem acquaintance_theorem (g : AcquaintanceGraph) :\n  -- For any n people, there exists someone else who knows all of them\n  (\u2200 (S : Finset (Fin (2 * g.n + 1))), S.card = g.n \u2192\n    \u2203 k, k \u2209 S \u2227 \u2200 i \u2208 S, g.knows k i) \u2192\n  -- Then there exists someone who knows everyone else\n  \u2203 k, \u2200 i, i \u2260 k \u2192 g.knows k i :=\n  sorry"}
{"id": "CombStruct4Lean_198", "informal_problem": "# Task 11.4\n\nA rectangle of size $7 \\times 9$ is divided into squares of size $1 \\times 1$. The central square is shaded. Prove that it is impossible to draw a broken line through the centers of all unshaded squares such that each segment connects the centers of adjacent squares by side without passing through any of them more than once.\n\n## Number of points 7", "formal_statement": "import Mathlib\n\n-- Grid coordinates using Fin for bounded indices\nstructure GridPoint where\n  x : Fin 7\n  y : Fin 9\n\ndef center : GridPoint where\n  x := \u27e83, by norm_num\u27e9  -- 0-based indexing\n  y := \u27e84, by norm_num\u27e9\n\n-- Two points are adjacent if they differ by 1 in exactly one coordinate\ndef are_adjacent (p\u2081 p\u2082 : GridPoint) : Prop :=\n  (p\u2081.x = p\u2082.x \u2227 (p\u2081.y.val + 1 = p\u2082.y.val \u2228 p\u2082.y.val + 1 = p\u2081.y.val)) \u2228\n  (p\u2081.y = p\u2082.y \u2227 (p\u2081.x.val + 1 = p\u2082.x.val \u2228 p\u2082.x.val + 1 = p\u2081.x.val))\n\n-- A path is a list of points that must satisfy certain properties\nstructure ValidPath where\n  points : List GridPoint\n  no_center : \u2200 p \u2208 points, p \u2260 center\n  no_repeats : points.Nodup\n  all_adjacent : List.Chain' are_adjacent points\n  visits_all : points.length = 62  -- 7*9-1 squares (all except center)\n\ntheorem no_valid_path_exists : \u00ac\u2203 (p : ValidPath), True :=\n  sorry"}
{"id": "CombStruct4Lean_199", "informal_problem": "2. Given a $7 \\times 3$ table. Each cell is filled with a number 0 or 1. If at the intersection of any two rows and any two columns all four numbers are the same, then the table is considered to be filled unsuccessfully. Is it possible to fill the table in such a way to avoid this phenomenon?", "formal_statement": "import Mathlib\n\n-- A table is represented as a function from positions to Bool\nstructure Table where\n  values : (Fin 7) \u2192 (Fin 3) \u2192 Bool\n\n/-- Check if a 2x2 subtable at given positions has all same values -/\ndef hasAllSameValues (t : Table) (r1 r2 : Fin 7) (c1 c2 : Fin 3) : Bool :=\n  let v := t.values r1 c1\n  v = t.values r1 c2 \u2227 v = t.values r2 c1 \u2227 v = t.values r2 c2\n\n/-- A table is successful if no 2x2 subtable has all same values -/\ndef isSuccessful (t : Table) : Prop :=\n  \u2200 (r1 r2 : Fin 7), \u2200 (c1 c2 : Fin 3),\n    r1 \u2260 r2 \u2192 c1 \u2260 c2 \u2192 \u00ac(hasAllSameValues t r1 r2 c1 c2)\n\ntheorem exists_successful_table :\n  \u2203 (t : Table), isSuccessful t :=\n  sorry"}
{"id": "CombStruct4Lean_200", "informal_problem": "5. In a $1000 \\times 1000$ grid, 2000 cells are painted blue. Prove that there exist 4 blue cells such that the centers of these cells are the vertices of a parallelogram.", "formal_statement": "import Mathlib\n\nstructure Point where\n  x : Nat \n  y : Nat\n  isBlue : Bool\n  h_x : x < 1000\n  h_y : y < 1000\n\ndef isParallelogram (p1 p2 p3 p4 : Point) : Prop :=\n  let v1 := (p2.x - p1.x, p2.y - p1.y)\n  let v2 := (p4.x - p3.x, p4.y - p3.y)\n  let v3 := (p3.x - p2.x, p3.y - p2.y)\n  let v4 := (p1.x - p4.x, p1.y - p4.y)\n  v1 = v2 \u2227 v3 = v4\n\ntheorem blue_parallelogram_exists (grid : Finset Point) \n  (h_size : grid.card = 2000)\n  (h_blue : \u2200 p \u2208 grid, p.isBlue = true) :\n  \u2203 (p1 p2 p3 p4 : Point),\n    p1 \u2208 grid \u2227 p2 \u2208 grid \u2227 p3 \u2208 grid \u2227 p4 \u2208 grid \u2227\n    isParallelogram p1 p2 p3 p4 :=\n  sorry"}
{"id": "CombStruct4Lean_201", "informal_problem": "4. Is it possible to arrange balls of seven colors in five boxes standing in a circle so that each box contains three balls of different colors, and no two balls of the same color are in adjacent boxes?", "formal_statement": "import Mathlib\n\nstructure ColorArrangement where\n  -- Each box contains a list of colors (represented as Fin 7)\n  boxes : Fin 5 \u2192 Fin 7 \u00d7 Fin 7 \u00d7 Fin 7\n\ndef isValidArrangement (arr : ColorArrangement) : Prop :=\n  -- All colors in each box are different\n  (\u2200 i : Fin 5, let (c1, c2, c3) := arr.boxes i\n                c1 \u2260 c2 \u2227 c2 \u2260 c3 \u2227 c1 \u2260 c3) \u2227\n  -- No adjacent boxes share colors\n  (\u2200 i : Fin 5, let (c1, c2, c3) := arr.boxes i\n                let (n1, n2, n3) := arr.boxes (i + 1)\n                c1 \u2260 n1 \u2227 c1 \u2260 n2 \u2227 c1 \u2260 n3 \u2227\n                c2 \u2260 n1 \u2227 c2 \u2260 n2 \u2227 c2 \u2260 n3 \u2227\n                c3 \u2260 n1 \u2227 c3 \u2260 n2 \u2227 c3 \u2260 n3)\n\ntheorem exists_valid_color_arrangement :\n  \u2203 (arr : ColorArrangement), isValidArrangement arr :=\n  sorry"}
{"id": "CombStruct4Lean_202", "informal_problem": "10.3. At a freestyle cycling competition, there were 100 judges. Each judge ranked all participants from the best to the worst according to their opinion. It turned out that for no three participants $A, B, C$ did there exist three judges, one of whom considered $A$ the best of the three and $B$ the worst, another considered $B$ the best and $C$ the worst, and the third considered $C$ the best and $A$ the worst. Prove that it is possible to create an overall ranking of participants such that for any two participants $A$ and $B$, the one who is higher in the ranking is better than the other according to at least half of the judges.\n\n(I. Bogdanov)", "formal_statement": "import Mathlib\n\ndef forms_cycle {\u03b1 : Type} (r\u2081 r\u2082 r\u2083 : \u03b1 \u2192 \u03b1 \u2192 Bool) (a b c : \u03b1) : Prop :=\n  r\u2081 a b = true \u2227 r\u2081 b c = true \u2227\n  r\u2082 b c = true \u2227 r\u2082 c a = true \u2227\n  r\u2083 c a = true \u2227 r\u2083 a b = true\n\nstructure JudgingCompetition (participants : Type) [Fintype participants] [DecidableEq participants] where\n  /-- Each judge's ranking is represented as a function that returns true when the first participant\n      is ranked above the second -/\n  rankings : Fin 100 \u2192 participants \u2192 participants \u2192 Bool\n  /-- Each judge's ranking must be transitive -/\n  rankings_trans : \u2200 j a b c, rankings j a b = true \u2192 rankings j b c = true \u2192 rankings j c a = false\n  /-- Each judge's ranking must be total -/\n  rankings_total : \u2200 j a b, rankings j a b = true \u2228 rankings j b a = true\n  /-- Each judge's ranking must be antisymmetric -/\n  rankings_antisymm : \u2200 j a b, rankings j a b = true \u2192 rankings j b a = false\n  /-- No cyclic rankings among any three participants by three different judges -/\n  no_cyclic_three : \u2200 a b c j\u2081 j\u2082 j\u2083, \u00acforms_cycle (rankings j\u2081) (rankings j\u2082) (rankings j\u2083) a b c\n\ntheorem exists_majority_ranking {p : Type} [Fintype p] [DecidableEq p] (comp : JudgingCompetition p) :\n  \u2203 (final_ranking : p \u2192 p \u2192 Bool),\n    (\u2200 a b c, final_ranking a b = true \u2192 final_ranking b c = true \u2192 final_ranking c a = false) \u2227\n    (\u2200 a b, final_ranking a b = true \u2192\n      (Fintype.card {j : Fin 100 | comp.rankings j a b = true}) \u2265 50) :=\n  sorry"}
{"id": "CombStruct4Lean_203", "informal_problem": "11.5. Given an infinite grid plane. A teacher and a class of 30 students play a game, taking turns - first the teacher, then each of the students in turn, then the teacher again, and so on. In one move, a player can paint a unit segment that is a boundary between two adjacent cells. Segments cannot be painted more than once. The teacher wins if, after one of the 31 players' moves, there is a grid rectangle $1 \\times 2$ or $2 \\times 1$ such that its entire boundary is painted, but the unit segment inside it is not painted. Can the students prevent the teacher from winning?\n\n(M. Diden, A. Kuznetsov)", "formal_statement": "import Mathlib\n\nstructure Segment where\n  start : \u2124 \u00d7 \u2124\n  direction : Bool  -- true for horizontal, false for vertical\n\nstructure GridGame where\n  painted_segments : Set Segment\n  current_player : Fin 31  -- 0 is teacher, 1-30 are students\n\ndef is_valid_move (game : GridGame) (seg : Segment) : Prop :=\n  seg \u2209 game.painted_segments\n\ndef is_teacher_turn (game : GridGame) : Prop :=\n  game.current_player = 0\n\ndef forms_rectangle (segs : Set Segment) (pos : \u2124 \u00d7 \u2124) (horizontal : Bool) : Prop :=\n  if horizontal then\n    -- 1\u00d72 rectangle at position pos\n    { Segment.mk pos true,                    -- bottom edge\n      Segment.mk pos false,                   -- left edge\n      Segment.mk (pos.1, pos.2 + 1) true,    -- top edge\n      Segment.mk (pos.1 + 1, pos.2) false    -- right edge\n    } \u2286 segs\n  else\n    -- 2\u00d71 rectangle at position pos\n    { Segment.mk pos false,                   -- left edge\n      Segment.mk pos true,                    -- bottom edge\n      Segment.mk (pos.1 + 1, pos.2) false,   -- right edge\n      Segment.mk (pos.1, pos.2 + 1) true     -- top edge\n    } \u2286 segs\n\ndef has_unpainted_middle (game : GridGame) (pos : \u2124 \u00d7 \u2124) (horizontal : Bool) : Prop :=\n  let middle := if horizontal then\n    Segment.mk (pos.1, pos.2) true    -- horizontal middle segment\n  else\n    Segment.mk (pos.1, pos.2) false   -- vertical middle segment\n  middle \u2209 game.painted_segments\n\ndef winning_position (game : GridGame) : Prop :=\n  \u2203 (pos : \u2124 \u00d7 \u2124) (horizontal : Bool),\n    forms_rectangle game.painted_segments pos horizontal \u2227\n    has_unpainted_middle game pos horizontal\n\ntheorem students_cannot_prevent_teacher_win :\n  \u2203 (teacher_strategy : GridGame \u2192 Segment),\n    \u2200 (student_strategies : Fin 30 \u2192 GridGame \u2192 Segment),\n    \u2203 (final_state : GridGame),\n      (\u2200 move, is_valid_move final_state move) \u2192\n      winning_position final_state :=\n  sorry"}
{"id": "CombStruct4Lean_204", "informal_problem": "11.8. Each of 100 girls has 100 balls; among these 10000 balls, there are 100 balls of 100 different colors. Two girls can exchange, passing one ball to each other. They want to achieve that each girl has 100 balls of different colors. Prove that they can achieve this with a series of exchanges such that any ball participates in no more than one exchange.\n\n(I. Bogdanov, F. Petrov)", "formal_statement": "import Mathlib\n\nstructure BallDistribution where\n  -- For each girl (0 to 99) and each color (0 to 99), how many balls of that color she has\n  distribution : Fin 100 \u2192 Fin 100 \u2192 Nat\n  -- Each girl has exactly 100 balls in total\n  total_balls : \u2200 g : Fin 100, (\u2211 c : Fin 100, distribution g c) = 100\n  -- For each color, there are exactly 100 balls of that color in total\n  total_per_color : \u2200 c : Fin 100, (\u2211 g : Fin 100, distribution g c) = 100\n\n-- An exchange is represented by two girls and two colors\nstructure Exchange where\n  girl1 : Fin 100\n  girl2 : Fin 100\n  color1 : Fin 100\n  color2 : Fin 100\n  valid_girls : girl1 \u2260 girl2\n  valid_colors : color1 \u2260 color2\n\ndef is_valid_sequence (exchanges : List Exchange) : Prop :=\n  -- Each ball (girl-color pair) appears at most once in the exchanges\n  \u2200 g : Fin 100, \u2200 c : Fin 100,\n    (exchanges.filter (\u03bb e => \n      (e.girl1 = g \u2227 e.color1 = c) \u2228 \n      (e.girl1 = g \u2227 e.color2 = c) \u2228\n      (e.girl2 = g \u2227 e.color1 = c) \u2228\n      (e.girl2 = g \u2227 e.color2 = c))).length \u2264 1\n\ndef is_rainbow_distribution (d : BallDistribution) : Prop :=\n  \u2200 g : Fin 100, \u2200 c : Fin 100, d.distribution g c \u2264 1\n\ntheorem ball_exchange_possible (initial : BallDistribution) :\n  \u2203 (exchanges : List Exchange),\n    is_valid_sequence exchanges \u2227\n    \u2203 (final : BallDistribution),\n      is_rainbow_distribution final :=\n  sorry"}
{"id": "CombStruct4Lean_205", "informal_problem": "9.5. There are 23 students in the class. During the year, each student in this class celebrated their birthday once, to which some (at least one, but not all) of their classmates came. Could it be that every two students in this class met at such celebrations the same number of times? (It is assumed that at each party, any two guests met, and the birthday person met with all the guests.)\n\n(I. Bogdanov)", "formal_statement": "import Mathlib\n\nstructure BirthdayParties where\n  n : Nat\n  guests : Fin n \u2192 Finset (Fin n)  -- each party has a set of guests\n  some_guests : \u2200 i, 0 < (guests i).card\n  not_all_guests : \u2200 i, (guests i).card < n - 1\n  host_not_guest : \u2200 i, i \u2209 guests i\n\n/-- Number of times two students met at birthday parties -/\ndef meetCount (bp : BirthdayParties) (s1 s2 : Fin bp.n) : Nat :=\n  let at_s1_party := if s2 \u2208 bp.guests s1 then 1 else 0\n  let at_s2_party := if s1 \u2208 bp.guests s2 then 1 else 0\n  let at_others := Finset.sum Finset.univ fun k =>\n    if s1 \u2208 bp.guests k \u2227 s2 \u2208 bp.guests k then 1 else 0\n  at_s1_party + at_s2_party + at_others\n\ntheorem birthday_meetings_not_equal (bp : BirthdayParties) (h : bp.n = 23) :\n  \u00ac(\u2200 s1 s2 : Fin bp.n, s1 \u2260 s2 \u2192 meetCount bp s1 s2 = meetCount bp s1 s2) :=\n  sorry"}
{"id": "CombStruct4Lean_206", "informal_problem": "6. Participants of the summer physics and mathematics camp for schoolchildren received either an orange or a purple T-shirt. The number of participants in the physics group who received an orange T-shirt is equal to the number of participants in the mathematics group who received a purple T-shirt. Who is more - participants in the mathematics group, or those who received an orange T-shirt?", "formal_statement": "import Mathlib\n\nstructure CampParticipants where\n  physics : Finset Nat    -- Set of physics participants\n  math : Finset Nat       -- Set of math participants\n  orange : Finset Nat     -- Set of participants with orange T-shirts\n  purple : Finset Nat     -- Set of participants with purple T-shirts\n  disjoint_groups : Disjoint physics math      -- No one is in both groups\n  all_participants : physics \u222a math = orange \u222a purple  -- Everyone has exactly one T-shirt\n  valid_shirts : Disjoint orange purple        -- No one has both shirts\n\ntheorem camp_comparison (c : CampParticipants)\n  (h : (c.physics \u2229 c.orange).card = (c.math \u2229 c.purple).card) :\n  (c.math.card \u2260 c.orange.card) \u2228 (c.math.card = c.orange.card \u2227 c.physics.card = c.purple.card) :=\n  sorry"}
{"id": "CombStruct4Lean_207", "informal_problem": "5. In each cell of a $25 \\times 25$ square table, one of the numbers 1 or -1 is written arbitrarily. Under each column, the product of all numbers in that column is written. To the right of each row, the product of all numbers in that row is written. Prove that the sum of the 50 written products cannot be zero.", "formal_statement": "import Mathlib\n\n-- Define the type for valid cell entries (1 or -1)\ndef SignEntry := {x : Int // x = 1 \u2228 x = -1}\n\n-- Define the table structure\nstructure SignTable where\n  -- The main table entries\n  entries : Fin 25 \u2192 Fin 25 \u2192 SignEntry\n  -- Column products (product of all entries in each column)\n  colProducts : Fin 25 \u2192 Int := \u03bb j => (\u220f i, (entries i j).val)\n  -- Row products (product of all entries in each row)\n  rowProducts : Fin 25 \u2192 Int := \u03bb i => (\u220f j, (entries i j).val)\n\ntheorem sign_table_products_nonzero (t : SignTable) : \n  (\u2211 i, t.rowProducts i) + (\u2211 j, t.colProducts j) \u2260 0 :=\n  sorry"}
{"id": "CombStruct4Lean_208", "informal_problem": "10.1. 33 heroes go on patrol for 33 days. On the first day, one hero should go out, on the second day two, on the third day three, and so on, on the last day - all the heroes. Can Chernomor the Elder organize the patrols so that all heroes go on patrol an equal number of times?", "formal_statement": "import Mathlib\n\nstructure PatrolSchedule (n : Nat) where\n  assignment : Fin n \u2192 Finset (Fin n)\n  size_constraint : \u2200 d : Fin n, (assignment d).card = d.val + 1\n\ndef count_patrols {n : Nat} (schedule : PatrolSchedule n) (hero : Fin n) : Nat :=\n  (Finset.filter (fun d => hero \u2208 schedule.assignment d) (Finset.univ : Finset (Fin n))).card\n\ntheorem patrol_schedule_impossible : \u00ac\u2203 (schedule : PatrolSchedule 33), \n  (\u2200 h\u2081 h\u2082 : Fin 33, count_patrols schedule h\u2081 = count_patrols schedule h\u2082) :=\n  sorry"}
{"id": "CombStruct4Lean_209", "informal_problem": "10.6. There are two boxes, one with 2017 candies, and the other with 2018. Two players take turns. On each turn, a player can eat any non-zero number of candies from any one box. The rules of the game do not allow the number of candies in one box to be divisible by the number of candies in the other after any move. The player who cannot make a move without violating this condition loses. Who can win: the player starting the game or the second player, regardless of how their opponent plays?", "formal_statement": "import Mathlib\n\nstructure CandyGame where\n  box1 : Nat\n  box2 : Nat\n  deriving Repr\n\ndef isValidMove (game : CandyGame) (newGame : CandyGame) : Bool :=\n  -- Check if the move is valid:\n  -- 1. Only one box changes\n  -- 2. The changed box decreases\n  -- 3. The new numbers are not divisible by each other\n  let box1Same := game.box1 = newGame.box1\n  let box2Same := game.box2 = newGame.box2\n  let box1Decreases := newGame.box1 < game.box1\n  let box2Decreases := newGame.box2 < game.box2\n  let notDivisible := \n    (newGame.box1 = 0 \u2228 newGame.box2 = 0 \u2228 \n     (newGame.box1 % newGame.box2 \u2260 0 \u2227 newGame.box2 % newGame.box1 \u2260 0))\n  \n  (box1Same \u2260 box2Same) \u2227  -- exactly one box changes\n  ((box1Same \u2227 box2Decreases) \u2228 (box2Same \u2227 box1Decreases)) \u2227\n  notDivisible\n\ntheorem candy_game_second_player_wins : \n  \u2203 (strategy : CandyGame \u2192 CandyGame),\n    let initialGame := CandyGame.mk 2017 2018\n    -- For any valid first move by player 1\n    \u2200 (p1move : CandyGame),\n      isValidMove initialGame p1move \u2192\n      -- There exists a response by player 2\n      isValidMove p1move (strategy p1move) \u2227\n      -- Such that player 2 can force a win\n      \u2200 (subsequent_position : CandyGame),\n        -- No matter what moves follow\n        \u00ac(\u2203 (final_position : CandyGame), \n          isValidMove subsequent_position final_position) :=\n  sorry"}
{"id": "CombStruct4Lean_210", "informal_problem": "# Task 9.1\n\nThere are 2005 coins on the table. Two players play the following game: they take turns; on a turn, the first player can take any odd number of coins from 1 to 99, and the second player can take any even number of coins from 2 to 100. The player who cannot make a move loses. Who will win with correct play?\n\n## Number of points 7\n\n#", "formal_statement": "import Mathlib\n\ninductive Player where\n  | First\n  | Second\n  deriving Repr\n\nstructure GameState where\n  coins : Nat\n  currentPlayer : Player\n\nstructure GameResult where\n  winner : Player\n\ndef isValidMove (move : Nat) (player : Player) : Bool :=\n  match player with\n  | Player.First => \n    Nat.mod move 2 = 1 \u2227 move \u2265 1 \u2227 move \u2264 99\n  | Player.Second => \n    Nat.mod move 2 = 0 \u2227 move \u2265 2 \u2227 move \u2264 100\n\ndef nextPlayer : Player \u2192 Player\n  | Player.First => Player.Second\n  | Player.Second => Player.First\n\ndef makeMove (state : GameState) (move : Nat) : Option GameState :=\n  if isValidMove move state.currentPlayer \u2227 move \u2264 state.coins then\n    some \u27e8state.coins - move, nextPlayer state.currentPlayer\u27e9\n  else\n    none\n\ndef hasValidMove (state : GameState) : Bool :=\n  match state.currentPlayer with\n  | Player.First => \n    \u2203 m, m \u2264 state.coins \u2227 Nat.mod m 2 = 1 \u2227 m \u2265 1 \u2227 m \u2264 99\n  | Player.Second => \n    \u2203 m, m \u2264 state.coins \u2227 Nat.mod m 2 = 0 \u2227 m \u2265 2 \u2227 m \u2264 100\n\ntheorem coin_game_winner (initialCoins : Nat) (h : initialCoins = 2005) :\n  \u2203 (winningStrategy : GameState \u2192 Nat),\n    \u2200 (state : GameState),\n    state.coins = initialCoins \u2192\n    state.currentPlayer = Player.First \u2192\n    \u00ac(hasValidMove \u27e8state.coins - winningStrategy state, nextPlayer state.currentPlayer\u27e9) :=\n  sorry"}
{"id": "CombStruct4Lean_211", "informal_problem": "10.5. Given the \"skeleton\" of a $10 \\times 10$ grid (that is, the set of vertical and horizontal segments dividing the square into unit squares, including the boundary of the square). This skeleton is divided into corners (consisting of two unit segments) and segments of length 2 (also consisting of two unit segments). Could there be exactly $21$ segments of length 2?", "formal_statement": "import Mathlib\n\n/-- Type for unit segments in a 10\u00d710 grid -/\ninductive UnitSegment\n  | horizontal (x : Fin 10) (y : Fin 11)  -- horizontal segment starting at (x,y)\n  | vertical (x : Fin 11) (y : Fin 10)    -- vertical segment starting at (x,y)\n  deriving Repr, DecidableEq\n\n/-- Total number of unit segments in a 10\u00d710 grid -/\ndef totalSegments : \u2115 := 10 * 11 + 11 * 10  -- horizontal + vertical segments\n\n/-- A partition of the grid skeleton consists of corners and length-2 segments -/\nstructure GridPartition where\n  corners : Finset (UnitSegment \u00d7 UnitSegment)\n  length2 : Finset (UnitSegment \u00d7 UnitSegment)\n  /-- Each pair in corners forms a valid corner -/\n  valid_corners : \u2200 p \u2208 corners, match p.1, p.2 with\n    | UnitSegment.horizontal x y, UnitSegment.vertical x' y' => x' = x + 1 \u2227 y' = y\n    | UnitSegment.vertical x y, UnitSegment.horizontal x' y' => x = x' \u2227 y = y'\n    | _, _ => False\n  /-- Each pair in length2 forms a valid length-2 segment -/\n  valid_length2 : \u2200 p \u2208 length2, match p.1, p.2 with\n    | UnitSegment.horizontal x y, UnitSegment.horizontal x' y' => x' = x + 1 \u2227 y' = y\n    | UnitSegment.vertical x y, UnitSegment.vertical x' y' => x' = x \u2227 y' = y + 1\n    | _, _ => False\n  /-- Every segment appears exactly once in either corners or length2 -/\n  partition : \u2200 s : UnitSegment, \n    (\u2203! p \u2208 corners, s = p.1 \u2228 s = p.2) \u2228 \n    (\u2203! p \u2208 length2, s = p.1 \u2228 s = p.2)\n\ntheorem no_partition_with_21_length2 :\n  \u00ac\u2203 (p : GridPartition), p.length2.card = 21 :=\n  sorry"}
{"id": "CombStruct4Lean_212", "informal_problem": "11.8. In a boarding school, 9 subjects are taught and 512 children are enrolled, accommodated in 256 double rooms (children living in the same room are called neighbors). It is known that any two children have different sets of subjects they are interested in (in particular, exactly one child is not interested in anything). Prove that all the children can be arranged in a circle so that any two neighbors stand next to each other, and for any two non-neighbors standing next to each other, one of them is interested in all the subjects the other is interested in, plus exactly one additional subject.\n\n(D. Fon-Der-Flaass)", "formal_statement": "import Mathlib\n\nopen Set Function Finset\n\nstructure School where\n  /-- The set of all subjects -/\n  subjects : Finset (Fin 9)\n  /-- All subjects are included -/\n  subject_complete : subjects = Finset.univ\n  /-- The set of all students -/\n  students : Finset (Fin 512)\n  /-- All student slots are filled -/\n  student_complete : students = Finset.univ\n  /-- The rooming arrangement: maps students to their room numbers -/\n  room : Fin 512 \u2192 Fin 256\n  /-- Each room has exactly two students (neighbors) -/\n  room_pairs : \u2200 r : Fin 256, \u2203! p : Fin 512 \u00d7 Fin 512,\n    p.1 \u2260 p.2 \u2227 room p.1 = r \u2227 room p.2 = r\n  /-- Room assignment is surjective -/\n  room_surjective : Surjective room\n  /-- The subjects each student is interested in -/\n  interests : Fin 512 \u2192 Finset (Fin 9)\n  /-- Any two students have different sets of interests -/\n  distinct_interests : \u2200 s\u2081 s\u2082, s\u2081 \u2260 s\u2082 \u2192 interests s\u2081 \u2260 interests s\u2082\n  /-- Exactly one student is not interested in anything -/\n  exists_uninterested : \u2203! s, interests s = \u2205\n\n/-- Two students are neighbors if they share the same room -/\ndef are_neighbors (school : School) (s\u2081 s\u2082 : Fin 512) : Prop :=\n  school.room s\u2081 = school.room s\u2082 \u2227 s\u2081 \u2260 s\u2082\n\n/-- One student's interests properly contain another's with exactly one extra subject -/\ndef proper_interest_containment (school : School) (s\u2081 s\u2082 : Fin 512) : Prop :=\n  school.interests s\u2081 \u2282 school.interests s\u2082 \u2227 \n  (school.interests s\u2082).card = (school.interests s\u2081).card + 1\n\ntheorem exists_circular_arrangement (school : School) :\n  \u2203 \u03c3 : Equiv.Perm (Fin 512),\n    \u2200 i : Fin 512,\n      let j := \u03c3 i\n      let k := \u03c3 ((i + 1) % 512 : Fin 512)\n      are_neighbors school j k \u2228\n      proper_interest_containment school j k \u2228\n      proper_interest_containment school k j :=\n  sorry"}
{"id": "CombStruct4Lean_213", "informal_problem": "7.1. Masha surveyed her friends from her ensemble and received the following answers: 25 of them study mathematics, 30 have been to Moscow, 28 have traveled by train. Among those who have traveled by train, 18 study mathematics and 17 have been to Moscow. 16 friends study mathematics and have been to Moscow, and among them, 15 have also traveled by train. At the same time, there are only 45 girls in the ensemble. Is this possible?", "formal_statement": "import Mathlib\n\nstructure ValidCounts where\n  math : Nat\n  moscow : Nat\n  train : Nat\n  math_train : Nat\n  moscow_train : Nat\n  math_moscow : Nat\n  math_moscow_train : Nat\n  total : Nat\n  -- Basic size constraints\n  h_total : total = 45\n  h_math_le : math \u2264 total\n  h_moscow_le : moscow \u2264 total\n  h_train_le : train \u2264 total\n  -- Intersection constraints\n  h_math_train_le : math_train \u2264 math\n  h_math_train_le_train : math_train \u2264 train\n  h_moscow_train_le : moscow_train \u2264 moscow\n  h_moscow_train_le_train : moscow_train \u2264 train\n  h_math_moscow_le_math : math_moscow \u2264 math\n  h_math_moscow_le_moscow : math_moscow \u2264 moscow\n  h_triple_le_math_train : math_moscow_train \u2264 math_train\n  h_triple_le_moscow_train : math_moscow_train \u2264 moscow_train\n  h_triple_le_math_moscow : math_moscow_train \u2264 math_moscow\n  -- Inclusion-exclusion constraints\n  h_math_moscow_sum : math_moscow + math_train - math_moscow_train \u2264 math\n  h_moscow_train_sum : moscow_train + math_moscow - math_moscow_train \u2264 moscow\n  h_math_train_sum : math_train + moscow_train - math_moscow_train \u2264 train\n\ntheorem ensemble_possible : \u2203 (counts : ValidCounts), \n  counts.total = 45 \u2227\n  counts.math = 25 \u2227 \n  counts.moscow = 30 \u2227 \n  counts.train = 28 \u2227 \n  counts.math_train = 18 \u2227 \n  counts.moscow_train = 17 \u2227 \n  counts.math_moscow = 16 \u2227 \n  counts.math_moscow_train = 15 :=\n  sorry"}
{"id": "CombStruct4Lean_214", "informal_problem": "10.4 On the Unified State Exam (USE) in mathematics, 333 students made a total of 1000 mistakes. Prove that in this case, the number of students who made more than 5 mistakes is no greater than the number of students who made fewer than 4 mistakes.", "formal_statement": "import Mathlib\n\nstructure ExamResults where\n  totalStudents : Nat\n  totalMistakes : Nat\n  mistakeCount : Fin totalStudents \u2192 Nat\n  sum_constraint : (Finset.sum Finset.univ mistakeCount) = totalMistakes\n\n/-- Number of students who made more than n mistakes -/\ndef studentsAbove (results : ExamResults) (n : Nat) : Nat :=\n  Finset.card (Finset.filter (fun i => results.mistakeCount i > n) Finset.univ)\n\n/-- Number of students who made fewer than n mistakes -/\ndef studentsBelow (results : ExamResults) (n : Nat) : Nat :=\n  Finset.card (Finset.filter (fun i => results.mistakeCount i < n) Finset.univ)\n\ntheorem exam_mistakes_distribution \n  (results : ExamResults)\n  (h1 : results.totalStudents = 333)\n  (h2 : results.totalMistakes = 1000) :\n  studentsAbove results 5 \u2264 studentsBelow results 4 :=\n  sorry"}
{"id": "CombStruct4Lean_215", "informal_problem": "5. In the tournament, 49 chess players participated. At a certain point in the tournament, 83 games had been played, and each participant had played either three or four games (and no one played each other twice). Could it have been the case that no two players who played exactly three games played against each other?\n\nAnswer: No.", "formal_statement": "import Mathlib\n\nstructure ChessTournament where\n  n : Nat                                    -- number of players\n  games_played : Nat                         -- total number of games played\n  player_games : Fin n \u2192 Nat                 -- number of games each player played\n  played_against : Fin n \u2192 Fin n \u2192 Bool      -- whether player i played against j\n  \n  no_self_games : \u2200 i, \u00acplayed_against i i  -- players don't play against themselves\n  symmetric : \u2200 i j, played_against i j = played_against j i  -- symmetry of games\n  games_count_valid : \u2200 i, player_games i = 3 \u2228 player_games i = 4  -- each played 3 or 4 games\n  total_games_match : games_played = (\u2211 i, player_games i) / 2  -- total games matches sum of games\n  no_repeats : \u2200 i j, played_against i j \u2192 \u00ac(\u2203 k, k \u2260 j \u2227 played_against i k)  -- no repeated games\n\ntheorem chess_tournament_three_games_must_play \n  (t : ChessTournament) \n  (h1 : t.n = 49) \n  (h2 : t.games_played = 83) : \n  \u2203 i j, i \u2260 j \u2227 \n    t.player_games i = 3 \u2227 \n    t.player_games j = 3 \u2227 \n    t.played_against i j := \n  sorry"}
{"id": "CombStruct4Lean_216", "informal_problem": "9.4. In a volleyball tournament, 110 teams participated, each playing exactly one game with each of the others (there are no ties in volleyball). It turned out that in any group of 55 teams, there is one that lost to no more than four of the other 54 teams in this group. Prove that in the entire tournament, there is a team that lost to no more than four of the other 109 teams. (S. Berlov)", "formal_statement": "import Mathlib\n\n/-- A tournament where each team plays exactly one game against every other team.\n    `games i j = true` means team i won against team j -/\nstructure Tournament (n : Nat) where\n  games : Fin n \u2192 Fin n \u2192 Bool\n  no_self_games : \u2200 i, \u00ac(games i i)\n  antisymmetric : \u2200 i j, i \u2260 j \u2192 games i j = !games j i\n\n/-- Count number of losses for a team against all other teams -/\ndef countLosses {n : Nat} (t : Tournament n) (team : Fin n) (opponents : Finset (Fin n)) : Nat :=\n  (opponents.filter (fun opp => t.games opp team)).card\n\ntheorem volleyball_tournament_property\n  (t : Tournament 110)\n  (h_subgroup : \u2200 (teams : Finset (Fin 110)), teams.card = 55 \u2192 \n    \u2203 team \u2208 teams, countLosses t team teams \u2264 4) :\n  \u2203 team : Fin 110, countLosses t team (Finset.univ) \u2264 4 :=\n  sorry"}
{"id": "CombStruct4Lean_217", "informal_problem": "5. Any two strangers in the company have exactly two common acquaintances. Dina and Tolya are acquainted with each other, but they do not have any common acquaintances. Prove that Dina and Tolya have the same number of acquaintances in this company.", "formal_statement": "import Mathlib\n\nstructure Company where\n  people : Type\n  acquainted : people \u2192 people \u2192 Prop\n  -- Acquaintance relation is symmetric\n  symm : \u2200 x y, acquainted x y \u2192 acquainted y x\n  -- No one is acquainted with themselves\n  irrefl : \u2200 x, \u00acacquainted x x\n  -- Two strangers have exactly two common acquaintances\n  two_common : \u2200 x y, \u00acacquainted x y \u2192 \n    \u2203 (s : Finset people), s.card = 2 \u2227 \n    \u2200 z, z \u2208 s \u2194 (acquainted x z \u2227 acquainted y z)\n\n/-- Count of acquaintances for a person -/\ndef acquaintance_count (C : Company) [Fintype C.people] [DecidableRel C.acquainted]\n    (p : C.people) : \u2115 :=\n  (Finset.filter (C.acquainted p) Finset.univ).card\n\ntheorem dina_tolya_same_acquaintances \n  (C : Company) [Fintype C.people] [DecidableRel C.acquainted]\n  (dina tolya : C.people)\n  (are_acquainted : C.acquainted dina tolya)\n  (no_common : \u2200 z, z \u2260 dina \u2192 z \u2260 tolya \u2192 \u00ac(C.acquainted dina z \u2227 C.acquainted tolya z)) :\n  acquaintance_count C dina = acquaintance_count C tolya :=\nsorry"}
{"id": "CombStruct4Lean_218", "informal_problem": "2. Schoolchildren from grades 6 to 11 participate in the olympiad. The chairman of the jury knows that exactly 1000 schoolchildren will come, but does not know their distribution by grades. He has exactly 500 sheets of paper. Two copies of the conditions (one on the left, one on the right) are printed on one sheet; different grades can be printed, or the same grade can be printed on both sides.\n\nWith one command to the printer, any number of identical sheets can be printed. For example, the chairman can command the printer to print 142 sheets of the type \"7th grade + 10th grade\". The chairman is confident that when he learns the distribution of participants by grades, he will need only 6 commands to the printer to print all 1000 necessary conditions. Is he right?", "formal_statement": "import Mathlib\n\n-- Grades 6-11 mapped to 0-5\nabbrev Grade := Fin 6\n\n/-- A distribution of students across grades summing to 1000 -/\nstructure Distribution where\n  counts : Grade \u2192 Nat  -- Non-negativity automatically enforced by Nat\n  sum_valid : (Finset.univ : Finset Grade).sum counts = 1000\n\n/-- A single printer command specifying grades to print and number of copies -/\nstructure PrinterCommand where\n  leftGrade : Grade\n  rightGrade : Grade\n  copies : Nat\n  copies_pos : 0 < copies\n  sheet_bound : copies \u2264 500\n\n/-- Count how many copies of a specific grade are produced by a command -/\ndef copiesOfGrade (cmd : PrinterCommand) (g : Grade) : Nat :=\n  cmd.copies * (if cmd.leftGrade = g then 1 else 0 + if cmd.rightGrade = g then 1 else 0)\n\n/-- Total number of sheets used by a list of commands -/\ndef totalSheets (cmds : List PrinterCommand) : Nat :=\n  List.sum (List.map (fun cmd => cmd.copies) cmds)\n\n/-- Count total copies of a grade produced by a list of commands -/\ndef gradeCount (cmds : List PrinterCommand) (g : Grade) : Nat :=\n  List.sum (List.map (fun cmd => copiesOfGrade cmd g) cmds)\n\n/-- Whether a list of commands satisfies a given distribution -/\ndef satisfiesDistribution (cmds : List PrinterCommand) (d : Distribution) : Prop :=\n  \u2200 g : Grade, gradeCount cmds g = d.counts g\n\ntheorem olympiad_printing_possible (d : Distribution) : \n  \u2203 (cmds : List PrinterCommand), \n    cmds.length \u2264 6 \u2227  -- at most 6 commands\n    totalSheets cmds \u2264 500 \u2227  -- at most 500 sheets total\n    satisfiesDistribution cmds d :=\n  sorry"}
{"id": "CombStruct4Lean_219", "informal_problem": "11.5. From the integers from 0 to 1000, 101 numbers were chosen. Prove that among the absolute values of their pairwise differences, there are ten different numbers not exceeding 100.\n\n(I. Bogdanov)", "formal_statement": "import Mathlib\n\n-- Convert natural numbers to integers and compute absolute difference\ndef absDiff (a b : \u2115) : \u2115 := ((\u2191a - \u2191b : \u2124).natAbs)\n\n-- Set of all pairwise absolute differences for a finite set of naturals\ndef pairwiseDiffs (S : Finset \u2115) : Finset \u2115 :=\n  (S.product S).filter (fun p => p.1 \u2260 p.2)\n    |>.image (fun p => absDiff p.1 p.2)\n\n-- Set of pairwise differences not exceeding given bound\ndef smallDiffs (S : Finset \u2115) (bound : \u2115) : Finset \u2115 :=\n  (pairwiseDiffs S).filter (fun x => x \u2264 bound)\n\ntheorem bogdanov_differences \n  (S : Finset \u2115) \n  (bound : \u2115 := 1000)\n  (h1 : S.card = 101)\n  (h2 : \u2200 x \u2208 S, x \u2264 bound) :\n  \u2203 D : Finset \u2115, \n    D \u2286 smallDiffs S 100 \u2227 \n    D.card = 10 :=\n  sorry"}
{"id": "CombStruct4Lean_220", "informal_problem": "4. There are 15 students in the class. For homework, they were assigned 6 geometry problems. More than half of the students solved each problem.\n\nProve that there will be two students who, together, solved all 6 problems.", "formal_statement": "import Mathlib\n\nopen Finset\n\nstructure HomeworkSolutions where\n  solved : Fin 15 \u2192 Finset (Fin 6)\n  solutions_valid : \u2200 s : Fin 15, solved s \u2286 univ\n  more_than_half : \u2200 p : Fin 6, \n    (univ.filter (fun s => p \u2208 solved s)).card > 7\n\ntheorem homework_pigeonhole (h : HomeworkSolutions) : \n  \u2203 s\u2081 s\u2082 : Fin 15, s\u2081 \u2260 s\u2082 \u2227 (h.solved s\u2081 \u222a h.solved s\u2082) = univ :=\n  sorry"}
{"id": "CombStruct4Lean_221", "informal_problem": "5. 7 ginger and 7 black kittens are drinking water from a round basin. Is it true that there will be a kitten whose both neighbors are black kittens?\n\n#", "formal_statement": "import Mathlib\n\nstructure KittenCircle where\n  black_positions : Finset (Fin 14)\n  count_valid : black_positions.card = 7\n\ndef are_neighbors (i j : Fin 14) : Bool :=\n  i.val = (j.val + 1) % 14 \u2228 j.val = (i.val + 1) % 14\n\ntheorem exists_black_neighbors :\n  \u2200 (c : KittenCircle), \u2203 (i : Fin 14),\n    \u2200 j : Fin 14, are_neighbors i j \u2192 j \u2208 c.black_positions :=\n  sorry"}
{"id": "CombStruct4Lean_222", "informal_problem": "11.5. In 50 baskets, there are cucumbers, eggplants, and tomatoes. Prove that it is possible to choose 26 baskets such that they contain no less than half of all cucumbers (by count), no less than half of all eggplants, and no less than half of all tomatoes (also by count).\n\n#", "formal_statement": "import Mathlib\n\nstructure Basket where\n  cucumbers : Nat\n  eggplants : Nat\n  tomatoes : Nat\n\n/-- Given a list of baskets, compute the total count of each vegetable -/\ndef totalVegetables (baskets : List Basket) : Basket :=\n  let total := baskets.foldl (fun acc b => \u27e8\n    acc.cucumbers + b.cucumbers,\n    acc.eggplants + b.eggplants,\n    acc.tomatoes + b.tomatoes\n  \u27e9) \u27e80, 0, 0\u27e9\n  total\n\n/-- Check if a subset of baskets contains at least half of each vegetable type -/\ndef containsHalfOfEach (subset baskets : List Basket) : Prop :=\n  let subTotal := totalVegetables subset\n  let total := totalVegetables baskets\n  2 * subTotal.cucumbers \u2265 total.cucumbers \u2227\n  2 * subTotal.eggplants \u2265 total.eggplants \u2227\n  2 * subTotal.tomatoes \u2265 total.tomatoes\n\ntheorem basket_selection_theorem (baskets : List Basket)\n  (h1 : baskets.length = 50) :\n  \u2203 (subset : List Basket),\n    subset.length = 26 \u2227\n    subset.Sublist baskets \u2227\n    containsHalfOfEach subset baskets :=\n  sorry"}
{"id": "CombStruct4Lean_223", "informal_problem": "9.4. Given 9 different natural numbers, not greater than 19. Prove that among their pairwise differences, there will be three that are the same in absolute value.", "formal_statement": "import Mathlib\n\ndef AbsDiff (a b : \u2115) : \u2115 := \n  if a \u2265 b then a - b else b - a\n\nstructure NumberSelection where\n  nums : Fin 9 \u2192 \u2115 \n  distinct : \u2200 i j, i \u2260 j \u2192 nums i \u2260 nums j\n  bound : \u2200 i, nums i \u2264 19\n\ntheorem three_equal_diffs (sel : NumberSelection) : \n  \u2203 (i\u2081 j\u2081 i\u2082 j\u2082 i\u2083 j\u2083 : Fin 9), \n    i\u2081 \u2260 j\u2081 \u2227 i\u2082 \u2260 j\u2082 \u2227 i\u2083 \u2260 j\u2083 \u2227\n    (i\u2081, j\u2081) \u2260 (i\u2082, j\u2082) \u2227 (i\u2081, j\u2081) \u2260 (i\u2083, j\u2083) \u2227 (i\u2082, j\u2082) \u2260 (i\u2083, j\u2083) \u2227\n    AbsDiff (sel.nums i\u2081) (sel.nums j\u2081) = AbsDiff (sel.nums i\u2082) (sel.nums j\u2082) \u2227\n    AbsDiff (sel.nums i\u2081) (sel.nums j\u2081) = AbsDiff (sel.nums i\u2083) (sel.nums j\u2083) :=\n  sorry"}
{"id": "CombStruct4Lean_224", "informal_problem": "5. Katya wrote down the set $X=\\{1,2,3,4,5,6,7,8,9\\}$ in her notebook and decided to split it into two subsets. Prove that no matter how Katya splits the set into two subsets, at least one of the resulting subsets will contain three numbers such that the sum of two of them is twice the third.", "formal_statement": "import Mathlib\n\ndef has_sum_twice_relation (s : Set Nat) : Prop :=\n  \u2203 (a b c : Nat), a \u2208 s \u2227 b \u2208 s \u2227 c \u2208 s \u2227 a + b = 2 * c\n\ntheorem katya_set_split :\n  let X : Set Nat := {1, 2, 3, 4, 5, 6, 7, 8, 9}\n  \u2200 (A B : Set Nat), A \u222a B = X \u2192 A \u2229 B = \u2205 \u2192\n    has_sum_twice_relation A \u2228 has_sum_twice_relation B :=\n  sorry"}
{"id": "CombStruct4Lean_225", "informal_problem": "5. Can a $50 \\times 50$ square be cut into strips of $1 \\times 4$?", "formal_statement": "import Mathlib\n\nstructure Strip where\n  pos_x : Nat\n  pos_y : Nat\n  horizontal : Bool -- true if strip is horizontal, false if vertical\n\ndef validStrip (s : Strip) (n : Nat) : Bool :=\n  if s.horizontal then\n    s.pos_x + 4 \u2264 n \u2227 s.pos_y < n -- horizontal strip must fit within grid\n  else\n    s.pos_x < n \u2227 s.pos_y + 4 \u2264 n -- vertical strip must fit within grid\n\ndef coversSquare (strips : List Strip) (n : Nat) : Prop :=\n  \u2200 (x y : Nat), x < n \u2192 y < n \u2192\n    \u2203 (s : Strip), s \u2208 strips \u2227\n      (if s.horizontal then\n        s.pos_x \u2264 x \u2227 x < s.pos_x + 4 \u2227 s.pos_y = y\n      else\n        s.pos_y \u2264 y \u2227 y < s.pos_y + 4 \u2227 s.pos_x = x)\n\ntheorem square_50_strip_cover : \n  \u2203 (strips : List Strip), \n    (\u2200 s \u2208 strips, validStrip s 50) \u2227 \n    coversSquare strips 50 :=\n  sorry"}
{"id": "CombStruct4Lean_226", "informal_problem": "4. (3 points) In a certain country, there are 800 cities and 8 airlines. Any two cities are connected by flights of one of the eight airlines. Can we assert that there will be an airline and more than 200 cities, between any two of which it is possible to travel using flights of this airline (possibly with layovers)?", "formal_statement": "import Mathlib\n\nstructure AirlineNetwork where\n  numCities : Nat\n  numAirlines : Nat\n  -- flights[a][i][j] means airline a has a direct flight between cities i and j\n  flights : Fin numAirlines \u2192 Fin numCities \u2192 Fin numCities \u2192 Prop\n  -- Every pair of cities is connected by some airline\n  complete : \u2200 (i j : Fin numCities), i \u2260 j \u2192\n    \u2203 (a : Fin numAirlines), flights a i j\n\n-- Define reachability inductively for a specific airline\ninductive Reachable (net : AirlineNetwork) (a : Fin net.numAirlines) : \n  Fin net.numCities \u2192 Fin net.numCities \u2192 Prop where\n  | direct {i j} : net.flights a i j \u2192 Reachable net a i j\n  | trans {i j k} : Reachable net a i j \u2192 Reachable net a j k \u2192 \n      Reachable net a i k\n\ntheorem ramsey_airlines \n    (net : AirlineNetwork) \n    (h1 : net.numCities = 800) \n    (h2 : net.numAirlines = 8) :\n  \u2203 (a : Fin net.numAirlines) (cities : Finset (Fin net.numCities)),\n    -- The set has more than 200 cities\n    cities.card > 200 \u2227 \n    -- Any two cities in the set are reachable using only flights from airline a\n    \u2200 (i j : Fin net.numCities), i \u2208 cities \u2192 j \u2208 cities \u2192 \n      Reachable net a i j :=\n  sorry"}
{"id": "CombStruct4Lean_227", "informal_problem": "12. The king has 100 greyhounds, and he wants to select three for hunting. He gathered 100 courtiers and asked each one which three dogs they consider the fastest. It turned out that for any two courtiers, there are two dogs that both of them pointed out. Prove that the choice of some two courtiers completely coincided.", "formal_statement": "import Mathlib\n\nstructure CourtierChoice where\n  dogs : Finset (Fin 100)\n  size_is_three : dogs.card = 3\n\nstructure GreyhoundSelection where\n  choices : Finset (Fin 100 \u00d7 CourtierChoice)\n  choices_size : choices.card = 100\n  choices_valid : \u2200 i, \u2203! c, (i, c) \u2208 choices\n  any_two_share_two : \u2200 i j : Fin 100, i \u2260 j \u2192 \n    \u2200 ci cj, (i, ci) \u2208 choices \u2192 (j, cj) \u2208 choices \u2192\n    (ci.dogs \u2229 cj.dogs).card \u2265 2\n\ntheorem greyhound_coincidence (selection : GreyhoundSelection) :\n  \u2203 i j : Fin 100, i \u2260 j \u2227 \n    (\u2203 ci cj, (i, ci) \u2208 selection.choices \u2227 \n              (j, cj) \u2208 selection.choices \u2227 ci = cj) :=\n  sorry"}
{"id": "CombStruct4Lean_228", "informal_problem": "44. Let similar sizes be those that differ by no more than $\\sqrt{2}$ times. Prove that it is impossible to make 3 piles from the original pile.", "formal_statement": "import Mathlib\n\nstructure PileSplit where\n  piles : Fin 3 \u2192 \u211d\n  sum_to_original : (\u2211 i, piles i) = 1\n  all_positive : \u2200 i, piles i > 0\n  similar_sizes : \u2200 i j, piles i \u2264 Real.sqrt 2 * piles j\n\ntheorem no_three_similar_piles : \u00ac\u2203 (split : PileSplit), True :=\n  sorry"}
{"id": "CombStruct4Lean_229", "informal_problem": "46. Let similar sizes be those that differ by less than a factor of 2. Prove that a pile of 660 stones can be divided into 30 piles.", "formal_statement": "import Mathlib\n\nstructure StonePile where\n  size : Nat\n  valid : size > 0\n\ndef similar (p1 p2 : StonePile) : Prop :=\n  2 * p1.size > p2.size \u2227 2 * p2.size > p1.size\n\ndef validPartition (total : Nat) (piles : Fin n \u2192 StonePile) : Prop :=\n  (\u2200 i j : Fin n, similar (piles i) (piles j)) \u2227\n  (\u2211 i : Fin n, (piles i).size) = total\n\ntheorem stone_pile_partition :\n  \u2203 (piles : Fin 30 \u2192 StonePile), validPartition 660 piles :=\n  sorry"}
{"id": "CombStruct4Lean_230", "informal_problem": "1. Prove that if in a country any two schools are connected by exactly one direct route, then this country is harmonious.\n\n#", "formal_statement": "import Mathlib\n\nuniverse u v\n\nstructure Country (School : Type u) (Route : Type v) where\n  schools : Set School\n  routes : Set Route\n  connects : Route \u2192 School \u00d7 School\n  route_exists : \u2200 (s\u2081 s\u2082 : School), s\u2081 \u2208 schools \u2192 s\u2082 \u2208 schools \u2192 s\u2081 \u2260 s\u2082 \u2192\n    \u2203! (r : Route), r \u2208 routes \u2227 (connects r = (s\u2081, s\u2082) \u2228 connects r = (s\u2082, s\u2081))\n  valid_routes : \u2200 (r : Route), r \u2208 routes \u2192\n    let (s\u2081, s\u2082) := connects r\n    s\u2081 \u2208 schools \u2227 s\u2082 \u2208 schools \u2227 s\u2081 \u2260 s\u2082\n\ndef connected {School : Type u} {Route : Type v} (c : Country School Route) \n    (r : Route) (s\u2081 s\u2082 : School) : Prop :=\n  c.connects r = (s\u2081, s\u2082) \u2228 c.connects r = (s\u2082, s\u2081)\n\ndef forms_triangle {School : Type u} {Route : Type v} (c : Country School Route) \n    (s\u2081 s\u2082 s\u2083 : School) : Prop :=\n  s\u2081 \u2208 c.schools \u2227 s\u2082 \u2208 c.schools \u2227 s\u2083 \u2208 c.schools \u2227\n  s\u2081 \u2260 s\u2082 \u2227 s\u2082 \u2260 s\u2083 \u2227 s\u2081 \u2260 s\u2083 \u2227\n  \u2203 (r\u2081 r\u2082 r\u2083 : Route), r\u2081 \u2208 c.routes \u2227 r\u2082 \u2208 c.routes \u2227 r\u2083 \u2208 c.routes \u2227\n    connected c r\u2081 s\u2081 s\u2082 \u2227 connected c r\u2082 s\u2082 s\u2083 \u2227 connected c r\u2083 s\u2081 s\u2083\n\ndef harmonious {School : Type u} {Route : Type v} (c : Country School Route) : Prop :=\n  \u2200 (s\u2081 s\u2082 s\u2083 : School), s\u2081 \u2208 c.schools \u2192 s\u2082 \u2208 c.schools \u2192 s\u2083 \u2208 c.schools \u2192\n  s\u2081 \u2260 s\u2082 \u2192 s\u2082 \u2260 s\u2083 \u2192 s\u2081 \u2260 s\u2083 \u2192 forms_triangle c s\u2081 s\u2082 s\u2083\n\ntheorem country_harmonious {School : Type u} {Route : Type v} \n    (c : Country School Route) : harmonious c :=\n  sorry"}
{"id": "CombStruct4Lean_231", "informal_problem": "6. A $3 \\times 3$ grid is filled with numbers from 1 to 9, as shown on the right. Can two more $3 \\times 3$ grids be filled with the same numbers so that the following condition is met: any two numbers can be adjacent (by side) in no more than one of the three\n\n| 1 | 2 | 3 |\n| :--- | :--- | :--- |\n| 4 | 5 | 6 |\n| 7 | 8 | 9 |\n\ngrids?", "formal_statement": "import Mathlib\n\n/-- A valid 3x3 grid containing numbers 1-9 exactly once -/\nstructure Grid where\n  values : Fin 3 \u2192 Fin 3 \u2192 Fin 9\n  all_different : \u2200 i\u2081 j\u2081 i\u2082 j\u2082, (i\u2081 \u2260 i\u2082 \u2228 j\u2081 \u2260 j\u2082) \u2192 values i\u2081 j\u2081 \u2260 values i\u2082 j\u2082\n  all_used : \u2200 n : Fin 9, \u2203 i j, values i j = n\n\n/-- Two positions in a 3x3 grid are adjacent if they share a side -/\ndef is_adjacent (i\u2081 j\u2081 i\u2082 j\u2082 : Fin 3) : Bool :=\n  (i\u2081 = i\u2082 \u2227 (j\u2081.val + 1 = j\u2082.val \u2228 j\u2082.val + 1 = j\u2081.val)) \u2228\n  (j\u2081 = j\u2082 \u2227 (i\u2081.val + 1 = i\u2082.val \u2228 i\u2082.val + 1 = i\u2081.val))\n\n/-- Check if two numbers are adjacent in a given grid -/\ndef numbers_adjacent_in_grid (n\u2081 n\u2082 : Fin 9) (g : Grid) : Bool :=\n  \u2203 i\u2081 j\u2081 i\u2082 j\u2082, g.values i\u2081 j\u2081 = n\u2081 \u2227 \n                  g.values i\u2082 j\u2082 = n\u2082 \u2227 \n                  is_adjacent i\u2081 j\u2081 i\u2082 j\u2082\n\n/-- Standard grid pattern with numbers 1-9 in order -/\ndef is_standard_grid (g : Grid) : Prop :=\n  g.values 0 0 = 1 \u2227 g.values 0 1 = 2 \u2227 g.values 0 2 = 3 \u2227\n  g.values 1 0 = 4 \u2227 g.values 1 1 = 5 \u2227 g.values 1 2 = 6 \u2227\n  g.values 2 0 = 7 \u2227 g.values 2 1 = 8 \u2227 g.values 2 2 = 9\n\ntheorem three_grids_exist (first : Grid) (h : is_standard_grid first) :\n  \u2203 (second third : Grid),\n    -- For any two distinct numbers\n    \u2200 n\u2081 n\u2082 : Fin 9, n\u2081 \u2260 n\u2082 \u2192\n      -- Count how many grids have these numbers adjacent\n      let count := (numbers_adjacent_in_grid n\u2081 n\u2082 first).toNat +\n                   (numbers_adjacent_in_grid n\u2081 n\u2082 second).toNat +\n                   (numbers_adjacent_in_grid n\u2081 n\u2082 third).toNat\n      -- The count must not exceed 1\n      count \u2264 1 :=\n  sorry"}
{"id": "CombStruct4Lean_232", "informal_problem": "6. In the cells of an infinitely long tape, natural numbers are recorded in order. Vasisuaili Lokhankin and Engineer Ptiburdikov took out cardboard rectangles marked with cells of the same size. Each cut out several cells in one row of their rectangle. At the same time, Vasisuaili cut out one more hole than Ptiburdikov. Now they want to place their figures on the tape so that the cut-out cells overlap the cells of the tape. Prove that this can be done in such a way that the sum of the numbers visible through the holes of one figure coincides with the sum of the numbers visible through the holes of the other.", "formal_statement": "import Mathlib\n\nstructure TapeHoles where\n  startPos : \u2115  -- Starting position on the infinite tape\n  holes : List \u2115 -- List of relative positions of holes from startPos\n\ndef sumAtPosition (t : TapeHoles) : \u2115 :=\n  let tapeNumbers := fun i => i + 1  -- Infinite tape with natural numbers\n  (t.holes.map fun offset => tapeNumbers (t.startPos + offset)).sum\n\ntheorem holes_equal_sum_exists \n  (vHoles vStart pHoles pStart : \u2115) \n  (h_holes : vHoles = pHoles + 1) -- Vasisuaili has one more hole than Ptiburdikov\n  (h_positive : vHoles > 0) :\n  \u2203 (v p : TapeHoles),\n    v.holes.length = vHoles \u2227 \n    p.holes.length = pHoles \u2227\n    sumAtPosition v = sumAtPosition p :=\n  sorry"}
{"id": "CombStruct4Lean_233", "informal_problem": "6. A pile contains 2017 stones. On the $i$-th move, one of the existing piles is split into two non-empty piles, after which $i$ stones are added to one of them. Can it happen that after two or more moves, all piles have an equal number of stones?", "formal_statement": "import Mathlib\n\nstructure GameState where\n  piles : List Nat\n  moveCount : Nat\n\ndef totalStonesAdded (moves : Nat) : Nat :=\n  moves * (moves + 1) / 2\n\ndef totalStones (gs : GameState) (initialStones : Nat) : Nat :=\n  initialStones + totalStonesAdded gs.moveCount\n\ndef allPilesEqual (piles : List Nat) : Prop :=\n  \u2200 x \u2208 piles, \u2200 y \u2208 piles, x = y\n\ndef isValidGameState (gs : GameState) (initialStones : Nat) : Prop :=\n  gs.piles.sum = totalStones gs initialStones\n\ntheorem stone_splitting_game_equal_impossible (initialStones : Nat) (h : initialStones = 2017) :\n  \u00ac\u2203 (gs : GameState),\n    gs.moveCount \u2265 2 \u2227\n    gs.piles.length > 1 \u2227\n    isValidGameState gs initialStones \u2227\n    allPilesEqual gs.piles :=\n  sorry"}
{"id": "CombStruct4Lean_234", "informal_problem": "7. In the detachment, there are one hundred people, and each has three friends in the detachment. For duty, it is required to appoint groups of three people, each of whom is friends with each other. For 99 consecutive days, it was possible to appoint such groups of three without repeating them. Prove that this will also be possible on the hundredth day.", "formal_statement": "import Mathlib\n\nstructure Detachment where\n  people : Finset (Fin 100)\n  friends : Fin 100 \u2192 Finset (Fin 100)\n  total_count : people.card = 100\n  three_friends : \u2200 p, (friends p).card = 3\n  symmetric : \u2200 p q, q \u2208 friends p \u2194 p \u2208 friends q\n  irreflexive : \u2200 p, p \u2209 friends p\n\nstructure DutyGroup (d : Detachment) where\n  members : Finset (Fin 100)\n  card_eq : members.card = 3\n  all_friends : \u2200 {p q}, p \u2208 members \u2192 q \u2208 members \u2192 p \u2260 q \u2192 q \u2208 d.friends p\n\ndef Schedule (d : Detachment) (days : \u2115) := Fin days \u2192 DutyGroup d\n\ntheorem detachment_scheduling \n  (d : Detachment)\n  (schedule : Schedule d 99)\n  (distinct_groups : \u2200 i j : Fin 99, i \u2260 j \u2192 schedule i \u2260 schedule j) :\n  \u2203 (group : DutyGroup d), \n    (\u2200 i : Fin 99, schedule i \u2260 group) \u2227 \n    (\u2200 p \u2208 group.members, p \u2208 d.people) :=\n  sorry"}
{"id": "CombStruct4Lean_235", "informal_problem": "2. A circle is divided into 1000 sectors, all of which are white. Every minute, some 500 consecutive sectors are repainted - white sectors become red, and red sectors become white. At a certain repainting, the number of white sectors did not change. Prove that for one of the neighboring (previous or next) repaintings - it also did not change.\n\n#", "formal_statement": "import Mathlib\n\nstructure CircleState where\n  sectors : Fin 1000 \u2192 Bool  -- True represents white, False represents red\n  \ndef count_white (state : CircleState) : Nat :=\n  (Finset.univ.filter (fun i => state.sectors i)).card\n\n/-- Represents a repainting operation that flips 500 consecutive sectors -/\ndef repainting (start : Fin 1000) (state : CircleState) : CircleState where\n  sectors := fun i => \n    if (i - start) % 1000 < 500 \n    then !state.sectors i \n    else state.sectors i\n\ntheorem consecutive_unchanged_repaintings \n  (t : Nat) (start : Fin 1000) (state : CircleState)\n  (h : count_white (repainting start state) = count_white state) :\n  \u2203 start_next : Fin 1000,\n    count_white (repainting start_next (repainting start state)) = \n    count_white (repainting start state) \u2228\n    \u2203 start_prev : Fin 1000,\n    count_white (repainting start_prev state) = count_white state :=\n  sorry"}
{"id": "CombStruct4Lean_236", "informal_problem": "7. In a row, there are 50 boys and 50 girls standing in some order. In this row, there is exactly one group of 30 children standing in a row, in which there are an equal number of boys and girls. Prove that there will be a group of 70 children standing in a row, in which there are also an equal number of boys and girls.", "formal_statement": "import Mathlib\n\ninductive Child where\n  | Boy\n  | Girl\n  deriving Repr, DecidableEq\n\nstructure ChildrenRow where\n  arrangement : List Child\n  len : arrangement.length = 100\n  boy_count : arrangement.countP (\u00b7 = Child.Boy) = 50\n\nstructure Segment where\n  start : Nat\n  len : Nat\n  h : start + len \u2264 100\n\n/-- Checks if a segment has equal number of boys and girls -/\ndef isBalanced (row : ChildrenRow) (seg : Segment) : Prop :=\n  let segment := (row.arrangement.drop seg.start).take seg.len\n  segment.countP (\u00b7 = Child.Boy) = segment.countP (\u00b7 = Child.Girl)\n\ntheorem equal_distribution_extension \n  (row : ChildrenRow)\n  (h\u2081 : \u2203 seg : Segment, seg.len = 30 \u2227 isBalanced row seg) :\n  \u2203 seg : Segment, seg.len = 70 \u2227 isBalanced row seg :=\n  sorry"}
{"id": "CombStruct4Lean_237", "informal_problem": "6. At a masquerade ball, there were 20 people. In each dance, two people participated - a boy and a girl. It turned out that ten of them danced with three partners, two (Sasha and Zhenya) - with five, and the remaining eight - with six. Prove that Sasha and Zhenya are of different genders.", "formal_statement": "import Mathlib\n\nstructure Ball where\n  people : Finset (Fin 20)\n  gender : Fin 20 \u2192 Bool  -- True for boys, False for girls\n  dances : Finset (Fin 20 \u00d7 Fin 20)\n  sasha : Fin 20\n  zhenya : Fin 20\n  \n  -- Each dance involves exactly two people of different genders\n  dance_valid : \u2200 d \u2208 dances, gender d.1 \u2260 gender d.2\n  \n  -- Number of dance partners for each person\n  partners_count : \u2200 p : Fin 20,\n    let count := (dances.filter (fun d \u21a6 d.1 = p \u2228 d.2 = p)).card\n    if p = sasha \u2228 p = zhenya then\n      count = 5\n    else if count = 3 then\n      (people.filter (fun x \u21a6 \n        (dances.filter (fun d \u21a6 d.1 = x \u2228 d.2 = x)).card = 3)).card = 10\n    else\n      count = 6\n\ntheorem sasha_zhenya_different_gender (b : Ball) : \n  b.gender b.sasha \u2260 b.gender b.zhenya :=\n  sorry"}
{"id": "CombStruct4Lean_238", "informal_problem": "4. The castle consists of 81 rooms in a square shape $9 * 9$. In some walls between adjacent rooms, there is one door. There are no doors to the outside, but each room has at least two doors. Prove that in some room, there are at least three doors.", "formal_statement": "import Mathlib\n\nstructure Castle where\n  n : Nat\n  doors : Fin n \u00d7 Fin n \u2192 Fin n \u00d7 Fin n \u2192 Bool  -- True if there's a door between rooms\n  adjacent : Fin n \u00d7 Fin n \u2192 Fin n \u00d7 Fin n \u2192 Bool -- True if rooms are adjacent\n  door_symmetry : \u2200 r\u2081 r\u2082, doors r\u2081 r\u2082 = doors r\u2082 r\u2081\n  door_adjacent : \u2200 r\u2081 r\u2082, doors r\u2081 r\u2082 \u2192 adjacent r\u2081 r\u2082\n  min_two_doors : \u2200 r, (\u2203 r\u2081 r\u2082, r\u2081 \u2260 r\u2082 \u2227 doors r r\u2081 \u2227 doors r r\u2082)\n\ndef door_count (c : Castle) (room : Fin c.n \u00d7 Fin c.n) : Nat :=\n  (Finset.filter (fun r => c.doors room r) (Finset.univ)).card\n\ntheorem castle_doors_existence (c : Castle) (h : c.n = 9) :\n  \u2203 room, door_count c room \u2265 3 :=\n  sorry"}
{"id": "CombStruct4Lean_239", "informal_problem": "5. Each of the 777 bankers has several safes. At a meeting, the Chief Oligarch gave each banker N diamonds and ordered them to distribute them among the safes so that each safe contains a different number of diamonds. The Chief Oligarch is certain that this task is feasible. Prove that the bankers can keep no more than two safes (and destroy the rest) so that the Chief Oligarch's task remains feasible (with the same value of N).\n\n#", "formal_statement": "import Mathlib\n\nstructure Banker where\n  safes : Finset \u2115  -- Set of numbers representing diamonds in each safe\n  total : \u2115        -- Total number of diamonds (N)\n  valid : (\u2211 n in safes, n) = total  -- Sum of diamonds equals N\n\ntheorem bankers_two_safes_sufficient \n  (bankers : Fin 777 \u2192 Banker)  -- 777 bankers\n  (h_valid : \u2200 b, (bankers b).safes.toSet.Pairwise (\u00b7\u2260\u00b7)) -- Different numbers in safes\n  : \u2203 (new_bankers : Fin 777 \u2192 Banker),\n    (\u2200 b, (new_bankers b).total = (bankers b).total) \u2227     -- Same N for each banker\n    (\u2200 b, (new_bankers b).safes.card \u2264 2) \u2227                -- At most 2 safes each\n    (\u2200 b, (new_bankers b).safes.toSet.Pairwise (\u00b7\u2260\u00b7))      -- Still different numbers\n  := sorry"}
{"id": "CombStruct4Lean_240", "informal_problem": "7. At a masquerade ball, there were 20 people. In each dance, two people participated. It turned out that eleven of them danced with three partners, one with five, and the remaining eight with six. Prove that in some dance, people of the same gender participated.", "formal_statement": "import Mathlib\n\nstructure Dance where\n  person1 : Fin 20\n  person2 : Fin 20\n  different : person1 \u2260 person2\n\nstructure BallData where\n  dances : List Dance\n  gender : Fin 20 \u2192 Bool  -- True for one gender, False for the other\n  partners : Fin 20 \u2192 Finset (Fin 20)\n  -- Properties about the number of partners\n  eleven_three : \u2203 people : Finset (Fin 20), \n    people.card = 11 \u2227 \n    \u2200 p \u2208 people, (partners p).card = 3\n  one_five : \u2203 p : Fin 20, (partners p).card = 5\n  eight_six : \u2203 people : Finset (Fin 20),\n    people.card = 8 \u2227\n    \u2200 p \u2208 people, (partners p).card = 6\n\ntheorem masquerade_ball_same_gender \n  (ball : BallData) : \n  \u2203 d : Dance, d \u2208 ball.dances \u2192 ball.gender d.person1 = ball.gender d.person2 :=\n  sorry"}
{"id": "CombStruct4Lean_241", "informal_problem": "6. There is a grid table, in which some cells are shaded. \"I can shade 5 more cells in each row,\" said Yakov, \"and then in each column there will be as many shaded cells as there are in each row now.\" \"And I can erase 3 cells in each column,\" Yuri replied, \"and then in each row there will be as many shaded cells as there are in each column now.\" Prove that one of them is wrong.", "formal_statement": "import Mathlib\n\nstructure Grid (m n : Nat) where\n  shaded : Fin m \u00d7 Fin n \u2192 Bool\n\ndef count_row {m n : Nat} (g : Grid m n) (r : Fin m) : Nat :=\n  Finset.card (Finset.filter (fun c => g.shaded (r, c)) (Finset.univ))\n\ndef count_col {m n : Nat} (g : Grid m n) (c : Fin n) : Nat :=\n  Finset.card (Finset.filter (fun r => g.shaded (r, c)) (Finset.univ))\n\n/-- A grid obtained by adding k shaded cells to each row -/\ndef add_to_rows {m n : Nat} (g : Grid m n) (k : Nat) : Grid m n :=\n  { shaded := fun (r, c) => g.shaded (r, c) } -- actual implementation would add k cells\n\n/-- A grid obtained by removing k shaded cells from each column -/\ndef remove_from_cols {m n : Nat} (g : Grid m n) (k : Nat) : Grid m n :=\n  { shaded := fun (r, c) => g.shaded (r, c) } -- actual implementation would remove k cells\n\ntheorem grid_claims_contradiction {m n : Nat} (g : Grid m n) \n  (h_dims : m > 0 \u2227 n > 0) :\n  \u00ac(\n    -- Yakov's claim: Adding 5 to each row makes them equal to current columns\n    (\u2200 (r : Fin m) (c : Fin n),\n      count_row (add_to_rows g 5) r = count_col g c) \u2227\n    -- Yuri's claim: Removing 3 from each column makes them equal to current rows\n    (\u2200 (r : Fin m) (c : Fin n),\n      count_col (remove_from_cols g 3) c = count_row g r)\n  ) :=\n  sorry"}
{"id": "CombStruct4Lean_242", "informal_problem": "6. There is an unpainted board $101 \\times 201$. The first player has a bucket of yellow paint, the second player has a bucket of blue paint. On each turn, each player can paint a row (horizontal or vertical) with their color. When yellow and blue paints mix, they produce green. Further mixing of green with yellow or blue does not change the color. A player cannot paint a row if that row has already been painted by the opponent, nor can they paint a row if no cell on the board will change color. The player who cannot make a move loses. Who can ensure a win?", "formal_statement": "import Mathlib\n\n/-- The possible colors on the board -/\ninductive Color where\n  | unpainted\n  | yellow\n  | blue\n  | green\n  deriving Inhabited, DecidableEq, Fintype\n\n/-- The players in the game -/\ninductive Player where\n  | first\n  | second\n  deriving Inhabited, DecidableEq, Fintype\n\n/-- Get the color associated with a player -/\ndef Player.color : Player \u2192 Color\n  | first => Color.yellow\n  | second => Color.blue\n\n/-- A move is either a horizontal or vertical line -/\ninductive Move where\n  | horizontal (row : Fin 101)\n  | vertical (col : Fin 201)\n  deriving Inhabited, DecidableEq\n\n/-- The game board represented as a function from positions to colors -/\nstructure Board where\n  cells : Fin 101 \u2192 Fin 201 \u2192 Color\n  deriving Inhabited\n\n/-- The result of mixing two colors -/\ndef mixColors (c1 c2 : Color) : Color :=\n  match c1, c2 with\n  | Color.unpainted, c | c, Color.unpainted => c\n  | Color.yellow, Color.blue | Color.blue, Color.yellow => Color.green\n  | Color.green, _ | _, Color.green => Color.green\n  | c1, c2 => if c1 = c2 then c1 else c2\n\n/-- Apply a move to the board -/\ndef applyMove (b : Board) (m : Move) (p : Player) : Board :=\n  let color := p.color\n  match m with\n  | Move.horizontal row =>\n    \u27e8fun r c => if r = row then mixColors (b.cells r c) color else b.cells r c\u27e9\n  | Move.vertical col =>\n    \u27e8fun r c => if c = col then mixColors (b.cells r c) color else b.cells r c\u27e9\n\n/-- Check if a move is valid -/\ndef isValidMove (b : Board) (m : Move) (p : Player) : Prop :=\n  let newBoard := applyMove b m p\n  let oppColor := match p with\n    | Player.first => Color.blue\n    | Player.second => Color.yellow\n  match m with\n  | Move.horizontal row =>\n    (\u2200 col, b.cells row col \u2260 oppColor) \u2227\n    \u2203 col, newBoard.cells row col \u2260 b.cells row col\n  | Move.vertical col =>\n    (\u2200 row, b.cells row col \u2260 oppColor) \u2227\n    \u2203 row, newBoard.cells row col \u2260 b.cells row col\n\n/-- A game state contains the board, current player, and remaining moves -/\nstructure GameState where\n  board : Board\n  currentPlayer : Player\n  movesLeft : Nat  -- For well-founded recursion\n  deriving Inhabited\n\n/-- A strategy is valid if it produces valid moves when possible -/\ndef ValidStrategy (strategy : GameState \u2192 Move) : Prop :=\n  \u2200 gs : GameState, \n    (\u2203 m, isValidMove gs.board m gs.currentPlayer) \u2192\n    isValidMove gs.board (strategy gs) gs.currentPlayer\n\n/-- A strategy is winning if it leads to opponent having no valid moves -/\ndef WinningStrategy (p : Player) (strategy : GameState \u2192 Move) : Prop :=\n  \u2200 gs : GameState,\n    gs.movesLeft > 0 \u2192\n    gs.currentPlayer = p \u2192\n    \u2203 m, isValidMove gs.board m gs.currentPlayer \u2227\n        \u2200 gs' : GameState,\n          gs'.movesLeft < gs.movesLeft \u2192\n          \u00ac\u2203 m', isValidMove gs'.board m' gs'.currentPlayer\n\n/-- One of the players has a winning strategy -/\ntheorem painting_game_winner_exists :\n  \u2203 (p : Player) (strategy : GameState \u2192 Move),\n    ValidStrategy strategy \u2227 WinningStrategy p strategy :=\n  sorry"}
{"id": "CombStruct4Lean_243", "informal_problem": "6.2. Let $k=4, n=100$ and Pasha moves chips from only two cells (one in each strip) on each turn. Prove that Roma can ensure that no more than 50 chips (including those removed) end up in the last cells of their strips.", "formal_statement": "import Mathlib\nopen Fin Vector\n\nstructure GameState where\n  strip1 : Vector (Fin 100) 4  -- First strip of length 4, each cell containing 0-99 chips\n  strip2 : Vector (Fin 100) 4  -- Second strip of length 4\n  removed : Fin 100           -- Number of chips removed from game\n  h_total : (strip1.toList.map Fin.val).sum + \n            (strip2.toList.map Fin.val).sum + \n            removed.val = 100\n\nstructure Move where\n  from1 : Fin 4     -- Position in first strip to move from\n  from2 : Fin 4     -- Position in second strip to move from\n  amount : Nat      -- Number of chips to move\n  h_valid : amount > 0\n\n/-- Checks if a move is valid in the current game state -/\ndef isValidMove (state : GameState) (move : Move) : Prop :=\n  -- Enough chips in source positions\n  move.amount \u2264 (state.strip1.get move.from1).val \u2227\n  move.amount \u2264 (state.strip2.get move.from2).val\n\n/-- Returns the final position chips count (including removed) after a sequence of moves -/\ndef finalChipsCount (state : GameState) : Nat :=\n  (state.strip1.get \u27e83, by simp\u27e9).val +\n  (state.strip2.get \u27e83, by simp\u27e9).val +\n  state.removed.val\n\ntheorem roma_winning_strategy :\n  \u2203 (strategy : GameState \u2192 Move \u2192 Move),\n    \u2200 (state : GameState) (pasha_move : Move),\n    isValidMove state pasha_move \u2192\n    \u2200 (next_state : GameState),\n    finalChipsCount next_state \u2264 50 :=\n  sorry"}
{"id": "CombStruct4Lean_244", "informal_problem": "6.3. Let $n<2^{k-3}$. Prove that Roma can make it so that no chip reaches the end.", "formal_statement": "import Mathlib\n\nstructure GameState where\n  k : Nat                 -- number of positions\n  n : Nat                 -- number of chips\n  positions : Fin n \u2192 Nat -- positions of chips (0-based)\n  h_bound : n < 2^(k-3)   -- condition from problem\n\n/-- A move in the game consists of Roma choosing a chip and moving it left or right -/\ninductive Move\n  | left  : Fin n \u2192 Move  -- move chip i one position left\n  | right : Fin n \u2192 Move  -- move chip i one position right\n\n/-- Predicate indicating if a position is valid (within bounds) -/\ndef validPosition (pos : Nat) (k : Nat) : Bool :=\n  pos < k\n\n/-- Predicate indicating if a game state is winning for Roma -/\ndef isWinning (state : GameState) : Prop :=\n  \u2200 i : Fin state.n, state.positions i < state.k - 1\n\ntheorem roma_winning_strategy (k : Nat) (n : Nat) (h : n < 2^(k-3)) :\n  \u2203 (strategy : GameState \u2192 Move), \n    \u2200 (state : GameState),\n      isWinning state :=\n  sorry"}
{"id": "CombStruct4Lean_245", "informal_problem": "6. At the tournament, there were 1000 volleyball teams, some of which played one match against each other. Each team had an equal number of wins and losses (there are no draws in volleyball). It is known that if team A won against team B, then A also won against all the teams that B did not play against. Prove that some team played at least 800 matches.", "formal_statement": "import Mathlib\n\nstructure Tournament (n : Nat) [Fintype (Fin n)] where\n  played : Finset (Fin n \u00d7 Fin n)\n  won : Finset (Fin n \u00d7 Fin n)\n  no_draw : \u2200 i j, (i, j) \u2208 played \u2192 ((i, j) \u2208 won \u2194 (j, i) \u2209 won)\n  equal_record : \u2200 i, \n    (won.filter (fun p => p.1 = i)).card = \n    (won.filter (fun p => p.2 = i)).card\n  transitive_property : \u2200 i j k, \n    (i, j) \u2208 won \u2192 (j, k) \u2209 played \u2192 (i, k) \u2208 won\n\ntheorem tournament_bound (n : Nat) [Fintype (Fin n)] (h : n = 1000) \n  (t : Tournament n) : \n  \u2203 i : Fin n, (t.played.filter (fun p => p.1 = i \u2228 p.2 = i)).card \u2265 800 :=\n  sorry"}
{"id": "CombStruct4Lean_246", "informal_problem": "7. 22 football players played three training matches (each time they were divided into two teams of 11 players). Prove that some two players played on different teams all three times.", "formal_statement": "import Mathlib\n\n/-- A match consists of two teams of players -/\nstructure Match where\n  team1 : Finset (Fin 22)\n  team2 : Finset (Fin 22)\n\n/-- A match is valid if teams have 11 players each, are disjoint, and contain all players -/\ndef IsValidMatch (m : Match) : Prop :=\n  m.team1.card = 11 \u2227 \n  m.team2.card = 11 \u2227 \n  m.team1 \u2229 m.team2 = \u2205 \u2227 \n  m.team1 \u222a m.team2 = Finset.univ\n\n/-- Three matches form a valid tournament if each match is valid -/\ndef ValidTournament (m1 m2 m3 : Match) : Prop :=\n  IsValidMatch m1 \u2227 IsValidMatch m2 \u2227 IsValidMatch m3\n\n/-- Two players are always opponents if in every match they play on opposite teams -/\ndef AlwaysOpponents (p1 p2 : Fin 22) (m1 m2 m3 : Match) : Prop :=\n  (p1 \u2208 m1.team1 \u2192 p2 \u2208 m1.team2) \u2227 (p1 \u2208 m1.team2 \u2192 p2 \u2208 m1.team1) \u2227\n  (p1 \u2208 m2.team1 \u2192 p2 \u2208 m2.team2) \u2227 (p1 \u2208 m2.team2 \u2192 p2 \u2208 m2.team1) \u2227\n  (p1 \u2208 m3.team1 \u2192 p2 \u2208 m3.team2) \u2227 (p1 \u2208 m3.team2 \u2192 p2 \u2208 m3.team1)\n\ntheorem football_opponents : \n  \u2200 (m1 m2 m3 : Match), ValidTournament m1 m2 m3 \u2192\n  \u2203 (p1 p2 : Fin 22), p1 \u2260 p2 \u2227 AlwaysOpponents p1 p2 m1 m2 m3 :=\n  sorry"}
{"id": "CombStruct4Lean_247", "informal_problem": "8. In the foggy city of London, there are exactly $10^{10}$ clubs, and in each club, there are exactly 10 gentlemen. An enemy spy wants to kidnap several gentlemen so that among the kidnapped, there is at least one member of each club. It turns out that for any two clubs, there is a gentleman who is a member of both. Prove that the spy needs to kidnap only 9 gentlemen.", "formal_statement": "import Mathlib\n\nstructure LondonClubs where\n  -- The set of all gentlemen\n  gentlemen : Finset Nat\n  -- Club membership function: maps each club to its set of members\n  members : Fin (10^10) \u2192 Finset Nat\n  -- Each club has exactly 10 members\n  mem_size : \u2200 c, (members c).card = 10\n  -- Each club's members are a subset of all gentlemen\n  mem_subset : \u2200 c, members c \u2286 gentlemen\n  -- Any two clubs share at least one member\n  shared_mem : \u2200 (c\u2081 c\u2082 : Fin (10^10)), \n    \u2203 g \u2208 gentlemen, g \u2208 members c\u2081 \u2227 g \u2208 members c\u2082\n\ntheorem london_clubs_min_kidnap (L : LondonClubs) :\n  \u2203 (S : Finset Nat), \n    S.card = 9 \u2227 \n    S \u2286 L.gentlemen \u2227\n    \u2200 c, \u2203 g \u2208 S, g \u2208 L.members c :=\n  sorry"}
{"id": "CombStruct4Lean_248", "informal_problem": "9.3. From 60 numbers $1,2, \\ldots, 60$, 25 numbers were chosen. It is known that the sum of any two of the chosen numbers is not equal to 60. Prove that among the chosen numbers, there are multiples of five.", "formal_statement": "import Mathlib\n\nstructure NumberSelection where\n  numbers : Finset \u2115\n  size_is_25 : numbers.card = 25\n  all_in_range : \u2200 n \u2208 numbers, 0 < n \u2227 n \u2264 60\n  no_sum_60 : \u2200 (a : \u2115) (ha : a \u2208 numbers) (b : \u2115) (hb : b \u2208 numbers), a + b \u2260 60\n\ntheorem exists_multiple_of_five (sel : NumberSelection) : \n  \u2203 n \u2208 sel.numbers, 5 \u2223 n := sorry"}
{"id": "CombStruct4Lean_249", "informal_problem": "8.4. In grade 8, there are 30 people, among them 22 attend the French language club, 21 - the German language club, and 18 - the Chinese language club. Prove that there is a student in the class who attends all three clubs.", "formal_statement": "import Mathlib\n\n\n\ntheorem exists_student_in_all_clubs \n  (french german chinese : Finset (Fin 30))\n  (hf : french.card = 22)\n  (hg : german.card = 21)\n  (hc : chinese.card = 18) :\n  \u2203 i : Fin 30, i \u2208 french \u2229 german \u2229 chinese :=\n  sorry"}
{"id": "CombStruct4Lean_250", "informal_problem": "9.5. In a financial company, there are 20 shareholders, and their total package is 2000 shares. The shareholders need to be divided into two groups of 10 people each, with packages of 1000 shares in each group. Prove that there will be two such shareholders that if one of them sells a part of their shares to the other, the required division can be achieved.", "formal_statement": "import Mathlib\n\nstructure ShareholderSystem where\n  shareholders : Finset (Fin 20)\n  shares : Fin 20 \u2192 \u2115\n  total_shares : (shareholders.sum shares) = 2000\n  card_shareholders : shareholders.card = 20\n\ntheorem exists_transfer_for_equal_division \n  (sys : ShareholderSystem) : \n  \u2203 (i j : Fin 20) (transfer : \u2115), \n    i \u2260 j \u2227 \n    transfer \u2264 sys.shares i \u2227\n    \u2203 (group1 group2 : Finset (Fin 20)), \n      group1.card = 10 \u2227 \n      group2.card = 10 \u2227 \n      group1 \u2229 group2 = \u2205 \u2227\n      group1 \u222a group2 = sys.shareholders \u2227\n      (group1.sum (\u03bb k => if k = i then sys.shares k - transfer \n                         else if k = j then sys.shares k + transfer\n                         else sys.shares k)) = 1000 \u2227\n      (group2.sum (\u03bb k => if k = i then sys.shares k - transfer \n                         else if k = j then sys.shares k + transfer\n                         else sys.shares k)) = 1000 :=\n  sorry"}
{"id": "CombStruct4Lean_251", "informal_problem": "7.5. In the company, 11 people gathered. It turned out that each person is friends with at least six of those present. Prove that in this company, there will be three friends (each is friends with the other two).", "formal_statement": "import Mathlib\nimport Mathlib.Combinatorics.SimpleGraph.Basic\n\nstructure FriendshipGraph where\n  n : Nat\n  friends : Fin n \u2192 Fin n \u2192 Bool\n  symm : \u2200 i j, friends i j = friends j i\n  no_self : \u2200 i, friends i i = false\n\ndef friendCount (g : FriendshipGraph) (i : Fin g.n) : Nat :=\n  (Finset.univ.filter (fun j => g.friends i j)).card\n\ndef hasTriangle (g : FriendshipGraph) (i j k : Fin g.n) : Bool :=\n  i \u2260 j \u2227 j \u2260 k \u2227 i \u2260 k \u2227 \n  g.friends i j \u2227 g.friends j k \u2227 g.friends i k\n\ntheorem friendship_triangle (g : FriendshipGraph) \n  (h1 : g.n = 11)  -- there are 11 people\n  (h2 : \u2200 i : Fin g.n, friendCount g i \u2265 6)  -- each person has at least 6 friends\n  : \u2203 (i j k : Fin g.n), hasTriangle g i j k = true :=\n  sorry"}
{"id": "CombStruct4Lean_252", "informal_problem": "7.4. In the astronaut squad, there are 20 people, and each has at least 14 friends in the squad. A crew is needed for space, in which everyone is friends with each other. Is it necessarily possible to form a crew of four people?", "formal_statement": "import Mathlib\n\nstructure AstronautSquad where\n  friends : Fin 20 \u2192 Finset (Fin 20)\n  symmetric : \u2200 i, \u2200 j \u2208 friends i, i \u2208 friends j\n  enough_friends : \u2200 i, (friends i).card \u2265 14\n\ntheorem astronaut_crew_exists (squad : AstronautSquad) :\n  \u2203 (crew : Finset (Fin 20)), \n    crew.card = 4 \u2227 \n    \u2200 i \u2208 crew, \u2200 j \u2208 crew, i \u2260 j \u2192 j \u2208 squad.friends i :=\n  sorry"}
{"id": "CombStruct4Lean_253", "informal_problem": "7.5. In each cell of a $9 \\times 9$ grid, zeros are written. In one move, it is allowed to choose a row and add an arbitrary positive number to any two adjacent cells in the chosen row (the number added can be changed from move to move). Is it possible to form a square in which the sums in all nine columns are the same after several moves?", "formal_statement": "import Mathlib\n\n/-- A 9\u00d79 grid represented as a function from coordinates to natural numbers -/\ndef Grid := Fin 9 \u2192 Fin 9 \u2192 \u2115\n\n/-- A move consists of a row and starting column (with space for adjacent cell) -/\nstructure Move where\n  row : Fin 9\n  startCol : Fin 8  -- Using Fin 8 ensures space for adjacent column\n  value : \u2115\n\n/-- The initial grid with all zeros -/\ndef initialGrid : Grid := fun _ _ => 0\n\n/-- Apply a move to a grid -/\ndef applyMove (g : Grid) (m : Move) : Grid := fun i j =>\n  if i = m.row \u2227 (j.val = m.startCol.val \u2228 j.val = m.startCol.val + 1)\n  then g i j + m.value\n  else g i j\n\n/-- Sum of a column in the grid -/\ndef columnSum (g : Grid) (j : Fin 9) : \u2115 :=\n  (Finset.univ.sum fun i => g i j)\n\ntheorem equal_columns_impossible :\n  \u00ac\u2203 (moves : List Move), \n    let finalGrid := moves.foldl applyMove initialGrid\n    \u2200 j : Fin 9, columnSum finalGrid j = columnSum finalGrid \u27e80, by norm_num\u27e9 :=\n  sorry"}
{"id": "CombStruct4Lean_254", "informal_problem": "7.4 In a box, there are 25 colored pencils. It is known that among any five pencils, there will be at least two pencils of the same color. Prove that there are 7 pencils of the same color in the box.", "formal_statement": "import Mathlib\n\nstructure ColoredPencils where\n  num_colors : Nat  -- number of possible colors\n  colors : Fin 25 \u2192 Fin num_colors  -- maps each pencil to a finite color\n  pigeonhole_five : \u2200 (s : Finset (Fin 25)), s.card = 5 \u2192 \n    \u2203 (c : Fin num_colors) (i j : Fin 25), \n      i \u2208 s \u2227 j \u2208 s \u2227 i \u2260 j \u2227 colors i = colors j\n\ntheorem colored_pencils_seven \n  (box : ColoredPencils) : \n  \u2203 (c : Fin box.num_colors), \n    (Finset.filter (fun i => box.colors i = c) (Finset.univ : Finset (Fin 25))).card = 7 :=\n  sorry"}
{"id": "CombStruct4Lean_255", "informal_problem": "11.4. Petya has accumulated many pieces of plasticine of three colors, and he tightly filled a hollow cube with a side of 5 cm with plasticine, so that there was no free space left in the cube. Prove that there are two points of the same color inside the cube at a distance of exactly 7 cm from each other.", "formal_statement": "import Mathlib\n\n/-- A point in 3D space within the 5x5x5 cube -/\nstructure Point3D where\n  x : \u211d\n  y : \u211d\n  z : \u211d\n  hx : x \u2208 Set.Icc (0 : \u211d) 5\n  hy : y \u2208 Set.Icc (0 : \u211d) 5\n  hz : z \u2208 Set.Icc (0 : \u211d) 5\n\n/-- A cube filled with plasticine of three colors -/\nstructure ColoredCube where\n  coloring : Point3D \u2192 Fin 3\n\n/-- Euclidean distance between two points in 3D space -/\nnoncomputable def Point3D.distance (p\u2081 p\u2082 : Point3D) : \u211d :=\n  Real.sqrt ((p\u2081.x - p\u2082.x)^2 + (p\u2081.y - p\u2082.y)^2 + (p\u2081.z - p\u2082.z)^2)\n\ntheorem colored_cube_distance_seven (cube : ColoredCube) :\n  \u2203 (p\u2081 p\u2082 : Point3D), \n    cube.coloring p\u2081 = cube.coloring p\u2082 \u2227 \n    p\u2081.distance p\u2082 = 7 :=\n  sorry"}
{"id": "CombStruct4Lean_256", "informal_problem": "7.3. Can the 200 consecutive numbers: $1,2, \\ldots, 200$ be rearranged so that adjacent numbers differ by either 3 or $5?$", "formal_statement": "import Mathlib\n\n/-- Absolute difference between two natural numbers -/\ndef natAbsDiff (a b : \u2115) : \u2115 := \n  max a b - min a b\n\n/-- Predicate for valid differences (3 or 5) -/\ndef isValidDiff (n : \u2115) : Prop := n = 3 \u2228 n = 5\n\n/-- Predicate for whether a permutation of numbers 1..200 has valid differences -/\ndef isValidArrangement (p : Equiv.Perm (Fin 201)) : Prop :=\n  \u2200 i : Fin 200, \n    let n1 := (p i).val + 1\n    let n2 := (p (Fin.succ i)).val + 1\n    isValidDiff (natAbsDiff n1 n2)\n\ntheorem exists_valid_arrangement_200 : \n  \u2203 p : Equiv.Perm (Fin 201), isValidArrangement p :=\n  sorry"}
{"id": "CombStruct4Lean_257", "informal_problem": "7.5. Kolya placed 17 kings on a chessboard. Petya must remove 12 kings from the board so that the remaining 5 kings do not attack each other. Can he always do this? (A king attacks all squares adjacent to its square, either by side or corner.)", "formal_statement": "import Mathlib\n\nopen Finset\n\nabbrev File := Fin 8\nabbrev Rank := Fin 8\n\nstructure ChessPosition where\n  file : File\n  rank : Rank\n\ndef is_adjacent (p\u2081 p\u2082 : ChessPosition) : Prop :=\n  let row_diff := max p\u2081.rank.val p\u2082.rank.val - min p\u2081.rank.val p\u2082.rank.val\n  let col_diff := max p\u2081.file.val p\u2082.file.val - min p\u2081.file.val p\u2082.file.val\n  row_diff \u2264 1 \u2227 col_diff \u2264 1 \u2227 \u00ac(p\u2081.rank = p\u2082.rank \u2227 p\u2081.file = p\u2082.file)\n\ndef are_non_attacking (kings : Finset ChessPosition) : Prop :=\n  \u2200 k\u2081 \u2208 kings, \u2200 k\u2082 \u2208 kings, k\u2081 \u2260 k\u2082 \u2192 \u00acis_adjacent k\u2081 k\u2082\n\ndef is_valid_placement (kings : Finset ChessPosition) : Prop :=\n  kings.card \u2264 64 \u2227 are_non_attacking kings\n\ntheorem kings_removal_possible \n  (initial_kings : Finset ChessPosition) \n  (h\u2081 : initial_kings.card = 17) :\n  \u2203 (remaining_kings : Finset ChessPosition),\n    remaining_kings.card = 5 \u2227 \n    remaining_kings \u2286 initial_kings \u2227\n    are_non_attacking remaining_kings :=\n  sorry"}
{"id": "CombStruct4Lean_258", "informal_problem": "10.2. On a chessboard, 8 rooks were placed so that they do not attack each other. Prove that in any rectangular cell area of size $4 \\times 5$ (cells) there is at least one rook.", "formal_statement": "import Mathlib\n\n/-- A valid rook placement on an 8\u00d78 chessboard -/\nstructure ChessBoard where\n  rooks : Finset (Fin 8 \u00d7 Fin 8)\n  nonAttacking : \u2200 (r\u2081 r\u2082 : Fin 8 \u00d7 Fin 8), r\u2081 \u2208 rooks \u2192 r\u2082 \u2208 rooks \u2192 r\u2081 \u2260 r\u2082 \u2192 \n    (Prod.fst r\u2081 \u2260 Prod.fst r\u2082) \u2227 (Prod.snd r\u2081 \u2260 Prod.snd r\u2082)\n  exactlyEight : rooks.card = 8\n\n/-- A 4\u00d75 rectangular area on the chessboard -/\nstructure RectArea where\n  startRow : Fin 8\n  startCol : Fin 8\n  valid : startRow + 4 \u2264 8 \u2227 startCol + 5 \u2264 8\n\n/-- Checks if a position is within the given rectangular area -/\ndef inRectArea (pos : Fin 8 \u00d7 Fin 8) (area : RectArea) : Prop :=\n  let (row, col) := pos\n  row \u2265 area.startRow \u2227 row < area.startRow + 4 \u2227\n  col \u2265 area.startCol \u2227 col < area.startCol + 5\n\ntheorem rook_in_rect_area (board : ChessBoard) (area : RectArea) :\n  \u2203 pos \u2208 board.rooks, inRectArea pos area :=\n  sorry"}
{"id": "CombStruct4Lean_259", "informal_problem": "# Task 8. (16 points)\n\nIn a class, there are 14 girls. Each of them found out how many girls in the class have the same first name as her, and how many have the same last name, and wrote down two numbers on the board. It turned out that among the numbers on the board, all numbers from 0 to 6 are present. Prove that there will be two girls in the class who have both the same first name and the same last name.\n\n#", "formal_statement": "import Mathlib\n\nstructure Student where\n  firstName : String\n  lastName : String\nderiving DecidableEq\n\ndef countMatchingFirstNames (s : Student) (students : Finset Student) : Nat :=\n  (students.filter (fun t => t.firstName = s.firstName \u2227 t \u2260 s)).card\n\ndef countMatchingLastNames (s : Student) (students : Finset Student) : Nat :=\n  (students.filter (fun t => t.lastName = s.lastName \u2227 t \u2260 s)).card\n\nstructure ClassData where\n  students : Finset Student\n  size_eq : students.card = 14\n  -- For each student, their name counts are determined by actual matches\n  first_count_def : \u2200 (s : Student), s \u2208 students \u2192 \n    countMatchingFirstNames s students \u2264 6\n  last_count_def : \u2200 (s : Student), s \u2208 students \u2192 \n    countMatchingLastNames s students \u2264 6\n  -- All numbers from 0 to 6 appear in the actual counts\n  all_counts_appear : \u2200 n : Nat, n \u2264 6 \u2192 \n    (\u2203 s : Student, s \u2208 students \u2227 countMatchingFirstNames s students = n) \u2228\n    (\u2203 s : Student, s \u2208 students \u2227 countMatchingLastNames s students = n)\n\ntheorem pigeonhole_names (c : ClassData) : \n  \u2203 (s\u2081 s\u2082 : Student), s\u2081 \u2208 c.students \u2227 s\u2082 \u2208 c.students \u2227 s\u2081 \u2260 s\u2082 \u2227 \n    s\u2081.firstName = s\u2082.firstName \u2227 \n    s\u2081.lastName = s\u2082.lastName :=\n  sorry"}
{"id": "CombStruct4Lean_260", "informal_problem": "# Task 7. (14 points)\n\n281 employees from 7 different branches of the company participated in the conference. In every group of six participants, at least two were of the same age. Prove that among all the participants, you can find five of the same age, of the same gender, and from the same branch of the company.", "formal_statement": "import Mathlib\n\ninductive Gender where\n  | male\n  | female\nderiving Repr, DecidableEq, Ord\n\nstructure Participant where\n  age : Fin 150  -- Reasonable upper bound for age\n  gender : Gender\n  branch : Fin 7\nderiving Repr, DecidableEq\n\n/-- A group of participants sharing the same characteristic (age, gender, or branch) -/\nstructure CharacteristicGroup where\n  members : Finset Participant\n  sameAge : \u2200 p q, p \u2208 members \u2192 q \u2208 members \u2192 p.age = q.age\n  sameGender : \u2200 p q, p \u2208 members \u2192 q \u2208 members \u2192 p.gender = q.gender\n  sameBranch : \u2200 p q, p \u2208 members \u2192 q \u2208 members \u2192 p.branch = q.branch\n\n/-- Predicate indicating that two participants share the same age -/\ndef ShareSameAge (p q : Participant) : Prop := p.age = q.age\n\n/-- Predicate indicating that a group has at least two participants of the same age -/\ndef HasTwoSameAge (group : Finset Participant) : Prop :=\n  \u2203 p q, p \u2208 group \u2227 q \u2208 group \u2227 p \u2260 q \u2227 ShareSameAge p q\n\ntheorem conference_pigeonhole \n  (participants : Finset Participant)\n  (total_count : participants.card = 281)\n  (age_property : \u2200 (group : Finset Participant),\n    group \u2286 participants \u2192 group.card = 6 \u2192 HasTwoSameAge group) :\n  \u2203 (same_group : CharacteristicGroup),\n    same_group.members \u2286 participants \u2227 \n    same_group.members.card = 5 :=\n  sorry"}
{"id": "CombStruct4Lean_261", "informal_problem": "Problem 6. Five friends approached a river and found a boat on the shore that could accommodate all five of them. They decided to go for a ride in the boat. Each time, a group of one or several people would cross from one bank to the other. The friends want to organize the ride so that each possible group crosses exactly once. Will they be able to do this?\n\n[9 points] (A. V. Grigalko)", "formal_statement": "import Mathlib\n\n-- A crossing represents a subset of friends crossing the river\nstructure Crossing where\n  participants : Finset (Fin 5)\n\n-- A sequence of crossings represents the entire boat journey\nstructure BoatJourney where\n  crossings : List Crossing\n  \n-- Helper function to check if a list contains all possible subsets exactly once\ndef containsAllSubsetsOnce (journey : BoatJourney) : Prop :=\n  \u2200 s : Finset (Fin 5), \n    (\u2203! i, journey.crossings.get? i = some \u27e8s\u27e9)\n\ntheorem boat_journey_impossible : \n  \u00ac\u2203 (journey : BoatJourney), containsAllSubsetsOnce journey :=\n  sorry"}
{"id": "CombStruct4Lean_262", "informal_problem": "Problem 6. A row of 100 coins lies on a table, some showing heads and the rest showing tails. In one operation, it is allowed to select seven coins lying at equal intervals (i.e., seven consecutive coins, or seven coins lying every other coin, etc.), and flip all seven coins. Prove that using such operations, it is possible to have all the coins show heads.\n\n$[9$ points] (S.I. Tokarev, A.V. Shapovalov)", "formal_statement": "import Mathlib\n\n-- Represent a row of coins as a function from positions to bool (true = heads)\nstructure CoinRow where\n  coins : Fin 100 \u2192 Bool\n\n-- Define what it means to flip coins at equal intervals\ndef flipCoinsAtInterval (row : CoinRow) (start : Fin 100) (interval : Nat) : CoinRow where\n  coins := fun i => \n    if \u2203 k : Fin 7, i.val = start.val + k.val * interval \u2227 i.val < 100\n    then !row.coins i\n    else row.coins i\n\n-- Define what it means for all coins to show heads\ndef allHeads (row : CoinRow) : Prop :=\n  \u2200 i : Fin 100, row.coins i = true\n\ntheorem coin_flipping_possible :\n  \u2200 (initial : CoinRow),\n  \u2203 (steps : List (Fin 100 \u00d7 Nat)), \n    let final := steps.foldl (fun row (p) => flipCoinsAtInterval row p.1 p.2) initial\n    allHeads final :=\n  sorry"}
{"id": "CombStruct4Lean_263", "informal_problem": "Problem 3. In the nodes of a grid of a $4 \\times 5$ rectangular grid, there are 30 light bulbs, all initially turned off. In one move, it is allowed to draw any straight line that does not touch the light bulbs (the size of the light bulbs should be neglected, considering them as points), such that on one side of it no light bulb is lit, and turn on all the light bulbs on that side of the line. Each move must light at least one light bulb. Is it possible to light all the light bulbs in exactly four moves?", "formal_statement": "import Mathlib\n\n-- Grid representation using Fin types for type-safe coordinates\nstructure Grid where\n  bulbs : Set (Fin 4 \u00d7 Fin 5)\n\n-- Line represented by two points for simpler geometric reasoning\nstructure Line where\n  p1 : \u211d \u00d7 \u211d\n  p2 : \u211d \u00d7 \u211d\n  distinct : p1 \u2260 p2\n\n-- Predicate to check if a point is on the positive side of a line\ndef isPositiveSide (l : Line) (p : \u211d \u00d7 \u211d) : Prop :=\n  let dx := l.p2.1 - l.p1.1\n  let dy := l.p2.2 - l.p1.2\n  (dy * (p.1 - l.p1.1) - dx * (p.2 - l.p1.2)) \u2265 0\n\n-- A valid move consists of a line and the bulbs it lights\nstructure Move where\n  line : Line\n  litBulbs : Set (Fin 4 \u00d7 Fin 5)\n  -- The lit bulbs must be on the positive side of the line\n  valid : \u2200 b \u2208 litBulbs, isPositiveSide line (\u27e8b.1.val, b.2.val\u27e9)\n  -- The line must not intersect any bulb\n  noIntersect : \u2200 b : Fin 4 \u00d7 Fin 5, \u00acisPositiveSide line (\u27e8b.1.val, b.2.val\u27e9) \u2192\n                \u00ac(isPositiveSide line (\u27e8b.1.val + 0.1, b.2.val + 0.1\u27e9))\n  -- At least one bulb must be lit\n  nonEmpty : litBulbs.Nonempty\n\ntheorem grid_lighting_possible :\n  \u2203 (moves : Fin 4 \u2192 Move),\n    -- Each move lights at least one new bulb\n    (\u2200 i : Fin 4, \u2200 j : Fin 4, j.val < i.val \u2192\n      \u2203 b \u2208 (moves i).litBulbs, b \u2209 (moves j).litBulbs) \u2227\n    -- All bulbs are eventually lit\n    (\u2200 b : Fin 4 \u00d7 Fin 5, \u2203 i : Fin 4, b \u2208 (moves i).litBulbs) :=\n  sorry"}
{"id": "CombStruct4Lean_264", "informal_problem": "6. Andrei Mikhailovich wrote on the board all possible sequences of length 2022, consisting of 1011 zeros and 1011 ones. Let's call two sequences compatible if they coincide in exactly 4 positions. Prove that Andrei Mikhailovich can divide all the sequences into 20 groups so that no two compatible sequences end up in the same group.\n\n(A. Raigorodsky)", "formal_statement": "import Mathlib\n\n-- Define a binary sequence of length 2022 with exactly 1011 zeros and ones\nstructure BinarySequence where\n  seq : Fin 2022 \u2192 Bool\n  count_ones : (count_true : Fin 2022 \u2192 Bool) = 1011\n  count_zeros : (count_false : Fin 2022 \u2192 Bool) = 1011\n\n-- Define when two sequences are compatible\ndef compatible (s1 s2 : BinarySequence) : Prop :=\n  (\u2203 (positions : Finset (Fin 2022)), \n    positions.card = 4 \u2227 \n    (\u2200 i : Fin 2022, i \u2208 positions \u2194 s1.seq i = s2.seq i))\n\n-- Define a valid grouping as a function from sequences to group numbers\ndef validGrouping (f : BinarySequence \u2192 Fin 20) : Prop :=\n  \u2200 s1 s2 : BinarySequence, \n    compatible s1 s2 \u2192 f s1 \u2260 f s2\n\ntheorem sequence_grouping_exists : \n  \u2203 (f : BinarySequence \u2192 Fin 20), validGrouping f :=\n  sorry"}
{"id": "CombStruct4Lean_265", "informal_problem": "Problem 4. Some cells of a $100 \\times 100$ board are painted black. In all rows and columns where there are black cells, their number is odd. In each row where there are black cells, we place a red chip in the middle black cell. In each column where there are black cells, we place a blue chip in the middle black cell. It turns out that all red chips are in different columns, and all blue chips are in different rows. Prove that there will be a cell where both a blue and a red chip are placed.\n\n$(2022-65$ / Frengkin B.)", "formal_statement": "import Mathlib\n\ndef countBlackCells {n : Nat} (row : Fin n \u2192 Bool) : Nat :=\n  Finset.card (Finset.filter (fun i => row i = true) Finset.univ)\n\nstructure BlackBoard where\n  size : Nat\n  cells : Matrix (Fin size) (Fin size) Bool\n  odd_rows_proof : \u2200 i, Odd (countBlackCells (cells i \u00b7))\n  odd_cols_proof : \u2200 j, Odd (countBlackCells (cells \u00b7 j))\n\ndef hasBlackRow (b : BlackBoard) (i : Fin b.size) : Prop := \n  countBlackCells (b.cells i \u00b7) > 0\n\ndef hasBlackCol (b : BlackBoard) (j : Fin b.size) : Prop := \n  countBlackCells (b.cells \u00b7 j) > 0\n\ndef isMiddleBlackCell {n : Nat} (row : Fin n \u2192 Bool) (pos : Fin n) : Prop :=\n  row pos = true \u2227 \n  \u2200 k : Fin n, k \u2260 pos \u2192 \n    (Finset.card (Finset.filter (fun i => row i \u2227 i < k) Finset.univ)) =\n    (Finset.card (Finset.filter (fun i => row i \u2227 i > k) Finset.univ))\n\nstructure ChipPlacement (b : BlackBoard) where\n  red_pos : {i : Fin b.size // hasBlackRow b i} \u2192 Fin b.size\n  blue_pos : {j : Fin b.size // hasBlackCol b j} \u2192 Fin b.size\n  red_middle : \u2200 (i : {i // hasBlackRow b i}), \n    isMiddleBlackCell (b.cells i.val \u00b7) (red_pos i)\n  blue_middle : \u2200 (j : {j // hasBlackCol b j}), \n    isMiddleBlackCell (b.cells \u00b7 j.val) (blue_pos j)\n  red_injective : Function.Injective red_pos\n  blue_injective : Function.Injective blue_pos\n\ntheorem board_has_intersection (b : BlackBoard) (h : b.size = 100) \n    (chips : ChipPlacement b) :\n  \u2203 (i : {i // hasBlackRow b i}) (j : {j // hasBlackCol b j}),\n    chips.red_pos i = j.val \u2227 chips.blue_pos j = i.val :=\n  sorry"}
{"id": "CombStruct4Lean_266", "informal_problem": "Problem 4. Each point on the plane is painted in one of three colors. Is it necessarily true that there exists a triangle of area 1, all vertices of which have the same color?", "formal_statement": "import Mathlib\n\nstructure ColoredPlane where\n  coloring : \u211d \u00d7 \u211d \u2192 Fin 3  -- Maps each point to one of three colors (0, 1, or 2)\n\ndef hasMonochromaticTriangleArea1 (plane : ColoredPlane) : Prop :=\n  \u2203 (p\u2081 p\u2082 p\u2083 : \u211d \u00d7 \u211d),\n    -- All points have the same color\n    plane.coloring p\u2081 = plane.coloring p\u2082 \u2227\n    plane.coloring p\u2082 = plane.coloring p\u2083 \u2227\n    -- Area of triangle is 1\n    abs ((p\u2081.1 * (p\u2082.2 - p\u2083.2) + p\u2082.1 * (p\u2083.2 - p\u2081.2) + p\u2083.1 * (p\u2081.2 - p\u2082.2)) / 2) = 1\n\ntheorem exists_monochromatic_triangle_area1 :\n  \u2200 (plane : ColoredPlane), hasMonochromaticTriangleArea1 plane :=\n  sorry"}
{"id": "CombStruct4Lean_267", "informal_problem": "15.31. A rectangular parallelepiped of size $2 l \\times 2 m \\times 2 n$ is cut into cubes with a side of 1, and each of these cubes is painted in one of 8 colors, with any two cubes that share at least one vertex being painted in different colors. Prove that all corner cubes are painted in different colors.\n\n## \u00a7 4. Lone Problems", "formal_statement": "import Mathlib\n\n/-- A cube in 3D space with integer coordinates -/\nstructure Cube where\n  x : Nat\n  y : Nat\n  z : Nat\n\n/-- Determines if a cube's coordinates are within the bounds of a parallelepiped -/\ndef Cube.inBounds (c : Cube) (l m n : Nat) : Prop :=\n  c.x < 2*l \u2227 c.y < 2*m \u2227 c.z < 2*n\n\n/-- Determines if a cube is at a corner of the parallelepiped -/\ndef Cube.isCorner (c : Cube) (l m n : Nat) : Prop :=\n  (c.x = 0 \u2228 c.x = 2*l - 1) \u2227\n  (c.y = 0 \u2228 c.y = 2*m - 1) \u2227\n  (c.z = 0 \u2228 c.z = 2*n - 1)\n\n/-- Determines if two cubes share at least one vertex -/\ndef Cube.shareVertex (c\u2081 c\u2082 : Cube) : Prop :=\n  let dx := Int.natAbs (Int.ofNat c\u2081.x - Int.ofNat c\u2082.x)\n  let dy := Int.natAbs (Int.ofNat c\u2081.y - Int.ofNat c\u2082.y)\n  let dz := Int.natAbs (Int.ofNat c\u2081.z - Int.ofNat c\u2082.z)\n  dx \u2264 1 \u2227 dy \u2264 1 \u2227 dz \u2264 1 \u2227 \u00ac(dx = 0 \u2227 dy = 0 \u2227 dz = 0)\n\n/-- A colored parallelepiped with given dimensions -/\nstructure ColoredParallelepiped (l m n : Nat) where\n  coloring : Cube \u2192 Option (Fin 8)\n  valid_coords : \u2200 c, c.inBounds l m n \u2192 (coloring c).isSome\n  valid_colors : \u2200 c\u2081 c\u2082, c\u2081.inBounds l m n \u2192 c\u2082.inBounds l m n \u2192 \n    c\u2081.shareVertex c\u2082 \u2192 coloring c\u2081 \u2260 coloring c\u2082\n\ntheorem corner_cubes_different_colors \n  {l m n : Nat} (h\u2081 : l > 0) (h\u2082 : m > 0) (h\u2083 : n > 0)\n  (p : ColoredParallelepiped l m n) :\n  \u2200 c\u2081 c\u2082, c\u2081.inBounds l m n \u2192 c\u2082.inBounds l m n \u2192\n    c\u2081.isCorner l m n \u2192 c\u2082.isCorner l m n \u2192 c\u2081 \u2260 c\u2082 \u2192 \n    p.coloring c\u2081 \u2260 p.coloring c\u2082 :=\n  sorry"}
{"id": "CombStruct4Lean_268", "informal_problem": "3. The plane is divided into triangles. Any two triangles either have no common points, or share a common vertex, or share a common side 1). The vertices of these triangles are labeled with the digits $0,1,2$ such that vertices belonging to the same side are labeled with different digits (we will call such labeling correct) (Fig. 6). Prove that in this case, the resulting map can be correctly colored with two colors.", "formal_statement": "import Mathlib\n\nstructure TriangulatedPlane where\n  -- The type of vertices in our plane\n  Vertex : Type\n  -- The type of triangles in our plane\n  Triangle : Type\n  -- Function that returns the three vertices of a triangle\n  vertices : Triangle \u2192 Fin 3 \u2192 Vertex\n  -- Predicate that checks if two triangles share a vertex\n  shareVertex : Triangle \u2192 Triangle \u2192 Prop\n  -- Predicate that checks if two triangles share a side\n  shareSide : Triangle \u2192 Triangle \u2192 Prop\n  -- Property that triangles either don't intersect, share vertex, or share side\n  triangleIntersection : \u2200 t\u2081 t\u2082, t\u2081 \u2260 t\u2082 \u2192 \n    (\u00ac(shareVertex t\u2081 t\u2082 \u2228 shareSide t\u2081 t\u2082)) \u2228 shareVertex t\u2081 t\u2082 \u2228 shareSide t\u2081 t\u2082\n  -- Vertex labeling with digits 0,1,2\n  label : Vertex \u2192 Fin 3\n  -- Property that vertices on same side have different labels\n  validLabeling : \u2200 t : Triangle, \u2200 i j : Fin 3, i \u2260 j \u2192 \n    label (vertices t i) \u2260 label (vertices t j)\n\ntheorem triangulated_plane_two_colorable \n  (P : TriangulatedPlane) : \n  \u2203 (coloring : P.Triangle \u2192 Bool),\n    \u2200 t\u2081 t\u2082 : P.Triangle, \n      P.shareSide t\u2081 t\u2082 \u2192 coloring t\u2081 \u2260 coloring t\u2082 :=\n  sorry"}
{"id": "CombStruct4Lean_269", "informal_problem": "13. There were 225 people present at the meeting. Acquaintances exchanged handshakes. Prove that at least one of the participants shook hands with an even number of acquaintances ${ }^{1}$ ).[^2]", "formal_statement": "import Mathlib\n\nstructure Handshakes where\n  n : Nat                            -- number of people\n  shakes : Fin n \u2192 Fin n \u2192 Bool      -- handshake matrix\n  symmetric : \u2200 i j, shakes i j = shakes j i  -- handshakes are symmetric\n  no_self : \u2200 i, shakes i i = false  -- no self-handshakes\n\n/-- Number of handshakes for a person -/\ndef handshake_count (h : Handshakes) (person : Fin h.n) : Nat :=\n  Finset.card (Finset.filter (fun j => h.shakes person j) (Finset.univ))\n\n/-- Total number of handshakes in the meeting -/\ndef total_handshakes (h : Handshakes) : Nat :=\n  Finset.sum Finset.univ (fun i => handshake_count h i) / 2\n\ntheorem exists_even_handshakes (h : Handshakes) (h_count : h.n = 225) :\n  \u2203 person : Fin h.n, Even (handshake_count h person) :=\n  sorry"}
{"id": "CombStruct4Lean_270", "informal_problem": "25. All vertices on the map have even degree. The rook toured several countries on this map and returned to the starting country (it could have visited some countries more than once). Prove that it made an even number of moves.", "formal_statement": "import Mathlib\n\nstructure Map where\n  countries : Type\n  [fintype : Fintype countries]\n  [dec : DecidableEq countries]\n  edges : Finset (countries \u00d7 countries)\n  adjacent (c\u2081 c\u2082 : countries) : Prop := (c\u2081, c\u2082) \u2208 edges\n  [adj_dec : DecidableRel adjacent]\n  adjacent_sym : \u2200 c\u2081 c\u2082, adjacent c\u2081 c\u2082 \u2194 adjacent c\u2082 c\u2081\n  degree_even : \u2200 c, Even (Finset.filter (adjacent c) Finset.univ).card\n\ninductive ConsecutivelyAdjacent {\u03b1} (adj : \u03b1 \u2192 \u03b1 \u2192 Prop) : List \u03b1 \u2192 Prop\n  | nil : ConsecutivelyAdjacent adj []\n  | singleton (x : \u03b1) : ConsecutivelyAdjacent adj [x]\n  | cons (x y : \u03b1) (rest : List \u03b1) :\n      adj x y \u2192\n      ConsecutivelyAdjacent adj (y::rest) \u2192\n      ConsecutivelyAdjacent adj (x::y::rest)\n\nstructure RookTour (m : Map) where\n  moves : List m.countries\n  nonempty : moves \u2260 []\n  valid_moves : ConsecutivelyAdjacent m.adjacent moves\n  closed : m.adjacent (moves.getLast nonempty) (moves.head nonempty)\n\ntheorem rook_tour_even_moves (m : Map) (tour : RookTour m) :\n  Even tour.moves.length :=\n  sorry"}
{"id": "CombStruct4Lean_271", "informal_problem": "27. All vertices of the map have even multiplicity. Prove that it can be properly colored with two colors (compare problem 83).\n\nProblems 23 and 27 give the following theorem, completely solving the problem of proper two-coloring:\n\nA map can be properly colored with two colors if and only if all its vertices have even multiplicity.\n\n## 8 2. Three-color coloring\n\n", "formal_statement": "import Mathlib\n\nstructure Map where\n  V : Type -- vertices\n  E : Type -- edges\n  vertices : Set V\n  edges : Set E\n  endpoint : E \u2192 V \u00d7 V -- Each edge connects two vertices\n  multiplicity : V \u2192 \u2115 -- Number of edges incident to a vertex\n  even_multiplicity : \u2200 v \u2208 vertices, Even (multiplicity v)\n\n/-- A coloring of a map is an assignment of colors to vertices -/\ndef Coloring (M : Map) := M.V \u2192 Bool\n\n/-- A coloring is proper if adjacent vertices have different colors -/\ndef isProperColoring (M : Map) (c : Coloring M) : Prop :=\n  \u2200 e \u2208 M.edges,\n    let \u27e8v\u2081, v\u2082\u27e9 := M.endpoint e\n    c v\u2081 \u2260 c v\u2082\n\ntheorem even_multiplicity_two_colorable (M : Map) :\n  \u2203 c : Coloring M, isProperColoring M c :=\n  sorry"}
{"id": "CombStruct4Lean_272", "informal_problem": "134. Let all elements in the $s$-th row of the $m$-ary Pascal triangle, except for the boundary elements, be zeros. Prove that the rows with numbers $s^{2}, s^{3}, \\ldots, s^{k}, \\ldots$ also have this property.", "formal_statement": "import Mathlib\n\n/-- Represents an m-ary Pascal triangle where each element is calculated\n    using modulo m arithmetic -/\nstructure MAryPascalTriangle where\n  m : \u2115\n  coeff : \u2115 \u2192 \u2115 \u2192 \u2115  -- row \u2192 position \u2192 value\n  isValid : \u2200 (n k : \u2115), coeff n k = if k > n then 0 \n    else (if k = 0 \u2228 k = n then 1 \n    else (coeff (n-1) (k-1) + coeff (n-1) k) % m)\n\n/-- Predicate indicating that all non-boundary elements in a row are zero -/\ndef hasZeroInterior (pt : MAryPascalTriangle) (row : \u2115) : Prop :=\n  \u2200 k : \u2115, 0 < k \u2192 k < row \u2192 pt.coeff row k = 0\n\ntheorem zero_interior_power_rows (m s : \u2115) (h_m : m > 1) (h_s : s > 0)\n  (pt : MAryPascalTriangle) (h_pt : pt.m = m)\n  (h_base : hasZeroInterior pt s) :\n  \u2200 k : \u2115, k > 0 \u2192 hasZeroInterior pt (s^k) :=\n  sorry"}
{"id": "CombStruct4Lean_273", "informal_problem": "58. In a rectangle of area 5 sq. units, nine polygons of area 1 are placed; prove that among them there are two polygons, the area of the common part of which is not less than $\\frac{1}{9}$.", "formal_statement": "import Mathlib\nopen MeasureTheory\n\nstructure PolygonPlacement where\n  rectangle : Set (\u211d \u00d7 \u211d)\n  measurable_rect : MeasurableSet rectangle\n  rectangle_area : volume rectangle = (5 : ENNReal)\n  polygons : Fin 9 \u2192 Set (\u211d \u00d7 \u211d)\n  measurable_polygons : \u2200 i, MeasurableSet (polygons i)\n  polygon_areas : \u2200 i, volume (polygons i) = (1 : ENNReal)\n  contained : \u2200 i, polygons i \u2286 rectangle\n\ntheorem polygon_overlap_bound (p : PolygonPlacement) :\n  \u2203 i j : Fin 9, i \u2260 j \u2227 \n    MeasurableSet (Set.inter (p.polygons i) (p.polygons j)) \u2227\n    volume (Set.inter (p.polygons i) (p.polygons j)) \u2265 (1/9 : ENNReal) :=\n  sorry"}
{"id": "CombStruct4Lean_274", "informal_problem": "7. In the cells of an $m \\times n$ table, some numbers are written. It is allowed to simultaneously change the sign of all numbers in a certain column or a certain row. Prove that by repeatedly performing this operation, the given table can be transformed into one where the sums of the numbers in any column and any row are non-negative.", "formal_statement": "import Mathlib\n\n/-- A table of integers with m rows and n columns -/\nstructure SignTable (m n : Nat) where\n  entries : Matrix (Fin m) (Fin n) Int\nderiving Repr\n\n/-- A configuration of row and column signs (1 or -1) -/\nstructure SignChanges (m n : Nat) where\n  row_sign : Fin m \u2192 Int\n  col_sign : Fin n \u2192 Int\n  row_valid : \u2200 i, row_sign i = 1 \u2228 row_sign i = -1\n  col_valid : \u2200 j, col_sign j = 1 \u2228 col_sign j = -1\nderiving Repr\n\n/-- Sum of numbers in a row -/\ndef rowSum {m n : Nat} (t : SignTable m n) (i : Fin m) : Int :=\n  Finset.sum Finset.univ fun j => t.entries i j\n\n/-- Sum of numbers in a column -/\ndef colSum {m n : Nat} (t : SignTable m n) (j : Fin n) : Int :=\n  Finset.sum Finset.univ fun i => t.entries i j\n\n/-- Apply sign changes to a table -/\ndef applyChanges {m n : Nat} (t : SignTable m n) (f : SignChanges m n) : SignTable m n where\n  entries := Matrix.of fun i j => (f.row_sign i) * (f.col_sign j) * t.entries i j\n\n/-- Predicate indicating that a table has all non-negative row and column sums -/\ndef hasNonNegativeSums {m n : Nat} (t : SignTable m n) : Prop :=\n  (\u2200 i : Fin m, rowSum t i \u2265 0) \u2227 (\u2200 j : Fin n, colSum t j \u2265 0)\n\ntheorem exists_nonnegative_sums {m n : Nat} (hm : 0 < m) (hn : 0 < n)\n  (t : SignTable m n) :\n  \u2203 (f : SignChanges m n), hasNonNegativeSums (applyChanges t f) :=\n  sorry"}
{"id": "CombStruct4Lean_275", "informal_problem": "11. Prove that for any three infinite sequences of natural numbers\n\n$$\n\\begin{aligned}\n& a_{1}, a_{2}, \\ldots, a_{n}, \\ldots \\\\\n& b_{1}, \\quad b_{2}, \\ldots, b_{n}, \\ldots \\\\\n& c_{1}, \\quad c_{2}, \\ldots, c_{n}, \\ldots\n\\end{aligned}\n$$\n\nthere exist indices $p$ and $q$ such that $a_{p} \\geqslant a_{q}, b_{p} \\geqslant b_{q}$, $c_{p} \\geqslant c_{q}$.", "formal_statement": "import Mathlib\n\n-- Define a type for infinite sequences of natural numbers\ndef InfSeq := \u2115 \u2192 \u2115 \n\n-- Define what it means for two indices to satisfy our condition for a single sequence\ndef NonDecreasing (seq : InfSeq) (p q : \u2115) : Prop := seq p \u2265 seq q\n\n-- Define what it means for two indices to satisfy our condition for all three sequences\ndef SatisfiesAllSequences (a b c : InfSeq) (p q : \u2115) : Prop :=\n  NonDecreasing a p q \u2227 NonDecreasing b p q \u2227 NonDecreasing c p q\n\ntheorem exists_common_nondecreasing_indices (a b c : InfSeq) : \n  \u2203 p q : \u2115, SatisfiesAllSequences a b c p q :=\n  sorry"}
{"id": "CombStruct4Lean_276", "informal_problem": "26. Given positive numbers $a_{1}, a_{2}, \\ldots, a_{m}$, $b_{1}, b_{2}, \\ldots, b_{n}$, such that $a_{1}+a_{2}+\\ldots+a_{m}=b_{1}+$ $+b_{2}+\\ldots+b_{n}$. Prove that in an empty table with $m$ rows and $n$ columns, no more than $m+n-1$ positive numbers can be placed so that the sum of the numbers in the $i$-th row equals $a_{i}$, and the sum of the numbers in the $k$-th column equals $b_{k}$.\n\nThird All-Russian Olympiad, 1963 (Moscow)\n\n| Class |  |  |  |  |  |\n| :---: | :---: | :---: | :---: | :---: | :---: |\n| 8 | 27 | 28 | $29 a$ | 30 | $31 a$ |\n| 9 | 32 | 33 | 34 | 316 | 28 |\n| 10 | 35 | 36 | 37 | 296 | 28 |\n| 11 | 38 | 28 | 39 | 40 | 296 |", "formal_statement": "import Mathlib\n\nstructure TableConstraints (m n : \u2115) where\n  pos_m : m > 0\n  pos_n : n > 0\n  rowSums : Fin m \u2192 \u211d\n  colSums : Fin n \u2192 \u211d\n  rowSums_pos : \u2200 i, rowSums i > 0\n  colSums_pos : \u2200 j, colSums j > 0\n  sums_equal : (Finset.sum Finset.univ rowSums) = (Finset.sum Finset.univ colSums)\n\n/-- Represents positions in the table where positive numbers are placed -/\nstructure TablePlacement (m n : \u2115) (tc : TableConstraints m n) where\n  positions : Finset (Fin m \u00d7 Fin n)\n  values : (Fin m \u00d7 Fin n) \u2192 \u211d\n  values_pos : \u2200 p \u2208 positions, values p > 0\n  row_sums_match : \u2200 i, Finset.sum (positions.filter (fun p => p.1 = i)) (fun p => values p) = tc.rowSums i\n  col_sums_match : \u2200 j, Finset.sum (positions.filter (fun p => p.2 = j)) (fun p => values p) = tc.colSums j\n\ntheorem table_placement_bound {m n : \u2115} (tc : TableConstraints m n) \n    (t : TablePlacement m n tc) : \n    t.positions.card \u2264 m + n - 1 :=\n  sorry"}
{"id": "CombStruct4Lean_277", "informal_problem": "37. Given a regular 45-gon. Is it possible to place the digits $0,1, \\ldots, 9$ at its vertices such that for any pair of different digits, there is a side whose endpoints are labeled with these digits?", "formal_statement": "import Mathlib\n\nstructure RegularPolygonLabeling where\n  n : Nat                              -- number of vertices\n  labels : Fin n \u2192 Fin 10             -- labeling function for vertices\n  \n/-- Check if two vertices are connected by an edge in a regular n-gon -/\ndef areAdjacent (n : Nat) (v\u2081 v\u2082 : Fin n) : Bool :=\n  v\u2081.val + 1 = v\u2082.val \u2228 (v\u2081.val = n - 1 \u2227 v\u2082.val = 0)\n\n/-- Predicate stating that all pairs of digits appear on some edge -/\ndef hasAllPairsOnEdges (l : RegularPolygonLabeling) : Prop :=\n  \u2200 d\u2081 d\u2082 : Fin 10, d\u2081 \u2260 d\u2082 \u2192 \n    \u2203 v\u2081 v\u2082 : Fin l.n, \n      areAdjacent l.n v\u2081 v\u2082 \u2227 \n      l.labels v\u2081 = d\u2081 \u2227 \n      l.labels v\u2082 = d\u2082\n\ntheorem fortyfive_gon_digit_placement : \n  \u00ac\u2203 (l : RegularPolygonLabeling), l.n = 45 \u2227 hasAllPairsOnEdges l :=\n  sorry"}
{"id": "CombStruct4Lean_278", "informal_problem": "61. In the people's militia, there are 100 people, and every evening three people go on duty. Prove that it is impossible to organize the duty schedule so that any two people are on duty together exactly once.", "formal_statement": "import Mathlib\n\nstructure DutySchedule where\n  n : Nat                    -- total number of people\n  days : Nat                 -- number of days in the schedule\n  duties : Fin days \u2192 Fin n \u00d7 Fin n \u00d7 Fin n  -- assignment of 3 people to each day\n  \n/-- Two people are considered to have served together if they were assigned to the same duty -/\ndef servedTogether (schedule : DutySchedule) (p1 p2 : Fin schedule.n) : Bool :=\n  \u2203 d : Fin schedule.days, let (a, b, c) := schedule.duties d\n                          (p1 = a \u2227 p2 = b) \u2228 (p1 = a \u2227 p2 = c) \u2228 (p1 = b \u2227 p2 = c)\n\ntheorem militia_schedule_impossible : \n  \u00ac\u2203 (schedule : DutySchedule), \n    schedule.n = 100 \u2227 \n    (\u2200 p1 p2 : Fin schedule.n, p1 \u2260 p2 \u2192 \n      (\u2203! d : Fin schedule.days, servedTogether schedule p1 p2)) :=\n  sorry"}
{"id": "CombStruct4Lean_279", "informal_problem": "76. On a grid paper, a rectangle $A B C D$ is drawn, with its sides lying on the grid lines, and $A D$ is $k$ times greater than $A B$ ($k$ is an integer). Consider all possible paths that follow the grid lines and lead from $A$ to $C$ in the shortest way. Prove that among these paths, those in which the first segment lies on $A D$ are $k$ times more numerous than those in which the first segment lies on $A B$.", "formal_statement": "import Mathlib\n\nstructure GridRectangle where\n  width : Nat\n  height : Nat\n  k : Nat\n  h_k : height = k * width\n\n/-- A path on the grid is represented as a list of steps, where each step is either Right or Up -/\ninductive GridStep\n  | right : GridStep\n  | up : GridStep\n\n/-- Count paths that start with a specific first step -/\ndef countPathsWithFirstStep (rect : GridRectangle) (firstStep : GridStep) : Nat :=\n  match firstStep with\n  | GridStep.right => Nat.choose (rect.width + rect.height - 1) (rect.width - 1)\n  | GridStep.up => Nat.choose (rect.width + rect.height - 1) rect.width\n\ntheorem grid_paths_ratio (rect : GridRectangle) :\n  countPathsWithFirstStep rect GridStep.up = rect.k * countPathsWithFirstStep rect GridStep.right :=\n  sorry"}
{"id": "CombStruct4Lean_280", "informal_problem": "154. a) At vertex $A_{1}$ of a regular 12-sided polygon $A_{1} A_{2} \\ldots A_{12}$, there is a minus sign, while the others have plus signs. It is allowed to simultaneously change the sign to the opposite in any six consecutive vertices of the polygon. Prove that it is impossible to achieve, after several such operations, that vertex $A_{2}$ has a minus sign, and the other vertices have plus signs.\n\nb) Prove the same statement if it is allowed to change the signs in any four consecutive vertices of the polygon.\n\nc) Prove the same statement if it is allowed to simultaneously change the sign in any three consecutive vertices of the polygon.", "formal_statement": "import Mathlib\n\nstructure SignConfiguration where\n  signs : Fin 12 \u2192 Bool  -- True represents '+', False represents '-'\n\ndef is_valid_initial_config (config : SignConfiguration) : Prop :=\n  config.signs 0 = false \u2227 \n  \u2200 i, i \u2260 0 \u2192 config.signs i = true\n\ndef is_target_config (config : SignConfiguration) : Prop :=\n  config.signs 1 = false \u2227 \n  \u2200 i, i \u2260 1 \u2192 config.signs i = true\n\ndef flip_k_consecutive (k : Nat) (start : Fin 12) (config : SignConfiguration) : SignConfiguration where\n  signs := fun i => \n    if (i.val \u2265 start.val \u2227 i.val < start.val + k) \u2228 \n       (start.val + k > 12 \u2227 i.val < (start.val + k) % 12)\n    then !config.signs i\n    else config.signs i\n\ndef can_reach_config (k : Nat) (initial target : SignConfiguration) : Prop :=\n  \u2203 (steps : List (Fin 12)), \n    let final := steps.foldl (fun acc pos => flip_k_consecutive k pos acc) initial\n    final = target\n\ntheorem polygon_sign_flip_impossible \n  (k : Nat) (h : k \u2208 [3, 4, 6]) :\n  \u00ac\u2203 (initial target : SignConfiguration),\n    is_valid_initial_config initial \u2227 \n    is_target_config target \u2227\n    can_reach_config k initial target :=\n  sorry"}
{"id": "CombStruct4Lean_281", "informal_problem": "176. Given $n$ points, $n>4$. Prove that it is possible to connect them with arrows so that from any point to any other point it is possible to get by following either one arrow or two (any two points can be connected by an arrow in only one direction; it is possible to follow an arrow only in the direction indicated on it).", "formal_statement": "import Mathlib\n\nstructure DirectedGraph (n : Nat) where\n  -- edges represented as a function that returns true if there's an edge from i to j\n  edges : Fin n \u2192 Fin n \u2192 Bool\n\n/-- Path of length at most 2 exists between vertices i and j -/\ndef hasPathAtMost2 {n : Nat} (g : DirectedGraph n) (i j : Fin n) : Prop :=\n  g.edges i j \u2228 \u2203 k : Fin n, g.edges i k \u2227 g.edges k j\n\n/-- A valid solution is a directed graph where any two vertices are connected by a path of length \u2264 2 -/\ndef isValidSolution {n : Nat} (g : DirectedGraph n) : Prop :=\n  \u2200 i j : Fin n, i \u2260 j \u2192 hasPathAtMost2 g i j\n\ntheorem directed_graph_exists_solution (n : Nat) (h : n > 4) :\n  \u2203 g : DirectedGraph n, isValidSolution g :=\n  sorry"}
{"id": "CombStruct4Lean_282", "informal_problem": "200. a) Prove that the numbers $1,2,3, \\ldots, 32$ can be arranged in such an order that for no two numbers their half-sum equals any of the numbers placed between them.\n\nb) Can the numbers $1,2,3, \\ldots, 100$ be arranged in such an order that for no two numbers their half-sum equals any of the numbers placed between them?", "formal_statement": "import Mathlib\n\nstructure ValidArrangement (n : Nat) where\n  perm : Fin n \u2192 Nat\n  is_permutation : Function.Bijective perm\n  no_half_sum_between : \u2200 i j : Fin n, i < j \u2192\n    \u2200 k : Fin n, i < k \u2227 k < j \u2192\n      perm k \u2260 (perm i + perm j) / 2\n\ndef is_valid_arrangement (n : Nat) : Prop :=\n  \u2203 arr : ValidArrangement n, \u2200 i : Fin n, arr.perm i \u2208 Finset.range n\n\ntheorem arrangement_existence : \n  (is_valid_arrangement 32) \u2227 \u00ac(is_valid_arrangement 100) :=\n  sorry"}
{"id": "CombStruct4Lean_283", "informal_problem": "229. On a $99 \\times 99$ chessboard, a figure (this figure will be different in parts a), b), and c)) is marked. In each cell of the figure $F$, there is a beetle. At some point, the beetles fly up and land again in the cells of the same figure $F$; in this process, several beetles could land in the same cell. After the flight, any two beetles that were in adjacent cells ended up in adjacent cells again or in the same cell. (Cells are considered adjacent if they share a side or a vertex.)\n\na) Let the figure $F$ be the \"central cross,\" i.e., the union of the middle vertical and middle horizontal lines (Fig. 12,a). Prove that in this case, some beetle either returned to its original place or moved to an adjacent cell.", "formal_statement": "import Mathlib\n\nstructure ChessboardState where\n  n : Nat\n  figure : Set (Nat \u00d7 Nat)\n  beetles_initial : (Nat \u00d7 Nat) \u2192 List (Nat \u00d7 Nat)\n  beetles_final : (Nat \u00d7 Nat) \u2192 List (Nat \u00d7 Nat)\n\ndef is_adjacent (p1 p2 : Nat \u00d7 Nat) : Bool :=\n  let (x1, y1) := p1\n  let (x2, y2) := p2\n  let dx := if x1 \u2265 x2 then x1 - x2 else x2 - x1\n  let dy := if y1 \u2265 y2 then y1 - y2 else y2 - y1\n  dx \u2264 1 && dy \u2264 1 && (p1 \u2260 p2)\n\ndef central_cross (n : Nat) : Set (Nat \u00d7 Nat) :=\n  { p | let (x, y) := p\n        (x = n/2 || y = n/2) && x < n && y < n }\n\ndef preserves_adjacency (state : ChessboardState) : Prop :=\n  \u2200 p1 p2 : Nat \u00d7 Nat,\n    p1 \u2208 state.figure \u2192 p2 \u2208 state.figure \u2192\n    is_adjacent p1 p2 \u2192\n    \u2203 q1 \u2208 (state.beetles_final p1), \u2203 q2 \u2208 (state.beetles_final p2),\n      is_adjacent q1 q2 \u2228 q1 = q2\n\ntheorem central_cross_beetle_movement \n  (state : ChessboardState)\n  (h_size : state.n = 99)\n  (h_figure : state.figure = central_cross state.n)\n  (h_adj : preserves_adjacency state) :\n  \u2203 pos \u2208 state.figure,\n    \u2203 beetle \u2208 (state.beetles_initial pos),\n    \u2203 final_pos \u2208 (state.beetles_final pos),\n      final_pos = pos \u2228 is_adjacent pos final_pos :=\n  sorry"}
{"id": "CombStruct4Lean_284", "informal_problem": "265*. Given a prime number $p>3$. Consider a set $M$ on the coordinate plane consisting of points with integer coordinates $(x, y)$ such that $0 \\leqslant x < p, 0 \\leqslant y < p$. Prove that it is possible to mark $p$ different points of the set $M$ such that no four of them lie at the vertices of a parallelogram and no three of them lie on the same line.", "formal_statement": "import Mathlib\n\nstructure Point where\n  x : Int\n  y : Int\nderiving Repr, DecidableEq\n\nnamespace Point\ndef sub (a b : Point) : Point :=\n  \u27e8a.x - b.x, a.y - b.y\u27e9\n\ndef isEqual (a b : Point) : Bool :=\n  a.x = b.x \u2227 a.y = b.y\nend Point\n\nstructure Grid (p : Nat) where\n  points : Finset Point\n  valid : \u2200 pt \u2208 points, 0 \u2264 pt.x \u2227 pt.x < p \u2227 0 \u2264 pt.y \u2227 pt.y < p\n\ndef areVectorsEqual (v\u2081 v\u2082 : Point) : Bool :=\n  v\u2081.x = v\u2082.x \u2227 v\u2081.y = v\u2082.y\n\ndef formParallelogram (a b c d : Point) : Prop :=\n  let v\u2081 := Point.sub b a\n  let v\u2082 := Point.sub c b\n  let v\u2083 := Point.sub d c\n  let v\u2084 := Point.sub a d\n  (\u00aca.isEqual b) \u2227 (\u00acb.isEqual c) \u2227 (\u00acc.isEqual d) \u2227 (\u00acd.isEqual a) \u2227\n  ((areVectorsEqual v\u2081 v\u2083 \u2227 areVectorsEqual v\u2082 v\u2084) \u2228\n   (areVectorsEqual v\u2081 v\u2084 \u2227 areVectorsEqual v\u2082 v\u2083))\n\ndef areCollinear (a b c : Point) : Prop :=\n  (\u00aca.isEqual b) \u2227 (\u00acb.isEqual c) \u2227 (\u00acc.isEqual a) \u2227\n  (b.x - a.x) * (c.y - a.y) = (c.x - a.x) * (b.y - a.y)\n\ndef ValidSelection (p : Nat) (pts : Finset Point) : Prop :=\n  -- Set has exactly p points\n  pts.card = p \u2227\n  -- All points are in range\n  (\u2200 pt \u2208 pts, 0 \u2264 pt.x \u2227 pt.x < p \u2227 0 \u2264 pt.y \u2227 pt.y < p) \u2227\n  -- No four points form a parallelogram\n  (\u2200 (a b c d : Point), a \u2208 pts \u2192 b \u2208 pts \u2192 c \u2208 pts \u2192 d \u2208 pts \u2192 \n    \u00acformParallelogram a b c d) \u2227\n  -- No three points are collinear\n  (\u2200 (a b c : Point), a \u2208 pts \u2192 b \u2208 pts \u2192 c \u2208 pts \u2192 \n    \u00acareCollinear a b c)\n\ntheorem exists_valid_selection (p : Nat) (h_prime : Nat.Prime p) (h_gt3 : p > 3) :\n  \u2203 pts : Finset Point, ValidSelection p pts :=\n  sorry"}
{"id": "CombStruct4Lean_285", "informal_problem": "271. In the parliament, each of its members has no more than three enemies. Prove that the parliament can be divided into two chambers so that each parliamentarian will have no more than one enemy in the same chamber. (It is assumed that if $B$ is an enemy of $A$, then $A$ is an enemy of $B$.)", "formal_statement": "import Mathlib\n\nstructure Parliament where\n  members : Finset Nat\n  enemies : Finset (Nat \u00d7 Nat)\n  enemy_valid : \u2200 a b, (a, b) \u2208 enemies \u2192 a \u2208 members \u2227 b \u2208 members\n  enemy_symmetric : \u2200 a b, (a, b) \u2208 enemies \u2194 (b, a) \u2208 enemies\n  enemy_bound : \u2200 a, a \u2208 members \u2192 \n    (Finset.filter (fun p => p.1 = a \u2228 p.2 = a) enemies).card \u2264 3\n  nonempty : members.Nonempty\n\ntheorem parliament_division (P : Parliament) :\n  \u2203 (chamber1 chamber2 : Finset Nat),\n    -- The chambers form a partition of the parliament\n    chamber1 \u222a chamber2 = P.members \u2227\n    chamber1 \u2229 chamber2 = \u2205 \u2227\n    -- Each member has at most one enemy in their chamber\n    (\u2200 a \u2208 chamber1,\n      (Finset.filter (fun p => (p.1 = a \u2228 p.2 = a) \u2227\n        (p.1 \u2208 chamber1 \u2227 p.2 \u2208 chamber1)) P.enemies).card \u2264 1) \u2227\n    (\u2200 a \u2208 chamber2,\n      (Finset.filter (fun p => (p.1 = a \u2228 p.2 = a) \u2227\n        (p.1 \u2208 chamber2 \u2227 p.2 \u2208 chamber2)) P.enemies).card \u2264 1) :=\n  sorry"}
{"id": "CombStruct4Lean_286", "informal_problem": "274. On a plane, there are several points. For some pairs $A, B$ of these points, vectors $\\overrightarrow{A B}$ are taken, such that in each point, the number of vectors starting from it is equal to the number of vectors ending at it. Prove that the sum of all selected vectors is 0.", "formal_statement": "import Mathlib\n\nstructure PointSystem where\n  points : Finset (\u211d \u00d7 \u211d)\n  vectors : Finset ((\u211d \u00d7 \u211d) \u00d7 (\u211d \u00d7 \u211d))\n  balanced : \u2200 p \u2208 points,\n    (vectors.filter (fun v => v.1 = p)).card = \n    (vectors.filter (fun v => v.2 = p)).card\n\ntheorem vector_sum_zero (sys : PointSystem) :\n  sys.vectors.sum (fun v => (v.2.1 - v.1.1, v.2.2 - v.1.2)) = (0, 0) :=\n  sorry"}
{"id": "CombStruct4Lean_287", "informal_problem": "290. On the shore of a large round lake, there are several settlements. Some of them are connected by ferry routes. It is known that two settlements are connected by a route if and only if the two next settlements in the counterclockwise direction are not connected by a route. Prove that from any settlement to any other settlement, one can travel by ferry, and with no more than two transfers.", "formal_statement": "import Mathlib\n\ndef cyclicNext {n : Nat} (i : Fin n) (h : 0 < n): Fin n :=\n  Fin.mk ((i.val + 1) % n) (Nat.mod_lt _ h)\n\ndef cyclicNextTwo {n : Nat} (i : Fin n) (h : 0 < n): Fin n :=\n  Fin.mk ((i.val + 2) % n) (Nat.mod_lt _ h)\n\nstructure LakeSettlements where\n  n : Nat                        -- number of settlements\n  h_pos : 0 < n                  -- at least one settlement\n  hasRoute : Fin n \u2192 Fin n \u2192 Bool   -- ferry routes between settlements\n  h_next : \u2200 i : Fin n,         -- the \"next settlements\" property\n    hasRoute i (cyclicNext i h_pos) = !hasRoute (cyclicNext i h_pos) (cyclicNextTwo i h_pos)\n\n/-- Two settlements are connected by a path of length at most k -/\ndef IsConnectedWithinSteps (L : LakeSettlements) (i j : Fin L.n) (k : Nat) : Prop :=\n  match k with\n  | 0 => i = j\n  | 1 => L.hasRoute i j\n  | 2 => \u2203 v : Fin L.n, L.hasRoute i v \u2227 L.hasRoute v j\n  | _ => False\n\ntheorem ferry_connectivity (L : LakeSettlements) (i j : Fin L.n) :\n  \u2203 k : Nat, k \u2264 2 \u2227 IsConnectedWithinSteps L i j k :=\n  sorry"}
{"id": "CombStruct4Lean_288", "informal_problem": "314*. Is it possible to color all cells of some rectangular table in white and black so that there are an equal number of white and black cells, and in each row and each column, more than $3 / 4$ of the cells are of one color?", "formal_statement": "import Mathlib\n\nstructure ColoredTable where\n  rows : Nat\n  cols : Nat\n  rowPos : 0 < rows\n  colPos : 0 < cols\n  coloring : Fin rows \u2192 Fin cols \u2192 Bool  -- True for white, False for black\n\ndef countColorInRow (t : ColoredTable) (r : Fin t.rows) (color : Bool) : Nat :=\n  Finset.filter (fun c => t.coloring r c = color) (Finset.univ : Finset (Fin t.cols)) |>.card\n\ndef countColorInCol (t : ColoredTable) (c : Fin t.cols) (color : Bool) : Nat :=\n  Finset.filter (fun r => t.coloring r c = color) (Finset.univ : Finset (Fin t.rows)) |>.card\n\ndef totalColorCount (t : ColoredTable) (color : Bool) : Nat :=\n  Finset.sum (Finset.univ : Finset (Fin t.rows)) (fun r => countColorInRow t r color)\n\ntheorem no_balanced_coloring_exists :\n  \u00ac\u2203 (t : ColoredTable), \n    -- Equal number of white and black cells\n    totalColorCount t true = totalColorCount t false \u2227 \n    -- For each row, one color takes more than 3/4 of cells\n    (\u2200 r : Fin t.rows, \n      4 * countColorInRow t r true > 3 * t.cols \u2228 \n      4 * countColorInRow t r false > 3 * t.cols) \u2227\n    -- For each column, one color takes more than 3/4 of cells\n    (\u2200 c : Fin t.cols,\n      4 * countColorInCol t c true > 3 * t.rows \u2228 \n      4 * countColorInCol t c false > 3 * t.rows) :=\n  sorry"}
{"id": "CombStruct4Lean_289", "informal_problem": "330. A non-negative real number is assigned to each vertex of a cube, with the sum of all these numbers being 1. Two players play the following game: the first player chooses any face of the cube, the second player chooses another face, and finally, the first player chooses a third face. It is not allowed to choose faces parallel to the already chosen ones. Prove that the first player can play in such a way that the number corresponding to the common vertex of the three chosen faces does not exceed $1 / 6$.", "formal_statement": "import Mathlib\n\nstructure CubeGame where\n  -- Vertex values are non-negative reals assigned to each vertex\n  -- We represent vertices as triples of coordinates (\u00b11, \u00b11, \u00b11)\n  vertex_value : (Fin 2 \u00d7 Fin 2 \u00d7 Fin 2) \u2192 \u211d\n  -- Values are non-negative\n  values_nonneg : \u2200 v, vertex_value v \u2265 0\n  -- Sum of all values is 1\n  sum_one : (\u2211 v, vertex_value v) = 1\n\n-- Helper function to get faces that are not parallel to given faces\ndef valid_face (f\u2081 f\u2082 : Fin 3) : Prop :=\n  f\u2081 \u2260 f\u2082 \u2227 (\u2200 f\u2083, f\u2083 \u2260 f\u2081 \u2227 f\u2083 \u2260 f\u2082)\n\ntheorem cube_game_strategy (game : CubeGame) :\n  \u2203 (f\u2081 : Fin 3), \u2200 (f\u2082 : Fin 3), valid_face f\u2081 f\u2082 \u2192\n    \u2203 (f\u2083 : Fin 3), valid_face f\u2081 f\u2083 \u2227 valid_face f\u2082 f\u2083 \u2227\n      \u2203 (v : Fin 2 \u00d7 Fin 2 \u00d7 Fin 2), \n        (game.vertex_value v \u2264 1/6) :=\n  sorry"}
{"id": "CombStruct4Lean_290", "informal_problem": "345. In a square table of $n \\times n$ cells, $n-1$ cells are marked. Prove that by permuting the rows among themselves and the columns among themselves, it is possible to achieve that all the marked cells lie below the diagonal of the table.", "formal_statement": "import Mathlib\n\nstructure MarkedTable where\n  n : Nat\n  h_pos : n > 0\n  marks : Finset (Fin n \u00d7 Fin n)\n  mark_count : marks.card = n - 1\n\nstructure TablePermutation (n : Nat) where\n  row_perm : Equiv.Perm (Fin n)\n  col_perm : Equiv.Perm (Fin n)\n\ndef below_diagonal {n : Nat} (pos : Fin n \u00d7 Fin n) : Prop :=\n  pos.1.val > pos.2.val\n\ndef apply_permutation {n : Nat} (p : TablePermutation n) (pos : Fin n \u00d7 Fin n) : Fin n \u00d7 Fin n :=\n  (p.row_perm pos.1, p.col_perm pos.2)\n\ntheorem marked_cells_below_diagonal (t : MarkedTable) :\n  \u2203 (p : TablePermutation t.n), \u2200 pos \u2208 t.marks,\n    below_diagonal (apply_permutation p pos) :=\n  sorry"}
{"id": "CombStruct4Lean_291", "informal_problem": "362. Is it possible to arrange integers in the cells of an infinite grid paper such that in every rectangle of size $4 \\times 6$ cells, with sides along the grid lines, the sum of the numbers is a) 10; b) 1?", "formal_statement": "import Mathlib\n\nstructure InfiniteGrid where\n  value : \u2124 \u00d7 \u2124 \u2192 \u2124  -- Function mapping grid coordinates to integers\n\ndef rectangleSum (grid : InfiniteGrid) (x y : \u2124) : \u2124 :=\n  (Finset.range 4).sum (fun i =>\n    (Finset.range 6).sum (fun j =>\n      grid.value (x + i, y + j)))\n\ndef validGrid (grid : InfiniteGrid) (target : \u2124) : Prop :=\n  \u2200 x y : \u2124, rectangleSum grid x y = target\n\ntheorem infinite_grid_sum_existence (target : \u2124) : \n  target = 10 \u2228 target = 1 \u2192 \n  (\u2203 grid : InfiniteGrid, validGrid grid target) \u2228 \n  (\u00ac\u2203 grid : InfiniteGrid, validGrid grid target) :=\n  sorry"}
{"id": "CombStruct4Lean_292", "informal_problem": "367. Prove that among any $2 m+1$ different integers, not exceeding $2 m-1$ in absolute value, one can find three numbers whose sum is 0.", "formal_statement": "import Mathlib\n\ndef AbsLeq (n : \u2124) (m : \u2115) : Prop := Int.natAbs n \u2264 m\n\nstructure IntegerSelection (m : \u2115) where\n  nums : Finset \u2124\n  size : nums.card = 2 * m + 1\n  bound : \u2200 x \u2208 nums, AbsLeq x (2 * m - 1)\n\ntheorem exists_three_sum_zero (m : \u2115) (h : m > 0) \n  (sel : IntegerSelection m) : \n  \u2203 (a b c : \u2124), a \u2208 sel.nums \u2227 b \u2208 sel.nums \u2227 c \u2208 sel.nums \u2227 \n    a \u2260 b \u2227 b \u2260 c \u2227 a \u2260 c \u2227 \n    a + b + c = 0 :=\n  sorry"}
{"id": "CombStruct4Lean_293", "informal_problem": "407. There is a cube, a cubic box with a lid of the same size, and six paints. Each paint is used to color one face of the cube and one of the faces of the box. Prove that the cube can be placed in the box in such a way that each face of the cube touches a face of the box painted with a different color.", "formal_statement": "import Mathlib\n\nstructure CubePainting where\n  -- Maps each face (1-6) to its color (1-6)\n  cube_colors : Fin 6 \u2192 Fin 6\n  box_colors : Fin 6 \u2192 Fin 6\n  -- Each color is used exactly once for cube and box\n  cube_bijective : Function.Bijective cube_colors\n  box_bijective : Function.Bijective box_colors\n\n/-- Represents a placement of the cube in the box -/\nstructure CubePlacement where\n  -- Maps each face of the cube (1-6) to the face of the box it touches (1-6)\n  placement : Fin 6 \u2192 Fin 6\n  -- The placement must be bijective (each box face touches exactly one cube face)\n  is_bijective : Function.Bijective placement\n\ntheorem cube_box_painting_exists :\n  \u2200 (p : CubePainting), \u2203 (placement : CubePlacement),\n    \u2200 (face : Fin 6), p.cube_colors face \u2260 p.box_colors (placement.placement face) :=\n  sorry"}
{"id": "CombStruct4Lean_294", "informal_problem": "421. In one country, the king wants to build $n$ cities and $n-1$ roads between them so that it is possible to travel from any city to any other. (Each road connects two cities, roads do not intersect and do not pass through other cities.) The king wants the shortest distances along the network of roads between pairs of cities to be $1,2,3, \\ldots, \\frac{n(n-1)}{2}$ km. Is this possible if a) $n=6 ; 6$ ) ${ }^{*} n=1986$ ?", "formal_statement": "import Mathlib\n\nstructure RoadNetwork where\n  n : Nat\n  roads : List (Nat \u00d7 Nat)  -- List of pairs representing road connections\n  distances : List Nat      -- List of distances between cities\n  isConnected : Bool       -- Whether the network is connected\n  noIntersections : Bool   -- Whether roads don't intersect\n  \n-- Helper definition for checking if a list contains all numbers from 1 to n\ndef containsSequentialNumbers (l : List Nat) (n : Nat) : Prop :=\n  l.toFinset = Finset.range n.succ\n\ntheorem road_network_possible (n : Nat) (h : n > 0) :\n  \u2203 (network : RoadNetwork),\n    network.n = n \u2227\n    network.roads.length = n - 1 \u2227\n    network.isConnected = true \u2227\n    network.noIntersections = true \u2227\n    containsSequentialNumbers network.distances (n * (n - 1) / 2) :=\n  sorry"}
{"id": "CombStruct4Lean_295", "informal_problem": "429. A cube with edge length $n, n \\geqslant 3$, consists of $n^{3}$ unit cubes. Prove that it is possible to write an integer in each of these unit cubes such that all $n^{3}$ numbers are distinct, and the sums of the numbers in any row parallel to any edge of the cube equal zero.", "formal_statement": "import Mathlib\n\n/-- Direction of a row in the cube -/\ninductive Direction where\n  | X : Direction\n  | Y : Direction\n  | Z : Direction\n\n/-- A labeling of an n\u00d7n\u00d7n cube with integers such that all labels are distinct\n    and sums along any row parallel to any edge equal zero -/\nstructure CubeLabeling (n : Nat) where\n  size_constraint : n \u2265 3\n  labels : Fin n \u2192 Fin n \u2192 Fin n \u2192 Int\n  distinct : \u2200 i\u2081 j\u2081 k\u2081 i\u2082 j\u2082 k\u2082, \n    (i\u2081, j\u2081, k\u2081) \u2260 (i\u2082, j\u2082, k\u2082) \u2192 \n    labels i\u2081 j\u2081 k\u2081 \u2260 labels i\u2082 j\u2082 k\u2082\n\n/-- Get a row of labels in the specified direction -/\ndef getRow (n : Nat) (d : Direction) (i j : Fin n) : \n    Fin n \u2192 Fin n \u00d7 Fin n \u00d7 Fin n :=\n  match d with\n  | Direction.X => fun k => (k, i, j)\n  | Direction.Y => fun k => (i, k, j)\n  | Direction.Z => fun k => (i, j, k)\n\n/-- Sum of labels along a row in any direction -/\ndef rowSum {n : Nat} (c : CubeLabeling n) (d : Direction) (i j : Fin n) : Int :=\n  let coords := getRow n d i j\n  Finset.sum (Finset.univ : Finset (Fin n)) fun k => \n    let (x, y, z) := coords k\n    c.labels x y z\n\ntheorem cube_labeling_exists (n : Nat) (h : n \u2265 3) : \n  \u2203 (c : CubeLabeling n), \u2200 (d : Direction) (i j : Fin n), \n    rowSum c d i j = 0 :=\n  sorry"}
{"id": "CombStruct4Lean_296", "informal_problem": "453. In each cell of a square table $1987 \\times$ $\\times 1987$, a number is written, not exceeding 1 in absolute value. In any $2 \\times 2$ square of this table, the sum of the numbers is 0. Prove that the sum of all the numbers in the table does not exceed 1987.", "formal_statement": "import Mathlib\n\nstructure TableConstraints where\n  table : Matrix (Fin 1987) (Fin 1987) \u211d\n  bound_constraint : \u2200 (i j : Fin 1987), |table i j| \u2264 1\n  square_sum_zero : \u2200 (i j : Fin 1987),\n    (i.val + 1 < 1987) \u2192 (j.val + 1 < 1987) \u2192\n    table i j + table i (Fin.add j 1) + \n    table (Fin.add i 1) j + table (Fin.add i 1) (Fin.add j 1) = 0\n\ntheorem table_sum_bound (t : TableConstraints) :\n  \u2211 i : Fin 1987, \u2211 j : Fin 1987, t.table i j \u2264 (1987 : \u211d) :=\n  sorry"}
{"id": "CombStruct4Lean_297", "informal_problem": "7.7. The corridor is completely covered by several carpet runners, the width of which is equal to the width of the corridor. Prove that some of the runners can be removed so that the remaining ones do not overlap and cover at least half of the corridor. (It is assumed that any runner can be removed without changing the position of the others.)", "formal_statement": "import Mathlib\n\nstructure Runner where\n  start : Int\n  endPos : Int\n  valid : start \u2264 endPos\n\n/-- A covering of a corridor by runners -/\nstructure CarpetCovering where\n  length : Int\n  runners : Finset Runner\n  all_in_bounds : \u2200 r \u2208 runners, 0 \u2264 r.start \u2227 r.endPos \u2264 length\n  covers_corridor : \u2200 x, 0 \u2264 x \u2227 x < length \u2192 \u2203 r \u2208 runners, r.start \u2264 x \u2227 x < r.endPos\n\n/-- Two runners overlap if their intervals intersect -/\ndef runners_overlap (r\u2081 r\u2082 : Runner) : Prop :=\n  r\u2081.start \u2264 r\u2082.endPos \u2227 r\u2082.start \u2264 r\u2081.endPos\n\n/-- Two runners are disjoint if they don't overlap -/\ndef disjoint_runners (r\u2081 r\u2082 : Runner) : Prop :=\n  \u00ac(runners_overlap r\u2081 r\u2082)\n\n/-- The length covered by a set of non-overlapping runners -/\ndef coverage_length (runners : Finset Runner) : Int :=\n  runners.sum (fun r => r.endPos - r.start)\n\ntheorem carpet_covering_theorem (c : CarpetCovering) :\n  \u2203 subset : Finset Runner,\n    subset \u2286 c.runners \u2227 \n    (\u2200 (r\u2081 r\u2082 : Runner), r\u2081 \u2208 subset \u2192 r\u2082 \u2208 subset \u2192 r\u2081 \u2260 r\u2082 \u2192 disjoint_runners r\u2081 r\u2082) \u2227\n    coverage_length subset \u2265 c.length / 2 :=\n  sorry"}
{"id": "CombStruct4Lean_298", "informal_problem": "7.8. The floor of a rectangular room $6 \\times 3 \\mu^{2}$ is completely covered by square carpets of different sizes (the edges of the carpets are parallel to the walls). Prove that some of the carpets can be removed so that the remaining carpets do not overlap and cover more than $2 \\mu^{2}$.\n\n## SNAIL AND OBSERVERS", "formal_statement": "import Mathlib\n\nstructure Room where\n  width : \u211d\n  height : \u211d\n  h_pos : width > 0 \u2227 height > 0\n\nstructure SquareCarpet where\n  bottomLeft : \u211d \u00d7 \u211d\n  size : \u211d\n  h_pos : size > 0\n\ndef area (c : SquareCarpet) : \u211d := c.size * c.size\n\ndef carpetInterval (c : SquareCarpet) : Set (\u211d \u00d7 \u211d) :=\n  {p | c.bottomLeft.1 \u2264 p.1 \u2227 p.1 \u2264 c.bottomLeft.1 + c.size \u2227\n       c.bottomLeft.2 \u2264 p.2 \u2227 p.2 \u2264 c.bottomLeft.2 + c.size}\n\ndef inRoom (r : Room) (c : SquareCarpet) : Prop :=\n  c.bottomLeft.1 \u2265 0 \u2227 c.bottomLeft.1 + c.size \u2264 r.width \u2227\n  c.bottomLeft.2 \u2265 0 \u2227 c.bottomLeft.2 + c.size \u2264 r.height\n\ndef overlaps (c\u2081 c\u2082 : SquareCarpet) : Prop :=\n  \u2203 p : \u211d \u00d7 \u211d, p \u2208 carpetInterval c\u2081 \u2227 p \u2208 carpetInterval c\u2082\n\ntheorem carpet_covering_exists (r : Room) (carpets : Finset SquareCarpet)\n    (h_room : r.width = 6 \u2227 r.height = 3)\n    (h_in_room : \u2200 c \u2208 carpets, inRoom r c)\n    (h_covers : \u2200 p : \u211d \u00d7 \u211d, 0 \u2264 p.1 \u2227 p.1 \u2264 r.width \u2192\n                            0 \u2264 p.2 \u2227 p.2 \u2264 r.height \u2192\n                            \u2203 c \u2208 carpets, p \u2208 carpetInterval c) :\n    \u2203 subcarpets : Finset SquareCarpet,\n      subcarpets \u2286 carpets \u2227\n      (\u2200 (c\u2081 c\u2082 : SquareCarpet), c\u2081 \u2208 subcarpets \u2192 c\u2082 \u2208 subcarpets \u2192 c\u2081 \u2260 c\u2082 \u2192 \u00acoverlaps c\u2081 c\u2082) \u2227\n      (\u2211 c in subcarpets, area c : \u211d) > 2 :=\n  sorry"}
{"id": "CombStruct4Lean_299", "informal_problem": "1. Some cells of a chessboard are occupied by pieces. It is known that each row contains at least one piece, and different rows contain a different number of pieces. Prove that it is always possible to mark 8 pieces so that each column and each row contains exactly one marked piece.", "formal_statement": "import Mathlib\n\nabbrev Position := Fin 8 \u00d7 Fin 8\nabbrev Board := Finset Position\n\nstructure ChessboardState where\n  pieces : Board\n  has_piece_in_row : \u2200 i, \u2203 j, (i, j) \u2208 pieces\n  different_row_counts : \u2200 i j, i \u2260 j \u2192 \n    (pieces.filter (fun p => p.1 = i)).card \u2260 \n    (pieces.filter (fun p => p.1 = j)).card\n\ntheorem chessboard_marking_exists (board : ChessboardState) :\n  \u2203 marked : Board,\n    marked \u2286 board.pieces \u2227\n    (\u2200 i, (marked.filter (fun p => p.1 = i)).card = 1) \u2227\n    (\u2200 j, (marked.filter (fun p => p.2 = j)).card = 1) :=\n  sorry"}
{"id": "CombStruct4Lean_300", "informal_problem": "5. $2 n$ athletes conducted a round-robin tournament twice (in a round-robin tournament, everyone meets everyone, one point is awarded for a win, $-1 / 2$ for a draw, and 0 for a loss). Prove that if the sum of points of each changed by at least $n$, then it changed exactly by $n$.", "formal_statement": "import Mathlib\n\nstructure TournamentResult where\n  numPlayers : Nat\n  scores1 : Fin (2 * numPlayers) \u2192 \u211a  -- Scores from first tournament\n  scores2 : Fin (2 * numPlayers) \u2192 \u211a  -- Scores from second tournament\n  valid_scores1 : \u2200 i, scores1 i \u2208 ({1, -1/2, 0} : Set \u211a)\n  valid_scores2 : \u2200 i, scores2 i \u2208 ({1, -1/2, 0} : Set \u211a)\n  round_robin1 : \u2200 i j, i \u2260 j \u2192 \n    scores1 i + scores1 j = 1/2  -- Sum of points for each match is 1/2\n  round_robin2 : \u2200 i j, i \u2260 j \u2192 \n    scores2 i + scores2 j = 1/2\n\ntheorem tournament_score_change \n  {n : Nat} (t : TournamentResult) (hn : t.numPlayers = n) (h : n > 0) :\n  (\u2200 i, |t.scores2 i - t.scores1 i| \u2265 n) \u2192 \n  (\u2200 i, |t.scores2 i - t.scores1 i| = n) :=\n  sorry"}
{"id": "CombStruct4Lean_301", "informal_problem": "5. In a round-robin tournament, there were no draws; 1 point was awarded for a win, and 0 for a loss. Then, a coefficient for each participant was determined. It was equal to the sum of the points scored by those whom the athlete defeated. It turned out that all participants had equal coefficients. The number of participants in the tournament is greater than two. Prove that all athletes scored the same number of points.", "formal_statement": "import Mathlib\n\nopen Finset\n\nstructure Tournament where\n  n : Nat\n  h_size : n > 2\n  wins : Fin n \u2192 Fin n \u2192 Bool\n  h_no_self : \u2200 i, wins i i = false\n  h_complete : \u2200 i j, i \u2260 j \u2192 wins i j = !wins j i\n\ndef Tournament.points (t : Tournament) (i : Fin t.n) : Nat :=\n  (univ.filter (fun j \u21a6 t.wins i j)).card\n\ndef Tournament.coefficient (t : Tournament) (i : Fin t.n) : Nat :=\n  (univ.filter (fun j \u21a6 t.wins i j)).sum (fun j \u21a6 t.points j)\n\ntheorem tournament_equal_coeffs_impl_equal_points\n  (t : Tournament)\n  (h_equal_coeffs : \u2200 i j : Fin t.n, t.coefficient i = t.coefficient j) :\n  \u2200 i j : Fin t.n, t.points i = t.points j :=\n  sorry"}
{"id": "CombStruct4Lean_302", "informal_problem": "4. $2 n$ radii divide a circle into $2 n$ equal sectors: $n$ blue and $n$ red. In the blue sectors, starting from a certain one, the numbers from 1 to $n$ are written counterclockwise. In the red sectors, starting from a certain one, the same numbers are written in the same way, but clockwise. Prove that there will be a semicircle in which all numbers from 1 to $n$ are written.", "formal_statement": "import Mathlib\nopen Finset\n\n-- Helper function to determine if a position is within a semicircle\ndef IsInSemicircle (n : \u2115) (start pos : Fin (2 * n)) : Prop :=\n  (pos.val - start.val) % (2 * n) < n\n\nstructure ColoredCircle (n : \u2115) where\n  -- For each position in the circle (0 to 2n-1), we store:\n  -- The color (true for blue, false for red)\n  colors : Fin (2 * n) \u2192 Bool\n  -- The number written in that position (1 to n)\n  numbers : Fin (2 * n) \u2192 Fin n.succ\n  -- Ensure n positions are blue and n are red\n  color_count : (filter (fun i => colors i = true) (univ : Finset (Fin (2 * n)))).card = n\n  -- Each number appears exactly once in blue sectors\n  blue_numbers_once : \u2200 k : Fin n.succ,\n    (filter (fun i => colors i = true \u2227 numbers i = k) (univ : Finset (Fin (2 * n)))).card = 1\n  -- Each number appears exactly once in red sectors\n  red_numbers_once : \u2200 k : Fin n.succ,\n    (filter (fun i => colors i = false \u2227 numbers i = k) (univ : Finset (Fin (2 * n)))).card = 1\n  -- Blue numbers are written counterclockwise\n  blue_counter_clockwise : \u2200 i j : Fin (2 * n),\n    colors i = true \u2192 colors j = true \u2192\n    (j.val - i.val) % (2 * n) < n \u2192\n    numbers i < numbers j\n  -- Red numbers are written clockwise\n  red_clockwise : \u2200 i j : Fin (2 * n),\n    colors i = false \u2192 colors j = false \u2192\n    (j.val - i.val) % (2 * n) < n \u2192\n    numbers i > numbers j\n\ntheorem colored_circle_semicircle_property (n : \u2115) (h : n > 0)\n  (circle : ColoredCircle n) :\n  \u2203 (start : Fin (2 * n)), \u2200 k : Fin n.succ,\n    \u2203 pos : Fin (2 * n), IsInSemicircle n start pos \u2227 circle.numbers pos = k :=\n  sorry"}
{"id": "CombStruct4Lean_303", "informal_problem": "6. In a chess tournament, each participant played two games with each other: one with white pieces, the other with black. At the end of the tournament, it turned out that everyone had scored the same number of points (1 point for a win, $-1 / 2$ point for a draw, 0 points for a loss). Prove that there will be two participants who won the same number of games with white pieces.\n\n## 9 t h  g r a d e", "formal_statement": "import Mathlib\n\nstructure ChessTournament where\n  n : Nat                             -- number of participants\n  h_pos : n > 0                       -- at least one participant\n  white_wins : Fin n \u2192 Nat            -- number of wins with white pieces for each player\n  black_wins : Fin n \u2192 Nat            -- number of wins with black pieces for each player\n  draws : Fin n \u2192 Nat                 -- number of draws for each player\n  \n  -- Each player plays exactly one game with white and one with black against every other player\n  h_games : \u2200 i, white_wins i + black_wins i + draws i = 2 * (n - 1)\n  \n  -- Total score is the same for all players\n  h_equal_scores : \u2200 i j, \n    white_wins i + black_wins i - draws i / 2 = \n    white_wins j + black_wins j - draws j / 2\n\ntheorem chess_tournament_same_white_wins (t : ChessTournament) : \n  \u2203 i j, i \u2260 j \u2227 t.white_wins i = t.white_wins j :=\n  sorry"}
{"id": "CombStruct4Lean_304", "informal_problem": "6*. In a rectangular grid of $m \\times n$, each cell can be either alive or dead. Every minute, all living cells die simultaneously, and those dead cells that had an odd number of living neighbors (by side) come to life. Indicate all pairs ( $m, n$ ) for which there exists an initial arrangement of living and dead cells such that life in the rectangle will continue indefinitely (i.e., at every moment, at least one cell will be alive).\n\n## 9 t h  g r a d e", "formal_statement": "import Mathlib\n\nstructure Grid (m n : Nat) where\n  alive : Finset (Fin m \u00d7 Fin n)\n\ndef neighbors {m n : Nat} (pos : Fin m \u00d7 Fin n) : Finset (Fin m \u00d7 Fin n) :=\n  Finset.filter (fun p => \n    let (i, j) := pos\n    let (pi, pj) := p\n    (pi.val = i.val + 1 \u2227 pj = j) \u2228 \n    (pi.val = i.val - 1 \u2227 pj = j) \u2228\n    (pi = i \u2227 pj.val = j.val + 1) \u2228\n    (pi = i \u2227 pj.val = j.val - 1)) Finset.univ\n\ndef livingNeighbors {m n : Nat} (g : Grid m n) (pos : Fin m \u00d7 Fin n) : Nat :=\n  (neighbors pos \u2229 g.alive).card\n\ndef isAlive {m n : Nat} (g : Grid m n) (pos : Fin m \u00d7 Fin n) : Bool :=\n  pos \u2208 g.alive\n\ndef nextState {m n : Nat} (g : Grid m n) : Grid m n where\n  alive := Finset.filter (fun pos => \n    \u00ac isAlive g pos \u2227 livingNeighbors g pos % 2 = 1) Finset.univ\n\ndef hasLife {m n : Nat} (g : Grid m n) : Prop :=\n  g.alive.card > 0\n\ndef evolves_forever {m n : Nat} (g : Grid m n) : Prop :=\n  \u2200 t : Nat, hasLife (Nat.rec g (fun _ => nextState) t)\n\ntheorem eternal_life_condition (m n : Nat) (hm : m > 0) (hn : n > 0) :\n  (\u2203 initial : Grid m n, evolves_forever initial) \u2194 \n  (m \u2260 1 \u2227 n \u2260 1) :=\n  sorry"}
{"id": "CombStruct4Lean_305", "informal_problem": "3-3. From two hundred numbers: $1,2,3,4,5,6,7, \\ldots, 199,200$ one hundred and one numbers are chosen arbitrarily. Prove that among the chosen numbers, there will be two such that one divides the other.", "formal_statement": "import Mathlib\n\ndef isSubset (S : Set Nat) (n : Nat) : Prop :=\n  S \u2286 Finset.range (n + 1) \\ {0}\n\ndef divides_in_set (S : Set Nat) : Prop :=\n  \u2203 a b : Nat, a \u2208 S \u2227 b \u2208 S \u2227 a \u2260 b \u2227 a \u2223 b\n\ntheorem division_in_large_subset :\n  \u2200 S : Set Nat, isSubset S 200 \u2192 S.ncard = 101 \u2192\n  divides_in_set S :=\n  sorry"}
{"id": "CombStruct4Lean_306", "informal_problem": "3-3. There are 13 weights, each weighing a whole number of grams. It is known that any 12 of them can be divided into 2 groups of 6 weights each, such that the scales will balance. Prove that all the weights have the same weight.", "formal_statement": "import Mathlib\n\nstructure WeightSet where\n  weights : Fin 13 \u2192 \u2115  -- 13 natural numbers representing weights in grams\n  balanced : \u2200 (excluded : Fin 13),\n    \u2203 (partition : Fin 12 \u2192 Bool),\n    let remaining := {i : Fin 13 | i \u2260 excluded}\n    let group1_sum := \u2211 i in remaining, if partition i then weights i else 0\n    let group2_sum := \u2211 i in remaining, if !partition i then weights i else 0\n    group1_sum = group2_sum \u2227 \n    (\u2211 i in remaining, partition i) = 6 -- Each group has exactly 6 weights\n\ntheorem all_weights_equal (w : WeightSet) : \n  \u2203 (n : \u2115), \u2200 i : Fin 13, w.weights i = n :=\n  sorry"}
{"id": "CombStruct4Lean_307", "informal_problem": "3-4. Can 10 bus routes be laid out in a city and stops be set up on them in such a way that for any 8 routes chosen, there is a stop not lying on any of them, while any 9 routes pass through all stops.", "formal_statement": "import Mathlib\n\nstructure BusSystem where\n  n : Nat -- number of stops\n  stops : Fin n\n  routes : Finset (Finset (Fin n)) -- set of routes, each route is a set of stops\n  route_count : routes.card = 10 -- exactly 10 routes\n  routes_nonempty : \u2200 r \u2208 routes, r.Nonempty -- each route has at least one stop\n\ntheorem bus_system_exists : \u2203 (n : Nat) (bs : BusSystem), \n  (\u2200 S \u2286 bs.routes, S.card = 8 \u2192 \n    \u2203 p : Fin bs.n, \u2200 r \u2208 S, p \u2209 r) \u2227 -- 8-route property\n  (\u2200 S \u2286 bs.routes, S.card = 9 \u2192 \n    \u2200 p : Fin bs.n, \u2203 r \u2208 S, p \u2208 r) -- 9-route property\n  :=\n  sorry"}
{"id": "CombStruct4Lean_308", "informal_problem": "3-\u0447\u0430 3. At the consultation, there were 20 schoolchildren and 20 problems were discussed. It turned out that each of the schoolchildren solved two problems and each problem was solved by two schoolchildren. Prove that it is possible to organize the discussion of the problems in such a way that each schoolchild presents one of the problems they solved and all problems are discussed.", "formal_statement": "import Mathlib\n\nstructure ConsultationGraph where\n  n : Nat\n  h_size : n = 20\n  -- Adjacency relation between students and problems\n  adj : Fin n \u2192 Fin n \u2192 Prop\n  -- Each student solved exactly two problems\n  h_student_solved_two : \u2200 s : Fin n, \u2203 p\u2081 p\u2082, p\u2081 \u2260 p\u2082 \u2227 adj s p\u2081 \u2227 adj s p\u2082 \u2227 \n    \u2200 p\u2083, adj s p\u2083 \u2192 p\u2083 = p\u2081 \u2228 p\u2083 = p\u2082\n  -- Each problem was solved by exactly two students\n  h_problem_solved_by_two : \u2200 p : Fin n, \u2203 s\u2081 s\u2082, s\u2081 \u2260 s\u2082 \u2227 adj s\u2081 p \u2227 adj s\u2082 p \u2227\n    \u2200 s\u2083, adj s\u2083 p \u2192 s\u2083 = s\u2081 \u2228 s\u2083 = s\u2082\n\n/-- A valid presentation matching assigns each student one of their solved problems -/\nstructure PresentationMatching (g : ConsultationGraph) where\n  assignment : Fin g.n \u2192 Fin g.n\n  h_valid : \u2200 s, g.adj s (assignment s)  -- Student presents a problem they solved\n  h_injective : Function.Injective assignment  -- Each problem presented exactly once\n\ntheorem consultation_matching_exists (g : ConsultationGraph) :\n  \u2203 m : PresentationMatching g, True :=\n  sorry"}
{"id": "CombStruct4Lean_309", "informal_problem": "3-\u0447\u0430 1. A square \\(17 \\times 17\\) is cut out from a grid paper. The cells of the square are arbitrarily filled with the numbers \\(1,2,3, \\ldots, 70\\), with one and only one number in each cell.\n\nProve that there exist four different cells with centers at points \\(A, B, C, D\\) such that \\(A B=C D, A D=B C\\) and the sum of the numbers in the cells with centers at \\(A\\) and \\(C\\) is equal to the sum of the numbers in the cells with centers at \\(B\\) and \\(D\\).", "formal_statement": "import Mathlib\n\n-- Points on a 17x17 grid\nstructure GridPoint where\n  x : Fin 17\n  y : Fin 17\n\n-- Assignment of numbers 1 to 70 to grid points\nstructure GridAssignment where\n  values : GridPoint \u2192 Fin 71\n  -- Every number from 1 to 70 appears exactly once\n  injective : Function.Injective values\n  range_valid : \u2200 p, (values p).val \u2264 70\n  surjective : \u2200 n : Fin 71, n.val \u2264 70 \u2192 \u2203 p, values p = n\n\n-- Distance between two grid points (squared to avoid Real numbers)\ndef distanceSquared (p q : GridPoint) : \u2115 :=\n  (p.x.val - q.x.val)^2 + (p.y.val - q.y.val)^2\n\n-- Check if four points form a rectangle with equal sides\ndef isRectangle (a b c d : GridPoint) : Prop :=\n  distanceSquared a b = distanceSquared c d \u2227 \n  distanceSquared a d = distanceSquared b c \u2227\n  -- Points are distinct\n  a \u2260 b \u2227 a \u2260 c \u2227 a \u2260 d \u2227 b \u2260 c \u2227 b \u2260 d \u2227 c \u2260 d\n\ntheorem exists_equal_sum_rectangle : \n  \u2200 (g : GridAssignment),\n    \u2203 (a b c d : GridPoint),\n      isRectangle a b c d \u2227 \n      (g.values a).val + (g.values c).val = (g.values b).val + (g.values d).val :=\n  sorry"}
{"id": "CombStruct4Lean_310", "informal_problem": "3-\u0447\u0430 1. A square table with \\(n^{2}\\) cells is filled with numbers from 1 to \\(n\\) such that each row and each column contains all these numbers. If \\(n\\) is odd and the table is symmetric with respect to the diagonal running from the top left corner to the bottom right, then all these numbers \\(1,2,3, \\ldots, n\\) will appear on this diagonal. Prove.", "formal_statement": "import Mathlib\n\nstructure SymmetricTable (n : Nat) where\n  -- The table is represented as a function from coordinates to values\n  values : Fin n \u2192 Fin n \u2192 Fin n\n  -- Each row contains all numbers from 1 to n\n  row_complete : \u2200 i : Fin n, Function.Surjective (values i)\n  -- Each column contains all numbers from 1 to n\n  col_complete : \u2200 j : Fin n, Function.Surjective (fun i => values i j)\n  -- Table is symmetric with respect to main diagonal\n  symmetric : \u2200 (i j : Fin n), values i j = values j i\n\ntheorem diagonal_contains_all_numbers {n : Nat} (h_odd : Odd n) (t : SymmetricTable n) :\n  Function.Surjective (fun i => t.values i i) :=\n  sorry"}
{"id": "CombStruct4Lean_311", "informal_problem": "3-4. 64 non-negative numbers, the sum of which is 1956, are arranged in the form of a square table: eight numbers in each row and in each column. The sum of the numbers on one of the diagonals is 112. The numbers symmetrically located relative to this diagonal are equal. Prove that the sum of the numbers in any column is less than 1035.", "formal_statement": "import Mathlib\n\nstructure SquareTable where\n  entries : Matrix (Fin 8) (Fin 8) \u211d\n  -- All entries are non-negative\n  non_neg : \u2200 i j, 0 \u2264 entries i j\n  -- Total sum is 1956\n  sum_total : (Finset.univ.sum fun i => Finset.univ.sum fun j => entries i j) = 1956\n  -- Main diagonal sum is 112\n  diag_sum : (Finset.univ.sum fun i => entries i i) = 112\n  -- Symmetry around main diagonal\n  symmetric : \u2200 i j, entries i j = entries j i\n\n/-- Helper definition for column sum -/\ndef columnSum (t : SquareTable) (j : Fin 8) : \u211d :=\n  Finset.univ.sum fun i => t.entries i j\n\ntheorem square_table_column_sum_bound (t : SquareTable) (j : Fin 8) :\n  columnSum t j < 1035 :=\n  sorry"}
{"id": "CombStruct4Lean_312", "informal_problem": "3-5. There are 15 magazines on the table, covering it completely. Prove that you can remove seven magazines so that the remaining magazines cover no less than \\(8 / 15\\) of the table's area.\n\n(This problem was not solved by any of the participants in the competition.)", "formal_statement": "import Mathlib\nopen MeasureTheory\n\nstructure MagazineConfiguration where\n  total_magazines : Nat\n  /-- Each magazine is represented as a measurable set in \u211d\u00b2 -/\n  magazines : Fin total_magazines \u2192 Set (\u211d \u00d7 \u211d)\n  /-- Each magazine region is measurable in the Borel \u03c3-algebra on \u211d\u00b2 -/\n  measurable_regions : \u2200 i, MeasurableSet (magazines i)\n  /-- The magazines completely cover the unit square [0,1] \u00d7 [0,1] -/\n  covers_table : (\u22c3 i, magazines i) \u2287 (Set.Icc (0 : \u211d) 1).prod (Set.Icc (0 : \u211d) 1)\n  /-- Each magazine is contained in the unit square -/\n  bounded_regions : \u2200 i, magazines i \u2286 (Set.Icc (0 : \u211d) 1).prod (Set.Icc (0 : \u211d) 1)\n\ntheorem magazine_coverage_exists \n  (config : MagazineConfiguration) \n  (h1 : config.total_magazines = 15) :\n  \u2203 (removed : Finset (Fin config.total_magazines)), \n    removed.card = 7 \u2227 \n    volume (\u22c3 i \u2208 (Finset.univ \\ removed), config.magazines i) \u2265 8/15 * volume ((Set.Icc (0 : \u211d) 1).prod (Set.Icc (0 : \u211d) 1)) :=\n  sorry"}
{"id": "CombStruct4Lean_313", "informal_problem": "3-\u0447\u0430 1. A cargo weighing 13.5 tons is packed into boxes such that the weight of each box does not exceed 350 kg. Prove that this cargo can be transported using 11 one-and-a-half-ton trucks. (The weight of the empty boxes can be neglected.)", "formal_statement": "import Mathlib\n\nstructure Box where\n  weight : \u211a  -- weight in tons\n  weight_valid : weight \u2264 (350 : \u211a)/1000  -- 350kg = 0.35 tons\n\nstructure CargoDistribution where\n  boxes : Finset Box\n  total_weight : (\u2211 b in boxes, b.weight) = (27/2 : \u211a)  -- 13.5 tons\n  exists_partition : \u2203 (parts : Fin 11 \u2192 Finset Box),\n    (\u2200 i : Fin 11, (\u2211 b in parts i, b.weight) \u2264 (3/2 : \u211a)) \u2227  -- each truck \u2264 1.5 tons\n    (\u2200 b \u2208 boxes, \u2203! i : Fin 11, b \u2208 parts i) \u2227  -- each box in exactly one part\n    (\u2200 i : Fin 11, parts i \u2286 boxes)  -- all parts come from boxes\n\ntheorem cargo_distribution_exists : \u2203 (d : CargoDistribution), d.boxes.Nonempty :=\n  sorry"}
{"id": "CombStruct4Lean_314", "informal_problem": "3-2. In a cube with an edge length of 13, 1956 points are selected. Is it possible to place a cube with an edge length of 1 inside the larger cube so that it does not contain any of the selected points?", "formal_statement": "import Mathlib\n\nstructure Point3D where\n  x : Real\n  y : Real\n  z : Real\n  h_x_bound : 0 \u2264 x \u2227 x \u2264 13\n  h_y_bound : 0 \u2264 y \u2227 y \u2264 13\n  h_z_bound : 0 \u2264 z \u2227 z \u2264 13\n\nstructure UnitCube where\n  corner : Point3D\n  h_x_valid : corner.x + 1 \u2264 13\n  h_y_valid : corner.y + 1 \u2264 13\n  h_z_valid : corner.z + 1 \u2264 13\n\ndef pointInUnitCube (p : Point3D) (c : UnitCube) : Prop :=\n  c.corner.x \u2264 p.x \u2227 p.x \u2264 c.corner.x + 1 \u2227\n  c.corner.y \u2264 p.y \u2227 p.y \u2264 c.corner.y + 1 \u2227\n  c.corner.z \u2264 p.z \u2227 p.z \u2264 c.corner.z + 1\n\ntheorem exists_empty_unit_cube \n  (points : Finset Point3D) \n  (h_count : points.card = 1956) :\n  \u2203 (c : UnitCube), \u2200 p \u2208 points, \u00acpointInUnitCube p c :=\n  sorry"}
{"id": "CombStruct4Lean_315", "informal_problem": "13.20. Prove that from five vectors, it is always possible to choose two such that the length of their sum does not exceed the length of the sum of the remaining three vectors.", "formal_statement": "import Mathlib\n\nstructure VectorProblem (n : \u2115) (V : Type) [NormedAddCommGroup V] where\n  vectors : Fin n \u2192 V\n\ntheorem vector_sum_inequality {V : Type} [NormedAddCommGroup V] \n  (p : VectorProblem 5 V) : \n  \u2203 (i j : Fin 5), i \u2260 j \u2227 \n    \u2016p.vectors i + p.vectors j\u2016 \u2264 \n    \u2016Finset.sum (Finset.univ.filter (fun k => k \u2260 i \u2227 k \u2260 j)) (fun k => p.vectors k)\u2016 :=\n  sorry"}
{"id": "CombStruct4Lean_316", "informal_problem": "14.29. A centrally symmetric figure on graph paper consists of $n$ \"corners\" and $k$ rectangles of size $1 \\times 4$, as shown in Fig. 14.1. Prove that $n$ is even.", "formal_statement": "import Mathlib\n\nstructure GraphPaperFigure where\n  -- The number of corners in the figure\n  corners : Nat\n  -- The number of 1\u00d74 rectangles\n  rectangles : Nat\n  -- Property that the figure is centrally symmetric\n  is_centrally_symmetric : Bool\n  -- All components are properly placed on graph paper\n  valid_placement : Bool\n\n/-- A corner is a shape made of two perpendicular line segments on graph paper -/\nstructure Corner where\n  -- Position of the corner's vertex on the graph paper\n  x : Int\n  y : Int\n  -- Orientation of the corner (which way it points)\n  orientation : Fin 4\n\ntheorem corner_count_even (fig : GraphPaperFigure) \n  (h1 : fig.is_centrally_symmetric = true) \n  (h2 : fig.valid_placement = true) :\n  \u2203 k : Nat, fig.corners = 2 * k :=\n  sorry"}
{"id": "CombStruct4Lean_317", "informal_problem": "16.2. Two players take turns placing coins on a rectangular table. A coin can only be placed on a free spot. The player who cannot make a move loses. Prove that the first player can always win.", "formal_statement": "import Mathlib\n\nstructure RectangularBoard where\n  rows : Nat\n  cols : Nat\n  board : Fin rows \u2192 Fin cols \u2192 Bool  -- True means occupied, False means free\n\n/-- A valid move places a coin on an unoccupied position -/\ndef isValidMove (board : RectangularBoard) (row : Fin board.rows) (col : Fin board.cols) : Bool :=\n  !board.board row col\n\n/-- Returns whether the game is over (no valid moves remain) -/\ndef isGameOver (board : RectangularBoard) : Bool :=\n  \u2200 r : Fin board.rows, \u2200 c : Fin board.cols, board.board r c\n\n/-- Represents a winning strategy for the first player -/\ndef HasWinningStrategy (board : RectangularBoard) : Prop :=\n  \u2203 (firstMove : Fin board.rows \u00d7 Fin board.cols),\n    isValidMove board firstMove.1 firstMove.2 \u2227\n    \u2200 (response : Fin board.rows \u00d7 Fin board.cols),\n      isValidMove board response.1 response.2 \u2192\n        \u2203 (nextMove : Fin board.rows \u00d7 Fin board.cols),\n          isValidMove board nextMove.1 nextMove.2\n\ntheorem rectangular_board_first_player_wins \n  (rows cols : Nat) \n  (h1 : rows > 0) \n  (h2 : cols > 0) : \n  HasWinningStrategy \u27e8rows, cols, fun _ _ => false\u27e9 :=\n  sorry"}
{"id": "CombStruct4Lean_318", "informal_problem": "20.30. On the plane, there is an infinite set of rectangles, the vertices of each of which are located at points with coordinates $(0,0)$, $(0, m)$, $(n, 0)$, $(n, m)$, where $n$ and $m$ are positive integers (different for each rectangle). Prove that from these rectangles, two can be chosen such that one is contained within the other.", "formal_statement": "import Mathlib\n\nstructure Rectangle where\n  n : Nat\n  m : Nat\n  pos_n : n > 0\n  pos_m : m > 0\n\n/-- A rectangle R1 is contained within rectangle R2 if R1's width and height\n    are less than or equal to R2's width and height respectively -/\ndef isContainedIn (r1 r2 : Rectangle) : Prop :=\n  r1.n \u2264 r2.n \u2227 r1.m \u2264 r2.m\n\ntheorem infinite_rectangles_containment \n  (S : Set Rectangle) \n  (h_inf : Set.Infinite S) : \n  \u2203 (r1 r2 : Rectangle), r1 \u2208 S \u2227 r2 \u2208 S \u2227 r1 \u2260 r2 \u2227 isContainedIn r1 r2 :=\n  sorry"}
{"id": "CombStruct4Lean_319", "informal_problem": "21.1. The nodes of an infinite grid paper are colored in two colors. Prove that there exist two horizontal and two vertical lines, at the intersections of which lie points of the same color.", "formal_statement": "import Mathlib\n\n-- A coloring of the grid is a function from pairs of integers to Bool\n-- where Bool represents the two colors (true and false)\nstructure GridColoring where\n  color : (\u2124 \u00d7 \u2124) \u2192 Bool\n\ntheorem grid_same_color_points (c : GridColoring) :\n  \u2203 (x\u2081 x\u2082 y\u2081 y\u2082 : \u2124) (h\u2081 : x\u2081 \u2260 x\u2082) (h\u2082 : y\u2081 \u2260 y\u2082),\n    let p\u2081\u2081 := (x\u2081, y\u2081)\n    let p\u2081\u2082 := (x\u2081, y\u2082)\n    let p\u2082\u2081 := (x\u2082, y\u2081)\n    let p\u2082\u2082 := (x\u2082, y\u2082)\n    c.color p\u2081\u2081 = c.color p\u2081\u2082 \u2227\n    c.color p\u2081\u2081 = c.color p\u2082\u2081 \u2227\n    c.color p\u2081\u2081 = c.color p\u2082\u2082 :=\n  sorry"}
{"id": "CombStruct4Lean_320", "informal_problem": "21.19*. On a segment of length 1, several segments are painted, and the distance between any two painted points is not equal to 0.1. Prove that the sum of the lengths of the painted segments does not exceed 0.5.", "formal_statement": "import Mathlib\nopen MeasureTheory\n\n/-- A painted segment on [0,1] represented by its endpoints -/\nstructure PaintedSegment where\n  startPoint : \u211d\n  endPoint : \u211d\n  h_ordered : startPoint \u2264 endPoint\n  h_bounds : startPoint \u2208 Set.Icc (0 : \u211d) (1 : \u211d) \u2227 \n            endPoint \u2208 Set.Icc (0 : \u211d) (1 : \u211d)\n\n/-- A collection of painted segments is valid if no two points from any segments\n    have distance exactly 0.1 -/\ndef ValidPaintedSegments (segments : Finset PaintedSegment) : Prop :=\n  \u2200 s\u2081 \u2208 segments, \u2200 s\u2082 \u2208 segments, \u2200 x \u2208 Set.Icc s\u2081.startPoint s\u2081.endPoint,\n    \u2200 y \u2208 Set.Icc s\u2082.startPoint s\u2082.endPoint, |x - y| \u2260 (1/10 : \u211d)\n\ntheorem painted_segments_bound (segments : Finset PaintedSegment)\n    (h_valid : ValidPaintedSegments segments) :\n    Finset.sum segments (fun s => s.endPoint - s.startPoint) \u2264 (1/2 : \u211d) :=\n  sorry"}
{"id": "CombStruct4Lean_321", "informal_problem": "23.5*. A circle is divided by points into $3 k$ arcs: $k$ arcs of length 1, 2, and 3. Prove that there will be two diametrically opposite division points.", "formal_statement": "import Mathlib\n\nstructure CircleArc where\n  startPoint : \u211d\n  length : \u211d\n  valid_start : 0 \u2264 startPoint \u2227 startPoint < 2 * \u03c0\n  valid_length : length > 0\n\nstructure CircleDivision (k : \u2115) where\n  arcs : Fin (3 * k) \u2192 CircleArc\n  ordered : \u2200 i j, i < j \u2192 (arcs i).startPoint < (arcs j).startPoint\n  length_partition : \u2203 (S\u2081 S\u2082 S\u2083 : Finset (Fin (3 * k))),\n    S\u2081.card = k \u2227 S\u2082.card = k \u2227 S\u2083.card = k \u2227\n    (\u2200 i \u2208 S\u2081, (arcs i).length = \u03c0/3) \u2227\n    (\u2200 i \u2208 S\u2082, (arcs i).length = 2*\u03c0/3) \u2227\n    (\u2200 i \u2208 S\u2083, (arcs i).length = \u03c0)\n  total_length : (\u2211 i, (arcs i).length) = 2 * \u03c0\n\ntheorem circle_division_has_opposite_points (k : \u2115) (h : k > 0) :\n  \u2200 d : CircleDivision k, \u2203 i j : Fin (3 * k),\n    let a\u2081 := d.arcs i\n    let a\u2082 := d.arcs j\n    -- Two points are diametrically opposite if their angular distance is \u03c0\n    (a\u2081.startPoint - a\u2082.startPoint = \u03c0) \u2228 (a\u2082.startPoint - a\u2081.startPoint = \u03c0) :=\n  sorry"}
{"id": "CombStruct4Lean_322", "informal_problem": "23.14*. In the center of each cell of a chessboard, there is a chip. The chips were rearranged so that the pairwise distances between them did not decrease. Prove that in fact, the pairwise distances did not change.", "formal_statement": "import Mathlib\n\nstructure ChessCoord where\n  x : Fin 8\n  y : Fin 8\n\nstructure BoardPosition where\n  point : \u211d \u00d7 \u211d\n  valid : \u2203 x y : \u2124, \n    point = ((\u2191x : \u211d) + (1/2 : \u211d), (\u2191y : \u211d) + (1/2 : \u211d)) \u2227 \n    0 \u2264 x \u2227 x < 8 \u2227 0 \u2264 y \u2227 y < 8\n\nstructure ChessboardConfiguration where\n  positions : Fin 64 \u2192 BoardPosition\n  distinct : \u2200 i j, i \u2260 j \u2192 positions i \u2260 positions j\n\n/-- Checks if one configuration is a permutation of another -/\ndef is_permutation (c\u2081 c\u2082 : ChessboardConfiguration) : Prop :=\n  \u2203 \u03c3 : Equiv.Perm (Fin 64), \u2200 i, c\u2082.positions i = c\u2081.positions (\u03c3 i)\n\n/-- Checks if one configuration's distances are not smaller than another's -/\ndef has_nondecreasing_distances (c\u2081 c\u2082 : ChessboardConfiguration) : Prop :=\n  \u2200 i j, dist (c\u2081.positions i).point (c\u2081.positions j).point \u2264 \n         dist (c\u2082.positions i).point (c\u2082.positions j).point\n\ntheorem chessboard_rearrangement \n  (initial final : ChessboardConfiguration)\n  (h_perm : is_permutation initial final)\n  (h_dist : has_nondecreasing_distances initial final) :\n  \u2200 i j, dist (initial.positions i).point (initial.positions j).point = \n         dist (final.positions i).point (final.positions j).point :=\nsorry"}
{"id": "CombStruct4Lean_323", "informal_problem": "23.20. A beetle sits in each cell of a $5 \\times 5$ board. At some moment, all the beetles crawl to adjacent (horizontally or vertically) cells. Will there necessarily be an empty cell?", "formal_statement": "import Mathlib\n\nstructure Position where\n  row : Fin 5\n  col : Fin 5\nderiving Fintype\n\ndef isAdjacent (p\u2081 p\u2082 : Position) : Prop :=\n  (p\u2081.row = p\u2082.row \u2227 |p\u2081.col - p\u2082.col| = 1) \u2228\n  (p\u2081.col = p\u2082.col \u2227 |p\u2081.row - p\u2082.row| = 1)\n\nstructure Board where\n  beetles : Position \u2192 Bool  -- true means occupied, false means empty\n\nstructure BeetleMove where\n  initial : Board\n  final : Board\n  initial_has_one : \u2200 p : Position, initial.beetles p = true  -- exactly one beetle per position initially\n  valid_moves : \u2200 p\u2081 : Position, initial.beetles p\u2081 = true \u2192 \n    \u2203! p\u2082 : Position, final.beetles p\u2082 = true \u2227 isAdjacent p\u2081 p\u2082  -- each beetle moves to exactly one adjacent cell\n  no_overlap : \u2200 p : Position, final.beetles p \u2192 \n    \u2203! p\u2081 : Position, initial.beetles p\u2081 = true \u2227 isAdjacent p\u2081 p  -- at most one beetle per final position\n\ntheorem beetle_movement_creates_empty_cell :\n  \u2200 (move : BeetleMove), \u2203 p : Position, move.final.beetles p = false :=\n  sorry"}
{"id": "CombStruct4Lean_324", "informal_problem": "23.27. The bottom of a rectangular box is paved with tiles of size $2 \\times 2$ and $1 \\times 4$. The tiles were spilled out of the box and one $2 \\times 2$ tile was lost. Instead of it, a $1 \\times 4$ tile was taken out. Prove that it is now impossible to pave the bottom of the box with the tiles.", "formal_statement": "import Mathlib\n\nstructure TilingProblem where\n  width : Nat\n  height : Nat\n  tiles_2x2 : Nat      -- number of 2\u00d72 tiles\n  tiles_1x4 : Nat      -- number of 1\u00d74 tiles\n  \n/-- Represents a valid tiling of a rectangle using 2\u00d72 and 1\u00d74 tiles -/\ndef isValidTiling (p : TilingProblem) : Prop :=\n  -- The area covered by all tiles equals the area of the rectangle\n  p.width * p.height = (p.tiles_2x2 * 4 + p.tiles_1x4 * 4)\n\ntheorem impossible_tiling_after_swap \n  (p : TilingProblem) \n  (h_original : isValidTiling p) \n  (h_swap : \u2203 p_new : TilingProblem, \n      p_new.width = p.width \u2227 \n      p_new.height = p.height \u2227 \n      p_new.tiles_2x2 = p.tiles_2x2 - 1 \u2227 \n      p_new.tiles_1x4 = p.tiles_1x4 + 1) : \n  \u00ac isValidTiling (Classical.choose h_swap) :=\nsorry"}
{"id": "CombStruct4Lean_325", "informal_problem": "23.28. From a sheet of graph paper measuring $29 \\times 29$ cells, 99 squares of size $2 \\times 2$ cells have been cut out. Prove that it is possible to cut out one more such square.", "formal_statement": "import Mathlib\n\nstructure GridPaper where\n  size : Nat\n  cutSquares : Finset (Nat \u00d7 Nat)  -- Coordinates of top-left corners of cut 2x2 squares\n  valid : size = 29\n  noOverlap : \u2200 (p q : Nat \u00d7 Nat), p \u2208 cutSquares \u2192 q \u2208 cutSquares \u2192 p \u2260 q \u2192\n    \u00ac(\u2203 (i j : Fin 2), \n      p.1 + i.val = q.1 + i.val \u2227 \n      p.2 + j.val = q.2 + j.val)\n  inBounds : \u2200 p \u2208 cutSquares, \n    p.1 + 1 < size \u2227 p.2 + 1 < size\n\ntheorem can_cut_one_more_square (g : GridPaper) \n  (h : g.cutSquares.card = 99) : \n  \u2203 (x y : Nat), x + 1 < g.size \u2227 y + 1 < g.size \u2227\n    (\u2200 p \u2208 g.cutSquares, \u00ac(\u2203 (i j : Fin 2), \n      x + i.val = p.1 + i.val \u2227 \n      y + j.val = p.2 + j.val)) :=\n  sorry"}
{"id": "CombStruct4Lean_326", "informal_problem": "23.31. On a grid paper, there are $n$ arbitrary cells. Prove that from them, one can select at least $n / 4$ cells that do not share any common points.", "formal_statement": "import Mathlib\n\n/-- A cell on a finite grid paper with natural number coordinates -/\nstructure GridCell where\n  x : \u2115 \n  y : \u2115\nderiving Repr, BEq, Ord\n\n/-- Two grid cells share a point if they share a vertex or edge -/\ndef share_point (c1 c2 : GridCell) : Prop :=\n  (c1.x = c2.x \u2227 (c1.y = c2.y + 1 \u2228 c1.y = c2.y - 1)) \u2228\n  (c1.y = c2.y \u2227 (c1.x = c2.x + 1 \u2228 c1.x = c2.x - 1)) \u2228\n  (c1.x = c2.x \u2227 c1.y = c2.y)\n\n/-- A set of cells is independent if no two distinct cells share a point -/\ndef is_independent (cells : Finset GridCell) : Prop :=\n  \u2200 (c1 c2 : GridCell), c1 \u2208 cells \u2192 c2 \u2208 cells \u2192 c1 \u2260 c2 \u2192 \u00ac(share_point c1 c2)\n\ntheorem grid_independent_selection {m n : \u2115} (cells : Finset GridCell)\n  (h_size : cells.card = n)\n  (h_bound : \u2200 c \u2208 cells, c.x < m \u2227 c.y < m) :\n  \u2203 (selected : Finset GridCell),\n    selected \u2286 cells \u2227 \n    is_independent selected \u2227 \n    selected.card \u2265 n / 4 :=\n  sorry"}
{"id": "CombStruct4Lean_327", "informal_problem": "23.33*. From 16 tiles of size $1 \\times 3$ and one tile $1 \\times 1$, a square with a side of 7 was formed. Prove that the $1 \\times 1$ tile lies in the center of the square or touches its boundary.", "formal_statement": "import Mathlib\n\nstructure GridPos where\n  mk ::\n  row : Fin 7\n  col : Fin 7\n\nstructure Tile where\n  mk ::\n  position : GridPos\n  orient : Bool   -- true for horizontal, false for vertical\n\ndef validTilePlacement (t : Tile) : Prop :=\n  if t.orient then\n    t.position.col.val + 2 < 7  -- horizontal tile fits within grid\n  else\n    t.position.row.val + 2 < 7  -- vertical tile fits within grid\n\ndef covers (t : Tile) (p : GridPos) : Prop :=\n  if t.orient then\n    t.position.row = p.row \u2227\n    (p.col.val = t.position.col.val \u2228\n     p.col.val = t.position.col.val + 1 \u2228\n     p.col.val = t.position.col.val + 2)\n  else\n    t.position.col = p.col \u2227\n    (p.row.val = t.position.row.val \u2228\n     p.row.val = t.position.row.val + 1 \u2228\n     p.row.val = t.position.row.val + 2)\n\ndef isCenterOrBoundary (p : GridPos) : Prop :=\n  (p.row.val = 3 \u2227 p.col.val = 3) \u2228  -- center\n  p.row.val = 0 \u2228 p.row.val = 6 \u2228 p.col.val = 0 \u2228 p.col.val = 6  -- boundary\n\nstructure TilePlacement where\n  mk ::\n  large_tiles : Finset Tile\n  small_tile : GridPos\n  valid_tiles : \u2200 t \u2208 large_tiles, validTilePlacement t\n  tile_count : large_tiles.card = 16\n  no_overlap : \u2200 p : GridPos,\n    (\u2203 t \u2208 large_tiles, covers t p) \u2192\n    (\u2200 t' \u2208 large_tiles, t' \u2260 t \u2192 \u00accovers t' p)\n  no_small_cover : \u2200 t \u2208 large_tiles, \u00accovers t small_tile\n  full_coverage : \u2200 p : GridPos,\n    p \u2260 small_tile \u2192 \u2203 t \u2208 large_tiles, covers t p\n\ntheorem small_tile_center_or_boundary \n  (tp : TilePlacement) : isCenterOrBoundary tp.small_tile := sorry"}
{"id": "CombStruct4Lean_328", "informal_problem": "23.35. A plane is colored in two colors. Prove that there are two points of the same color, the distance between which is 1.", "formal_statement": "import Mathlib\n\nopen Real\n\nstructure Point where\n  x : \u211d\n  y : \u211d\n\ndef PlaneColoring (\u03b1 : Type) := Point \u2192 \u03b1\n\nnoncomputable def distance (p\u2081 p\u2082 : Point) : \u211d :=\n  sqrt ((p\u2081.x - p\u2082.x)^2 + (p\u2081.y - p\u2082.y)^2)\n\ntheorem exists_same_color_unit_distance {\u03b1 : Type} (c : PlaneColoring \u03b1) \n    [Fintype \u03b1] [DecidableEq \u03b1] (h : Fintype.card \u03b1 = 2) :\n  \u2203 (p\u2081 p\u2082 : Point), c p\u2081 = c p\u2082 \u2227 distance p\u2081 p\u2082 = 1 :=\n  sorry"}
{"id": "CombStruct4Lean_329", "informal_problem": "23.36*. A plane is painted in three colors. Prove that there are two points of the same color, the distance between which is 1.", "formal_statement": "import Mathlib\n\nstructure ColoredPlane where\n  coloring : \u211d \u00d7 \u211d \u2192 Fin 3\n  -- A function that assigns one of three colors (0, 1, or 2) to each point in \u211d\u00b2\n\ntheorem monocromatic_unit_distance (p : ColoredPlane) : \n  \u2203 (x y : \u211d \u00d7 \u211d), \n    x \u2260 y \u2227 \n    p.coloring x = p.coloring y \u2227 \n    Real.sqrt ((x.1 - y.1)^2 + (x.2 - y.2)^2) = 1 :=\n  sorry"}
{"id": "CombStruct4Lean_330", "informal_problem": "23.41*. Several circles of the same radius were placed on a table so that no two overlap. Prove that the circles can be colored with four colors so that any two touching circles are of different colors.", "formal_statement": "import Mathlib\n\nstructure CircleConfiguration (\u03b1 : Type*) [MetricSpace \u03b1] where\n  centers : Set \u03b1\n  radius : \u211d\n  radius_pos : radius > 0\n  no_overlap : \u2200 (c\u2081 c\u2082 : {c // c \u2208 centers}), c\u2081 \u2260 c\u2082 \u2192\n    dist c\u2081.val c\u2082.val \u2265 2 * radius\n\ndef Coloring {\u03b1 : Type*} [MetricSpace \u03b1] (cfg : CircleConfiguration \u03b1) := \n  {c // c \u2208 cfg.centers} \u2192 Fin 4\n\ndef TouchingCircles {\u03b1 : Type*} [MetricSpace \u03b1] (cfg : CircleConfiguration \u03b1) \n    (c\u2081 c\u2082 : {c // c \u2208 cfg.centers}) : Prop :=\n  c\u2081 \u2260 c\u2082 \u2227 dist c\u2081.val c\u2082.val = 2 * cfg.radius\n\ntheorem circle_four_coloring {\u03b1 : Type*} [MetricSpace \u03b1] (cfg : CircleConfiguration \u03b1) :\n  \u2203 (coloring : Coloring cfg),\n    \u2200 (c\u2081 c\u2082 : {c // c \u2208 cfg.centers}), \n      TouchingCircles cfg c\u2081 c\u2082 \u2192 coloring c\u2081 \u2260 coloring c\u2082 :=\n  sorry"}
{"id": "CombStruct4Lean_331", "informal_problem": "25.46*. A segment of length 1 is covered by several segments lying on it. Prove that among them, one can choose several pairwise non-intersecting segments, the sum of the lengths of which is not less than 0.5.", "formal_statement": "import Mathlib\n\nstructure Segment : Type where\n  start : Real\n  len : Real\n  h_pos : len > 0\n  h_in_unit : start \u2265 0 \u2227 start + len \u2264 1\n  \ndef Segment.endpoint (s : Segment) : Real := s.start + s.len\n\ndef disjoint (s\u2081 s\u2082 : Segment) : Prop :=\n  s\u2081.endpoint \u2264 s\u2082.start \u2228 s\u2082.endpoint \u2264 s\u2081.start\n\ntheorem segment_covering_selection {S : Set Segment} \n  (h_nonempty : Set.Nonempty S)\n  (h_cover : \u2200 x : Real, 0 \u2264 x \u2227 x \u2264 1 \u2192 \u2203 s \u2208 S, s.start \u2264 x \u2227 x < s.endpoint) :\n  \u2203 (T : Finset Segment), \n    (\u2200 s \u2208 T, s \u2208 S) \u2227 \n    (\u2200 s\u2081 s\u2082, s\u2081 \u2208 T \u2227 s\u2082 \u2208 T \u2227 s\u2081 \u2260 s\u2082 \u2192 disjoint s\u2081 s\u2082) \u2227\n    (\u2211 s in T, s.len) \u2265 (1/2 : Real) :=\n  sorry"}
{"id": "CombStruct4Lean_332", "informal_problem": "26.3*. On a plane, there are 400 points. Prove that the number of different distances between them is not less than 15.", "formal_statement": "import Mathlib\n\n/-- A point in the Euclidean plane -/\nstructure Point where\n  x : \u211d\n  y : \u211d\n\n/-- Euclidean distance between two points -/\nnoncomputable def distance (p\u2081 p\u2082 : Point) : \u211d :=\n  Real.sqrt ((p\u2081.x - p\u2082.x)^2 + (p\u2081.y - p\u2082.y)^2)\n\n/-- Set of distinct distances between points in a finite set -/\nnoncomputable def distinctDistances (points : Finset Point) : Finset \u211d :=\n  (points.product points).filter (fun p => p.1.x < p.2.x \u2228 (p.1.x = p.2.x \u2227 p.1.y < p.2.y))\n    |>.image (fun p => distance p.1 p.2)\n\n/-- For any set of 400 points in the plane, there are at least 15 distinct distances between them -/\ntheorem min_distinct_distances_between_points \n  (points : Finset Point) \n  (hcard : points.card = 400) :\n  (distinctDistances points).card \u2265 15 :=\n  sorry"}
{"id": "CombStruct4Lean_333", "informal_problem": "30.49*. Using projective transformations of the line, solve the butterfly problem (problem 30.44 ).\n\nTranslate the text above into English, please retain the original text's line breaks and format, and output the translation result directly.", "formal_statement": "import Mathlib\n\n/-- A projective line with its points and transformations -/\nstructure ProjectiveLine where\n  point : Type\n  transformations : Type\n  apply : transformations \u2192 point \u2192 point\n  id : transformations\n  compose : transformations \u2192 transformations \u2192 transformations\n  cross_ratio : point \u2192 point \u2192 point \u2192 point \u2192 \u211d\n  -- Axioms for projective structure\n  id_apply : \u2200 p, apply id p = p\n  compose_apply : \u2200 f g p, apply (compose f g) p = apply f (apply g p)\n  cross_ratio_invariant : \u2200 f a b c d,\n    cross_ratio a b c d = cross_ratio (apply f a) (apply f b) (apply f c) (apply f d)\n  distinct_cross_ratio : \u2200 a b c d,\n    a \u2260 b \u2192 b \u2260 c \u2192 c \u2260 d \u2192 d \u2260 a \u2192\n    \u2203 r, cross_ratio a b c d = r\n\ntheorem butterfly_theorem {P : ProjectiveLine} \n  (A B C D E F : P.point)\n  (hAB : A \u2260 B) (hBC : B \u2260 C) (hCD : C \u2260 D) \n  (hDE : D \u2260 E) (hEF : E \u2260 F) (hFA : F \u2260 A) :\n  P.cross_ratio A B C D = 1 \u2192\n  P.cross_ratio C D E F = 1 \u2192\n  P.cross_ratio E F A B = 1 :=\n  sorry"}
{"id": "CombStruct4Lean_334", "informal_problem": "29. A segment of length 1 is completely covered by some number of smaller segments lying on it. Prove that among these segments, one can find non-intersecting segments whose total length is greater than or equal to $1 / 2$.", "formal_statement": "import Mathlib\n\nstructure Segment where\n  start : \u211d\n  length : \u211d\n  nonneg : length \u2265 0\n  start_bound : 0 \u2264 start\n  end_bound : start + length \u2264 1\n  \ndef Segment.endpoint (s : Segment) : \u211d := s.start + s.length\n\ndef Segment.toSet (s : Segment) : Set \u211d := Set.Icc s.start s.endpoint\n\ndef segments_intersect (s\u2081 s\u2082 : Segment) : Prop :=\n  \u00ac(s\u2081.endpoint \u2264 s\u2082.start \u2228 s\u2082.endpoint \u2264 s\u2081.start)\n\ndef covers (segments : Finset Segment) : Prop :=\n  Set.Icc (0 : \u211d) 1 \u2286 \u22c3 s \u2208 segments, s.toSet\n\ndef pairwise_nonintersecting (segments : Finset Segment) : Prop :=\n  \u2200 s\u2081 \u2208 segments, \u2200 s\u2082 \u2208 segments, s\u2081 \u2260 s\u2082 \u2192 \n    \u00ac(segments_intersect s\u2081 s\u2082)\n\ndef total_length (segments : Finset Segment) : \u211d :=\n  segments.sum (\u03bb s => s.length)\n\ntheorem segment_covering_exists_nonintersecting \n  (segments : Finset Segment) \n  (h_cover : covers segments) :\n  \u2203 subsegments : Finset Segment, \n    subsegments \u2286 segments \u2227 \n    pairwise_nonintersecting subsegments \u2227\n    total_length subsegments \u2265 1/2 :=\n  sorry"}
{"id": "CombStruct4Lean_335", "informal_problem": "54. Prove that in Pascal's triangle, the sum of the numbers in the $(n+1)$-th row is equal to $2^{n}$.", "formal_statement": "import Mathlib\n\ndef binomSum (n : \u2115) : \u2115 := \n  Finset.sum (Finset.range (n + 1)) (fun k => Nat.choose n k)\n\ntheorem pascal_row_sum (n : \u2115) : \n  binomSum n = 2^n :=\n  sorry"}
{"id": "CombStruct4Lean_336", "informal_problem": "63. Let $C_{n}^{k}$ denote the number of ways to light $k$ bulbs out of $n$ (each bulb can be in two states). Prove that the number $C_{n}^{k}$ is located at the $(k+1)$-th position in the $(n+1)$-th row of Pascal's Triangle.", "formal_statement": "import Mathlib\n\n-- A bulb configuration is equivalent to choosing k elements from n elements\nstructure BulbSelection (n : \u2115) where\n  k : \u2115\n  h_valid : k \u2264 n\n\n/-- The position in Pascal's triangle (0-based indexing) -/\ndef pascalPosition (n k : \u2115) : \u2115 \u00d7 \u2115 := (n, k)\n\ntheorem bulb_selection_pascal_triangle (n k : \u2115) (h : k \u2264 n) :\n  Nat.choose n k = Nat.choose (n + 1) k - Nat.choose n (k - 1) :=\n  sorry"}
{"id": "CombStruct4Lean_337", "informal_problem": "92. In the library, there is a certain number of readers (i.e., people who have read at least one book from this library). For any $k$ books ( $1 \\leqslant k \\leqslant \\boldsymbol{n}$ ), it is known how many readers have read all of them. How can we find out how many readers are in the library? (There are a total of $n$ books in the library.)", "formal_statement": "import Mathlib\n\nstructure LibraryData (n : \u2115) where\n  -- For each subset of books, counts readers who have read all books in that subset\n  readersCount : (s : Finset (Fin n)) \u2192 (0 < s.card \u2227 s.card \u2264 n) \u2192 \u2115\n  -- If t contains s, then readers who read all of t also read all of s\n  mono : \u2200 (s t : Finset (Fin n)) \n         (hs : 0 < s.card \u2227 s.card \u2264 n) \n         (ht : 0 < t.card \u2227 t.card \u2264 n),\n         s \u2286 t \u2192 readersCount t ht \u2264 readersCount s hs\n\ntheorem find_total_readers (n : \u2115) (h : n > 0) (data : LibraryData n) :\n  \u2203! total : \u2115,\n    -- total is the number of readers who read at least one book\n    (\u2200 (s : Finset (Fin n)) (hs : 0 < s.card \u2227 s.card \u2264 n),\n      data.readersCount s hs \u2264 total) \u2227\n    -- total is minimal with this property and consistent with inclusion-exclusion\n    (\u2203 (s : Finset (Fin n)) (hs : 0 < s.card \u2227 s.card \u2264 n),\n      data.readersCount s hs = total) :=\n  sorry"}
{"id": "CombStruct4Lean_338", "informal_problem": "1.3. (Czechoslovakia, 52; England, 65). In an infinite \"triangular\" table\n\n\\[\n\\begin{aligned}\n& a_{1,0} \\Leftrightarrow \\&, \\\\\n& a_{2,-1} a_{2,0} a_{2, i} \\\\\n& a_{3,-2} a_{3,-1} a_{3,0} a_{3,1} \\quad a_{3,2} \\\\\n& a_{4,-3} a_{4,-2} a_{4,-1} a_{4,0} a_{4,1} a_{4,2} a_{4,3}\n\\end{aligned}\n\\]\n\n$a_{i, 0}=1$, and each number $a_{n, k}$, located in the $n$-th row $(n \\in \\mathbf{N}, n>1)$ at the $k$-th position $(k \\in \\mathbf{Z},|k|<n)$, is equal to the sum of\n$a_{n-1, k-1}+a_{n-1, k}+a_{n-1, k+1}$ of three numbers from the previous row (if any of these numbers are absent in the table, they are replaced by zero in the sum). Prove that in each row, starting from the \"third\", there is at least one even number.", "formal_statement": "import Mathlib\n\nstructure TriangularArray where\n  table : \u2115 \u2192 \u2124 \u2192 \u2115\n  middle_one : \u2200 n, table n 0 = 1\n  bounds : \u2200 n k, Int.natAbs k \u2265 n \u2192 table n k = 0\n  sum_rule : \u2200 n k, n > 1 \u2192 Int.natAbs k < n \u2192\n    table n k = (if k = 0 then 1 \n                else table (n-1) (k-1) + table (n-1) k + table (n-1) (k+1))\n\ndef isValidPos (n : \u2115) (k : \u2124) : Prop := k < n \u2227 k > -n\n\ntheorem exists_even_number_from_third_row (A : TriangularArray) (n : \u2115) (h : n \u2265 3) :\n  \u2203 k : \u2124, isValidPos n k \u2227 Even (A.table n k) :=\n  sorry"}
{"id": "CombStruct4Lean_339", "informal_problem": "3.4. (USA, 82). Prove that for any value of $n \\in \\mathbf{N}$, the following equality holds:\n\n$$\n\\sum_{k=0}^{n} \\frac{(2 n)!}{(k!)^{2}((n-k)!)^{2}}=\\left(C_{2 n}^{n}\\right)^{2}\n$$", "formal_statement": "import Mathlib\n\ndef binomialSum (n : \u2115) : \u211a :=\n  (Finset.range (n + 1)).sum (fun k => \n    (Nat.factorial (2 * n)) / \n    ((Nat.factorial k)^2 * (Nat.factorial (n - k))^2))\n\ntheorem usa_82_binomial_sum_equality (n : \u2115) : \n  binomialSum n = (Nat.choose (2 * n) n)^2 :=\n  sorry"}
{"id": "CombStruct4Lean_340", "informal_problem": "3.6. (New York, 74). Prove that for any natural values $n \\geqslant k$ the greatest common divisor of the numbers $C_{n}^{k}, C_{n+1}^{k}, \\ldots, C_{n+k}^{k}$ is 1.", "formal_statement": "import Mathlib\n\ndef binomialGCD (n k : \u2115) : \u2115 :=\n  let coeffs := (List.range (k + 1)).map (fun i => Nat.choose (n + i) k)\n  match coeffs with\n  | [] => 1\n  | (x :: xs) => xs.foldl Nat.gcd x\n\ntheorem binomial_gcd_one (n k : \u2115) (h\u2081 : k \u2265 0) (h\u2082 : n \u2265 k) : \n  binomialGCD n k = 1 :=\n  sorry"}
{"id": "CombStruct4Lean_341", "informal_problem": "3.12*. (NBR, 68). Prove that the number $C_{n}^{\\prime 2}$ is odd if and only if the numbers $n, k \\in \\mathbf{N}$ satisfy the condition: if in some digit of the binary representation of the number $k$ there is a 1, then in the same digit of the binary representation of the number $n$ there is also a 1.", "formal_statement": "import Mathlib\n\ndef hasBitImplication (n k : Nat) : Prop :=\n  \u2200 i : Nat, Nat.bit k i = true \u2192 Nat.bit n i = true\n\ntheorem binomial_odd_iff_bit_implication (n k : Nat) :\n  Odd (Nat.choose n 2) \u2194 hasBitImplication n k :=\n  sorry"}
{"id": "CombStruct4Lean_342", "informal_problem": "4.1. (SRP, 78). Prove that for any partition of the set\n\n$$\nX=\\{1 ; 2 ; 3 ; 4 ; 5 ; 6 ; 7 ; 8 ; 9\\}\n$$\n\ninto two subsets, at least one of the resulting subsets contains 3 numbers such that the sum of two of them is twice the third.", "formal_statement": "import Mathlib\n\ndef has_sum_twice_relation (s : Set Nat) : Prop :=\n  \u2203 (a b c : Nat), a \u2208 s \u2227 b \u2208 s \u2227 c \u2208 s \u2227 a + b = 2 * c\n\ntheorem partition_contains_sum_twice :\n  let X : Set Nat := {1, 2, 3, 4, 5, 6, 7, 8, 9}\n  \u2200 (A B : Set Nat), A \u222a B = X \u2192 A \u2229 B = \u2205 \u2192 \n    has_sum_twice_relation A \u2228 has_sum_twice_relation B :=\n  sorry"}
{"id": "CombStruct4Lean_343", "informal_problem": "4.7. (SFRY, 81). The set of numbers $1,2, \\ldots, 100$ is partitioned into 7 subsets. Prove that in at least one of these subsets, there will be either 4 numbers $a, b, c, d$ such that $a+b=c+d$, or 3 numbers $e, f, g$ such that $e+f=2 g$.", "formal_statement": "import Mathlib\n\ndef IsPartition (P : Finset (Finset Nat)) (S : Finset Nat) : Prop :=\n  (\u2200 A \u2208 P, A \u2286 S) \u2227 \n  (\u2200 x \u2208 S, \u2203! A \u2208 P, x \u2208 A) \u2227\n  (\u2205 \u2209 P)\n\ndef HasFourSum (A : Finset Nat) : Prop :=\n  \u2203 a b c d : Nat, \n    a \u2208 A \u2227 b \u2208 A \u2227 c \u2208 A \u2227 d \u2208 A \u2227\n    a \u2260 b \u2227 a \u2260 c \u2227 a \u2260 d \u2227 b \u2260 c \u2227 b \u2260 d \u2227 c \u2260 d \u2227\n    a + b = c + d\n\ndef HasThreeSum (A : Finset Nat) : Prop :=\n  \u2203 e f g : Nat,\n    e \u2208 A \u2227 f \u2208 A \u2227 g \u2208 A \u2227\n    e \u2260 f \u2227 e \u2260 g \u2227 f \u2260 g \u2227\n    e + f = 2 * g\n\ntheorem partition_sum_property :\n  let S := Finset.range 100\n  \u2200 P : Finset (Finset Nat),\n    IsPartition P S \u2192 P.card = 7 \u2192\n    \u2203 A \u2208 P, HasFourSum A \u2228 HasThreeSum A :=\n  sorry"}
{"id": "CombStruct4Lean_344", "informal_problem": "4.20*. (Jury, Finland, 79). A set $\\left(a_{1} ; \\ldots ; a_{n}\\right)$ of natural numbers satisfying the equation\n\n$$\na_{1}+2 a_{2}+\\ldots+n a_{n}=1979\n$$\n\nis called even if the number $r$ is even, and is called odd if the number $n$ is odd. Prove that there are as many even sets as there are odd sets.", "formal_statement": "import Mathlib\n\nstructure NumberSet where\n  n : Nat\n  n_pos : 0 < n\n  seq : Fin n \u2192 Nat\n  sum_eq : (\u2211 i : Fin n, (i.val + 1) * seq i) = 1979\n\ndef isEvenSet (s : NumberSet) : Prop := Even s.n\ndef isOddSet (s : NumberSet) : Prop := Odd s.n\n\ntheorem even_odd_sets_equal :\n  \u2203 (f : NumberSet \u2192 NumberSet) (g : NumberSet \u2192 NumberSet),\n    (\u2200 s, isEvenSet s \u2192 isOddSet (f s)) \u2227\n    (\u2200 s, isOddSet s \u2192 isEvenSet (g s)) \u2227\n    (\u2200 s, g (f s) = s) \u2227 (\u2200 s, f (g s) = s) :=\n  sorry"}
{"id": "CombStruct4Lean_345", "informal_problem": "17.9. (Jury, France, 82). Let all members of the sequences $\\left\\{a_{n}\\right\\}$ and $\\left\\{b_{n}\\right\\}$ be natural numbers. Prove that there exists a pair of indices $p<q$, for which the inequalities $a_{p} \\leqslant a_{q}$ and $b_{p} \\leqslant b_{q}$ hold.", "formal_statement": "import Mathlib\n\nstructure FiniteSequences where\n  n : \u2115\n  a : \u2115 \u2192 \u2115\n  b : \u2115 \u2192 \u2115\n\ntheorem exists_nondecreasing_pair {s : FiniteSequences} :\n  \u2203 (p q : \u2115), p < q \u2227 s.a p \u2264 s.a q \u2227 s.b p \u2264 s.b q :=\n  sorry"}
{"id": "CombStruct4Lean_346", "informal_problem": "24.5. (England, 76). Let 50 subsets $A_{1}, \\ldots, A_{50}$ be chosen in a finite set $X$, each of which contains more than half of the elements of the set $X$. Prove that one can find a subset $B \\subset X$, containing no more than 5 elements and having at least one element in common with each of the sets $A_{1}, \\ldots, A_{50}$.", "formal_statement": "import Mathlib\n\nstructure SubsetSystem (X : Type u) [Finite X] where\n  subsets : Fin 50 \u2192 Set X\n  subset_size_prop : \u2200 i, 2 * Cardinal.mk (subsets i) > Cardinal.mk X\n\ntheorem england_76 {X : Type u} [Finite X] (sys : SubsetSystem X) :\n  \u2203 B : Set X, Cardinal.mk B \u2264 5 \u2227 \u2200 i : Fin 50, Set.Nonempty (sys.subsets i \u2229 B) :=\n  sorry"}
{"id": "CombStruct4Lean_347", "informal_problem": "25.7. (Yugoslavia, 75). In a certain society, any two acquaintances do not have common acquaintances, and any two non-acquaintances have exactly two common acquaintances. Prove that in this society everyone has the same number of acquaintances.", "formal_statement": "import Mathlib\n\n/-- A society where relationships between people follow specific acquaintance rules -/\nstructure Society (Person : Type) [Fintype Person] [Nonempty Person] where\n  acquainted : Person \u2192 Person \u2192 Prop\n  [decRel : DecidableRel acquainted]\n  -- Basic relationship properties\n  basic_props : \n    (\u2200 p, \u00acacquainted p p) \u2227 \n    (\u2200 p\u2081 p\u2082, acquainted p\u2081 p\u2082 \u2194 acquainted p\u2082 p\u2081)\n  -- Core society properties\n  society_props :\n    (\u2200 p\u2081 p\u2082, acquainted p\u2081 p\u2082 \u2192 \u2200 p\u2083, \u00ac(acquainted p\u2081 p\u2083 \u2227 acquainted p\u2082 p\u2083)) \u2227\n    (\u2200 p\u2081 p\u2082, \u00acacquainted p\u2081 p\u2082 \u2192 \n      \u2203! (s : Finset Person), (\u2200 p \u2208 s, acquainted p\u2081 p \u2227 acquainted p\u2082 p) \u2227 s.card = 2)\n\n/-- Counts the number of people who are acquainted with a given person -/\ndef acquaintance_count {Person : Type} [Fintype Person] [Nonempty Person] \n    (S : Society Person) (x : Person) : Nat := \n  have := S.decRel\n  (Finset.univ.filter (fun y => S.acquainted x y)).card\n\n/-- In a society with at least two people where:\n    1) any two acquaintances have no common acquaintances\n    2) any two non-acquaintances have exactly two common acquaintances\n    everyone has the same number of acquaintances -/\ntheorem all_same_acquaintance_count {Person : Type} [Fintype Person] [Nonempty Person]\n    (S : Society Person) (h : 2 \u2264 Fintype.card Person) :\n    \u2200 p\u2081 p\u2082 : Person, acquaintance_count S p\u2081 = acquaintance_count S p\u2082 :=\n  sorry"}
{"id": "CombStruct4Lean_348", "informal_problem": "25.8. (VNR, 77). In each of three schools, there are $n$ students. Any student has a total of $n+1$ acquaintances among students from the other two schools. Prove that it is possible to choose one student from each school such that all three chosen students are acquainted with each other.", "formal_statement": "import Mathlib\n\nstructure ThreeSchools (n : \u2115) where\n  acq12 : Fin n \u2192 Finset (Fin n)  -- School 1 \u2192 School 2\n  acq21 : Fin n \u2192 Finset (Fin n)  -- School 2 \u2192 School 1\n  acq23 : Fin n \u2192 Finset (Fin n)  -- School 2 \u2192 School 3\n  acq32 : Fin n \u2192 Finset (Fin n)  -- School 3 \u2192 School 2\n  acq13 : Fin n \u2192 Finset (Fin n)  -- School 1 \u2192 School 3\n  acq31 : Fin n \u2192 Finset (Fin n)  -- School 3 \u2192 School 1\n  symm12 : \u2200 x y, y \u2208 acq12 x \u2194 x \u2208 acq21 y\n  symm23 : \u2200 x y, y \u2208 acq23 x \u2194 x \u2208 acq32 y\n  symm13 : \u2200 x y, y \u2208 acq13 x \u2194 x \u2208 acq31 y\n  acq_count : \u2200 x : Fin n,\n    (acq12 x).card + (acq13 x).card = n + 1 \u2227    -- School 1 student\n    (acq21 x).card + (acq23 x).card = n + 1 \u2227    -- School 2 student\n    (acq31 x).card + (acq32 x).card = n + 1      -- School 3 student\n\ntheorem three_schools_acquaintance \n    (n : \u2115) \n    (h1 : n > 0) \n    (h2 : n + 1 \u2264 2*n)  -- Ensures n+1 acquaintances is possible\n    (schools : ThreeSchools n) :\n  \u2203 (s1 s2 s3 : Fin n), \n    s2 \u2208 schools.acq12 s1 \u2227 \n    s3 \u2208 schools.acq23 s2 \u2227 \n    s3 \u2208 schools.acq13 s1 :=\n  sorry"}
{"id": "CombStruct4Lean_349", "informal_problem": "26.2. (Jury, NRB, 79). On a grid paper, $n$ cells are marked arbitrarily. Prove that it is always possible to select at least $n / 4$ cells from them, such that no two selected cells touch each other (cells are considered touching if they share at least one vertex).", "formal_statement": "import Mathlib\n\n/-- A cell on the grid paper is represented by its coordinates -/\nstructure GridCell where\n  x : Int\n  y : Int\n\n/-- Two cells are touching if they share at least one vertex -/\ndef touching (c1 c2 : GridCell) : Prop :=\n  max (abs (c1.x - c2.x)) (abs (c1.y - c2.y)) \u2264 1\n\n/-- A set of cells is independent if no two cells in the set are touching -/\ndef isIndependent (cells : Finset GridCell) : Prop :=\n  \u2200 c1 c2, c1 \u2208 cells \u2192 c2 \u2208 cells \u2192 c1 \u2260 c2 \u2192 \u00actouching c1 c2\n\ntheorem grid_independent_cells {n : \u2115} (marked : Finset GridCell)\n    (h : marked.card = n) :\n    \u2203 (selected : Finset GridCell),\n      selected \u2286 marked \u2227\n      isIndependent selected \u2227\n      selected.card \u2265 n / 4 :=\n  sorry"}
{"id": "CombStruct4Lean_350", "informal_problem": "26.14. (USA, 76). a) Let each cell of a rectangular board of size $4 \\times 7$ be colored either white or black. Prove that there must be a rectangle on the board, formed by horizontal and vertical lines of the board, all four corner cells of which are colored the same color.\n\nb) Provide an example of a coloring of a rectangular board of size $4 \\times 6$ for which the rectangle mentioned in part a) does not exist.", "formal_statement": "import Mathlib\n\n-- Represent a board coloring as a function from positions to Bool\n-- where True represents white and False represents black\nstructure BoardColoring (m n : Nat) where\n  color : Fin m \u2192 Fin n \u2192 Bool\n\n-- Define what it means to have a monochromatic rectangle\ndef hasMonochromaticRectangle (m n : Nat) (board : BoardColoring m n) : Prop :=\n  \u2203 (r\u2081 r\u2082 : Fin m) (c\u2081 c\u2082 : Fin n),\n    r\u2081 < r\u2082 \u2227 c\u2081 < c\u2082 \u2227\n    (board.color r\u2081 c\u2081 = board.color r\u2081 c\u2082) \u2227\n    (board.color r\u2081 c\u2081 = board.color r\u2082 c\u2081) \u2227\n    (board.color r\u2081 c\u2081 = board.color r\u2082 c\u2082)\n\ntheorem board_4x7_has_monochromatic_rectangle :\n  \u2200 (board : BoardColoring 4 7), hasMonochromaticRectangle 4 7 board :=\n  sorry"}
{"id": "CombStruct4Lean_351", "informal_problem": "26.15. (Sweden, 82). On a plane with a rectangular coordinate system, consider the set $M$ of points $(x, y)$, where $x, y \\in \\mathbf{N}$, and $x \\leqslant 12, y \\leqslant 12$. Each of these 144 points is colored either red, white, or blue. Prove that there exists a rectangle (with sides parallel to the axes) all of whose vertices belong to the set $M$ and are of the same color.", "formal_statement": "import Mathlib\n\n-- Define a color type for the three possible colors\ninductive Color where\n  | Red : Color\n  | White : Color\n  | Blue : Color\n  deriving Repr, DecidableEq\n\n-- Define a coloring as a function from coordinates to colors\ndef Coloring := (Fin 13 \u00d7 Fin 13) \u2192 Color\n\n-- Define what it means to have a monochromatic rectangle\ndef HasMonochromaticRectangle (c : Coloring) : Prop :=\n  \u2203 (x\u2081 x\u2082 : Fin 13) (y\u2081 y\u2082 : Fin 13),\n    x\u2081 < x\u2082 \u2227 y\u2081 < y\u2082 \u2227\n    c (x\u2081, y\u2081) = c (x\u2081, y\u2082) \u2227\n    c (x\u2081, y\u2081) = c (x\u2082, y\u2081) \u2227\n    c (x\u2081, y\u2081) = c (x\u2082, y\u2082)\n\ntheorem sweden_1982 :\n  \u2200 c : Coloring, HasMonochromaticRectangle c :=\n  sorry"}
{"id": "CombStruct4Lean_352", "informal_problem": "26.18*. (PRC, 81). The cells of an $n \\times n$ chessboard, where $n$ is an even number greater than 2, are colored with $n^{2} / 2$ colors such that each color is used to color exactly two cells. Prove that it is possible to place $n$ rooks on the board such that they stand on cells of different colors and do not attack each other.", "formal_statement": "import Mathlib\n\nstructure ColoredBoard where\n  n : Nat\n  n_even : Even n\n  n_gt_2 : n > 2\n  coloring : Fin n \u00d7 Fin n \u2192 Fin (n * n / 2)\n  two_per_color : \u2200 c : Fin (n * n / 2), \n    (Finset.filter (\u03bb p => coloring p = c) (Finset.product Finset.univ Finset.univ)).card = 2\n\n/-- A valid rook placement is one where no two rooks share a row or column -/\ndef ValidRookPlacement {n : Nat} (rooks : Finset (Fin n \u00d7 Fin n)) : Prop :=\n  (rooks.card = n) \u2227 \n  (\u2200 p \u2208 rooks, \u2200 q \u2208 rooks, p \u2260 q \u2192 p.1 \u2260 q.1 \u2227 p.2 \u2260 q.2)\n\n/-- All rooks must be placed on cells of different colors -/\ndef RooksHaveDifferentColors (board : ColoredBoard) (rooks : Finset (Fin board.n \u00d7 Fin board.n)) : Prop :=\n  \u2200 p \u2208 rooks, \u2200 q \u2208 rooks, p \u2260 q \u2192 ColoredBoard.coloring board p \u2260 ColoredBoard.coloring board q\n\ntheorem colored_board_rook_placement \n  (board : ColoredBoard) : \n  \u2203 rooks : Finset (Fin (ColoredBoard.n board) \u00d7 Fin (ColoredBoard.n board)),\n    ValidRookPlacement rooks \u2227 RooksHaveDifferentColors board rooks :=\n  sorry"}
{"id": "CombStruct4Lean_353", "informal_problem": "2. Each person who has ever lived on Earth has exchanged a certain number of handshakes with others. Prove that the number of people who have exchanged an odd number of handshakes is even.", "formal_statement": "import Mathlib\n\nstructure HandshakeGraph (n : \u2115) where\n  handshakes : Fin n \u2192 Fin n \u2192 \u2115\n  symm : \u2200 i j, handshakes i j = handshakes j i\n  no_self : \u2200 i, handshakes i i = 0\n\n/-- The degree (total number of handshakes) of a person in the graph -/\ndef degree (n : \u2115) (g : HandshakeGraph n) (p : Fin n) : \u2115 := \n  Finset.sum (Finset.univ.erase p) (g.handshakes p)\n\n/-- The set of people with odd degree (odd number of handshakes) -/\ndef oddDegreeSet (n : \u2115) (g : HandshakeGraph n) : Finset (Fin n) :=\n  Finset.univ.filter (fun p => degree n g p % 2 = 1)\n\ntheorem odd_degree_vertices_even {n : \u2115} (g : HandshakeGraph n) : \n  Even (oddDegreeSet n g).card :=\n  sorry"}
{"id": "CombStruct4Lean_354", "informal_problem": "6. A large number of scientists arrived at the congress; some of them were previously acquainted with each other, others -[^1]not. It turned out that no two scientists with the same number of acquaintances had any common acquaintances. Prove that among the scientists present at the congress, there is a scientist who is acquainted with exactly one participant of the congress.", "formal_statement": "import Mathlib\n\nopen Finset Prod\n\nstructure Congress where\n  scientists : Finset Nat\n  acquainted : Finset (Nat \u00d7 Nat)\n  symm : \u2200 x y, (x, y) \u2208 acquainted \u2194 (y, x) \u2208 acquainted\n  irrefl : \u2200 x, (x, x) \u2209 acquainted\n  valid : \u2200 (x y), (x, y) \u2208 acquainted \u2192 x \u2208 scientists \u2227 y \u2208 scientists\n\n/-- Number of scientists that a given scientist is acquainted with -/\ndef acquaintanceCount (c : Congress) (s : Nat) : Nat :=\n  (c.acquainted.filter (fun p => p.1 = s)).card\n\n/-- Set of scientists who are acquainted with both s\u2081 and s\u2082 -/\ndef commonAcquaintances (c : Congress) (s\u2081 s\u2082 : Nat) : Finset Nat :=\n  c.scientists.filter (fun x => (s\u2081, x) \u2208 c.acquainted \u2227 (s\u2082, x) \u2208 c.acquainted)\n\ntheorem exists_one_acquaintance (c : Congress) \n  (h_size : c.scientists.card \u2265 2)\n  (h_same_count : \u2200 (s\u2081 s\u2082 : Nat), s\u2081 \u2208 c.scientists \u2192 s\u2082 \u2208 c.scientists \u2192 \n    acquaintanceCount c s\u2081 = acquaintanceCount c s\u2082 \u2192 \n    s\u2081 = s\u2082 \u2228 (commonAcquaintances c s\u2081 s\u2082).card = 0) :\n  \u2203 s \u2208 c.scientists, acquaintanceCount c s = 1 :=\n  sorry"}
{"id": "CombStruct4Lean_355", "informal_problem": "19*. In the country of Dolphinia, there are $n$ cities, each pair of which is connected by a highway, and movement along all highways is one-way. Prove that if $n \\neq 2$ or 4, the directions of movement along the highways can be chosen such that from any city to any other city, one can travel with no more than one intermediate stop; if, however, $n=2$ or 4, such movement cannot be organized.", "formal_statement": "import Mathlib\n\nopen Function\n\n/-- A directed graph where each pair of vertices has exactly one directed edge -/\nstructure DirectedGraph (n : Nat) where\n  edges : Fin n \u2192 Fin n \u2192 Prop                   -- directed edges as propositions\n  exclusive : \u2200 i j, i \u2260 j \u2192                     -- exactly one direction between distinct vertices\n    (edges i j \u2194 \u00acedges j i)\n  no_self_loops : \u2200 i, \u00acedges i i               -- no self-loops\n\n/-- A path of length exactly k exists between two vertices -/\ndef PathOfLength (G : DirectedGraph n) (k : Nat) (i j : Fin n) : Prop :=\n  match k with\n  | 0 => i = j\n  | 1 => G.edges i j\n  | 2 => \u2203 v, G.edges i v \u2227 G.edges v j\n  | _ => False\n\n/-- There exists a path of length at most 2 between vertices -/\ndef HasShortPath (G : DirectedGraph n) (i j : Fin n) : Prop :=\n  \u2203 k \u2264 2, PathOfLength G k i j\n\n/-- For n \u2260 2,4, a directed graph exists where all paths are \u2264 2; \n    for n = 2,4, no such graph exists -/\ntheorem dolphinia_cities :\n  \u2200 n : Nat, (n = 2 \u2228 n = 4) \u2194 \n    \u00ac\u2203 (G : DirectedGraph n), \u2200 i j : Fin n, HasShortPath G i j :=\n  sorry"}
{"id": "CombStruct4Lean_356", "informal_problem": "173. A square table of $n^{2}$ cells is filled with integers from 1 to $n$ such that each row and each column of the table contains all numbers from 1 to $n$. Prove that if the table is symmetric with respect to the diagonal leading from its upper left corner to the lower right corner, and $n$ is odd, then all numbers from 1 to $n$ will appear on this diagonal. Will this statement also be true when $n$ is even?", "formal_statement": "import Mathlib\n\nstructure SymmetricTable (n : Nat) where\n  -- The table represented as a function from row and column indices to values\n  values : Fin n \u2192 Fin n \u2192 Fin n\n  -- Each row contains all numbers from 1 to n\n  row_complete : \u2200 i : Fin n, Function.Surjective (values i)\n  -- Each column contains all numbers from 1 to n\n  col_complete : \u2200 j : Fin n, Function.Surjective (fun i => values i j)\n  -- Table is symmetric across main diagonal\n  symmetric : \u2200 (i j : Fin n), values i j = values j i\n\ntheorem diagonal_contains_all_odd (n : Nat) (h : n > 0) (hodd : Odd n) \n  (t : SymmetricTable n) : Function.Surjective (fun i => t.values i i) :=\n  sorry"}
{"id": "CombStruct4Lean_357", "informal_problem": "103*. a) Show that there exist nine pairwise distinct squares from which a certain rectangle can be formed.\n\nb) From 10 pairwise distinct squares, form a rectangle with sides 47 and 65.\n\nc) Show that for any number $n$, greater than eight, it is always possible to find $n$ pairwise distinct squares from which a rectangle can be formed.", "formal_statement": "import Mathlib\n\n-- Part (a) and (b) are specific instances of part (c), so we'll formalize the general case\n\n/-- A configuration of squares that form a rectangle -/\nstructure SquareRectConfig where\n  n : \u2115                     -- number of squares\n  squares : Fin n \u2192 \u2115       -- the side lengths of the squares\n  distinct : \u2200 i j, i \u2260 j \u2192 squares i \u2260 squares j  -- squares are pairwise distinct\n  width : \u2115                 -- width of the rectangle\n  height : \u2115                -- height of the rectangle\n  forms_rectangle : width * height = (\u2211 i, (squares i) ^ 2)  -- squares form the rectangle\n\ntheorem squares_form_rectangle (n : \u2115) (h : n > 8) : \n  \u2203 (config : SquareRectConfig), config.n = n :=\n  sorry"}
{"id": "CombStruct4Lean_358", "informal_problem": "8. Prove that in any group of six schoolchildren, there are always either three schoolchildren who are all acquainted with each other, or three schoolchildren, each of whom is not acquainted with the other two.", "formal_statement": "import Mathlib\n\n-- Define a type for representing acquaintance relationships\nstructure AcquaintanceGraph where\n  -- A function that returns true if two children are acquainted\n  knows : Fin 6 \u2192 Fin 6 \u2192 Bool\n  -- The relation is symmetric\n  symm : \u2200 i j, knows i j = knows j i\n  -- A child cannot be acquainted with themselves\n  irrefl : \u2200 i, knows i i = false\n\ntheorem ramsey_acquaintance_theorem (g : AcquaintanceGraph) :\n  (\u2203 (a b c : Fin 6), \n    -- Either there are three children who all know each other\n    (g.knows a b \u2227 g.knows b c \u2227 g.knows a c) \u2228\n    -- Or there are three children who all don't know each other\n    (\u00acg.knows a b \u2227 \u00acg.knows b c \u2227 \u00acg.knows a c)) :=\n  sorry"}
{"id": "CombStruct4Lean_359", "informal_problem": "9. In a chess tournament, $n$ chess players, including grandmasters and masters, participated. After the tournament, it turned out that each participant scored exactly half of their points in games against masters. Prove that $\\sqrt{n}$ is an integer.", "formal_statement": "import Mathlib\n\nstructure ChessPlayer where\n  isMaster : Bool\n  points : Nat\n  gamesAgainstMasters : Nat\n  pointsAgainstMasters : Nat\n\nstructure ChessTournament where\n  n : Nat\n  players : Fin n \u2192 ChessPlayer\n  -- Each player's total points is twice their points against masters\n  points_condition : \u2200 i, (players i).points = 2 * (players i).pointsAgainstMasters\n\ntheorem chess_tournament_sqrt_integer (t : ChessTournament) :\n  \u2203 k : Nat, t.n = k * k :=\n  sorry"}
{"id": "CombStruct4Lean_360", "informal_problem": "22**. A circle is divided into 256 sectors. Prove that it is possible to write an eight-digit number, consisting only of ones and twos (for example, 12212111, 22121121), in each sector such that: a) any two numbers will be different, b) any two numbers in adjacent sectors will differ in exactly one digit.", "formal_statement": "import Mathlib\n\n-- Define valid digits (1 or 2)\ndef Digit := {n : Nat // n = 1 \u2228 n = 2}\n\n-- An 8-digit number is a function from positions to digits\ndef Number := Fin 8 \u2192 Digit\n\n-- Helper to check if two numbers differ in exactly one position\ndef differsInOneDigit (n1 n2 : Number) : Prop :=\n  \u2203! pos : Fin 8, n1 pos \u2260 n2 pos\n\n-- Main structure representing the circular arrangement\nstructure CircularArrangement where\n  -- Assignment of numbers to sectors\n  numbers : Fin 256 \u2192 Number\n  -- All numbers must be different\n  all_different : \u2200 i j : Fin 256, i \u2260 j \u2192 numbers i \u2260 numbers j\n  -- Adjacent sectors differ in exactly one digit\n  adjacent_differ : \u2200 i : Fin 256,\n    differsInOneDigit (numbers i) (numbers ((i.val + 1) % 256))\n\ntheorem circular_arrangement_exists : \u2203 arr : CircularArrangement, True :=\n  sorry"}
{"id": "CombStruct4Lean_361", "informal_problem": "28**. In the Martian language, the alphabet consists of the letters $A$ and O. Any two words of the same length differ in at least three positions. Prove that the number of words of length $n$ is no more than $2^{n} /(n+1)$.", "formal_statement": "import Mathlib\n\ndef hamming_distance {n : Nat} (w\u2081 w\u2082 : Fin n \u2192 Bool) : Nat :=\n  (Finset.filter (fun i => w\u2081 i \u2260 w\u2082 i) (Finset.univ : Finset (Fin n))).card\n\nstructure MartianLanguage where\n  n : Nat\n  words : Finset (Fin n \u2192 Bool)\n  valid_distance : \u2200 w\u2081 w\u2082, w\u2081 \u2208 words \u2192 w\u2082 \u2208 words \u2192 w\u2081 \u2260 w\u2082 \u2192\n    hamming_distance w\u2081 w\u2082 \u2265 3\n\ntheorem martian_language_bound (n : Nat) (L : MartianLanguage) :\n  L.words.card * (n + 1) \u2264 2^n := sorry"}
{"id": "CombStruct4Lean_362", "informal_problem": "38. In class 4A, there are 30 students. During a dictation, one student made 12 mistakes, and the others made fewer. Prove that there are at least three students in the class who made the same number of mistakes.", "formal_statement": "import Mathlib\n\nstructure DictationClass where\n  numStudents : \u2115\n  mistakes : Fin numStudents \u2192 \u2115\n\ntheorem pigeonhole_dictation\n  (c : DictationClass)\n  (h_size : c.numStudents = 30)\n  (h_bound : \u2200 i, c.mistakes i \u2264 12) :\n  \u2203 m : \u2115, \u2203 s : Finset (Fin c.numStudents),\n    s.card = 3 \u2227 \n    (\u2200 i \u2208 s, c.mistakes i = m) :=\n  sorry"}
{"id": "CombStruct4Lean_363", "informal_problem": "39. 30 teams participate in a football championship. Each pair of teams must play one match against each other. Prove that at any moment during the competitions, there are two teams that have played the same number of matches up to that point.", "formal_statement": "import Mathlib\n\n-- A team's state in the championship is represented by the number of matches played\nstructure TeamState where\n  matches_played : Nat\n\n-- The championship state tracks the number of matches played by each team\nstructure ChampionshipState where\n  n_teams : Nat\n  team_states : Fin n_teams \u2192 TeamState\n  -- Each pair of teams must eventually play one match\n  total_matches_constraint : n_teams = 30\n\ntheorem pigeonhole_in_championship (state : ChampionshipState) :\n  \u2203 (i j : Fin state.n_teams), i \u2260 j \u2227\n    (state.team_states i).matches_played = (state.team_states j).matches_played :=\n  sorry"}
{"id": "CombStruct4Lean_364", "informal_problem": "40. Prove that on October 23, 1965, in the cinema \"Mir\" during the first session, there were at least two viewers who had the same number of acquaintances among those sitting in the hall (it is known that 5 people were sitting in the first row).", "formal_statement": "import Mathlib\n\nopen Finset\n\nstructure CinemaViewer where\n  id : Nat\n  acquaintances : Finset Nat\n  h_no_self : id \u2209 acquaintances  -- Cannot be acquainted with oneself\n\n/-- A valid viewer configuration requires symmetric acquaintance relationships -/\ndef validViewerConfig (viewers : Finset CinemaViewer) : Prop :=\n  \u2200 v1 \u2208 viewers, \u2200 v2 \u2208 viewers,\n    v2.id \u2208 v1.acquaintances \u2194 v1.id \u2208 v2.acquaintances\n\n/-- Count of acquaintances for a viewer among the given viewer set -/\ndef acquaintanceCount (v : CinemaViewer) (viewers : Finset CinemaViewer) : Nat :=\n  (v.acquaintances.filter (\u03bb id \u21a6 \u2203 v' \u2208 viewers, v'.id = id)).card\n\ntheorem cinema_acquaintances_1965 \n  (viewers : Finset CinemaViewer)\n  (h_valid : validViewerConfig viewers)\n  (h_first_row : \u2203 first_row : Finset CinemaViewer, first_row \u2286 viewers \u2227 first_row.card = 5) :\n  \u2203 (v1 v2 : CinemaViewer), \n    v1 \u2208 viewers \u2227 \n    v2 \u2208 viewers \u2227 \n    v1 \u2260 v2 \u2227 \n    acquaintanceCount v1 viewers = acquaintanceCount v2 viewers :=\n  sorry"}
{"id": "CombStruct4Lean_365", "informal_problem": "41. Given 20 distinct positive integers, all less than 70. Prove that among their differences, there will be 4 identical ones.", "formal_statement": "import Mathlib\n\nstructure NumberSet where\n  nums : Finset \u2115\n  distinct : nums.card = 20\n  range : \u2200 n \u2208 nums, n > 0 \u2227 n < 70\n\ndef absDiff (a b : \u2115) : \u2115 := \n  if a \u2265 b then a - b else b - a\n\n/-- The multiset of all possible differences between pairs of numbers in the set -/\ndef allDifferences (s : NumberSet) : Multiset \u2115 :=\n  (s.nums.product s.nums).val.map (fun p => absDiff p.1 p.2)\n\ntheorem four_identical_differences (s : NumberSet) :\n  \u2203 d : \u2115, (allDifferences s).count d \u2265 4 :=\n  sorry"}
{"id": "CombStruct4Lean_366", "informal_problem": "72. Seven mushroom pickers collected a total of 100 mushrooms, and each of the seven collected a different number of mushrooms. Prove that there are three mushroom pickers who together collected no fewer than 50 mushrooms.", "formal_statement": "import Mathlib\n\nstructure MushroomCollection where\n  pickers : Fin 7 \u2192 Nat\n  total_is_100 : (\u2211 i, pickers i) = 100\n  all_different : \u2200 i j, i \u2260 j \u2192 pickers i \u2260 pickers j\n\ntheorem mushroom_pickers_theorem (c : MushroomCollection) :\n  \u2203 (i j k : Fin 7), i \u2260 j \u2227 j \u2260 k \u2227 i \u2260 k \u2227\n    c.pickers i + c.pickers j + c.pickers k \u2265 50 :=\n  sorry"}
{"id": "CombStruct4Lean_367", "informal_problem": "76**. Several numbers are arranged around a circle, the sum of which is positive. Prove that one can choose such a number that it itself is positive, the sum of it and the next one in the clockwise direction is positive, and so on.", "formal_statement": "import Mathlib\n\nstructure CircularArrangement (n : \u2115) [NeZero n] where\n  numbers : ZMod n \u2192 \u211d\n  sum_pos : (Finset.sum (Finset.univ : Finset (ZMod n)) numbers) > 0\n\ndef consecutive_sum {n : \u2115} [NeZero n] (numbers : ZMod n \u2192 \u211d) (start : ZMod n) (k : \u2115) : \u211d :=\n  Finset.sum (Finset.range k) fun i => numbers (start + i)\n\ntheorem exists_positive_consecutive_sums {n : \u2115} [NeZero n] (arr : CircularArrangement n) :\n  \u2203 start : ZMod n, \u2200 k : \u2115, k \u2264 n \u2192 consecutive_sum arr.numbers start k > 0 :=\n  sorry"}
{"id": "CombStruct4Lean_368", "informal_problem": "Example 9. Prove the recurrence formula for binomial probabilities:\n\n$$\nP_{n}(k+1)=\\frac{p}{q} \\frac{n-k}{k+1} P_{n}(k)\n$$", "formal_statement": "import Mathlib\n\ndef binomialProb (n k : \u2115) (p : \u211d) : \u211d :=\n  (n.choose k) * p^k * (1-p)^(n-k)\n\ntheorem binomial_prob_recurrence \n  (n k : \u2115) (p q : \u211d) \n  (h1 : k < n)\n  (h2 : p + q = 1) \n  (h3 : p \u2260 0) \n  (h4 : q \u2260 0) :\n  binomialProb n (k+1) p = (p/q) * ((n-k)/(k+1)) * binomialProb n k p :=\n  sorry"}
{"id": "CombStruct4Lean_369", "informal_problem": "17. (\u00abMatching Problem\u00bb.) Suppose there are $n$ letters and $n$ envelopes. The letters are placed into the envelopes \"randomly,\" meaning that the assignment of probabilities is done according to the \"classical\" method of defining probabilities. Let $P_{(m)}$ be the probability that exactly $m$ letters end up in their \"correct\" envelopes.\n\nShow that\n\n$$\nP_{(m)}=\\frac{1}{m!}\\left(1+\\sum_{j=1}^{n-m} \\frac{(-1)^{j}}{j!}\\right)\n$$", "formal_statement": "import Mathlib\n\n/-- The probability of exactly m letters being correctly placed in n envelopes\n    under the classical probability model (uniform distribution over permutations).\n    This is computed as (number of permutations with m fixed points) / n! -/\ndef matching_probability (n m : \u2115) : \u211a :=\n  let derangement_sum (k : \u2115) : \u211a := \u2211 j in Finset.range (k + 1), ((-1 : \u211a)^j / (Nat.factorial j : \u211a))\n  let derangement (k : \u2115) : \u211a := (Nat.factorial k : \u211a) * derangement_sum k\n  (Nat.choose n m : \u211a) * derangement (n - m) / (Nat.factorial n : \u211a)\n\ntheorem matching_probability_formula (n m : \u2115) (h\u2081 : m \u2264 n) (h\u2082 : n > 0) :\n  matching_probability n m = \n    1 / (Nat.factorial m : \u211a) * \n      (1 + \u2211 j in Finset.range (n - m), ((-1 : \u211a)^j / (Nat.factorial j : \u211a))) :=\n  sorry"}
{"id": "CombStruct4Lean_370", "informal_problem": "22. From an urn containing $M$ balls numbered $1, \\ldots, M$, a \"random\" selection is made $n$ times with replacement. Consider the event $A_{k}$, which consists of the maximum number of the drawn balls being $k$. Show that\n\n$$\n\\mathrm{P}\\left(A_{k}\\right)=\\frac{k^{n}-(k-1)^{n}}{N^{n}}\n$$\n\nAlso show that if the selection is made without replacement, then\n\n$$\n\\mathrm{P}\\left(A_{k}\\right)=\\frac{C_{k-1}^{n-1}}{C_{N}^{k}}, \\quad n \\leqslant k \\leqslant N .\n$$", "formal_statement": "import Mathlib\n\nstructure DrawingExperiment where\n  M : \u2115                 -- Total number of balls in urn\n  n : \u2115                 -- Number of draws\n  k : \u2115                 -- Maximum number considered\n  h1 : k \u2264 M           -- Maximum number must be less than or equal to total balls\n  h2 : n > 0           -- Number of draws must be positive\n\n/-- Probability of maximum number being k in n draws with replacement -/\ndef probWithReplacement (e : DrawingExperiment) : \u211a :=\n  (e.k ^ e.n - (e.k - 1) ^ e.n) / e.M ^ e.n\n\n/-- Probability of maximum number being k in n draws without replacement -/\ndef probWithoutReplacement (e : DrawingExperiment) : \u211a :=\n  Nat.choose (e.k - 1) (e.n - 1) / Nat.choose e.M e.k\n\ntheorem drawing_probability_correct (e : DrawingExperiment) :\n  let withRepl := probWithReplacement e\n  let withoutRepl := probWithoutReplacement e\n  (withRepl = (e.k ^ e.n - (e.k - 1) ^ e.n) / e.M ^ e.n) \u2227\n  (e.n \u2264 e.k \u2192 withoutRepl = Nat.choose (e.k - 1) (e.n - 1) / Nat.choose e.M e.k) :=\n  sorry"}
{"id": "CombStruct4Lean_371", "informal_problem": "8. Prove the following duality property of Stirling numbers of the first and second kind:\n\n$$\n\\sum_{n \\geqslant 0} S_{N}^{n} s_{n}^{M}=\\delta_{N M}\n$$\n\nwhere $\\delta_{a b}$ is the Kronecker delta ( $\\delta_{a a}=1, \\delta_{a b}=0$, if $a \\neq b$ ).", "formal_statement": "import Mathlib\n\ndef StirlingFirst (n k : \u2115) : \u2124 :=\n  if n = 0 \u2227 k = 0 then 1\n  else if k = 0 \u2228 n = 0 then 0\n  else StirlingFirst (n-1) (k-1) - (n-1) * StirlingFirst (n-1) k\n\ndef StirlingSecond (n k : \u2115) : \u2124 :=\n  if n = 0 \u2227 k = 0 then 1\n  else if k = 0 \u2228 n = 0 then 0\n  else StirlingSecond (n-1) (k-1) + k * StirlingSecond (n-1) k\n\ndef KroneckerDelta (a b : \u2115) : \u2124 :=\n  if a = b then 1 else 0\n\ntheorem stirling_duality (N M : \u2115) :\n  (\u2211' (n : \u2115), (StirlingFirst N n) * (StirlingSecond n M)) = KroneckerDelta N M :=\n  sorry"}
{"id": "CombStruct4Lean_372", "informal_problem": "16. Let $P_{N}=\\sum_{n=0}^{N}(N)_{n}$ be the total number of arrangements of $N$ elements $\\left((N)_{0}=1,(N)_{n}=N(N-1) \\ldots(N-n+1)\\right), N \\geqslant 1$. Show that the numbers $P_{N}$ satisfy the following recurrence relations ( $P_{0}=1$ ):\n\n$$\nP_{N}=N P_{N-1}+1, \\quad N \\geqslant 1\n$$\n\nShow also that\n\n$$\nP_{N}=N!\\sum_{n=0}^{N} \\frac{1}{n!}\n$$\n\nand that $P_{N}$ is the nearest integer to $e N!$.", "formal_statement": "import Mathlib\n\nopen Nat BigOperators\n\ndef falling_factorial (N n : \u2115) : \u2115 := \n  if n = 0 then 1\n  else Finset.prod (Finset.range n) fun i => (N - i)\n\ndef P (N : \u2115) : \u2115 := \n  Finset.sum (Finset.range (N + 1)) fun n => falling_factorial N n\n\ntheorem P_recurrence_and_sum_and_nearest {N : \u2115} (h : 0 < N) : \n  -- First part: recurrence relation\n  P N = N * P (N-1) + 1 \u2227 \n  -- Second part: factorial sum representation\n  (P N : \u211d) = N.factorial * \u2211 n in Finset.range (N + 1), 1 / n.factorial \u2227\n  -- Third part: nearest integer to e\u22c5N!\n  |P N - Real.exp 1 * N.factorial| \u2264 1/2 :=\n  sorry"}
{"id": "CombStruct4Lean_373", "informal_problem": "29. Let $\\Omega$ be a set consisting of no more than a countable number of elements, and let $\\mathscr{F}$ be some $\\sigma$-algebra of its subsets. Show that there always exists a partition $D_{1}, D_{2}, \\ldots$ (i.e., $\\bigcup_{n} D_{n}=\\Omega$ and $D_{m} \\cap D_{n}=\\varnothing, m \\neq n$), generating $\\mathscr{F}$:\n\n$$\n\\mathscr{F}=\\left\\{\\bigcup_{n \\in N} D_{n}, N \\subseteq \\mathbb{N}\\right\\}\n$$", "formal_statement": "import Mathlib\n\n/-- A partition sequence of measurable sets -/\nstructure MeasurablePartition (\u03b1 : Type*) [MeasurableSpace \u03b1] where\n  partition : \u2115 \u2192 Set \u03b1\n  measurable : \u2200 n, MeasurableSet (partition n)\n  disjoint : \u2200 m n, m \u2260 n \u2192 Disjoint (partition m) (partition n)\n  covers : (\u22c3 n, partition n) = Set.univ\n\ntheorem exists_generating_partition {\u03b1 : Type*} [MeasurableSpace \u03b1] [Countable \u03b1] :\n  \u2203 (P : MeasurablePartition \u03b1), \u2200 (A : Set \u03b1),\n    MeasurableSet A \u2194 \u2203 (N : Set \u2115), A = \u22c3 n \u2208 N, P.partition n :=\n  sorry"}
{"id": "CombStruct4Lean_374", "informal_problem": "32. Let sets $A_{1}, \\ldots, A_{N} \\subset\\{1, \\ldots, n\\}$ be such that none of them is a subset of any other. Prove Sperner's lemma, which states that\n\n$$\nN \\leqslant C_{n}^{[n / 2]}\n$$\n\nwhere $[x]$ is the integer part of $x \\in \\mathbb{R}$.", "formal_statement": "import Mathlib\n\n\n\ntheorem sperner_lemma {\u03b1 : Type*} [Fintype \u03b1] (\ud835\udc9c : Finset (Finset \u03b1))\n  (h : IsAntichain (\u00b7 \u2286 \u00b7) (\ud835\udc9c : Set (Finset \u03b1))) :\n  \ud835\udc9c.card \u2264 (Fintype.card \u03b1).choose (Fintype.card \u03b1 / 2) :=\n  sorry"}
{"id": "CombStruct4Lean_375", "informal_problem": "56. 17 scientists are corresponding with each other. The correspondence is conducted on three scientific topics. Each pair of scientists corresponds with each other on one topic. Prove that at least three scientists correspond with each other on the same topic.", "formal_statement": "import Mathlib\n\nstructure Correspondence where\n  scientists : Finset (Fin 17)  -- Set of 17 scientists\n  topics : Fin 3               -- Three topics\n  topic_assignment : (Fin 17 \u00d7 Fin 17) \u2192 Fin 3  -- Assignment of topics to pairs\n  valid : \u2200 (i j : Fin 17), i \u2260 j \u2192 \n    topic_assignment (i, j) = topic_assignment (j, i)  -- Symmetric correspondence\n\ntheorem ramsey_correspondence : \n  \u2200 (c : Correspondence), \u2203 (topic : Fin 3) (s1 s2 s3 : Fin 17),\n    s1 \u2260 s2 \u2227 s2 \u2260 s3 \u2227 s1 \u2260 s3 \u2227\n    c.topic_assignment (s1, s2) = topic \u2227\n    c.topic_assignment (s2, s3) = topic \u2227\n    c.topic_assignment (s1, s3) = topic :=\n  sorry"}
{"id": "CombStruct4Lean_376", "informal_problem": "22. Network of Squares. A plane can be covered with equal squares; the nodes of this network in mathematics are called an integer lattice.\n\nCan the nodes be labeled with the letters $a, b, c, d$ such that each composite square has all four letters at its vertices and such that every column and every row of the lattice also contains all four letters?", "formal_statement": "import Mathlib\n\n-- Define the type for our labels\ninductive Label\n  | a | b | c | d\n\n-- A labeling is a function from integer coordinates to labels\nstructure LatticeLabeling\u1d62 where\n  label : \u2124 \u00d7 \u2124 \u2192 Label\n\n-- Check if a 1\u00d71 square has all different labels\ndef hasAllLabels (f : LatticeLabeling\u1d62) (x y : \u2124) : Prop :=\n  let vertices := [(x,y), (x+1,y), (x+1,y+1), (x,y+1)]\n  \u2200 l : Label, \u2203 v \u2208 vertices, f.label v = l\n\n-- Check if a row contains all labels\ndef rowHasAllLabels (f : LatticeLabeling\u1d62) (y : \u2124) : Prop :=\n  \u2200 l : Label, \u2203 x : \u2124, f.label (x,y) = l\n\n-- Check if a column contains all labels\ndef colHasAllLabels (f : LatticeLabeling\u1d62) (x : \u2124) : Prop :=\n  \u2200 l : Label, \u2203 y : \u2124, f.label (x,y) = l\n\ntheorem network_of_squares_labeling :\n  \u2203 (f : LatticeLabeling\u1d62),\n    (\u2200 x y : \u2124, hasAllLabels f x y) \u2227 \n    (\u2200 y : \u2124, rowHasAllLabels f y) \u2227\n    (\u2200 x : \u2124, colHasAllLabels f x) :=\n  sorry"}
{"id": "CombStruct4Lean_377", "informal_problem": "77. Chessboard. Let a square or rectangular chessboard have an odd number of cells (for example, 49 or 63). Cells that share a side will be called adjacent.\n\nOn each cell of the chessboard, we place one pawn, then collect the pawns and place them again on the cells of the chessboard.\n\nIs it possible for each pawn to end up in a cell adjacent to the one it originally occupied?", "formal_statement": "import Mathlib\n\nstructure ChessBoard where\n  rows : Nat\n  cols : Nat\n  total_odd : (rows * cols) % 2 = 1\n\nstructure PawnPlacement (board : ChessBoard) where\n  initial : Fin (board.rows * board.cols) \u2192 Fin (board.rows * board.cols)\n  final : Fin (board.rows * board.cols) \u2192 Fin (board.rows * board.cols)\n  bijective_initial : Function.Bijective initial\n  bijective_final : Function.Bijective final\n\ndef adjacent (board : ChessBoard) (pos1 pos2 : Fin (board.rows * board.cols)) : Prop :=\n  let row1 := pos1 / board.cols\n  let col1 := pos1 % board.cols\n  let row2 := pos2 / board.cols\n  let col2 := pos2 % board.cols\n  (row1 = row2 \u2227 (col1 + 1 = col2 \u2228 col2 + 1 = col1)) \u2228\n  (col1 = col2 \u2227 (row1 + 1 = row2 \u2228 row2 + 1 = row1))\n\ntheorem no_adjacent_rearrangement (board : ChessBoard) :\n  \u00ac\u2203 (p : PawnPlacement board), \u2200 (i : Fin (board.rows * board.cols)),\n    adjacent board (p.initial i) (p.final i) :=\n  sorry"}
{"id": "CombStruct4Lean_378", "informal_problem": "Example 2. In each cell of a square table of size $25 \\times 25$, one of the numbers +1 or -1 is written arbitrarily. Under each column, the product of all numbers in that column is recorded, and to the right of each row, the product of all numbers in that row is recorded. Prove that the sum of all fifty products cannot be zero.", "formal_statement": "import Mathlib\n\ndef SignMatrix (n : Nat) := Fin n \u2192 Fin n \u2192 Int\n\ndef isValidSignMatrix (n : Nat) (m : SignMatrix n) : Prop :=\n  \u2200 i j, m i j = 1 \u2228 m i j = -1\n\ndef columnProduct (n : Nat) (m : SignMatrix n) (j : Fin n) : Int :=\n  \u220f i, m i j\n\ndef rowProduct (n : Nat) (m : SignMatrix n) (i : Fin n) : Int :=\n  \u220f j, m i j\n\ntheorem sign_matrix_products_nonzero :\n  \u2200 (m : SignMatrix 25), isValidSignMatrix 25 m \u2192\n    (\u2211 i, rowProduct 25 m i) + (\u2211 j, columnProduct 25 m j) \u2260 0 :=\n  sorry"}
{"id": "CombStruct4Lean_379", "informal_problem": "7. Points on a Line. Several points are located on a line. Then, between each pair of adjacent points, another point was placed. This process was repeated several times, after which all the marked points were counted. Could the total number of points be 1998?", "formal_statement": "import Mathlib\n\ndef insert_points (n : Nat) : Nat :=\n  2 * n - 1\n\ndef iterate_insertion (initial_points : Nat) (iterations : Nat) : Nat :=\n  match iterations with\n  | 0 => initial_points\n  | k + 1 => iterate_insertion (insert_points initial_points) k\n\ntheorem points_on_line_1998 : \u00ac\u2203 (initial_points iterations : Nat), \n    initial_points > 0 \u2227 iterate_insertion initial_points iterations = 1998 :=\n  sorry"}
{"id": "CombStruct4Lean_380", "informal_problem": "9. Tetromino. Can a \"chessboard\" $10 \\times 10$ be covered with 25 rectangular tiles of size $4 \\times 1$?", "formal_statement": "import Mathlib\n\nstructure Board where\n  covered : Fin 10 \u2192 Fin 10 \u2192 Bool\n  tiles : Fin 25 \u2192 (Fin 4 \u2192 (Fin 10 \u00d7 Fin 10))\n\n/-- Predicate that checks if a tile placement is valid (no overlaps and within bounds) -/\ndef isValidTilePlacement (b : Board) : Prop :=\n  -- Each tile must be placed horizontally or vertically\n  (\u2200 t : Fin 25, \n    (\u2200 i j : Fin 4, i \u2260 j \u2192 \n      ((b.tiles t i).1 = (b.tiles t j).1 \u2227 ((b.tiles t j).2 - (b.tiles t i).2).val = (j - i).val) \u2228\n      ((b.tiles t i).2 = (b.tiles t j).2 \u2227 ((b.tiles t j).1 - (b.tiles t i).1).val = (j - i).val))) \u2227\n  -- No overlapping tiles\n  (\u2200 t1 t2 : Fin 25, \u2200 i j : Fin 4,\n    t1 \u2260 t2 \u2192 b.tiles t1 i \u2260 b.tiles t2 j) \u2227\n  -- All squares are covered\n  (\u2200 x : Fin 10, \u2200 y : Fin 10,\n    \u2203 t : Fin 25, \u2203 i : Fin 4,\n      b.tiles t i = (x, y))\n\ntheorem tetromino_covering_impossible : \u00ac\u2203 (b : Board), isValidTilePlacement b :=\n  sorry"}
{"id": "CombStruct4Lean_381", "informal_problem": "4. Odd or even? During a chess tournament, the number of players who played an odd number of games was counted. Prove that the number of such players is even.", "formal_statement": "import Mathlib\n\nstructure Game where\n  player1 : Nat\n  player2 : Nat\n  valid : player1 \u2260 player2\n\nstructure ChessTournament where\n  players : Finset Nat\n  games : Finset Game\n  valid : \u2200 g \u2208 games, g.player1 \u2208 players \u2227 g.player2 \u2208 players\n\ndef gamesCount (t : ChessTournament) (p : Nat) : Nat :=\n  (t.games.filter (fun g => g.player1 = p \u2228 g.player2 = p)).card\n\ntheorem odd_games_players_even (t : ChessTournament) : \n  Even ((t.players.filter (fun p => Odd (gamesCount t p))).card) :=\n  sorry"}
{"id": "CombStruct4Lean_382", "informal_problem": "1. A plane is painted in 2 colors. Prove that there are two points 1 meter apart that are painted the same color.", "formal_statement": "import Mathlib\n\ndef ColoredPlane := \u211d \u00d7 \u211d \u2192 Bool\n\nnoncomputable def distance (p q : \u211d \u00d7 \u211d) : \u211d :=\n  Real.sqrt ((p.1 - q.1)^2 + (p.2 - q.2)^2)\n\ntheorem same_color_points_exist (coloring : ColoredPlane) :\n  \u2203 (p q : \u211d \u00d7 \u211d), distance p q = 1 \u2227 coloring p = coloring q :=\n  sorry"}
