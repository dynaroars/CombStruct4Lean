{"id": "CombStruct4Lean_8", "informal_problem": "\nC1 We call a tiling of an $m \\times n$ rectangle with corners (see figure below) \"regular\" if there is no sub-rectangle which is tiled with corners. Prove that if for some $m$ and $n$ there exists a \"regular\" tiling of the $m \\times n$ rectangular then there exists a \"regular\" tiling also for the $2 m \\times 2 n$ rectangle.", "formal_statement": "import Mathlib\n\n-- Corner orientation\ninductive Corner where\n  | NW | NE | SE | SW\n  deriving BEq, Repr\n\n-- Position in a rectangle with proper bounds\nstructure Pos (m n : \u2115) where\n  row : Fin m\n  col : Fin n\n\n-- Helper functions for position arithmetic\ndef Pos.toDoubled {m n : \u2115} (p : Pos m n) (hm : m > 0) (hn : n > 0) : Pos (2 * m) (2 * n) where\n  row := \u27e82 * p.row.val, by omega\u27e9\n  col := \u27e82 * p.col.val, by omega\u27e9\n\n-- Corner tile with bounded coordinates\nstructure CornerTile (m n : \u2115) where\n  center : Pos m n\n  orientation : Corner\n\n-- A subrectangle within m\u00d7n rectangle with proper bounds\nstructure Subrect (m n : \u2115) where\n  topLeft : Pos m n\n  botRight : Pos m n\n  valid : topLeft.row.val < botRight.row.val \u2227 topLeft.col.val < botRight.col.val\n\n-- Check if a position is within a subrectangle\ndef Subrect.contains {m n : \u2115} (s : Subrect m n) (p : Pos m n) : Prop :=\n  s.topLeft.row.val \u2264 p.row.val \u2227 p.row.val \u2264 s.botRight.row.val \u2227\n  s.topLeft.col.val \u2264 p.col.val \u2227 p.col.val \u2264 s.botRight.col.val\n\n-- A valid tiling of a rectangle\nstructure RectangleTiling (m n : \u2115) where\n  tiles : Finset (CornerTile m n)\n  -- Every position is covered exactly once\n  covers_once : \u2200 p : Pos m n, \u2203! t \u2208 tiles, \n    match t.orientation with\n    | Corner.NW => p = t.center \u2228 (p.row.val + 1 = t.center.row.val \u2227 p.col = t.center.col) \u2228\n                   (p.row = t.center.row \u2227 p.col.val + 1 = t.center.col.val)\n    | Corner.NE => p = t.center \u2228 (p.row.val + 1 = t.center.row.val \u2227 p.col = t.center.col) \u2228\n                   (p.row = t.center.row \u2227 p.col.val = t.center.col.val + 1)\n    | Corner.SE => p = t.center \u2228 (p.row.val = t.center.row.val + 1 \u2227 p.col = t.center.col) \u2228\n                   (p.row = t.center.row \u2227 p.col.val = t.center.col.val + 1)\n    | Corner.SW => p = t.center \u2228 (p.row.val = t.center.row.val + 1 \u2227 p.col = t.center.col) \u2228\n                   (p.row = t.center.row \u2227 p.col.val + 1 = t.center.col.val)\n  -- No subrectangle is fully tiled\n  regular : \u2200 s : Subrect m n, \u2203 p : Pos m n,\n    s.contains p \u2227 \u2200 t \u2208 tiles, t.center \u2260 p\n\ntheorem regular_tiling_double_size (m n : \u2115) (hm : m > 0) (hn : n > 0) :\n  (\u2203 t : RectangleTiling m n, True) \u2192 \n  (\u2203 t : RectangleTiling (2 * m) (2 * n), True) :=\n  sorry", "formal_statement_pred": "theorem lean_workbook_plus_19137 (m n : \u2115) : \u2203 a b c d e f g h : Fin 4 \u2192 Fin 4 \u2192 Fin 4 \u2192 Fin 4 \u2192 Fin 4 \u2192 Fin 4 \u2192 Fin 4 \u2192 Fin 4,  \u2200 i j, a i j \u2260 b i j \u2227 a i j \u2260 c i j \u2227 a i j \u2260 d i j \u2227 a i j \u2260 e i j \u2227 a i j \u2260 f i j \u2227 a i j \u2260 g i j \u2227 a i j \u2260 h i j \u2227  b i j \u2260 c i j \u2227 b i j \u2260 d i j \u2227 b i j \u2260 e i j \u2227 b i j \u2260 f i j \u2227 b i j \u2260 g i j \u2227 b i j \u2260 h i j \u2227  c i j \u2260 d i j \u2227 c i j \u2260 e i j \u2227 c i j \u2260 f i j \u2227 c i j \u2260 g i j \u2227 c i j \u2260 h i j \u2227  d i j \u2260 e i j \u2227 d i j \u2260 f i j \u2227 d i j \u2260 g i j \u2227 d i j \u2260 h i j \u2227  e i j \u2260 f i j \u2227 e i j \u2260 g i j \u2227 e i j \u2260 h i j \u2227  f i j \u2260 g i j \u2227 f i j \u2260 h i j \u2227  g i j \u2260 h i j   :=  by sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_26", "informal_problem": "XXXVII OM - II - Problem 2\n\nIn a chess tournament, 66 players participate, each playing one game against every other player, and the matches take place in four cities. Prove that there exists a trio of players who play all their games against each other in the same city.", "formal_statement": "import Mathlib\n\nstructure Tournament where\n  players : Finset Nat\n  num_players : players.card = 66\n  cities : Finset Nat\n  num_cities : cities.card = 4\n  game_location : Nat \u2192 Nat \u2192 Nat\n  valid_location : \u2200 p1 p2, p1 \u2208 players \u2192 p2 \u2208 players \u2192 p1 \u2260 p2 \u2192 game_location p1 p2 \u2208 cities\n\ntheorem tournament_trio_exists (t : Tournament) : \n  \u2203 (p1 p2 p3 : Nat) (c : Nat), \n    p1 \u2208 t.players \u2227 p2 \u2208 t.players \u2227 p3 \u2208 t.players \u2227 \n    p1 \u2260 p2 \u2227 p2 \u2260 p3 \u2227 p1 \u2260 p3 \u2227\n    c \u2208 t.cities \u2227\n    t.game_location p1 p2 = c \u2227 \n    t.game_location p2 p3 = c \u2227 \n    t.game_location p1 p3 = c :=\n  sorry", "formal_statement_pred": "theorem lean_workbook_plus_59421 (p : Fin 66) (c : Fin 4) (f : Fin 66 \u00d7 Fin 66 \u2192 Fin 4) : \u2203 a b c : Fin 66, a \u2260 b \u2227 b \u2260 c \u2227 c \u2260 a \u2227 f (a, b) = f (b, c) \u2227 f (b, c) = f (c, a) \u2227 f (c, a) = f (a, b)   :=  by sorry", "compiled": true, "aligned": true}
{"id": "CombStruct4Lean_48", "informal_problem": "3. There are 288 visually identical coins weighing 7 and 8 grams (both types are present). On the scales, 144 coins were placed on each pan such that the scales are in balance. In one operation, you can take any two groups of the same number of coins from the pans and swap their places. Prove that it is possible to make the scales unbalanced in no more than 11 operations.", "formal_statement": "import Mathlib\n\nstructure CoinConfiguration where\n  leftEights : Nat    -- 8g coins in left pan\n  leftSevens : Nat    -- 7g coins in left pan\n  rightEights : Nat   -- 8g coins in right pan\n  rightSevens : Nat   -- 7g coins in right pan\n\ndef panWeight (eights sevens : Nat) : Nat :=\n  8 * eights + 7 * sevens\n\ndef isValidConfiguration (conf : CoinConfiguration) : Prop :=\n  conf.leftEights + conf.leftSevens = 144 \u2227\n  conf.rightEights + conf.rightSevens = 144 \u2227\n  conf.leftEights + conf.leftSevens + conf.rightEights + conf.rightSevens = 288\n\ndef isBalanced (conf : CoinConfiguration) : Prop :=\n  panWeight conf.leftEights conf.leftSevens = \n  panWeight conf.rightEights conf.rightSevens\n\ndef swapGroups (conf : CoinConfiguration) (countEights countSevens : Nat) : CoinConfiguration :=\n  { leftEights := conf.leftEights - countEights + countEights\n    leftSevens := conf.leftSevens - countSevens + countSevens\n    rightEights := conf.rightEights + countEights - countEights\n    rightSevens := conf.rightSevens + countSevens - countSevens }\n\ntheorem coin_balance_problem (initial : CoinConfiguration) \n    (h\u2081 : isValidConfiguration initial) \n    (h\u2082 : isBalanced initial) :\n  \u2203 (operations : List (Nat \u00d7 Nat)), \n    operations.length \u2264 11 \u2227 \n    let final := operations.foldl (fun conf op => swapGroups conf op.1 op.2) initial\n    isValidConfiguration final \u2227 \u00acisBalanced final :=\n  sorry", "formal_statement_pred": "theorem lean_workbook_23844 (hg : 7 < 8) (hG : 8 < 7) (h : 0 < 144) : 144 \u2264 288 \u2227 288 \u2264 144 + 144 \u2227 144 + 144 \u2264 288  :=  by sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_143", "informal_problem": "5. Is it possible to color the cells of an 8 x 8 board in three colors: 21 cells in white, 21 cells in blue, 22 cells in red - so that no diagonal (not only the two main diagonals, but all those parallel to them) contains cells of all three colors simultaneously?", "formal_statement": "import Mathlib\n\n/-- Determines if a position (row,col) lies on a diagonal starting at (start_row, start_col) -/\ndef is_on_diagonal (start_row start_col row col : Fin 8) : Prop :=\n  (row.val : \u2124) - (col.val : \u2124) = (start_row.val : \u2124) - (start_col.val : \u2124)\n\n/-- Count the number of cells of a given color -/\ndef count_cells (coloring : Fin 8 \u2192 Fin 8 \u2192 Fin 3) (c : Fin 3) : \u2115 :=\n  Finset.sum (Finset.univ : Finset (Fin 8)) fun i =>\n    Finset.card (Finset.filter (fun j => coloring i j = c) Finset.univ)\n\n/-- A valid three-coloring of an 8x8 board -/\nstructure BoardColoring where\n  color : Fin 8 \u2192 Fin 8 \u2192 Fin 3\n  white_count : count_cells color 0 = 21\n  blue_count : count_cells color 1 = 21\n  red_count : count_cells color 2 = 22\n\n/-- Checks if a diagonal contains all three colors -/\ndef has_all_colors (coloring : Fin 8 \u2192 Fin 8 \u2192 Fin 3) (start_row start_col : Fin 8) : Prop :=\n  \u2203 (i\u2081 i\u2082 i\u2083 j\u2081 j\u2082 j\u2083 : Fin 8), \n    (is_on_diagonal start_row start_col i\u2081 j\u2081 \u2227 coloring i\u2081 j\u2081 = 0) \u2227\n    (is_on_diagonal start_row start_col i\u2082 j\u2082 \u2227 coloring i\u2082 j\u2082 = 1) \u2227\n    (is_on_diagonal start_row start_col i\u2083 j\u2083 \u2227 coloring i\u2083 j\u2083 = 2)\n\ntheorem three_color_board_possible : \n  \u2203 (board : BoardColoring), \n    \u2200 (start_row start_col : Fin 8), \u00ac(has_all_colors board.color start_row start_col) :=\n  sorry", "formal_statement_pred": "theorem lean_workbook_plus_12957 : \u2203 (color : Fin 8 \u2192 Fin 8 \u2192 Fin 3), (color (1 : Fin 8) (0 : Fin 8) = 0 \u2227 color (2 : Fin 8) (0 : Fin 8) = 0 \u2227 color (3 : Fin 8) (0 : Fin 8) = 0 \u2227 color (4 : Fin 8) (0 : Fin 8) = 0 \u2227 color (5 : Fin 8) (0 : Fin 8) = 0 \u2227 color (6 : Fin 8) (0 : Fin 8) = 0 \u2227 color (7 : Fin 8) (0 : Fin 8) = 0 \u2227 color (0 : Fin 8) (1 : Fin 8) = 0 \u2227 color (0 : Fin 8) (2 : Fin 8) = 0 \u2227 color (0 : Fin 8) (3 : Fin 8) = 0 \u2227 color (0 : Fin 8) (4 : Fin 8) = 0 \u2227 color (0 : Fin 8) (5 : Fin 8) = 0 \u2227 color (0 : Fin 8) (6 : Fin 8) = 0 \u2227 color (0 : Fin 8) (7 : Fin 8) = 0 \u2227 color (1 : Fin 8) (1 : Fin 8) = 1 \u2227 color (2 : Fin 8) (2 : Fin 8) = 1 \u2227 color (3 : Fin 8) (3 : Fin 8) = 1 \u2227 color (4 : Fin 8) (4 : Fin 8) = 1 \u2227 color (5 : Fin 8) (5 : Fin 8) = 1 \u2227 color (6 : Fin 8) (6 : Fin 8) = 1 \u2227 color (7 : Fin 8) (7 : Fin 8) = 1 \u2227 color (1 : Fin 8) (2 : Fin 8) = 2 \u2227 color (2 : Fin 8) (1 : Fin 8) = 2 \u2227 color (3 : Fin 8) (2 : Fin 8) = 2 \u2227 color (4 : Fin 8) (3 : Fin 8) = 2 \u2227 color (5 : Fin 8) (4 : Fin 8) = 2 \u2227 color (6 : Fin 8) (5 : Fin 8) = 2 \u2227 color (7 : Fin 8) (6 : Fin 8) = 2 \u2227 color (1 : Fin 8) (3 : Fin 8) = 2 \u2227 color (2 : Fin 8) (3 : Fin 8) = 2 \u2227 color (3 : Fin 8) (1 : Fin 8) = 2 \u2227 color (4 : Fin 8) (1 : Fin 8) = 2 \u2227 color (5 : Fin 8) (1 : Fin 8) = 2 \u2227 color (6 : Fin 8) (1 : Fin 8) = 2 \u2227 color (7 : Fin 8) (1 : Fin 8) = 2 \u2227 color (1 : Fin 8) (4 : Fin 8) = 1 \u2227 color (2 : Fin 8) (4 : Fin 8) = 1 \u2227 color (3 : Fin 8) (4 : Fin 8) = 1 \u2227 color (4 : Fin 8) (2 : Fin 8) = 1 \u2227 color (5 : Fin 8) (2 : Fin 8) = 1 \u2227 color (6 : Fin 8) (2 : Fin 8) = 1 \u2227 color (7 : Fin 8) (2 : Fin 8) = 1 \u2227 color (1 : Fin 8) (5 : Fin 8) = 1 \u2227 color (2 : Fin 8) (5 : Fin 8) = 1 \u2227 color (3 : Fin 8) (5 : Fin 8) = 1 \u2227 color (4 : Fin 8) (5 : Fin 8) = 1 \u2227 color (5 : Fin 8) (3 : Fin 8) = 1 \u2227 color (6 : Fin 8) (3 : Fin 8) = 1 \u2227 color (7 : Fin 8) (3 : Fin 8) = 1 \u2227 color (1 : Fin 8) (6 : Fin 8) = 1 \u2227 color (2 : Fin 8) (6 : Fin 8) = 1 \u2227 color (3 : Fin 8) (6 : Fin 8) = 1 \u2227 color (4 : Fin 8) (6 : Fin 8) = 1 \u2227 color (5 : Fin 8) (6 : Fin 8) = 1 \u2227 color (6 : Fin 8) (4 : Fin 8) = 1 \u2227 color (7 : Fin 8) (4 : Fin 8) = 1 \u2227 color (1 : Fin 8) (7 : Fin 8) = 1 \u2227 color (2 : Fin 8) (7 : Fin 8) = 1 \u2227 color (3 : Fin 8) (7 : Fin 8) = 1 \u2227 color (4 : Fin 8) (7 : Fin 8) = 1 \u2227 color (5 : Fin 8) (7 : Fin 8) = 1 \u2227 color (6 : Fin 8) (7 : Fin 8) = 1 \u2227 color (7 : Fin 8) (5 : Fin 8) = 1)   :=  by sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_148", "informal_problem": "4. Is it possible to arrange 10 black and several white chips in a circle such that each black chip has a diametrically opposite white chip and no two white chips are adjacent?", "formal_statement": "import Mathlib\n\nstructure ChipArrangement where\n  n : Nat                     -- Total number of positions (diameter)\n  black_positions : Finset Nat -- Positions of black chips\n  white_positions : Finset Nat -- Positions of white chips\n  valid_positions : black_positions \u222a white_positions \u2286 Finset.range n\n  no_overlap : black_positions \u2229 white_positions = \u2205\n  black_count : black_positions.card = 10\n  opposite_exists : \u2200 p \u2208 black_positions, \n    ((p + n/2) % n) \u2208 white_positions\n  no_adjacent_whites : \u2200 p \u2208 white_positions, \n    ((p + 1) % n) \u2209 white_positions\n\ntheorem circle_arrangement_exists : \u2203 (arr : ChipArrangement), True :=\n  sorry", "formal_statement_pred": "theorem lean_workbook_plus_15019 : \u2203 n, \u2200 k, (k < n \u2227 k % 2 = 0 \u2192 k + n / 2 % n = n) \u2227 (k < n \u2227 k % 2 = 1 \u2192 k + 1 % n = n)   :=  by sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_155", "informal_problem": "10.2. In a chess tournament, each of the 10 players played one game against each other, and Petya came in last place (scored fewer points than any other participant). Then one player was disqualified, and all points earned in matches against him were annulled, and this player was removed from the table. Could Petya have become the winner of the tournament (scored more points than any other participant) as a result?", "formal_statement": "import Mathlib\n\nstructure ChessTournament where\n  n : Nat                                    -- number of players\n  scores : Fin n \u2192 Nat                       -- scores of each player\n  disqualified : Fin n                       -- the player who got disqualified\n  original_scores : Fin n \u2192 Nat              -- scores before disqualification\n  petya : Fin n                              -- Petya's player number\n  h_petya_last : \u2200 i : Fin n, i \u2260 petya \u2192 original_scores petya < original_scores i\n  h_scores_valid : \u2200 i : Fin n, scores i = if i = disqualified then 0 \n    else original_scores i - (if original_scores i > original_scores disqualified then 1 else 0)\n\ntheorem chess_tournament_petya_winner \n  : \u2203 (t : ChessTournament), t.n = 10 \u2227 \n    (\u2200 i : Fin t.n, i \u2260 t.petya \u2192 i \u2260 t.disqualified \u2192 t.scores t.petya > t.scores i) :=\n  sorry", "formal_statement_pred": "theorem lean_workbook_plus_27600 (h : \u2200 p : Fin 10, p \u2260 0 \u2192 \u2200 q : Fin 10, p \u2260 q \u2192 p > q \u2228 p < q) : \u2200 p : Fin 10, p \u2260 0 \u2192 \u2200 q : Fin 10, p \u2260 q \u2192 p > q \u2228 p < q   :=  by sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_168", "informal_problem": "5. Can a $5 \\times 5$ square be cut into two types of rectangles: $1 \\times 4$ and $1 \\times 3$, so that exactly 8 rectangles are obtained?\n\n7 points are awarded for a complete solution to each problem\n\nThe maximum total score is 35", "formal_statement": "import Mathlib\n\n-- Define valid rectangle types\ninductive RectType where\n  | long  : RectType  -- 1\u00d74 rectangle\n  | short : RectType  -- 1\u00d73 rectangle\n\nstructure PlacedRectangle where\n  rect_type : RectType\n  pos_x : Fin 5\n  pos_y : Fin 5\n  is_valid : pos_y.val + (match rect_type with \n    | RectType.long => 4 \n    | RectType.short => 3) \u2264 5\n\ndef PlacedRectangle.height (r : PlacedRectangle) : Nat :=\n  match r.rect_type with\n  | RectType.long  => 4\n  | RectType.short => 3\n\ndef PlacedRectangle.covers (r : PlacedRectangle) (x y : Fin 5) : Prop :=\n  x = r.pos_x \u2227 \n  y.val \u2265 r.pos_y.val \u2227 \n  y.val < r.pos_y.val + r.height\n\nstructure RectangleTiling where\n  pieces : List PlacedRectangle\n  piece_count : pieces.length = 8\n  covers_all : \u2200 x y : Fin 5, \u2203 p, p \u2208 pieces \u2227 p.covers x y\n  no_overlap : \u2200 p\u2081 p\u2082, p\u2081 \u2208 pieces \u2192 p\u2082 \u2208 pieces \u2192 p\u2081 \u2260 p\u2082 \u2192 \n    \u2200 x y : Fin 5, \u00ac(p\u2081.covers x y \u2227 p\u2082.covers x y)\n\ntheorem five_by_five_tiling_exists : \u2203 t : RectangleTiling, t.pieces \u2260 [] :=\n  sorry", "formal_statement_pred": "theorem lean_workbook_plus_33210  (h\u2080 : 5 * 5 = 1 * 4 + 1 * 3) :\n  5 * 5 = 1 * 4 + 1 * 3   :=  by sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_258", "informal_problem": "10.2. On a chessboard, 8 rooks were placed so that they do not attack each other. Prove that in any rectangular cell area of size $4 \\times 5$ (cells) there is at least one rook.", "formal_statement": "import Mathlib\n\n/-- A valid rook placement on an 8\u00d78 chessboard -/\nstructure ChessBoard where\n  rooks : Finset (Fin 8 \u00d7 Fin 8)\n  nonAttacking : \u2200 (r\u2081 r\u2082 : Fin 8 \u00d7 Fin 8), r\u2081 \u2208 rooks \u2192 r\u2082 \u2208 rooks \u2192 r\u2081 \u2260 r\u2082 \u2192 \n    (Prod.fst r\u2081 \u2260 Prod.fst r\u2082) \u2227 (Prod.snd r\u2081 \u2260 Prod.snd r\u2082)\n  exactlyEight : rooks.card = 8\n\n/-- A 4\u00d75 rectangular area on the chessboard -/\nstructure RectArea where\n  startRow : Fin 8\n  startCol : Fin 8\n  valid : startRow + 4 \u2264 8 \u2227 startCol + 5 \u2264 8\n\n/-- Checks if a position is within the given rectangular area -/\ndef inRectArea (pos : Fin 8 \u00d7 Fin 8) (area : RectArea) : Prop :=\n  let (row, col) := pos\n  row \u2265 area.startRow \u2227 row < area.startRow + 4 \u2227\n  col \u2265 area.startCol \u2227 col < area.startCol + 5\n\ntheorem rook_in_rect_area (board : ChessBoard) (area : RectArea) :\n  \u2203 pos \u2208 board.rooks, inRectArea pos area :=\n  sorry", "formal_statement_pred": "theorem lean_workbook_29067 (a : Fin 8 \u2192 Fin 8 \u2192 Bool) (h : \u2200 i j, a i j \u2192 \u2200 i' j', a i' j' \u2192 i \u2260 i' \u2227 j \u2260 j' \u2192 \u00ac(a i' j)) : \u2200 i j, a i j \u2192 \u2200 i' j', a i' j' \u2192 i \u2260 i' \u2227 j \u2260 j' \u2192 \u00ac(a i' j)  :=  by sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_262", "informal_problem": "Problem 6. A row of 100 coins lies on a table, some showing heads and the rest showing tails. In one operation, it is allowed to select seven coins lying at equal intervals (i.e., seven consecutive coins, or seven coins lying every other coin, etc.), and flip all seven coins. Prove that using such operations, it is possible to have all the coins show heads.\n\n$[9$ points] (S.I. Tokarev, A.V. Shapovalov)", "formal_statement": "import Mathlib\n\n-- Represent a row of coins as a function from positions to bool (true = heads)\nstructure CoinRow where\n  coins : Fin 100 \u2192 Bool\n\n-- Define what it means to flip coins at equal intervals\ndef flipCoinsAtInterval (row : CoinRow) (start : Fin 100) (interval : Nat) : CoinRow where\n  coins := fun i => \n    if \u2203 k : Fin 7, i.val = start.val + k.val * interval \u2227 i.val < 100\n    then !row.coins i\n    else row.coins i\n\n-- Define what it means for all coins to show heads\ndef allHeads (row : CoinRow) : Prop :=\n  \u2200 i : Fin 100, row.coins i = true\n\ntheorem coin_flipping_possible :\n  \u2200 (initial : CoinRow),\n  \u2203 (steps : List (Fin 100 \u00d7 Nat)), \n    let final := steps.foldl (fun row (p) => flipCoinsAtInterval row p.1 p.2) initial\n    allHeads final :=\n  sorry", "formal_statement_pred": "theorem lean_workbook_plus_56847 (a : \u2115 \u2192 Bool) : \u2203 b : \u2115 \u2192 Bool, a = b   :=  by sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_293", "informal_problem": "407. There is a cube, a cubic box with a lid of the same size, and six paints. Each paint is used to color one face of the cube and one of the faces of the box. Prove that the cube can be placed in the box in such a way that each face of the cube touches a face of the box painted with a different color.", "formal_statement": "import Mathlib\n\nstructure CubePainting where\n  -- Maps each face (1-6) to its color (1-6)\n  cube_colors : Fin 6 \u2192 Fin 6\n  box_colors : Fin 6 \u2192 Fin 6\n  -- Each color is used exactly once for cube and box\n  cube_bijective : Function.Bijective cube_colors\n  box_bijective : Function.Bijective box_colors\n\n/-- Represents a placement of the cube in the box -/\nstructure CubePlacement where\n  -- Maps each face of the cube (1-6) to the face of the box it touches (1-6)\n  placement : Fin 6 \u2192 Fin 6\n  -- The placement must be bijective (each box face touches exactly one cube face)\n  is_bijective : Function.Bijective placement\n\ntheorem cube_box_painting_exists :\n  \u2200 (p : CubePainting), \u2203 (placement : CubePlacement),\n    \u2200 (face : Fin 6), p.cube_colors face \u2260 p.box_colors (placement.placement face) :=\n  sorry", "formal_statement_pred": "theorem lean_workbook_plus_71728 (c b l r t b' : Fin 6) : \u2203 (h\u2081 : c \u2260 b) (h\u2082 : b \u2260 l) (h\u2083 : l \u2260 r) (h\u2084 : r \u2260 t) (h\u2085 : t \u2260 b') (h\u2086 : b' \u2260 c), (c + b + l + r + t + b') = 6   :=  by sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_319", "informal_problem": "21.1. The nodes of an infinite grid paper are colored in two colors. Prove that there exist two horizontal and two vertical lines, at the intersections of which lie points of the same color.", "formal_statement": "import Mathlib\n\n-- A coloring of the grid is a function from pairs of integers to Bool\n-- where Bool represents the two colors (true and false)\nstructure GridColoring where\n  color : (\u2124 \u00d7 \u2124) \u2192 Bool\n\ntheorem grid_same_color_points (c : GridColoring) :\n  \u2203 (x\u2081 x\u2082 y\u2081 y\u2082 : \u2124) (h\u2081 : x\u2081 \u2260 x\u2082) (h\u2082 : y\u2081 \u2260 y\u2082),\n    let p\u2081\u2081 := (x\u2081, y\u2081)\n    let p\u2081\u2082 := (x\u2081, y\u2082)\n    let p\u2082\u2081 := (x\u2082, y\u2081)\n    let p\u2082\u2082 := (x\u2082, y\u2082)\n    c.color p\u2081\u2081 = c.color p\u2081\u2082 \u2227\n    c.color p\u2081\u2081 = c.color p\u2082\u2081 \u2227\n    c.color p\u2081\u2081 = c.color p\u2082\u2082 :=\n  sorry", "formal_statement_pred": "theorem lean_workbook_plus_22284 (f : \u2124 \u00d7 \u2124 \u2192 Fin 2) : \u2203 a b c d : \u2124, (f (a, c) = f (b, c) \u2227 f (a, d) = f (b, d))   :=  by sorry", "compiled": true, "aligned": false}
