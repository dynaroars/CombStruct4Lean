{"id": "CombStruct4Lean_0", "informal_problem": "## Problem 3\n\nOn a board there are $n$ nails each two connected by a string. Each string is colored in one of $n$ given distinct colors. For each three distinct colors, there exist three nails connected with strings in these three colors. Prove that $n$ can be 6.", "formal_statement": "import Mathlib\n\nstructure ColoredCompleteGraph (n : Nat) where\n  getColor : Fin n \u2192 Fin n \u2192 Fin n\n  edge_order : \u2200 v\u2081 v\u2082, v\u2081.val < v\u2082.val \u2192 getColor v\u2081 v\u2082 = getColor v\u2082 v\u2081\n\n/-- A coloring is valid if all edge colors are within [0,n) -/\ndef valid_coloring (g : ColoredCompleteGraph n) : Prop :=\n  \u2200 v\u2081 v\u2082, v\u2081.val < v\u2082.val \u2192 g.getColor v\u2081 v\u2082 < n\n\n/-- Check if three vertices form a triangle with given colors -/\ndef has_triangle (g : ColoredCompleteGraph n) (c\u2081 c\u2082 c\u2083 : Fin n) : Prop :=\n  \u2203 (v\u2081 v\u2082 v\u2083 : Fin n), \n    v\u2081.val < v\u2082.val \u2227 v\u2082.val < v\u2083.val \u2227\n    (g.getColor v\u2081 v\u2082 = c\u2081 \u2227\n     g.getColor v\u2082 v\u2083 = c\u2082 \u2227\n     g.getColor v\u2081 v\u2083 = c\u2083)\n\n/-- Three colors are distinct -/\ndef distinct_colors (c\u2081 c\u2082 c\u2083 : Fin n) : Prop :=\n  c\u2081.val \u2260 c\u2082.val \u2227 c\u2082.val \u2260 c\u2083.val \u2227 c\u2081.val \u2260 c\u2083.val\n\ntheorem nail_graph_existence_six : \n  \u2203 (g : ColoredCompleteGraph 6), valid_coloring g \u2227\n    \u2200 (c\u2081 c\u2082 c\u2083 : Fin 6), distinct_colors c\u2081 c\u2082 c\u2083 \u2192 has_triangle g c\u2081 c\u2082 c\u2083 := \n  sorry", "formal_statement_pred": "import Mathlib\n\n\ninductive Color (n : Nat)\n| mk : Fin n \u2192 Color n\n\nstructure ColoredBoard where\n  n : Nat\n\n  strings : Fin n \u2192 Fin n \u2192 Color n\n\n  strings_symm : \u2200 i j, strings i j = strings j i\n\n  all_connected : \u2200 i j, i \u2260 j \u2192 \u2203 c, strings i j = c\n\n  colors_surj : \u2200 c : Color n, \u2203 i j, i \u2260 j \u2227 strings i j = c\n\n  three_color_property : \u2200 c\u2081 c\u2082 c\u2083 : Color n,\n    \u2203 i j k : Fin n, i \u2260 j \u2227 j \u2260 k \u2227 i \u2260 k \u2227\n    strings i j = c\u2081 \u2227 strings j k = c\u2082 \u2227 strings k i = c\u2083\n\ntheorem colored_board_exists_n_six :\n  \u2203 (b : ColoredBoard), b.n = 6 :=\n  sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_1", "informal_problem": "## Problem 3\n\nOn a board there are $n$ nails each two connected by a string. Each string is colored in one of $n$ given distinct colors. For each three distinct colors, there exist three nails connected with strings in these three colors. Prove that $n$ cannot be 7.", "formal_statement": "import Mathlib\n\nstructure ColoredCompleteGraph (n : Nat) where\n  getColor : Fin n \u2192 Fin n \u2192 Fin n\n  edge_order : \u2200 v\u2081 v\u2082, v\u2081.val < v\u2082.val \u2192 getColor v\u2081 v\u2082 = getColor v\u2082 v\u2081\n\n/-- A coloring is valid if all edge colors are within [0,n) -/\ndef valid_coloring (g : ColoredCompleteGraph n) : Prop :=\n  \u2200 v\u2081 v\u2082, v\u2081.val < v\u2082.val \u2192 g.getColor v\u2081 v\u2082 < n\n\n/-- Check if three vertices form a triangle with given colors -/\ndef has_triangle (g : ColoredCompleteGraph n) (c\u2081 c\u2082 c\u2083 : Fin n) : Prop :=\n  \u2203 (v\u2081 v\u2082 v\u2083 : Fin n), \n    v\u2081.val < v\u2082.val \u2227 v\u2082.val < v\u2083.val \u2227\n    (g.getColor v\u2081 v\u2082 = c\u2081 \u2227\n     g.getColor v\u2082 v\u2083 = c\u2082 \u2227\n     g.getColor v\u2081 v\u2083 = c\u2083)\n\n/-- Three colors are distinct -/\ndef distinct_colors (c\u2081 c\u2082 c\u2083 : Fin n) : Prop :=\n  c\u2081.val \u2260 c\u2082.val \u2227 c\u2082.val \u2260 c\u2083.val \u2227 c\u2081.val \u2260 c\u2083.val\n\ntheorem nail_graph_nonexistence_seven : \n  \u00ac\u2203 (g : ColoredCompleteGraph 7), valid_coloring g \u2227\n    \u2200 (c\u2081 c\u2082 c\u2083 : Fin 7), distinct_colors c\u2081 c\u2082 c\u2083 \u2192 has_triangle g c\u2081 c\u2082 c\u2083 := \n  sorry", "formal_statement_pred": "import Mathlib\n\nclass ColoredBoard where\n  n : Nat\n  strings : Fin n \u2192 Fin n \u2192 Fin n\n\n  strings_symm : \u2200 i j, strings i j = strings j i\n\n  all_connected : \u2200 (i j : Fin n), i \u2260 j \u2192 \u2203 (c : Fin n), strings i j = c\n\n  distinct_colors : \u2200 (i j k l : Fin n),\n    strings i j = strings k l \u2192\n    ((i = k \u2227 j = l) \u2228 (i = l \u2227 j = k) \u2228 i = j \u2228 k = l)\n\n  three_colors_property : \u2200 (c\u2081 c\u2082 c\u2083 : Fin n),\n    c\u2081 \u2260 c\u2082 \u2192 c\u2082 \u2260 c\u2083 \u2192 c\u2081 \u2260 c\u2083 \u2192\n    \u2203 (i j k : Fin n), i \u2260 j \u2227 j \u2260 k \u2227 i \u2260 k \u2227\n      ((strings i j = c\u2081 \u2227 strings j k = c\u2082 \u2227 strings i k = c\u2083) \u2228\n       (strings i j = c\u2081 \u2227 strings j k = c\u2083 \u2227 strings i k = c\u2082) \u2228\n       (strings i j = c\u2082 \u2227 strings j k = c\u2081 \u2227 strings i k = c\u2083) \u2228\n       (strings i j = c\u2082 \u2227 strings j k = c\u2083 \u2227 strings i k = c\u2081) \u2228\n       (strings i j = c\u2083 \u2227 strings j k = c\u2081 \u2227 strings i k = c\u2082) \u2228\n       (strings i j = c\u2083 \u2227 strings j k = c\u2082 \u2227 strings i k = c\u2081))\n\n\ntheorem no_seven_nails : \u00ac\u2203 (b : ColoredBoard), b.n = 7 :=\n  sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_5", "informal_problem": "\nC3. All possible pairs of $n$ apples are weighed and the results are given to us in an arbitrary order. Can we determine the weights of the apples if $n=4$?\n", "formal_statement": "import Mathlib\n\nstructure AppleWeighingSystem (n : Nat) where\n  -- Individual apple weights\n  weights : Fin n \u2192 \u211d\n  -- Function that gives the weight of any pair of apples\n  pairWeights : Fin n \u2192 Fin n \u2192 \u211d\n  -- The pair weights are the sums of individual weights\n  pairSum : \u2200 (i j : Fin n), i < j \u2192 pairWeights i j = weights i + weights j\n\n-- Definition for when a weighing system is uniquely determined by its pair weights\ndef isUniqueDetermination (n : Nat) (s\u2081 s\u2082 : AppleWeighingSystem n) : Prop :=\n  (\u2200 (i j : Fin n), i < j \u2192 s\u2081.pairWeights i j = s\u2082.pairWeights i j) \u2192 \n  (\u2200 (i : Fin n), s\u2081.weights i = s\u2082.weights i)\n\ntheorem apple_weighing_determination (n : Nat) (h : n \u2265 4) :\n (n = 4) \u2192\n  \u2200 (s\u2081 s\u2082 : AppleWeighingSystem n), isUniqueDetermination n s\u2081 s\u2082 :=\n  sorry", "formal_statement_pred": "import Mathlib\n\nstructure AppleWeighings where\n  n : Nat\n  pairWeights : Fin (n.choose 2) \u2192 \u211d\n\n\n\ndef reconstructible (w : AppleWeighings) : Prop :=\n  \u2203! (weights : Fin w.n \u2192 \u211d),\n    \u2200 (i j : Fin w.n), i < j \u2192\n      \u2203 (k : Fin (w.n.choose 2)),\n        w.pairWeights k = weights i + weights j\n\ntheorem apple_weights_n4 :\n  \u2200 (w : AppleWeighings), w.n = 4 \u2192 reconstructible w :=\n  sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_6", "informal_problem": "\nC3. All possible pairs of $n$ apples are weighed and the results are given to us in an arbitrary order. Can we determine the weights of the apples if $n=5$?\n", "formal_statement": "import Mathlib\n\nstructure AppleWeighingSystem (n : Nat) where\n  -- Individual apple weights\n  weights : Fin n \u2192 \u211d\n  -- Function that gives the weight of any pair of apples\n  pairWeights : Fin n \u2192 Fin n \u2192 \u211d\n  -- The pair weights are the sums of individual weights\n  pairSum : \u2200 (i j : Fin n), i < j \u2192 pairWeights i j = weights i + weights j\n\n-- Definition for when a weighing system is uniquely determined by its pair weights\ndef isUniqueDetermination (n : Nat) (s\u2081 s\u2082 : AppleWeighingSystem n) : Prop :=\n  (\u2200 (i j : Fin n), i < j \u2192 s\u2081.pairWeights i j = s\u2082.pairWeights i j) \u2192 \n  (\u2200 (i : Fin n), s\u2081.weights i = s\u2082.weights i)\n\ntheorem apple_weighing_determination (n : Nat) (h : n \u2265 4) :\n  (n = 5) \u2192\n  \u2200 (s\u2081 s\u2082 : AppleWeighingSystem n), isUniqueDetermination n s\u2081 s\u2082 :=\n  sorry", "formal_statement_pred": "import Mathlib\n\n\nstructure WeighingResult where\n  pair : Fin 5 \u00d7 Fin 5\n  weight : \u211d\n  h_valid : pair.1 \u2260 pair.2\n\n\ndef AllWeighings := { results : List WeighingResult //\n  results.length = (5 * 4)/2 \u2227\n  results.Nodup }\n\ntheorem apple_weights_determinable\n  (weighings : AllWeighings) :\n  \u2203! (weights : Fin 5 \u2192 \u211d),\n    \u2200 (r : WeighingResult) (h : r \u2208 weighings.val),\n      weights r.pair.1 + weights r.pair.2 = r.weight :=\n  sorry", "compiled": true, "aligned": true}
{"id": "CombStruct4Lean_7", "informal_problem": "\nC3. All possible pairs of $n$ apples are weighed and the results are given to us in an arbitrary order. Can we determine the weights of the apples if $n=6$ ?\n", "formal_statement": "import Mathlib\n\nstructure AppleWeighingSystem (n : Nat) where\n  -- Individual apple weights\n  weights : Fin n \u2192 \u211d\n  -- Function that gives the weight of any pair of apples\n  pairWeights : Fin n \u2192 Fin n \u2192 \u211d\n  -- The pair weights are the sums of individual weights\n  pairSum : \u2200 (i j : Fin n), i < j \u2192 pairWeights i j = weights i + weights j\n\n-- Definition for when a weighing system is uniquely determined by its pair weights\ndef isUniqueDetermination (n : Nat) (s\u2081 s\u2082 : AppleWeighingSystem n) : Prop :=\n  (\u2200 (i j : Fin n), i < j \u2192 s\u2081.pairWeights i j = s\u2082.pairWeights i j) \u2192 \n  (\u2200 (i : Fin n), s\u2081.weights i = s\u2082.weights i)\n\ntheorem apple_weighing_determination (n : Nat) (h : n \u2265 4) :\n  (n = 6) \u2192\n  \u2200 (s\u2081 s\u2082 : AppleWeighingSystem n), isUniqueDetermination n s\u2081 s\u2082 :=\n  sorry", "formal_statement_pred": "import Mathlib\n\n\nstructure Measurement (n : Nat) where\n  apple1 : Fin n\n  apple2 : Fin n\n  weight : \u211d\n  valid_pair : apple1 < apple2\n\n\nstructure AppleWeighingSystem (n : Nat) where\n\n  weights : Fin n \u2192 \u211d\n\n  measurements : List (Measurement n)\n\n  measure_count : measurements.length = n * (n - 1) / 2\n\n  measure_valid : \u2200 m \u2208 measurements,\n    m.weight = weights m.apple1 + weights m.apple2\n\n  pairs_complete : \u2200 (i j : Fin n), i < j \u2192\n    \u2203! m \u2208 measurements, m.apple1 = i \u2227 m.apple2 = j\n\ntheorem apple_weights_determinable {n : Nat} (sys\u2081 sys\u2082 : AppleWeighingSystem n)\n  (h : n = 6) :\n  sys\u2081.measurements.map Measurement.weight = sys\u2082.measurements.map Measurement.weight \u2192\n  \u2203 (perm : Equiv.Perm (Fin n)),\n    \u2200 i, sys\u2081.weights i = sys\u2082.weights (perm i) :=\n  sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_10", "informal_problem": "\nCOM 5. If $m$ is a number from the set $\\{1,2,3,4\\}$ and each point of the plane is painted in red or blue, prove that in the plane there exists at least an equilateral triangle with the vertices of the same colour and with length side $m$.\n", "formal_statement": "import Mathlib\n\n-- Define a color type\ninductive Color where\n  | Red : Color\n  | Blue : Color\n\n-- Define a coloring of the plane as a function from points to colors\ndef PlaneColoring := \u211d \u00d7 \u211d \u2192 Color\n\n-- Define what it means for three points to form an equilateral triangle of side length m\ndef IsEquilateralTriangle (p\u2081 p\u2082 p\u2083 : \u211d \u00d7 \u211d) (m : \u211d) : Prop :=\n  let dist := fun (x y : \u211d \u00d7 \u211d) => Real.sqrt ((x.1 - y.1)^2 + (x.2 - y.2)^2)\n  dist p\u2081 p\u2082 = m \u2227 dist p\u2082 p\u2083 = m \u2227 dist p\u2083 p\u2081 = m\n\n-- Define what it means for three points to have the same color under a coloring\ndef SameColor (c : PlaneColoring) (p\u2081 p\u2082 p\u2083 : \u211d \u00d7 \u211d) : Prop :=\n  c p\u2081 = c p\u2082 \u2227 c p\u2082 = c p\u2083\n\ntheorem exists_monochromatic_triangle (m : \u211d) (h : m \u2208 ({1, 2, 3, 4} : Set \u211d)) \n  (c : PlaneColoring) : \n  \u2203 (p\u2081 p\u2082 p\u2083 : \u211d \u00d7 \u211d), IsEquilateralTriangle p\u2081 p\u2082 p\u2083 m \u2227 SameColor c p\u2081 p\u2082 p\u2083 :=\n  sorry", "formal_statement_pred": "import Mathlib\n\n\ninductive Color where\n  | Red : Color\n  | Blue : Color\n  deriving Inhabited, DecidableEq\n\n\ndef PlaneColoring := \u211d \u00d7 \u211d \u2192 Color\n\n\ndef IsEquilateralTriangle (p\u2081 p\u2082 p\u2083 : \u211d \u00d7 \u211d) (m : \u211d) : Prop :=\n  let dist := fun (x y : \u211d \u00d7 \u211d) => Real.sqrt ((x.1 - y.1)^2 + (x.2 - y.2)^2)\n  dist p\u2081 p\u2082 = m \u2227 dist p\u2082 p\u2083 = m \u2227 dist p\u2083 p\u2081 = m\n\n\ndef SameColor (c : PlaneColoring) (p\u2081 p\u2082 p\u2083 : \u211d \u00d7 \u211d) : Prop :=\n  c p\u2081 = c p\u2082 \u2227 c p\u2082 = c p\u2083\n\ntheorem monochromatic_equilateral_triangle\n  (m : \u2115) (h\u2081 : m \u2265 1) (h\u2082 : m \u2264 4) (c : PlaneColoring) :\n  \u2203 (p\u2081 p\u2082 p\u2083 : \u211d \u00d7 \u211d),\n    IsEquilateralTriangle p\u2081 p\u2082 p\u2083 m \u2227 SameColor c p\u2081 p\u2082 p\u2083 :=\n  sorry", "compiled": true, "aligned": true}
{"id": "CombStruct4Lean_11", "informal_problem": "\n94.2. We call a finite plane set $S$ consisting of points with integer coefficients a twoneighbour set, if for each point $(p, q)$ of $S$ exactly two of the points $(p+1, q),(p, q+1)$, $(p-1, q),(p, q-1)$ belong to $S$. For which integers $n$ there exists a two-neighbour set which contains exactly $n$ points?\n", "formal_statement": "import Mathlib\n\ndef neighbors (p : Int \u00d7 Int) : Finset (Int \u00d7 Int) := \n  {(p.1 + 1, p.2), (p.1, p.2 + 1), (p.1 - 1, p.2), (p.1, p.2 - 1)}\n\nstructure TwoNeighbourSet where\n  points : Finset (Int \u00d7 Int)\n  two_neighbours : \u2200 p \u2208 points, (neighbors p \u2229 points).card = 2\n\ntheorem two_neighbour_set_existence (n : Nat) :\n  (\u2203 (S : TwoNeighbourSet), S.points.card = n) \u2194 n \u2265 4 :=\n  sorry", "formal_statement_pred": "import Mathlib\n\nstructure IntPoint where\n  x : \u2124\n  y : \u2124\nderiving DecidableEq, Inhabited\n\ndef isAdjacent (p q : IntPoint) : Prop :=\n  |p.x - q.x| + |p.y - q.y| = 1\n\ndef validNeighbors (p : IntPoint) : Set IntPoint :=\n  {\u27e8p.x + 1, p.y\u27e9, \u27e8p.x, p.y + 1\u27e9, \u27e8p.x - 1, p.y\u27e9, \u27e8p.x, p.y - 1\u27e9}\n\nstructure TwoNeighbourSet where\n  points : Set IntPoint\n  finite : Set.Finite points\n  two_neighbors : \u2200 p \u2208 points,\n    ({q \u2208 points | isAdjacent p q}).ncard = 2\n\ntheorem two_neighbour_existence (n : \u2115) :\n  (\u2203 S : TwoNeighbourSet, Set.ncard S.points = n) \u2194 n \u2265 4 :=\n  sorry", "compiled": true, "aligned": true}
{"id": "CombStruct4Lean_12", "informal_problem": "\n03.1. Stones are placed on the squares of a chessboard having 10 rows and 14 columns. There is an odd number of stones on each row and each column. The squares are coloured black and white in the usual fashion. Show that the number of stones on black squares is even. Note that there can be more than one stone on a square.\n", "formal_statement": "import Mathlib\n\nstructure ChessboardConfig where\n  stones : Fin 10 \u2192 Fin 14 \u2192 Nat\n  row_odd : \u2200 i, Odd (\u2211 j : Fin 14, stones i j)\n  col_odd : \u2200 j, Odd (\u2211 i : Fin 10, stones i j)\n\n/-- Returns true if the square at position (i,j) is black on a standard checkerboard pattern -/\ndef isBlackSquare (i : Fin 10) (j : Fin 14) : Bool :=\n  (i.val + j.val) % 2 = 0\n\ndef stonesOnBlackSquares (config : ChessboardConfig) : Nat :=\n  \u2211 i : Fin 10, \u2211 j : Fin 14, if isBlackSquare i j then config.stones i j else 0\n\ntheorem stones_on_black_squares_even\n  (config : ChessboardConfig) :\n  Even (stonesOnBlackSquares config) :=\n  sorry", "formal_statement_pred": "import Mathlib\n\nstructure ChessboardStones where\n  stones : Matrix (Fin 10) (Fin 14) Nat\n  odd_rows : \u2200 i, Odd (Finset.sum Finset.univ (fun j => stones i j))\n  odd_cols : \u2200 j, Odd (Finset.sum Finset.univ (fun i => stones i j))\n\ndef isBlackSquare (i : Fin 10) (j : Fin 14) : Bool :=\n  (i.val + j.val) % 2 = 1\n\ndef stonesOnBlackSquares (board : ChessboardStones) : Nat :=\n  Finset.sum Finset.univ fun i =>\n    Finset.sum Finset.univ fun j =>\n      if isBlackSquare i j then board.stones i j else 0\n\ntheorem stones_on_black_squares_even (board : ChessboardStones) :\n  Even (stonesOnBlackSquares board) := sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_13", "informal_problem": "\n06.4. The squares of a $100 \\times 100$ chessboard are painted with 100 different colours. Each square has only one colour and every colour is used exactly 100 times. Show that there exists a row or a column on the chessboard in which at least 10 colours are used.\n", "formal_statement": "import Mathlib\n\n/-- A 100\u00d7100 chessboard with 100 colors, each appearing exactly 100 times -/\nstructure ColoredBoard where\n  n : \u2115                           -- board size\n  k : \u2115                           -- number of colors\n  coloring : Fin n \u00d7 Fin n \u2192 Fin k\n  h_n : n = 100                   -- size constraint\n  h_k : k = 100                   -- colors constraint\n\n/-- Colors appearing in row i -/\ndef colors_in_row (board : ColoredBoard) (i : Fin board.n) : Finset (Fin board.k) :=\n  Finset.image (fun j \u21a6 board.coloring (i, j)) (Finset.univ)\n\n/-- Colors appearing in column j -/\ndef colors_in_col (board : ColoredBoard) (j : Fin board.n) : Finset (Fin board.k) :=\n  Finset.image (fun i \u21a6 board.coloring (i, j)) (Finset.univ)\n\n/-- In a 100\u00d7100 board with 100 colors each appearing exactly 100 times,\n    some row or column must contain at least 10 different colors -/\ntheorem chessboard_colors (board : ColoredBoard) :\n  (\u2203 i, (colors_in_row board i).card \u2265 10) \u2228 \n  (\u2203 j, (colors_in_col board j).card \u2265 10) :=\n  sorry", "formal_statement_pred": "import Mathlib\n\nstructure ColoredBoard where\n  n : Nat\n  k : Nat\n  coloring : Fin n \u00d7 Fin n \u2192 Fin k\n  n_eq : n = 100\n  k_eq : k = 100\n  color_count_valid : \u2200 (c : Fin k),\n    (Finset.univ.filter (fun p => coloring p = c)).card = n\n\n\ndef rowColors (board : ColoredBoard) (i : Fin board.n) : Finset (Fin board.k) :=\n  Finset.univ.image (fun j => board.coloring (i, j))\n\n\ndef colColors (board : ColoredBoard) (j : Fin board.n) : Finset (Fin board.k) :=\n  Finset.univ.image (fun i => board.coloring (i, j))\n\ntheorem chessboard_colors (board : ColoredBoard) :\n  (\u2203 i : Fin board.n, (rowColors board i).card \u2265 10) \u2228\n  (\u2203 j : Fin board.n, (colColors board j).card \u2265 10) :=\n  sorry", "compiled": true, "aligned": true}
{"id": "CombStruct4Lean_16", "informal_problem": "LIII OM - II - Problem 3\n\nIn an $ n $-person association, there are six committees. Each of them includes at least $ n/4 $ people. Prove that there exist two committees and a group of at least $ n/30 $ people, who belong to both of these committees.", "formal_statement": "import Mathlib\n\nstructure Association where\n  n : \u2115\n  committees : Fin 6 \u2192 Finset Nat\n  members : Finset Nat\n  n_pos : n > 0\n  size_bound : \u2200 i, (committees i).card \u2265 Nat.div n 4\n  valid_members : \u2200 i, committees i \u2286 members\n  total_size : members.card = n\n\ntheorem committee_intersection_bound (A : Association) :\n  \u2203 (i j : Fin 6) (S : Finset Nat), \n    i \u2260 j \u2227 \n    S \u2286 A.committees i \u2227 \n    S \u2286 A.committees j \u2227 \n    S.card \u2265 Nat.div A.n 30 :=\n  sorry", "formal_statement_pred": "import Mathlib\n\nstructure Association where\n  n : \u2115\n  n_pos : 0 < n\n  committees : Fin 6 \u2192 Finset \u2115\n  member_bound : \u2200 i : Fin 6, Finset.card (committees i) \u2265 Nat.div n 4\n  valid_members : \u2200 i : Fin 6, \u2200 x \u2208 committees i, x < n\n\ntheorem committee_intersection_bound (A : Association) :\n  \u2203 (i j : Fin 6) (S : Finset \u2115),\n    i \u2260 j \u2227\n    S \u2286 A.committees i \u2227\n    S \u2286 A.committees j \u2227\n    Finset.card S \u2265 Nat.div A.n 30 :=\n  sorry", "compiled": true, "aligned": true}
{"id": "CombStruct4Lean_19", "informal_problem": "XXV OM - III - Task 5\n\nProve that if natural numbers $ n $, $ r $ satisfy the inequality $ r + 3 \\leq n $, then the numbers $ \\binom{n}{r} $, $ \\binom{n}{r+1} $, $ \\binom{n}{r+2} $, $ \\binom{n}{r+3} $ are not consecutive terms of any arithmetic sequence.", "formal_statement": "import Mathlib\n\ndef isArithmeticSequence (a\u2081 a\u2082 a\u2083 a\u2084 : \u2115) : Prop :=\n  (a\u2082 - a\u2081) = (a\u2083 - a\u2082) \u2227 (a\u2083 - a\u2082) = (a\u2084 - a\u2083)\n\ntheorem binomial_not_arithmetic {n r : \u2115} (h : r + 3 \u2264 n) :\n  \u00ac isArithmeticSequence (n.choose r) (n.choose (r + 1)) (n.choose (r + 2)) (n.choose (r + 3)) :=\n  sorry", "formal_statement_pred": "import Mathlib\n\n\n\ntheorem binomial_not_arithmetic_seq (n r : \u2115) (h : r + 3 \u2264 n) :\n  \u00ac \u2203 d : \u2115,\n    (Nat.choose n (r + 1) = Nat.choose n r + d) \u2227\n    (Nat.choose n (r + 2) = Nat.choose n (r + 1) + d) \u2227\n    (Nat.choose n (r + 3) = Nat.choose n (r + 2) + d) :=\n  sorry", "compiled": true, "aligned": true}
{"id": "CombStruct4Lean_20", "informal_problem": "LIX OM - III - Task 1\n\nIn the fields of an $ n \\times n $ table, the numbers $ 1, 2, \\dots , n^2 $ are written, with the numbers $ 1, 2, \\dots , n $ being in the first row (from left to right), the numbers $ n +1, n +2, \\dots ,2n $ in the second row, and so on. \n$n$ fields of the table have been selected, such that no two lie in the same row or column. Let $ a_i $ be the number found in the selected field that lies in the row numbered $ i $. Prove that", "formal_statement": "import Mathlib\n\n-- Define a type for the n\u00d7n table with numbers 1 to n\u00b2\nstructure NumberTable (n : \u2115) where\n  -- The selected positions in the table, represented as pairs of row and column indices (1-based)\n  selections : Fin n \u2192 (Fin n \u00d7 Fin n)\n  -- Ensure no two selections share the same row or column\n  no_shared_rows : \u2200 i j : Fin n, i \u2260 j \u2192 (selections i).1 \u2260 (selections j).1\n  no_shared_cols : \u2200 i j : Fin n, i \u2260 j \u2192 (selections i).2 \u2260 (selections j).2\n\n-- Function to get the value at position (i,j) in the table\ndef getValue (n : \u2115) (i j : Fin n) : \u2115 :=\n  (i.val - 1) * n + j.val\n\ntheorem table_selection_sum_inequality {n : \u2115} (h : n > 0) (t : NumberTable n) :\n  \u2211 i : Fin n, getValue n i ((t.selections i).2) \u2265 \n  \u2211 i : Fin n, getValue n ((t.selections i).1) ((t.selections i).2) :=\n  sorry", "formal_statement_pred": "import Mathlib\n\n\nstructure TableSelection (n : \u2115) where\n\n  selection : Fin n \u2192 Fin n\n\n  is_perm : Function.Injective selection\n\n\ndef tableValue (n : \u2115) (i j : Fin n) : \u2115 :=\n  n * i.val + j.val + 1\n\n\ndef selectedNumber (n : \u2115) (sel : TableSelection n) (i : Fin n) : \u2115 :=\n  tableValue n i (sel.selection i)\n\ntheorem selected_numbers_sum_bound {n : \u2115} (h : n > 0) (sel : TableSelection n) :\n  \u2211 i : Fin n, selectedNumber n sel i \u2265 n * (n + 1) / 2 :=\n  sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_22", "informal_problem": "XXVIII - I - Problem 8\n\nProve that the set $ \\{1, 2, \\ldots, 2^{s+1}\\} $ can be partitioned into two $ 2s $-element sets $ \\{x_1, x_2, \\ldots, x_{2^s}\\} $, $ \\{y_1, y_2, \\ldots, y_{2^s}\\} $, such that for every natural number $ j \\leq s $ the following equality holds", "formal_statement": "import Mathlib\n\ndef is_valid_partition (s : \u2115) (X Y : Finset \u2115) : Prop :=\n  -- Both sets have size 2^s\n  X.card = 2^s \u2227 Y.card = 2^s \u2227\n  -- Sets form a partition of {1,...,2^(s+1)}\n  X \u2229 Y = \u2205 \u2227\n  X \u222a Y = Finset.range (2^(s+1) + 1) \\ {0} \u2227\n  -- All elements are positive and at most 2^(s+1)\n  (\u2200 x \u2208 X, 0 < x \u2227 x \u2264 2^(s+1)) \u2227\n  (\u2200 y \u2208 Y, 0 < y \u2227 y \u2264 2^(s+1))\n\ntheorem partition_power_sum (s : \u2115) :\n  \u2203 (X Y : Finset \u2115), is_valid_partition s X Y \u2227\n    \u2200 j : \u2115, j \u2264 s \u2192\n      (\u2211 i in X, i^j) = (\u2211 i in Y, i^j) :=\n  sorry", "formal_statement_pred": "import Mathlib\n\nstructure PartitionSolution (s : Nat) where\n  firstSet : Finset Nat\n  secondSet : Finset Nat\n  size_first : firstSet.card = 2^s\n  size_second : secondSet.card = 2^s\n  bound_first : \u2200 x \u2208 firstSet, 1 \u2264 x \u2227 x \u2264 2^(s+1)\n  bound_second : \u2200 x \u2208 secondSet, 1 \u2264 x \u2227 x \u2264 2^(s+1)\n  disjoint : firstSet \u2229 secondSet = \u2205\n  covers : firstSet \u222a secondSet = Finset.range (2^(s+1) + 1) \\ {0}\n\ntheorem partition_with_power_sums (s : Nat) :\n  \u2203 (sol : PartitionSolution s), \u2200 j : Nat, j \u2264 s \u2192\n    Finset.sum sol.firstSet (fun x \u21a6 x^j) = Finset.sum sol.secondSet (fun x \u21a6 x^j) :=\n  sorry", "compiled": true, "aligned": true}
{"id": "CombStruct4Lean_24", "informal_problem": "XXIV OM - I - Problem 7\n\nProve that among five segments lying on the same straight line, there are either three segments that have a common point or three segments that are pairwise disjoint.", "formal_statement": "import Mathlib\n\n/-- A line segment on the real line with ordered endpoints -/\nstructure LineSegment where\n  left : \u211d\n  right : \u211d\n  ordered : left \u2264 right\n\n/-- Whether a point lies in a line segment -/\ndef contains (s : LineSegment) (x : \u211d) : Prop :=\n  s.left \u2264 x \u2227 x \u2264 s.right\n\n/-- Two line segments intersect if they share at least one point -/\ndef intersect (s\u2081 s\u2082 : LineSegment) : Prop :=\n  \u2203 x : \u211d, contains s\u2081 x \u2227 contains s\u2082 x\n\n/-- Among five segments on a line, there are either three with a common point\n    or three that are pairwise disjoint -/\ntheorem segment_trichotomy (s : Fin 5 \u2192 LineSegment) :\n  (\u2203 i j k : Fin 5, i \u2260 j \u2227 j \u2260 k \u2227 i \u2260 k \u2227 \n    \u2203 x : \u211d, contains (s i) x \u2227 contains (s j) x \u2227 contains (s k) x) \u2228\n  (\u2203 i j k : Fin 5, i \u2260 j \u2227 j \u2260 k \u2227 i \u2260 k \u2227 \n    \u00ac(intersect (s i) (s j)) \u2227 \u00ac(intersect (s j) (s k)) \u2227 \u00ac(intersect (s i) (s k))) :=\n  sorry", "formal_statement_pred": "import Mathlib\n\nstructure Segment where\n  start : \u211d\n  endPoint : \u211d\n  property : start \u2264 endPoint\n\ndef intersect (s\u2081 s\u2082 : Segment) : Prop :=\n  \u00ac(s\u2081.endPoint < s\u2082.start \u2228 s\u2082.endPoint < s\u2081.start)\n\ndef hasCommonPoint (segments : Finset Segment) : Prop :=\n  \u2203 p : \u211d, \u2200 s \u2208 segments, s.start \u2264 p \u2227 p \u2264 s.endPoint\n\ndef pairwiseDisjoint (segments : Finset Segment) : Prop :=\n  \u2200 s\u2081 s\u2082, s\u2081 \u2208 segments \u2192 s\u2082 \u2208 segments \u2192 s\u2081 \u2260 s\u2082 \u2192 \u00ac(intersect s\u2081 s\u2082)\n\ntheorem segment_trichotomy (segments : Finset Segment)\n  (h_count : segments.card = 5) :\n  (\u2203 segs : Finset Segment, segs.card = 3 \u2227 segs \u2286 segments \u2227 hasCommonPoint segs) \u2228\n  (\u2203 segs : Finset Segment, segs.card = 3 \u2227 segs \u2286 segments \u2227 pairwiseDisjoint segs) :=\n  sorry", "compiled": true, "aligned": true}
{"id": "CombStruct4Lean_25", "informal_problem": "LI OM - II - Task 3\n\nOn an $ n \\times n $ chessboard, $ n^2 $ different integers are placed, one on each square. In each column, the square with the largest number is painted red. A set of $ n $ squares on the chessboard is called admissible if no two of these squares are in the same row or the same column. Among all admissible sets, the set for which the sum of the numbers placed on its squares is the largest is chosen.\nProve that in such a selected set, there is a red square.", "formal_statement": "import Mathlib\n\nstructure ChessBoard (n : \u2115) where\n  numbers : Fin n \u2192 Fin n \u2192 \u2124\n  different : \u2200 (i\u2081 j\u2081 i\u2082 j\u2082 : Fin n), \n    numbers i\u2081 j\u2081 = numbers i\u2082 j\u2082 \u2192 i\u2081 = i\u2082 \u2227 j\u2081 = j\u2082\n  redSquares : Fin n \u2192 Fin n  -- maps each column to its red square's row\n  red_is_max : \u2200 j k : Fin n, numbers k j \u2264 numbers (redSquares j) j\n  red_unique : \u2200 j i : Fin n, (\u2200 k : Fin n, numbers k j \u2264 numbers i j) \u2192 i = redSquares j\n\nstructure AdmissibleSet (n : \u2115) where\n  rowPerm : Equiv.Perm (Fin n)  -- represents row assignments\n  colPerm : Equiv.Perm (Fin n)  -- represents column assignments\n\ndef sumOfSet (n : \u2115) (board : ChessBoard n) (set : AdmissibleSet n) : \u2124 :=\n  Finset.univ.sum (\u03bb i : Fin n => board.numbers (set.rowPerm i) (set.colPerm i))\n\ntheorem max_admissible_set_has_red_square (n : \u2115) (h : n > 0) \n  (board : ChessBoard n) (maxSet : AdmissibleSet n)\n  (h_max : \u2200 other : AdmissibleSet n, sumOfSet n board other \u2264 sumOfSet n board maxSet) :\n  \u2203 i : Fin n, (maxSet.rowPerm i, maxSet.colPerm i) = (board.redSquares (maxSet.colPerm i), maxSet.colPerm i) :=\n  sorry", "formal_statement_pred": "import Mathlib\n\nstructure ChessBoard (n : \u2115) where\n\n  numbers : Fin n \u2192 Fin n \u2192 \u2124\n\n  different : \u2200 i j i' j', numbers i j = numbers i' j' \u2192 i = i' \u2227 j = j'\n\n  isRed : Fin n \u2192 Fin n \u2192 Prop := fun i j =>\n    \u2200 i', numbers i' j \u2264 numbers i j\n\n\nstructure AdmissibleSet (n : \u2115) where\n  positions : Fin n \u2192 (Fin n \u00d7 Fin n)\n\n  diffRows : \u2200 i j, i \u2260 j \u2192 (positions i).1 \u2260 (positions j).1\n\n  diffCols : \u2200 i j, i \u2260 j \u2192 (positions i).2 \u2260 (positions j).2\n\ntheorem exists_red_square_in_max_admissible_set (n : \u2115) (h : n > 0)\n    (board : ChessBoard n) (maxSet : AdmissibleSet n)\n    (isMax : \u2200 (otherSet : AdmissibleSet n),\n      (\u2211 i, board.numbers ((maxSet.positions i).1) ((maxSet.positions i).2)) \u2265\n      (\u2211 i, board.numbers ((otherSet.positions i).1) ((otherSet.positions i).2))) :\n    \u2203 i : Fin n, board.isRed ((maxSet.positions i).1) ((maxSet.positions i).2) :=\n  sorry", "compiled": true, "aligned": true}
{"id": "CombStruct4Lean_26", "informal_problem": "XXXVII OM - II - Problem 2\n\nIn a chess tournament, 66 players participate, each playing one game against every other player, and the matches take place in four cities. Prove that there exists a trio of players who play all their games against each other in the same city.", "formal_statement": "import Mathlib\n\nstructure Tournament where\n  players : Finset Nat\n  num_players : players.card = 66\n  cities : Finset Nat\n  num_cities : cities.card = 4\n  game_location : Nat \u2192 Nat \u2192 Nat\n  valid_location : \u2200 p1 p2, p1 \u2208 players \u2192 p2 \u2208 players \u2192 p1 \u2260 p2 \u2192 game_location p1 p2 \u2208 cities\n\ntheorem tournament_trio_exists (t : Tournament) : \n  \u2203 (p1 p2 p3 : Nat) (c : Nat), \n    p1 \u2208 t.players \u2227 p2 \u2208 t.players \u2227 p3 \u2208 t.players \u2227 \n    p1 \u2260 p2 \u2227 p2 \u2260 p3 \u2227 p1 \u2260 p3 \u2227\n    c \u2208 t.cities \u2227\n    t.game_location p1 p2 = c \u2227 \n    t.game_location p2 p3 = c \u2227 \n    t.game_location p1 p3 = c :=\n  sorry", "formal_statement_pred": "import Mathlib\n\nstructure Tournament where\n\n  n : Nat\n\n  k : Nat\n\n  gameCity : Fin n \u2192 Fin n \u2192 Fin k\n\n  games_played : \u2200 (i j : Fin n), i \u2260 j \u2192 gameCity i j = gameCity j i\n\ntheorem tournament_trio_exists :\n  \u2200 (t : Tournament), t.n = 66 \u2192 t.k = 4 \u2192\n  \u2203 (i j l : Fin t.n), i \u2260 j \u2227 j \u2260 l \u2227 i \u2260 l \u2227\n  (t.gameCity i j = t.gameCity j l \u2227 t.gameCity j l = t.gameCity i l) :=\n  sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_27", "informal_problem": "LIX OM - III - Task 4\n\nEach point in the plane with both integer coordinates has been painted either white or black. Prove that from the set of all painted points, an infinite subset can be selected which has a center of symmetry and all of whose points have the same color.", "formal_statement": "import Mathlib\n\n-- Define a point in Z \u00d7 Z\nstructure IntPoint where\n  x : Int\n  y : Int\n\n-- Define a coloring of the integer lattice\ndef Coloring := IntPoint \u2192 Bool  -- Bool represents black (true) and white (false)\n\n-- Define center of symmetry for a set of points\ndef hasCenterOfSymmetry (S : Set IntPoint) : Prop :=\n  \u2203 c : IntPoint, \u2200 p \u2208 S, \n    let sym := IntPoint.mk (2 * c.x - p.x) (2 * c.y - p.y)\n    sym \u2208 S\n\n-- Define a monochromatic set\ndef isMonochromatic (S : Set IntPoint) (col : Coloring) : Prop :=\n  \u2203 b : Bool, \u2200 p \u2208 S, col p = b\n\ntheorem infinite_symmetric_monochromatic \n  (col : Coloring) : \n  \u2203 S : Set IntPoint, \n    Set.Infinite S \u2227 \n    hasCenterOfSymmetry S \u2227 \n    isMonochromatic S col :=\n  sorry", "formal_statement_pred": "import Mathlib\n\n\nstructure IntPoint where\n  x : Int\n  y : Int\n\n\ndef Coloring := IntPoint \u2192 Bool\n\n\ndef hasCenterOfSymmetry (S : Set IntPoint) : Prop :=\n  \u2203 c : IntPoint, \u2200 p \u2208 S,\n    let sym := IntPoint.mk (2 * c.x - p.x) (2 * c.y - p.y)\n    sym \u2208 S\n\n\ndef isMonochromatic (S : Set IntPoint) (col : Coloring) : Prop :=\n  \u2203 b : Bool, \u2200 p \u2208 S, col p = b\n\ntheorem infinite_symmetric_monochromatic\n  (col : Coloring) :\n  \u2203 S : Set IntPoint,\n    Set.Infinite S \u2227\n    hasCenterOfSymmetry S \u2227\n    isMonochromatic S col :=\n  sorry", "compiled": true, "aligned": true}
{"id": "CombStruct4Lean_28", "informal_problem": "XLV OM - I - Problem 9\n\nIn a conference, $2n$ people are participating. Each participant has at least $n$ acquaintances among the other participants. Prove that all participants of the conference can be accommodated in double rooms so that each participant shares a room with an acquaintance.", "formal_statement": "import Mathlib\n\nstructure Conference where\n  n : Nat\n  participants : Finset (Fin (2 * n))\n  acquaintance : Fin (2 * n) \u2192 Finset (Fin (2 * n))\n  card_participants : participants.card = 2 * n\n  enough_acquaintances : \u2200 p, p \u2208 participants \u2192 (acquaintance p).card \u2265 n\n  valid_acquaintance : \u2200 p\u2081 p\u2082, p\u2082 \u2208 acquaintance p\u2081 \u2194 p\u2081 \u2208 acquaintance p\u2082\n\n/-- A pairing represents a valid room assignment where each person shares with an acquaintance -/\ndef ValidPairing (c : Conference) (pairs : Finset (Fin (2 * c.n) \u00d7 Fin (2 * c.n))) : Prop :=\n  -- Each person appears exactly once in a pair\n  (\u2200 p \u2208 c.participants, \u2203! pair \u2208 pairs, p = pair.1 \u2228 p = pair.2) \u2227\n  -- Each pair consists of acquaintances\n  (\u2200 pair \u2208 pairs, pair.2 \u2208 c.acquaintance pair.1) \u2227\n  -- Number of pairs is n (double rooms)\n  pairs.card = c.n\n\ntheorem conference_room_assignment (c : Conference) : \u2203 pairs, ValidPairing c pairs :=\n  sorry", "formal_statement_pred": "import Mathlib\n\nstructure Conference where\n  n : Nat\n  participants : Finset (Fin (2 * n))\n  acquaintances : Fin (2 * n) \u2192 Finset (Fin (2 * n))\n  participants_count : participants.card = 2 * n\n  min_acquaintances : \u2200 p \u2208 participants, (acquaintances p).card \u2265 n\n  valid_acquaintances : \u2200 p\u2081 p\u2082, p\u2082 \u2208 acquaintances p\u2081 \u2194 p\u2081 \u2208 acquaintances p\u2082\n\n\ndef IsValidRoomAssignment (conf : Conference) (rooms : Fin conf.n \u2192 Fin (2 * conf.n) \u00d7 Fin (2 * conf.n)) : Prop :=\n  (\u2200 i, (rooms i).1 \u2208 conf.participants \u2227 (rooms i).2 \u2208 conf.participants) \u2227\n  (\u2200 i, (rooms i).2 \u2208 conf.acquaintances (rooms i).1) \u2227\n  (\u2200 i j, i \u2260 j \u2192 (rooms i).1 \u2260 (rooms j).1 \u2227 (rooms i).1 \u2260 (rooms j).2 \u2227\n                   (rooms i).2 \u2260 (rooms j).1 \u2227 (rooms i).2 \u2260 (rooms j).2)\n\ntheorem conference_room_assignment (conf : Conference) :\n  \u2203 rooms : Fin conf.n \u2192 Fin (2 * conf.n) \u00d7 Fin (2 * conf.n),\n    IsValidRoomAssignment conf rooms :=\n  sorry", "compiled": true, "aligned": true}
{"id": "CombStruct4Lean_29", "informal_problem": "XXXII - III - Task 4\n\nOn the table lie $ n $ tokens marked with integers. If among these tokens there are two marked with the same number, for example, the number $ k $, then we replace them with one token marked with the number $ k+1 $ and one with the number $ k-1 $. Prove that after a finite (non-negative) number of such changes, all tokens will be marked with different numbers.", "formal_statement": "import Mathlib\n\nstructure TokenState where\n  n : Nat                    -- number of tokens\n  marks : Fin n \u2192 Int       -- marks on each token\n\n/-- Function to check if all marks are different -/\ndef allDifferent (state : TokenState) : Prop :=\n  \u2200 i j : Fin state.n, i \u2260 j \u2192 state.marks i \u2260 state.marks j\n\n/-- Represents one step of replacing two equal tokens -/\ndef canReplace (state : TokenState) : Prop :=\n  \u2203 i j : Fin state.n, i \u2260 j \u2227 state.marks i = state.marks j\n\ntheorem token_game_terminates (n : Nat) (initial : TokenState) (h : n > 0) :\n  \u2203 final : TokenState, final.n = n \u2227 allDifferent final :=\n  sorry", "formal_statement_pred": "import Mathlib\n\nstructure TokenGame where\n  n : Nat\n  marks : Fin n \u2192 Int\n\n\ndef TokenGame.move (game : TokenGame) (i j : Fin game.n) : TokenGame :=\n  sorry\n\ntheorem token_game_terminates (n : Nat) (h : n > 0) :\n  \u2200 (initial : TokenGame),\n    \u2203 (final : TokenGame),\n      (\u2200 (i j : Fin final.n), i \u2260 j \u2192 final.marks i \u2260 final.marks j) :=\n  sorry", "compiled": true, "aligned": true}
{"id": "CombStruct4Lean_30", "informal_problem": "XXIV OM - III - Problem 4\n\nOn a line, a system of segments with a total length $ < 1 $ is given. Prove that any system of $ n $ points on the line can be moved along it by a vector of length $ \\leq \\frac{n}{2} $ so that after the move, none of the points lies on any of the given segments.", "formal_statement": "import Mathlib\n\nstructure SegmentSystem where\n  segments : List (\u211d \u00d7 \u211d) -- List of segments represented as pairs of endpoints\n  total_length : \u211d\n  length_bound : total_length < 1\n  valid_segments : \u2200 s \u2208 segments, s.1 \u2264 s.2 -- Ensure left endpoint \u2264 right endpoint\n\n/-- Predicate to check if a point lies on any segment in the system -/\ndef lies_on_segments (sys : SegmentSystem) (point : \u211d) : Prop :=\n  \u2203 seg \u2208 sys.segments, seg.1 \u2264 point \u2227 point \u2264 seg.2\n\ntheorem segment_avoidance_theorem\n  (sys : SegmentSystem)\n  (points : List \u211d)\n  (n : \u2115)\n  (h_points : points.length = n) :\n  \u2203 (shift : \u211d),\n    (|shift| \u2264 n/2) \u2227\n    (\u2200 p \u2208 points, \u00aclies_on_segments sys (p + shift)) :=\n  sorry", "formal_statement_pred": "import Mathlib\n\nstructure SegmentSystem where\n  segments : List (\u211d \u00d7 \u211d)\n  total_length : \u211d\n  length_bound : total_length < 1\n  valid_segments : \u2200 s \u2208 segments, s.1 \u2264 s.2\n\n\ndef lies_on_segment (p : \u211d) (s : \u211d \u00d7 \u211d) : Prop :=\n  s.1 \u2264 p \u2227 p \u2264 s.2\n\n\ndef lies_on_any_segment (p : \u211d) (sys : SegmentSystem) : Prop :=\n  \u2203 s \u2208 sys.segments, lies_on_segment p s\n\ntheorem segment_avoidance_exists\n  (sys : SegmentSystem) (points : List \u211d) (n : \u2115) (h : points.length = n) :\n  \u2203 (shift : \u211d),\n    (|shift| \u2264 n/2) \u2227\n    (\u2200 p \u2208 points, \u00aclies_on_any_segment (p + shift) sys) :=\n  sorry", "compiled": true, "aligned": true}
{"id": "CombStruct4Lean_33", "informal_problem": "LI OM - I - Problem 11\n\nGiven a positive integer $ n $ and a set $ M $, consisting of $ n^2 + 1 $ different positive integers and having the following property: among any $ n+1 $ numbers chosen from the set $ M $, there is a pair of numbers, one of which divides the other. Prove that in the set $ M $ there exist distinct numbers $ a_1, a_2, \\ldots, a_{n+1} $ satisfying the condition: for $ i = 1,2,\\ldots,n $, the number $ a_i $ divides $ a_{i+1} $.", "formal_statement": "import Mathlib\n\nstructure DivisibilityChain (n : \u2115) where\n  M : Finset \u2115\n  size_cond : M.card = n^2 + 1\n  div_property : \u2200 S : Finset \u2115, S \u2286 M \u2192 S.card = n + 1 \u2192 \n    \u2203 x y, x \u2208 S \u2227 y \u2208 S \u2227 x \u2260 y \u2227 x \u2223 y\n\ntheorem exists_divisibility_chain (n : \u2115) (h : n > 0) (M : DivisibilityChain n) :\n  \u2203 (a : Fin (n+1) \u2192 \u2115),\n    (\u2200 i, a i \u2208 M.M) \u2227\n    (\u2200 i j, i.val < j.val \u2192 a i \u2223 a j) \u2227\n    (\u2200 i j, i \u2260 j \u2192 a i \u2260 a j) :=\n  sorry", "formal_statement_pred": "import Mathlib\n\ndef IsDivisibleChain (s : List Nat) : Bool :=\n  s.length > 1 \u2227 \u2200 i, i < s.length - 1 \u2192 s[i]! \u2223 s[i + 1]!\n\nstructure DivisibilitySet (n : Nat) where\n  elements : Finset Nat\n  size : elements.card = n^2 + 1\n  distinct : \u2200 x \u2208 elements, x > 0\n  divProp : \u2200 (subset : Finset Nat), subset \u2286 elements \u2192 subset.card = n + 1 \u2192\n    \u2203 (a b : Nat), a \u2208 subset \u2227 b \u2208 subset \u2227 a \u2260 b \u2227 a \u2223 b\n\ntheorem LI_OM_I_11 (n : Nat) (h : n > 0) (M : DivisibilitySet n) :\n  \u2203 (chain : List Nat), chain.Nodup \u2227 chain.length = n + 1 \u2227\n    (\u2200 x \u2208 chain, x \u2208 M.elements) \u2227 IsDivisibleChain chain :=\n  sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_34", "informal_problem": "XXXIII OM - I - Problem 5\n\nIn a certain workplace, each employee is a member of exactly one of 100 trade unions. The employees are to elect a director from among two candidates. Members of each union agree on whether to abstain from voting or which of the two candidates they will vote for. Prove that there exists a union such that if its members abstain from voting, and members of all other unions vote for one of the two candidates, the candidates for director will not receive an equal number of votes.", "formal_statement": "import Mathlib\n\ninductive VoteChoice\n  | abstain\n  | candidate1\n  | candidate2\n  deriving Repr, DecidableEq\n\nstructure VotingSystem where\n  unionSize : Fin 100 \u2192 Nat\n  votingChoice : Fin 100 \u2192 VoteChoice\n  size_pos : \u2200 i, unionSize i > 0\n  total_finite : (Finset.univ.sum unionSize) > 0\n\n/-- Predicate indicating if a voting configuration is valid:\n    all unions except possibly one must vote for a candidate -/\ndef isValidConfig (vs : VotingSystem) (abstaining : Option (Fin 100)) : Prop :=\n  \u2200 i : Fin 100, \n    if abstaining = some i \n    then vs.votingChoice i = VoteChoice.abstain\n    else vs.votingChoice i = VoteChoice.candidate1 \u2228 \n         vs.votingChoice i = VoteChoice.candidate2\n\n/-- Count votes for a specific candidate in a voting configuration -/\ndef countVotes (vs : VotingSystem) (c : VoteChoice) : Nat :=\n  Finset.sum Finset.univ fun i => \n    if vs.votingChoice i = c then vs.unionSize i else 0\n\ntheorem exists_decisive_union (vs : VotingSystem) :\n  \u2203 (k : Fin 100),\n    \u2200 (new_vs : VotingSystem),\n      isValidConfig new_vs (some k) \u2192\n      (\u2200 i \u2260 k, vs.unionSize i = new_vs.unionSize i) \u2192\n      countVotes new_vs VoteChoice.candidate1 \u2260 \n      countVotes new_vs VoteChoice.candidate2 :=\n  sorry", "formal_statement_pred": "import Mathlib\n\ninductive Vote where\n  | abstain\n  | candidate1\n  | candidate2\nderiving Repr\n\nstructure VoteCounts where\n  candidate1 : Nat\n  candidate2 : Nat\nderiving Repr\n\nstructure VotingScenario where\n  unionSizes : Fin 100 \u2192 Nat\n  votingChoices : Fin 100 \u2192 Vote\n\ndef getUnionVotes (scenario : VotingScenario) (i : Fin 100) : VoteCounts :=\n  match scenario.votingChoices i with\n  | Vote.abstain => \u27e80, 0\u27e9\n  | Vote.candidate1 => \u27e8scenario.unionSizes i, 0\u27e9\n  | Vote.candidate2 => \u27e80, scenario.unionSizes i\u27e9\n\ndef countVotes (scenario : VotingScenario) (abstainUnion : Fin 100) : VoteCounts :=\n  let votes := fun (i : Fin 100) =>\n    if i = abstainUnion then\n      \u27e80, 0\u27e9\n    else\n      getUnionVotes scenario i\n  \u27e8\n    Finset.sum (Finset.univ : Finset (Fin 100)) (fun i => (votes i).candidate1),\n    Finset.sum (Finset.univ : Finset (Fin 100)) (fun i => (votes i).candidate2)\n  \u27e9\n\ntheorem exists_unequal_votes_union (scenario : VotingScenario)\n  (h : \u2200 i : Fin 100, scenario.unionSizes i > 0) :\n  \u2203 u : Fin 100, (countVotes scenario u).candidate1 \u2260 (countVotes scenario u).candidate2 :=\n  sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_36", "informal_problem": "LX OM - III - Task 4\n\nLet $ x_1,x_2,\\cdots ,x_n $ be non-negative numbers whose sum is 1. Prove that there exist\nnumbers $ a1,a2,\\cdots ,an \\in \\{0, 1, 2, 3, 4\\} $ such that $ (a_1,a_2,\\cdots ,a_n) \\neq (2, 2,\\cdots , 2) $ and", "formal_statement": "import Mathlib\n\ndef validCoefficients (n : \u2115) : Set (Fin n \u2192 \u2115) :=\n  { a | (\u2200 i, a i \u2264 4) \u2227 \u2203 i, a i \u2260 2 }\n\ntheorem exists_valid_coefficients (n : \u2115) (x : Fin n \u2192 \u211d)\n  (hx_nonneg : \u2200 i, x i \u2265 0)\n  (hx_sum : (\u2211 i, x i) = 1) :\n  \u2203 a \u2208 validCoefficients n,\n    (\u2211 i, (a i : \u211d) * x i) = 2 :=\n  sorry", "formal_statement_pred": "import Mathlib\n\nopen Finset\n\nabbrev Assignment (n : \u2115) := Fin n \u2192 Fin 5\n\nstructure Distribution (n : \u2115) where\n  values : Fin n \u2192 \u211d\n  sum_one : Finset.sum univ values = 1\n  nonneg : \u2200 i, 0 \u2264 values i\n\ntheorem exists_valid_assignment (n : \u2115) (h : n > 0) :\n  \u2200 (d : Distribution n), \u2203 (a : Assignment n),\n    (\u2203 i, a i \u2260 2) \u2227\n    (\u2200 i, |5 * d.values i - (a i : \u211d)| \u2264 1) :=\n  sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_37", "informal_problem": "XLVI OM - I - Problem 4\n\nIn a certain school, 64 students participate in five subject olympiads. In each of these olympiads, at least 19 students from this school participate; none of them participate in more than three olympiads. Prove that if any three olympiads have a common participant, then some two of them have at least five participants in common.", "formal_statement": "import Mathlib\n\nstructure OlympiadParticipation where\n  participation : Finset (Fin 64 \u00d7 Fin 5)\n  total_valid : (participation.image Prod.fst).card = 64\n  min_participation : \u2200 o : Fin 5, (participation.filter (fun p => p.2 = o)).card \u2265 19\n  max_olympiads : \u2200 s : Fin 64, (participation.filter (fun p => p.1 = s)).card \u2264 3\n\ndef participants (p : OlympiadParticipation) (o : Fin 5) : Finset (Fin 64) :=\n  (p.participation.filter (fun x => x.2 = o)).image Prod.fst\n\ndef common_participants (p : OlympiadParticipation) (o\u2081 o\u2082 : Fin 5) : Finset (Fin 64) :=\n  participants p o\u2081 \u2229 participants p o\u2082\n\ntheorem olympiad_intersection_size \n  (p : OlympiadParticipation)\n  (h : \u2203 s : Fin 64, \u2203 i j k : Fin 5, i \u2260 j \u2227 j \u2260 k \u2227 i \u2260 k \u2227 \n    s \u2208 participants p i \u2227 s \u2208 participants p j \u2227 s \u2208 participants p k) :\n  \u2203 i j : Fin 5, i \u2260 j \u2227 (common_participants p i j).card \u2265 5 :=\n  sorry", "formal_statement_pred": "import Mathlib\n\nstructure OlympiadParticipation where\n  olympiads : Fin 5 \u2192 Finset (Fin 64)\n  min_size : \u2200 o, (olympiads o).card \u2265 19\n\ndef count_participation (p : OlympiadParticipation) (s : Fin 64) : Nat :=\n  (Finset.filter (fun o => s \u2208 p.olympiads o) (Finset.univ : Finset (Fin 5))).card\n\n\ndef valid_participation (p : OlympiadParticipation) : Prop :=\n  \u2200 s : Fin 64, count_participation p s \u2264 3\n\ntheorem olympiad_intersection_size\n  (p : OlympiadParticipation)\n  (hp : valid_participation p)\n  (h : \u2203 (s : Fin 64) (i j k : Fin 5),\n    i \u2260 j \u2227 j \u2260 k \u2227 i \u2260 k \u2227\n    s \u2208 p.olympiads i \u2227 s \u2208 p.olympiads j \u2227 s \u2208 p.olympiads k) :\n  \u2203 (i j : Fin 5), i \u2260 j \u2227 ((p.olympiads i) \u2229 (p.olympiads j)).card \u2265 5 :=\n  sorry", "compiled": true, "aligned": true}
{"id": "CombStruct4Lean_38", "informal_problem": "XXXI - I - Problem 10\n\nA plane is divided into congruent squares by two families of parallel lines. $ S $ is a set consisting of $ n $ such squares. Prove that there exists a subset of the set $ S $, in which the number of squares is no less than $ \\frac{n}{4} $ and no two squares have a common vertex.", "formal_statement": "import Mathlib\n\n/-- A square in a grid with integer coordinates -/\nstructure GridSquare where\n  x : Int\n  y : Int\n  deriving Repr, DecidableEq\n\n/-- Two squares share a vertex if they have coordinates that differ by at most 1 in both dimensions -/\ndef sharesVertex (s1 s2 : GridSquare) : Prop :=\n  Int.natAbs (s1.x - s2.x) \u2264 1 \u2227 Int.natAbs (s1.y - s2.y) \u2264 1\n\n/-- A set of grid squares is independent if no two squares share a vertex -/\ndef isIndependent (squares : Finset GridSquare) : Prop :=\n  \u2200 s1 s2, s1 \u2208 squares \u2192 s2 \u2208 squares \u2192 s1 \u2260 s2 \u2192 \u00acsharesVertex s1 s2\n\ntheorem grid_squares_independent_subset \n  (S : Finset GridSquare) (n : \u2115) (h\u2081 : n > 0) (h\u2082 : S.card = n) :\n  \u2203 (T : Finset GridSquare), T \u2286 S \u2227 isIndependent T \u2227 T.card \u2265 n / 4 :=\n  sorry", "formal_statement_pred": "import Mathlib\n\nstructure GridSquare where\n  x : \u2124\n  y : \u2124\n  deriving Repr\n\n\ndef share_vertex (s1 s2 : GridSquare) : Prop :=\n  (abs (s1.x - s2.x) \u2264 1 \u2227 abs (s1.y - s2.y) \u2264 1) \u2227\n  \u00ac(s1.x = s2.x \u2227 s1.y = s2.y)\n\n\ndef is_independent_set (S : Finset GridSquare) : Prop :=\n  \u2200 s1 s2 : GridSquare, s1 \u2208 S \u2192 s2 \u2208 S \u2192 s1 \u2260 s2 \u2192 \u00acshare_vertex s1 s2\n\ntheorem grid_independent_set_exists (S : Finset GridSquare) (n : \u2115)\n  (h_size : S.card = n)\n  (h_pos : n > 0) :\n  \u2203 T : Finset GridSquare, T \u2286 S \u2227\n    is_independent_set T \u2227\n    T.card \u2265 n / 4 :=\n  sorry", "compiled": true, "aligned": true}
{"id": "CombStruct4Lean_40", "informal_problem": "XLVIII OM - III - Problem 6\n\nOn a circle of radius $ 1 $, there are $ n $ different points ($ n \\geq 2 $). Let $ q $ be the number of segments with endpoints at these points and length greater than $ \\sqrt{2} $. Prove that $ 3q \\leq n^2 $.", "formal_statement": "import Mathlib\n\nstructure CirclePoints where\n  n : \u2115\n  h_size : n \u2265 2\n  points : Fin n \u2192 \u211d \u00d7 \u211d\n  on_circle : \u2200 i, (points i).1 ^ 2 + (points i).2 ^ 2 = 1\n  distinct : Function.Injective points\n\nnoncomputable def distance (p\u2081 p\u2082 : \u211d \u00d7 \u211d) : \u211d :=\n  Real.sqrt ((p\u2081.1 - p\u2082.1)^2 + (p\u2081.2 - p\u2082.2)^2)\n\nnoncomputable def long_segments (cp : CirclePoints) : \u2115 :=\n  Finset.card {p : Fin cp.n \u00d7 Fin cp.n | \n    p.1 < p.2 \u2227 \n    distance (cp.points p.1) (cp.points p.2) > Real.sqrt 2}.toFinset\n\ntheorem circle_points_long_segments (cp : CirclePoints) :\n  3 * long_segments cp \u2264 cp.n ^ 2 := sorry", "formal_statement_pred": "import Mathlib\n\nstructure CirclePoints where\n  n : Nat\n  h_size : n \u2265 2\n  points : Fin n \u2192 EuclideanSpace \u211d (Fin 2)\n  on_circle : \u2200 i, \u2016points i\u2016 = 1\n  distinct : \u2200 i j, i \u2260 j \u2192 points i \u2260 points j\n\n\nnoncomputable def segment_length (cp : CirclePoints) (i j : Fin cp.n) : \u211d :=\n  \u2016cp.points i - cp.points j\u2016\n\n\nnoncomputable def long_segments (cp : CirclePoints) : Finset (Fin cp.n \u00d7 Fin cp.n) :=\n  Finset.filter (fun p => segment_length cp p.1 p.2 > Real.sqrt 2 \u2227 p.1 < p.2)\n    (Finset.product Finset.univ Finset.univ)\n\n\nnoncomputable def q (cp : CirclePoints) : \u2115 :=\n  Finset.card (long_segments cp)\n\ntheorem circle_points_long_segments (cp : CirclePoints) :\n    3 * q cp \u2264 cp.n^2 := sorry", "compiled": true, "aligned": true}
{"id": "CombStruct4Lean_42", "informal_problem": "XXXVII OM - III - Problem 5\n\nIn a chess tournament, $2n$ ($n > 1$) players participate, and any two of them play at most one game against each other. Prove that such a tournament, in which no three players play three games among themselves, is possible if and only if the total number of games played in the tournament does not exceed $n^2$.", "formal_statement": "import Mathlib\n\nstructure ChessTournament (n : \u2115) where\n  games : Finset (Fin (2*n) \u00d7 Fin (2*n))\n  -- No player plays against themselves\n  no_self : \u2200 p \u2208 games, (Prod.fst p \u2260 Prod.snd p)\n  -- Games are symmetric (if (i,j) is in games, then (j,i) is too)\n  symmetric : \u2200 i j, (i, j) \u2208 games \u2194 (j, i) \u2208 games\n  -- No three players play three games among themselves\n  no_triangle : \u2200 i j k, \u00ac((i, j) \u2208 games \u2227 (j, k) \u2208 games \u2227 (k, i) \u2208 games)\n\ntheorem chess_tournament_characterization (n : \u2115) (h : n > 1) :\n  (\u2203 (t : ChessTournament n), (t.games.card / 2) \u2264 n^2) \u2194\n  (\u2203 (t : ChessTournament n), t.games.card \u2264 2 * n^2) :=\n  sorry", "formal_statement_pred": "import Mathlib\n\nopen Finset\n\n\nabbrev Player (n : \u2115) := Fin (2*n)\n\n\nstructure Game (n : \u2115) where\n  player1 : Player n\n  player2 : Player n\n  distinct : player1 < player2\n\n\ndef plays_in_game {n : \u2115} (p : Player n) (g : Game n) : Prop :=\n  p = g.player1 \u2228 p = g.player2\n\n\ndef plays_triangle {n : \u2115} (g\u2081 g\u2082 g\u2083 : Game n) (p\u2081 p\u2082 p\u2083 : Player n) : Prop :=\n  (plays_in_game p\u2081 g\u2081 \u2227 plays_in_game p\u2082 g\u2081) \u2227\n  (plays_in_game p\u2082 g\u2082 \u2227 plays_in_game p\u2083 g\u2082) \u2227\n  (plays_in_game p\u2083 g\u2083 \u2227 plays_in_game p\u2081 g\u2083)\n\n\nstructure ChessTournament (n : \u2115) where\n  games : Finset (Game n)\n  no_duplicate_games : \u2200 {g\u2081 g\u2082}, g\u2081 \u2208 games \u2192 g\u2082 \u2208 games \u2192 g\u2081 \u2260 g\u2082 \u2192\n    (g\u2081.player1 \u2260 g\u2082.player1 \u2228 g\u2081.player2 \u2260 g\u2082.player2)\n  no_triangle : \u2200 p\u2081 p\u2082 p\u2083 : Player n,\n    p\u2081 \u2260 p\u2082 \u2192 p\u2082 \u2260 p\u2083 \u2192 p\u2081 \u2260 p\u2083 \u2192\n    \u00ac(\u2203 g\u2081 g\u2082 g\u2083, g\u2081 \u2208 games \u2227 g\u2082 \u2208 games \u2227 g\u2083 \u2208 games \u2227\n      plays_triangle g\u2081 g\u2082 g\u2083 p\u2081 p\u2082 p\u2083)\n\ntheorem chess_tournament_exists (n : \u2115) (h\u2081 : n > 1) (k : \u2115) (h\u2082 : k \u2265 0) :\n  (\u2203 (t : ChessTournament n), t.games.card = k) \u2194 k \u2264 n^2 :=\n  sorry", "compiled": true, "aligned": true}
{"id": "CombStruct4Lean_43", "informal_problem": "5. Is it possible to color each $1 \\times 1$ cell of a $1000 \\times 1000$ square in one of three colors: red, blue, and green, such that each red cell has two adjacent blue cells, each blue cell has two adjacent green cells, and each green cell has two adjacent red cells? Cells are considered adjacent if they share a common side.", "formal_statement": "import Mathlib\n\ninductive Color where\n  | red : Color\n  | blue : Color\n  | green : Color\n  deriving BEq, Repr\n\nstructure Grid where\n  n : Nat\n  coloring : Fin n \u2192 Fin n \u2192 Color\n\ndef adjacent (n : Nat) (i j i' j' : Fin n) : Bool :=\n  (i = i' \u2227 (j.val + 1 = j'.val \u2228 j.val = j'.val + 1)) \u2228\n  (j = j' \u2227 (i.val + 1 = i'.val \u2228 i.val = i'.val + 1))\n\ndef validColoring (g : Grid) : Prop :=\n  \u2200 (i j : Fin g.n),\n    match g.coloring i j with\n    | Color.red => \u2203 (i\u2081 j\u2081 i\u2082 j\u2082 : Fin g.n),\n        adjacent g.n i j i\u2081 j\u2081 \u2227 adjacent g.n i j i\u2082 j\u2082 \u2227\n        g.coloring i\u2081 j\u2081 = Color.blue \u2227 g.coloring i\u2082 j\u2082 = Color.blue\n    | Color.blue => \u2203 (i\u2081 j\u2081 i\u2082 j\u2082 : Fin g.n),\n        adjacent g.n i j i\u2081 j\u2081 \u2227 adjacent g.n i j i\u2082 j\u2082 \u2227\n        g.coloring i\u2081 j\u2081 = Color.green \u2227 g.coloring i\u2082 j\u2082 = Color.green\n    | Color.green => \u2203 (i\u2081 j\u2081 i\u2082 j\u2082 : Fin g.n),\n        adjacent g.n i j i\u2081 j\u2081 \u2227 adjacent g.n i j i\u2082 j\u2082 \u2227\n        g.coloring i\u2081 j\u2081 = Color.red \u2227 g.coloring i\u2082 j\u2082 = Color.red\n\ntheorem no_valid_coloring_1000 :\n  \u00ac\u2203 (g : Grid), g.n = 1000 \u2227 validColoring g :=\n  sorry", "formal_statement_pred": "import Mathlib\n\ninductive Color where\n  | red : Color\n  | blue : Color\n  | green : Color\n  deriving BEq, Repr\n\ndef Cell (n : Nat) := Fin n \u00d7 Fin n\n\ninductive Direction where\n  | up | down | left | right\n\nstructure Grid (n : Nat) where\n  coloring : Fin n \u2192 Fin n \u2192 Color\n\ndef get_neighbor {n : Nat} (c : Cell n) (d : Direction) : Option (Cell n) :=\n  match d with\n  | Direction.up =>\n    if h : c.1.val + 1 < n then some (\u27e8\u27e8c.1.val + 1, h\u27e9, c.2\u27e9) else none\n  | Direction.down =>\n    if h : c.1.val > 0 then some (\u27e8\u27e8c.1.val - 1, sorry\u27e9, c.2\u27e9) else none\n  | Direction.right =>\n    if h : c.2.val + 1 < n then some (\u27e8c.1, \u27e8c.2.val + 1, h\u27e9\u27e9) else none\n  | Direction.left =>\n    if h : c.2.val > 0 then some (\u27e8c.1, \u27e8c.2.val - 1, sorry\u27e9\u27e9) else none\n\ndef is_adjacent {n : Nat} (c1 c2 : Cell n) : Prop :=\n  \u2203 d : Direction, get_neighbor c1 d = some c2\n\ndef valid_coloring (n : Nat) (g : Grid n) : Prop :=\n  \u2200 (c : Cell n),\n    (g.coloring c.1 c.2 = Color.red \u2192\n      \u2203 (c1 c2 : Cell n), c1 \u2260 c2 \u2227\n        is_adjacent c c1 \u2227 is_adjacent c c2 \u2227\n        g.coloring c1.1 c1.2 = Color.blue \u2227 g.coloring c2.1 c2.2 = Color.blue) \u2227\n    (g.coloring c.1 c.2 = Color.blue \u2192\n      \u2203 (c1 c2 : Cell n), c1 \u2260 c2 \u2227\n        is_adjacent c c1 \u2227 is_adjacent c c2 \u2227\n        g.coloring c1.1 c1.2 = Color.green \u2227 g.coloring c2.1 c2.2 = Color.green) \u2227\n    (g.coloring c.1 c.2 = Color.green \u2192\n      \u2203 (c1 c2 : Cell n), c1 \u2260 c2 \u2227\n        is_adjacent c c1 \u2227 is_adjacent c c2 \u2227\n        g.coloring c1.1 c1.2 = Color.red \u2227 g.coloring c2.1 c2.2 = Color.red)\n\ntheorem no_valid_1000x1000_coloring :\n  \u00ac\u2203 (g : Grid 1000), valid_coloring 1000 g :=\n  sorry", "compiled": true, "aligned": true}
{"id": "CombStruct4Lean_44", "informal_problem": "4. (13 points) In a large online chess tournament, each player had exactly three friends among the participants. Each player played one game with all the participants except for their three friends. Could exactly 404 games have been played?", "formal_statement": "import Mathlib\n\n/- Structure representing a chess tournament where each player has exactly 3 friends -/\nstructure ChessTournament where\n  n : Nat\n  /- Set of friends for each player -/\n  friends : Fin n \u2192 Finset (Fin n)\n  /- Each player has exactly 3 friends -/\n  three_friends : \u2200 p, (friends p).card = 3\n  /- Friendship relation is symmetric -/\n  symmetric : \u2200 p q, q \u2208 friends p \u2194 p \u2208 friends q\n  /- Players cannot be friends with themselves -/\n  not_self_friend : \u2200 p, p \u2209 friends p\n  /- Number of players must be at least 4 -/\n  min_players : n \u2265 4\n\n/-- Total number of possible games between n players -/\ndef total_possible_games (n : Nat) : Nat := (n * (n - 1))/2\n\n/-- Total number of friend pairs in the tournament -/\ndef total_friend_pairs (t : ChessTournament) : Nat := (3 * t.n)/2\n\ntheorem chess_tournament_404_possible : \u2203 (t : ChessTournament),\n  total_possible_games t.n - total_friend_pairs t = 404 :=\n  sorry", "formal_statement_pred": "import Mathlib\n\nstructure ChessTournament where\n  n : Nat\n  friends : Fin n \u2192 Finset (Fin n)\n  no_self_friends : \u2200 p, p \u2209 friends p\n  friend_count : \u2200 p, (friends p).card = 3\n  symmetric : \u2200 p q, q \u2208 friends p \u2194 p \u2208 friends q\n\ndef games_played (t : ChessTournament) : Nat :=\n  (t.n * (t.n - 1))/2 - (Finset.sum (Finset.univ : Finset (Fin t.n)) (fun i => (t.friends i).card))/2\n\ntheorem chess_tournament_404_impossible : \u00ac\u2203 (t : ChessTournament), games_played t = 404 :=\n  sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_46", "informal_problem": "Problem 5. In a physics competition, 17 schoolchildren are participating. The participants were offered 12 problems. As a result, each problem was solved correctly by more than half of the participants. Prove that there will definitely be three schoolchildren who, together, have solved all the problems.", "formal_statement": "import Mathlib\n\nstructure PhysicsCompetition where\n  n_students : Nat\n  n_problems : Nat\n  solutions : Fin n_students \u2192 Fin n_problems \u2192 Bool\n  more_than_half_solved : \u2200 p : Fin n_problems,\n    2 * (Finset.univ.filter (fun s => solutions s p)).card > n_students\nderiving Repr\n\ntheorem physics_competition_three_cover \n  (comp : PhysicsCompetition)\n  (h1 : comp.n_students = 17)\n  (h2 : comp.n_problems = 12) :\n  \u2203 (s1 s2 s3 : Fin comp.n_students),\n    \u2200 p : Fin comp.n_problems,\n      comp.solutions s1 p \u2228 comp.solutions s2 p \u2228 comp.solutions s3 p :=\n  sorry", "formal_statement_pred": "import Mathlib\n\nstructure PhysicsCompetition where\n  solvedBy : Fin 12 \u2192 Finset (Fin 17)\n  h_majority : \u2200 p, (solvedBy p).card > 8\n\ntheorem physics_competition_existence (comp : PhysicsCompetition) :\n  \u2203 students : Finset (Fin 17),\n    students.card = 3 \u2227\n    \u2200 p : Fin 12, \u2203 s \u2208 students, s \u2208 comp.solvedBy p :=\n  sorry", "compiled": true, "aligned": true}
{"id": "CombStruct4Lean_47", "informal_problem": "10.5. There are 64 checkers of several colors, paired such that the colors of the checkers in each pair are different. Prove that all the checkers can be arranged on a chessboard so that the checkers in each two-square rectangle are of different colors.", "formal_statement": "import Mathlib\n\nstructure CheckerArrangement where\n  n : Nat                              -- number of colors\n  colors : Fin 64 \u2192 Fin n             -- color assignment for each checker\n  pairs : Fin 32 \u2192 Fin 64 \u00d7 Fin 64    -- the given pairs of checkers\n  positions : Fin 64 \u2192 Fin 8 \u00d7 Fin 8   -- position of each checker on the board\n\n-- Predicate to check if two positions form a 2\u00d71 or 1\u00d72 rectangle\ndef isRectangle (p1 p2 : Fin 8 \u00d7 Fin 8) : Bool :=\n  let (x1, y1) := p1\n  let (x2, y2) := p2\n  (x1 = x2 && y1.val + 1 = y2.val) ||    -- vertical rectangle\n  (y1 = y2 && x1.val + 1 = x2.val)       -- horizontal rectangle\n\ntheorem checker_arrangement_exists : \u2203 (arr : CheckerArrangement), \n  -- Pairs have different colors\n  (\u2200 i : Fin 32, let (c1, c2) := arr.pairs i; arr.colors c1 \u2260 arr.colors c2) \u2227\n  -- Checkers in rectangles have different colors\n  (\u2200 i j : Fin 64, isRectangle (arr.positions i) (arr.positions j) \u2192 \n    arr.colors i \u2260 arr.colors j) :=\n  sorry", "formal_statement_pred": "import Mathlib\n\nstructure CheckerArrangement where\n  n : Nat\n  colors : Fin 64 \u2192 Fin n\n  pairs : Fin 32 \u2192 Fin 64 \u00d7 Fin 64\n  board : Fin 64 \u2192 Fin 8 \u00d7 Fin 8\n\n  pairs_different : \u2200 i, colors ((pairs i).1) \u2260 colors ((pairs i).2)\n  pairs_valid : \u2200 i, (pairs i).1 \u2260 (pairs i).2\n  board_injective : Function.Injective board\n\ndef isRectangle (p1 p2 : Fin 8 \u00d7 Fin 8) : Bool :=\n  (p1.1 = p2.1 \u2227 (p1.2.val + 1 = p2.2.val \u2228 p2.2.val + 1 = p1.2.val)) \u2228\n  (p1.2 = p2.2 \u2227 (p1.1.val + 1 = p2.1.val \u2228 p2.1.val + 1 = p1.1.val))\n\ntheorem checkers_arrangement_exists :\n  \u2200 (arr : CheckerArrangement),\n  \u2203 (board : Fin 64 \u2192 Fin 8 \u00d7 Fin 8),\n    Function.Injective board \u2227\n    (\u2200 i j : Fin 64,\n      isRectangle (board i) (board j) = true \u2192\n      arr.colors i \u2260 arr.colors j) :=\n  sorry", "compiled": true, "aligned": true}
{"id": "CombStruct4Lean_48", "informal_problem": "3. There are 288 visually identical coins weighing 7 and 8 grams (both types are present). On the scales, 144 coins were placed on each pan such that the scales are in balance. In one operation, you can take any two groups of the same number of coins from the pans and swap their places. Prove that it is possible to make the scales unbalanced in no more than 11 operations.", "formal_statement": "import Mathlib\n\nstructure CoinConfiguration where\n  leftEights : Nat    -- 8g coins in left pan\n  leftSevens : Nat    -- 7g coins in left pan\n  rightEights : Nat   -- 8g coins in right pan\n  rightSevens : Nat   -- 7g coins in right pan\n\ndef panWeight (eights sevens : Nat) : Nat :=\n  8 * eights + 7 * sevens\n\ndef isValidConfiguration (conf : CoinConfiguration) : Prop :=\n  conf.leftEights + conf.leftSevens = 144 \u2227\n  conf.rightEights + conf.rightSevens = 144 \u2227\n  conf.leftEights + conf.leftSevens + conf.rightEights + conf.rightSevens = 288\n\ndef isBalanced (conf : CoinConfiguration) : Prop :=\n  panWeight conf.leftEights conf.leftSevens = \n  panWeight conf.rightEights conf.rightSevens\n\ndef swapGroups (conf : CoinConfiguration) (countEights countSevens : Nat) : CoinConfiguration :=\n  { leftEights := conf.leftEights - countEights + countEights\n    leftSevens := conf.leftSevens - countSevens + countSevens\n    rightEights := conf.rightEights + countEights - countEights\n    rightSevens := conf.rightSevens + countSevens - countSevens }\n\ntheorem coin_balance_problem (initial : CoinConfiguration) \n    (h\u2081 : isValidConfiguration initial) \n    (h\u2082 : isBalanced initial) :\n  \u2203 (operations : List (Nat \u00d7 Nat)), \n    operations.length \u2264 11 \u2227 \n    let final := operations.foldl (fun conf op => swapGroups conf op.1 op.2) initial\n    isValidConfiguration final \u2227 \u00acisBalanced final :=\n  sorry", "formal_statement_pred": "import Mathlib\n\nstructure CoinPan where\n  coins7g : Nat\n  coins8g : Nat\n  valid : coins7g + coins8g = 144\n  nonneg : coins7g \u2265 0 \u2227 coins8g \u2265 0\nderiving Repr\n\nstructure CoinConfiguration (total8g : Fin 289) where\n  left : CoinPan\n  right : CoinPan\n  valid_total : left.coins8g + right.coins8g = total8g\n  valid_complement : left.coins7g + right.coins7g = 288 - total8g\nderiving Repr\n\nstructure SwapMove where\n  count : Nat\n  from_left : Bool\nderiving Repr\n\ndef panWeight (pan : CoinPan) : Nat :=\n  pan.coins7g * 7 + pan.coins8g * 8\n\ndef isBalanced (config : CoinConfiguration total8g) : Prop :=\n  panWeight config.left = panWeight config.right\n\ntheorem coins_unbalancing_possible\n  {total8g : Fin 289}\n  (config : CoinConfiguration total8g)\n  (h_init_balanced : isBalanced config)\n  (h_total8g_pos : total8g > 0) :\n  \u2203 (moves : List SwapMove),\n    moves.length \u2264 11 \u2227\n    \u00acisBalanced (moves.foldl (fun c m => sorry) config) :=\n  sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_49", "informal_problem": "8.4. At the Olympiad, 300 students from no fewer than 4 schools arrived. Prove that they can be divided into teams of 3 people each, so that in each team either all three students are from the same school, or all three are from different schools.", "formal_statement": "import Mathlib\n\n/-- Setup for the Olympiad problem with students and schools -/\nstructure OlympiadSetup where\n  numStudents : Nat\n  numSchools : Nat\n  students : Fin numStudents \u2192 Fin numSchools  -- maps each student to their school\n  exactly300 : numStudents = 300\n  atLeast4Schools : numSchools \u2265 4\n  schoolsNotEmpty : \u2200 s : Fin numSchools, \u2203 t : Fin numStudents, students t = s\n\n/-- A team of three students -/\nstructure Team (setup : OlympiadSetup) where\n  student1 : Fin setup.numStudents\n  student2 : Fin setup.numStudents\n  student3 : Fin setup.numStudents\n  distinct : student1 \u2260 student2 \u2227 student2 \u2260 student3 \u2227 student1 \u2260 student3\n\n/-- All students in the team are from the same school -/\ndef allSameSchool (setup : OlympiadSetup) (team : Team setup) : Prop :=\n  setup.students team.student1 = setup.students team.student2 \u2227\n  setup.students team.student2 = setup.students team.student3\n\n/-- All students in the team are from different schools -/\ndef allDifferentSchools (setup : OlympiadSetup) (team : Team setup) : Prop :=\n  setup.students team.student1 \u2260 setup.students team.student2 \u2227\n  setup.students team.student2 \u2260 setup.students team.student3 \u2227\n  setup.students team.student1 \u2260 setup.students team.student3\n\n/-- A team is valid if either all students are from the same school\n    or all students are from different schools -/\ndef isValidTeam (setup : OlympiadSetup) (team : Team setup) : Prop :=\n  allSameSchool setup team \u2228 allDifferentSchools setup team\n\ntheorem olympiad_team_division (setup : OlympiadSetup) :\n  \u2203 (teams : Fin 100 \u2192 Team setup),\n    (\u2200 t, isValidTeam setup (teams t)) \u2227 \n    (\u2200 s : Fin setup.numStudents, \u2203! t : Fin 100, \n      s = (teams t).student1 \u2228 s = (teams t).student2 \u2228 s = (teams t).student3) :=\n  sorry", "formal_statement_pred": "import Mathlib\n\n\nstructure OlympiadSetup where\n  numSchools : Nat\n  atLeast4Schools : numSchools \u2265 4\n  students : Fin 300 \u2192 Fin numSchools\n\n\ndef Team := Fin 3 \u2192 Fin 300\n\n\ndef hasDistinctStudents (t : Team) : Prop :=\n  \u2200 i j : Fin 3, i \u2260 j \u2192 t i \u2260 t j\n\n\ndef isValidTeam (setup : OlympiadSetup) (t : Team) : Prop :=\n  hasDistinctStudents t \u2227\n  ((\u2200 i j : Fin 3, setup.students (t i) = setup.students (t j)) \u2228\n   (\u2200 i j : Fin 3, i \u2260 j \u2192 setup.students (t i) \u2260 setup.students (t j)))\n\n\nstructure TeamPartition (setup : OlympiadSetup) where\n  assignment : Fin 100 \u2192 Team\n  covers_all : \u2200 s : Fin 300, \u2203 i : Fin 100, \u2203 j : Fin 3, assignment i j = s\n  no_overlap : \u2200 i\u2081 i\u2082 : Fin 100, \u2200 j\u2081 j\u2082 : Fin 3,\n    (i\u2081 \u2260 i\u2082 \u2228 j\u2081 \u2260 j\u2082) \u2192 assignment i\u2081 j\u2081 \u2260 assignment i\u2082 j\u2082\n\ntheorem olympiad_partition_exists (setup : OlympiadSetup) :\n  \u2203 partition : TeamPartition setup,\n    \u2200 i : Fin 100, isValidTeam setup (partition.assignment i) :=\n  sorry", "compiled": true, "aligned": true}
{"id": "CombStruct4Lean_50", "informal_problem": "Problem 5. At the court, 50 musketeers serve. Every day they split into pairs and conduct training duels. Is it true that after 24 days, there will be three musketeers who have not participated in training duels with each other?", "formal_statement": "import Mathlib\n\nstructure DuelSchedule where\n  edges : Fin 50 \u2192 Fin 50 \u2192 Option (Fin 24)  -- None means no duel scheduled\n  valid : \u2200 i j, i \u2260 j \u2192 edges i j = edges j i  -- symmetry\n  no_self_duels : \u2200 i, edges i i = none\n  one_per_day : \u2200 d i, (\u2203 j, edges i j = some d) \u2192 \n                       (\u2200 k \u2260 j, edges i k \u2260 some d)\n  daily_pairs : \u2200 i d, \u2203 j, edges i j = some d \u2228 edges j i = some d  -- everyone duels each day\n\ntheorem musketeer_pairs_ramsey :\n  \u2200 (schedule : DuelSchedule),\n  \u2203 (m1 m2 m3 : Fin 50), \n    m1 \u2260 m2 \u2227 m2 \u2260 m3 \u2227 m1 \u2260 m3 \u2227\n    schedule.edges m1 m2 = none \u2227\n    schedule.edges m2 m3 = none \u2227\n    schedule.edges m1 m3 = none :=\n  sorry", "formal_statement_pred": "import Mathlib\n\nstructure DailyPairings where\n  pairs : Finset (Fin 50 \u00d7 Fin 50)\n  no_self_pairs : \u2200 p \u2208 pairs, p.1 \u2260 p.2\n  each_once : \u2200 a : Fin 50, \u2203! b : Fin 50, (a, b) \u2208 pairs \u2228 (b, a) \u2208 pairs\n  symmetric : \u2200 a b : Fin 50, (a, b) \u2208 pairs \u2194 (b, a) \u2208 pairs\n\nstructure TournamentSchedule where\n  schedule : Fin 24 \u2192 DailyPairings\n\ndef have_dueled (t : TournamentSchedule) (a b : Fin 50) : Prop :=\n  \u2203 d : Fin 24, ((a, b) \u2208 (t.schedule d).pairs \u2228 (b, a) \u2208 (t.schedule d).pairs)\n\ntheorem musketeer_triangle_exists (t : TournamentSchedule) :\n  \u2203 (a b c : Fin 50), a \u2260 b \u2227 b \u2260 c \u2227 a \u2260 c \u2227\n    \u00ac(have_dueled t a b) \u2227\n    \u00ac(have_dueled t b c) \u2227\n    \u00ac(have_dueled t a c) :=\n  sorry", "compiled": true, "aligned": true}
{"id": "CombStruct4Lean_52", "informal_problem": "2. Each of the 8 squirrels threw a pine cone at some other squirrel, independently of the others. Prove that there will always be a group of three squirrels who did not throw a pine cone at a squirrel from this group.", "formal_statement": "import Mathlib\n\nabbrev Squirrel := Fin 8\n\nstructure PineConeThrows where\n  throws : Squirrel \u2192 Squirrel\n  no_self_throws : \u2200 i, throws i \u2260 i\n\n/-- Returns true if squirrel i throws a pine cone at any squirrel in the given set -/\ndef throws_into_set (throws : PineConeThrows) (i : Squirrel) (s : Finset Squirrel) : Prop :=\n  throws.throws i \u2208 s\n\ntheorem pine_cone_triangle (throws : PineConeThrows) :\n  \u2203 s : Finset Squirrel, s.card = 3 \u2227 \n    \u2200 i \u2208 s, \u00acthrows_into_set throws i s :=\n  sorry", "formal_statement_pred": "import Mathlib\n\nabbrev Squirrel := Fin 8\n\nstructure PineConeThrows where\n  throws : Squirrel \u2192 Squirrel\n  no_self_throws : \u2200 i, throws i \u2260 i\n\n\ndef isSafeGroup (throws : PineConeThrows) (group : Finset Squirrel) : Prop :=\n  group.card = 3 \u2227\n  \u2200 i \u2208 group, \u2200 j \u2208 group, throws.throws i \u2260 j\n\n\ntheorem pine_cone_safe_group_exists (throws : PineConeThrows) :\n  \u2203 group : Finset Squirrel, isSafeGroup throws group :=\n  sorry", "compiled": true, "aligned": true}
{"id": "CombStruct4Lean_56", "informal_problem": "7. Given a circle of length 90. Is it possible to mark 10 points on it so that among the arcs with endpoints at these points there are arcs of all integer lengths from 1 to 89? (K. Knop)", "formal_statement": "import Mathlib\n\n-- Points are represented as natural numbers from 0 to 89\nstructure CircleMarking where\n  points : Finset \u2115\n  -- Each point is in [0,89]\n  points_in_range : \u2200 p \u2208 points, p < 90\n  -- There are exactly 10 points\n  card_eq : points.card = 10\n\n/-- Compute arc length between two points on a circle of length 90.\n    Points are represented as natural numbers from 0 to 89. -/\ndef arcLength (x y : \u2115) : \u2115 :=\n  let diff := Int.natAbs (x - y)\n  Nat.min diff (90 - diff)\n\n/-- Predicate indicating that a marking contains arcs of all lengths from 1 to 89 -/\ndef hasAllLengths (m : CircleMarking) : Prop :=\n  \u2200 k : \u2115, 1 \u2264 k \u2227 k \u2264 89 \u2192\n    \u2203 x \u2208 m.points, \u2203 y \u2208 m.points, x \u2260 y \u2227 arcLength x y = k\n\ntheorem circle_marking_possible : \n  \u2203 (m : CircleMarking), hasAllLengths m :=\n  sorry", "formal_statement_pred": "import Mathlib\n\n\nstructure CircleMarking where\n  points : Fin 10 \u2192 Fin 90\n  distinct : \u2200 i j : Fin 10, i \u2260 j \u2192 points i \u2260 points j\n\n\ndef clockwiseDistance (a b : Fin 90) : Fin 90 :=\n  (b - a : Int).mod 90\n\n\ndef arcLength (a b : Fin 90) : \u2115 :=\n  let d := clockwiseDistance a b\n  min d (90 - d)\n\ntheorem exists_valid_circle_marking :\n  \u2203 (marking : CircleMarking),\n    \u2200 l : \u2115, 1 \u2264 l \u2227 l < 90 \u2192\n      \u2203 (i j : Fin 10),\n        i \u2260 j \u2227\n        arcLength (marking.points i) (marking.points j) = l :=\n  sorry", "compiled": true, "aligned": true}
{"id": "CombStruct4Lean_58", "informal_problem": "5. Can a rectangle $1000 \\times 2016$ be cut into rectangles $1 \\times 2015$ and three-cell \"corners\" so that both types of figures are present? (E. Bakayev)", "formal_statement": "import Mathlib\n\nstructure Corner where\n  -- A three-cell corner is a shape made of three unit squares in an L shape\n  pos : \u2115 \u00d7 \u2115  -- position of the top-left cell\n\nstructure RectangleTiling where\n  width : \u2115 \n  height : \u2115\n  -- List of positions of 1\u00d72015 rectangles (top-left corner position)\n  strips : List (\u2115 \u00d7 \u2115)\n  -- List of corner positions (top-left position)\n  corners : List Corner\n  -- The tiling must be valid (no overlaps and covers the whole rectangle)\n  valid : Bool\n\ntheorem rectangle_tiling_existence : \n  \u2203 (t : RectangleTiling), \n    t.width = 1000 \u2227 \n    t.height = 2016 \u2227 \n    t.valid = true \u2227 \n    t.strips.length > 0 \u2227 \n    t.corners.length > 0 :=\n  sorry", "formal_statement_pred": "import Mathlib\n\nstructure Corner where\n\n  pos : \u2115 \u00d7 \u2115\n  orientation : Fin 4\n\nstructure Rectangle1x2015 where\n\n  pos : \u2115 \u00d7 \u2115\n  isHorizontal : Bool\n\nstructure Tiling where\n  corners : List Corner\n  rectangles : List Rectangle1x2015\n\n  isValid : Bool\n  nonEmpty : corners.length > 0 \u2227 rectangles.length > 0\n\ntheorem rectangle_tiling_existence :\n  \u00ac\u2203 (t : Tiling), t.isValid :=\n  sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_59", "informal_problem": "5. On a circle, 2013 points are marked and each is connected to its two neighbors. Also, the center of the circle is marked and connected to all other marked points. Is it possible to paint 1007 of the marked points red and the other 1007 blue so that each red point is connected to an odd number of blue points, and each blue point is connected to an even number of blue points? (I. Rubanov)", "formal_statement": "import Mathlib\n\nstructure CircleGraph where\n  n : Nat                      -- number of points on circle\n  center : Fin (n + 1)        -- center point has index n\n  h_center : center = \u27e8n, by simp\u27e9  -- center is the last point\n\ndef Coloring (g : CircleGraph) := Fin (g.n + 1) \u2192 Bool\n\ndef isNeighbor (g : CircleGraph) (i j : Fin (g.n + 1)) : Bool :=\n  if i = g.center \u2228 j = g.center then\n    i \u2260 j  -- center connected to all other points\n  else if i.val < g.n \u2227 j.val < g.n then\n    -- points on circle connected to adjacent points\n    (i.val + 1) % g.n = j.val \u2228 (j.val + 1) % g.n = i.val\n  else\n    false\n\ndef blueNeighborCount (g : CircleGraph) (c : Coloring g) (v : Fin (g.n + 1)) : Nat :=\n  (Finset.filter (fun i => isNeighbor g v i \u2227 !c i) Finset.univ).card\n\ntheorem circle_coloring_impossible (g : CircleGraph) (h1 : g.n = 2013) : \n  \u00ac\u2203 (c : Coloring g),\n    -- Equal number of red and blue points\n    (Finset.filter (fun i => c i) Finset.univ).card = 1007 \u2227\n    (Finset.filter (fun i => !c i) Finset.univ).card = 1007 \u2227\n    -- Red points connected to odd number of blue points\n    (\u2200 v, c v \u2192 Odd (blueNeighborCount g c v)) \u2227\n    -- Blue points connected to even number of blue points\n    (\u2200 v, !c v \u2192 Even (blueNeighborCount g c v)) :=\n  sorry", "formal_statement_pred": "import Mathlib\n\n\ndef Coloring (n : Nat) := Fin (n + 1) \u2192 Bool\n\n\ndef blueNeighborCount (n : Nat) (c : Coloring n) (v : Fin (n + 1)) : Nat :=\n  if v = 0 then\n\n    Fintype.card { w : Fin (n + 1) | w \u2260 0 \u2227 \u00acc w }\n  else\n\n    let prev := \u27e8(v.val - 1 + n) % n + 1, sorry\u27e9\n    let next := \u27e8(v.val % n) + 1, sorry\u27e9\n    Fintype.card { w : Fin (n + 1) | (w = 0 \u2228 w = prev \u2228 w = next) \u2227 \u00acc w }\n\ntheorem circle_coloring_impossible (n : Nat) (c : Coloring n)\n  (h1 : n = 2013)\n  (h2 : Fintype.card { v : Fin (n + 1) | c v } = 1007)\n  (h3 : \u2200 v, c v \u2192 Odd (blueNeighborCount n c v))\n  (h4 : \u2200 v, \u00acc v \u2192 Even (blueNeighborCount n c v))\n  : False :=\n  sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_60", "informal_problem": "3. In a football tournament where each team played against each other once, 16 teams participated. Three points were awarded for a win, one point for a draw, and zero points for a loss. After the tournament, it was found that each team won at least a third of their matches and lost at least a third of their matches. Prove that some two teams scored the same number of points.", "formal_statement": "import Mathlib\n\nstructure TournamentResult where\n  numTeams : Nat\n  scores : Fin numTeams \u2192 Nat\n  wins : Fin numTeams \u2192 Nat\n  draws : Fin numTeams \u2192 Nat\n  losses : Fin numTeams \u2192 Nat\n  -- Each match results in exactly one outcome\n  matches_sum : \u2200 t, wins t + draws t + losses t = numTeams - 1\n  -- At least one third of matches are wins\n  min_wins : \u2200 t, 3 * wins t \u2265 numTeams - 1\n  -- At least one third of matches are losses\n  min_losses : \u2200 t, 3 * losses t \u2265 numTeams - 1\n  -- Score calculation (3 points for win, 1 for draw)\n  score_calc : \u2200 t, scores t = 3 * wins t + draws t\n\ntheorem tournament_equal_scores : \n  \u2200 (t : TournamentResult), t.numTeams = 16 \u2192 \n  \u2203 i j : Fin t.numTeams, i \u2260 j \u2227 t.scores i = t.scores j :=\n  sorry", "formal_statement_pred": "import Mathlib\n\nstructure TournamentResult where\n  teams : Nat\n  scores : Fin teams \u2192 Nat\n  wins : Fin teams \u2192 Nat\n  draws : Fin teams \u2192 Nat\n  losses : Fin teams \u2192 Nat\n  score_valid : \u2200 t, scores t = 3 * wins t + draws t\n  match_sum : \u2200 t, wins t + draws t + losses t = teams - 1\n  win_bound : \u2200 t, wins t * 3 \u2265 (teams - 1)\n  loss_bound : \u2200 t, losses t * 3 \u2265 (teams - 1)\n\ntheorem football_tournament_equal_scores :\n  \u2200 (t : TournamentResult), t.teams = 16 \u2192\n  \u2203 i j : Fin t.teams, i \u2260 j \u2227 t.scores i = t.scores j :=\n  sorry", "compiled": true, "aligned": true}
{"id": "CombStruct4Lean_62", "informal_problem": "8. In the club, there are 42 people, any two of whom have at least ten common friends among the club members. Prove that there will be two people who have at least twelve common friends among the club members. (M. Antipov)", "formal_statement": "import Mathlib\n\nstructure Club where\n  members : Finset Nat\n  size_eq : members.card = 42\n  friendship : Nat \u2192 Nat \u2192 Bool\n  friendship_symmetric : \u2200 x y, friendship x y = friendship y x\n  common_friends : Nat \u2192 Nat \u2192 Nat\n  common_friends_def : \u2200 x y, common_friends x y = \n    (members.filter (fun z \u21a6 friendship x z \u2227 friendship y z)).card\n  min_common_friends : \u2200 x y, x \u2208 members \u2192 y \u2208 members \u2192 x \u2260 y \u2192 \n    common_friends x y \u2265 10\n\ntheorem exists_twelve_common_friends (c : Club) : \n  \u2203 x y, x \u2208 c.members \u2227 y \u2208 c.members \u2227 x \u2260 y \u2227 c.common_friends x y \u2265 12 :=\n  sorry", "formal_statement_pred": "import Mathlib\n\n\nstructure FriendshipGraph where\n  n : Nat\n  friends : Fin n \u2192 Fin n \u2192 Bool\n  symm : \u2200 i j, friends i j = friends j i\n  not_self : \u2200 i, friends i i = false\n\n\ndef commonFriends (g : FriendshipGraph) (i j : Fin g.n) : Nat :=\n  (Finset.filter (fun k => g.friends i k \u2227 g.friends j k)\n    (Finset.univ : Finset (Fin g.n))).card\n\ntheorem friendship_problem (g : FriendshipGraph) (h1 : g.n = 42)\n  (h2 : \u2200 i j, i \u2260 j \u2192 commonFriends g i j \u2265 10) :\n  \u2203 i j, i \u2260 j \u2227 commonFriends g i j \u2265 12 :=\n  sorry", "compiled": true, "aligned": true}
{"id": "CombStruct4Lean_63", "informal_problem": "9. There are 70 switches and 15 lamps. Each lamp is connected to 35 switches. No two switches are connected to the same set of lamps. Pressing a switch changes the state of all the lamps it is connected to (turning on the off ones and vice versa). Initially, all lamps are off. Prove that it is possible to press some 19 switches in such a way that at least eight lamps are turned on. (S. Berlov)", "formal_statement": "import Mathlib\n\nstructure SwitchSystem where\n  switches : Fin 70 \u2192 Finset (Fin 15)  -- Each switch maps to the set of lamps it controls\n  switch_size : \u2200 s, (switches s).card = 35  -- Each switch controls 35 lamps\n  different_sets : \u2200 s\u2081 s\u2082, s\u2081 \u2260 s\u2082 \u2192 switches s\u2081 \u2260 switches s\u2082  -- No two switches control same set\n\n/-- Given a set of switches that are pressed, compute which lamps are on -/\ndef lampsOn (sys : SwitchSystem) (pressed : Finset (Fin 70)) (l : Fin 15) : Bool :=\n  Odd (Finset.filter (fun s => l \u2208 sys.switches s) pressed).card\n\ntheorem switch_problem (sys : SwitchSystem) :\n  \u2203 pressed : Finset (Fin 70),\n    (pressed.card = 19) \u2227\n    ((Finset.filter (fun l => lampsOn sys pressed l) (Finset.univ : Finset (Fin 15))).card \u2265 8) :=\n  sorry", "formal_statement_pred": "import Mathlib\n\n\ndef countTrueValues {n : Nat} (f : Fin n \u2192 Bool) : Nat :=\n  Finset.card (Finset.filter (fun i => f i) Finset.univ)\n\n\nstructure SwitchSystem where\n  connections : Fin 70 \u2192 Fin 15 \u2192 Bool\n  distinctRows : \u2200 i j, i \u2260 j \u2192 (\u2203 l, connections i l \u2260 connections j l)\n  properCounts : \u2200 i, countTrueValues (connections i) = 35\n\n\nstructure LampState where\n  state : Fin 15 \u2192 Bool\n\n\ndef applySwitch (switches : Finset (Fin 70)) (sys : SwitchSystem) : LampState where\n  state := fun l =>\n\n    Finset.card (Finset.filter (fun s => sys.connections s l) switches) % 2 = 1\n\ntheorem berlov_switches_problem :\n  \u2203 (sys : SwitchSystem),\n    \u2203 (switches : Finset (Fin 70)),\n      switches.card = 19 \u2227\n      countTrueValues ((applySwitch switches sys).state) \u2265 8 :=\n  sorry", "compiled": true, "aligned": true}
{"id": "CombStruct4Lean_64", "informal_problem": "5. Igor wants to cut out $1 \\times 6$ grid rectangles from a grid square of size $11 \\times 1117$. Is it possible to mark one cell in the square so that it will definitely remain uncut, no matter how hard Igor tries?", "formal_statement": "import Mathlib\n\nstructure Rectangle where\n  x : Nat\n  y : Nat\n  width : Nat\n  height : Nat\n  valid : width = 1 \u2227 height = 6 \u2228 width = 6 \u2227 height = 1\n\nstructure GridCovering (w h : Nat) where\n  rectangles : List Rectangle\n  marked : Fin w \u00d7 Fin h\n\ntheorem exists_uncovered_cell : \n  \u2203 (pos : Fin 11 \u00d7 Fin 1117), \n    \u2200 (covering : List Rectangle),\n      \u2200 (r : Rectangle), r \u2208 covering \u2192\n        \u00ac(Nat.le r.x pos.1.val \u2227 pos.1.val < r.x + r.width \u2227\n          Nat.le r.y pos.2.val \u2227 pos.2.val < r.y + r.height) :=\n  sorry", "formal_statement_pred": "import Mathlib\n\nstructure Rectangle where\n  x : Nat\n  y : Nat\n  width : Nat := 1\n  height : Nat := 6\n\ndef covers (r : Rectangle) (x : Fin 11) (y : Fin 1117) : Prop :=\n  r.x \u2264 x.val \u2227 x.val < r.x + r.width \u2227\n  r.y \u2264 y.val \u2227 y.val < r.y + r.height\n\ndef is_valid_placement (r : Rectangle) : Prop :=\n  r.x + r.width \u2264 11 \u2227 r.y + r.height \u2264 1117\n\ntheorem exists_uncoverable_cell :\n  \u2203 (x : Fin 11) (y : Fin 1117),\n    \u2200 (rectangles : List Rectangle),\n    (\u2200 r \u2208 rectangles, is_valid_placement r) \u2192\n    \u00ac(\u2203 r \u2208 rectangles, covers r x y) :=\n  sorry", "compiled": true, "aligned": true}
{"id": "CombStruct4Lean_65", "informal_problem": "5. A six-digit number $N$ coincides with each of the five six-digit numbers $A, B, C, D, E$ in three digits. Prove that among the numbers $A, B, C, D, E$ there will be two that coincide in at least two digits.", "formal_statement": "import Mathlib\n\n-- Represent a six-digit number as a function from Fin 6 to Fin 10\ndef SixDigitNum := Fin 6 \u2192 Fin 10\n\n-- Count matching digits between two numbers\ndef matchingDigits (n1 n2 : SixDigitNum) : Nat :=\n  (List.range 6).filter (fun i => n1 i = n2 i) |>.length\n\n-- Definition for when two numbers match in k positions\ndef matchesInK (n1 n2 : SixDigitNum) (k : Nat) : Prop :=\n  matchingDigits n1 n2 = k\n\ntheorem digit_matching_problem\n  (N A B C D E : SixDigitNum)\n  (hA : matchesInK N A 3)\n  (hB : matchesInK N B 3)\n  (hC : matchesInK N C 3)\n  (hD : matchesInK N D 3)\n  (hE : matchesInK N E 3) :\n  \u2203 (x y : SixDigitNum), x \u2208 [A, B, C, D, E] \u2227 y \u2208 [A, B, C, D, E] \u2227 x \u2260 y \u2227\n    matchingDigits x y \u2265 2 :=\n  sorry", "formal_statement_pred": "import Mathlib\n\nstructure SixDigitNumber where\n  digits : Fin 6 \u2192 Fin 10\n  first_nonzero : digits 0 \u2260 0\nderiving DecidableEq\n\ndef matchingPositions (n1 n2 : SixDigitNumber) : Finset (Fin 6) :=\n  Finset.filter (fun i => n1.digits i = n2.digits i) Finset.univ\n\ndef matchingDigits (n1 n2 : SixDigitNumber) : Nat :=\n  (matchingPositions n1 n2).card\n\ndef numberSet (A B C D E : SixDigitNumber) : Finset SixDigitNumber :=\n  {A, B, C, D, E}\n\ntheorem matching_digits_property\n  (N A B C D E : SixDigitNumber)\n  (hA : matchingDigits N A = 3)\n  (hB : matchingDigits N B = 3)\n  (hC : matchingDigits N C = 3)\n  (hD : matchingDigits N D = 3)\n  (hE : matchingDigits N E = 3) :\n  \u2203 x y, x \u2208 numberSet A B C D E \u2227\n         y \u2208 numberSet A B C D E \u2227\n         x \u2260 y \u2227\n         matchingDigits x y \u2265 2 :=\n  sorry", "compiled": true, "aligned": true}
{"id": "CombStruct4Lean_67", "informal_problem": "2. From a chessboard of size $13 \\times 13$, two opposite corner cells have been cut out. On the remaining part of the board, several cells have been marked. Prove that it is possible to place chess kings on the marked cells such that the total number of kings does not exceed 47, and they attack all the empty marked cells. Recall that a chess king attacks all cells adjacent to it vertically, horizontally, and diagonally. (S. Berlov)", "formal_statement": "import Mathlib\n\n-- Valid position on the modified chessboard (corners removed)\nstructure ValidPos where\n  row : Fin 13\n  col : Fin 13\n  not_corner : \u00ac((row = 0 \u2227 col = 0) \u2228 (row = 12 \u2227 col = 12))\n\n-- The chessboard with marked cells\nstructure ChessBoard where\n  marked : ValidPos \u2192 Bool\n\n-- Helper function to check if a king at position i,j attacks position x,y\ndef attacks (i j x y : Fin 13) : Bool :=\n  let di := if i \u2265 x then i - x else x - i\n  let dj := if j \u2265 y then j - y else y - j\n  di \u2264 1 \u2227 dj \u2264 1 \u2227 \u00ac(i = x \u2227 j = y)\n\n-- Predicate to check if a set of kings attacks all marked cells\ndef coversAllMarked (board : ChessBoard) (kings : Finset ValidPos) : Prop :=\n  \u2200 pos : ValidPos, board.marked pos \u2192 \n    pos \u2208 kings \u2228 \n    \u2203 k \u2208 kings, attacks k.row k.col pos.row pos.col\n\n-- Predicate to ensure kings are only placed on marked cells\ndef kingsOnMarked (board : ChessBoard) (kings : Finset ValidPos) : Prop :=\n  \u2200 k \u2208 kings, board.marked k\n\ntheorem kings_placement_exists (board : ChessBoard) :\n  \u2203 (kings : Finset ValidPos),\n    kings.card \u2264 47 \u2227\n    kingsOnMarked board kings \u2227\n    coversAllMarked board kings :=\n  sorry", "formal_statement_pred": "import Mathlib\n\ninductive CellState where\n  | empty : CellState\n  | marked : CellState\n  | removed : CellState\n  deriving Repr, DecidableEq\n\nstructure Position where\n  row : Fin 13\n  col : Fin 13\n  deriving Repr, DecidableEq\n\nstructure ChessBoard where\n  cells : Fin 13 \u2192 Fin 13 \u2192 CellState\n  removed_corners :\n    (cells 0 0 = CellState.removed \u2227 cells 12 12 = CellState.removed) \u2228\n    (cells 0 12 = CellState.removed \u2227 cells 12 0 = CellState.removed)\n\ndef attacks (p\u2081 p\u2082 : Position) : Prop :=\n  max p\u2081.row p\u2082.row - min p\u2081.row p\u2082.row \u2264 1 \u2227\n  max p\u2081.col p\u2082.col - min p\u2081.col p\u2082.col \u2264 1\n\ndef isValidKingPosition (board : ChessBoard) (pos : Position) : Prop :=\n  board.cells pos.row pos.col = CellState.marked\n\ndef covers (board : ChessBoard) (kings : Finset Position) : Prop :=\n  \u2200 i j, board.cells i j = CellState.marked \u2192\n    \u2203 k \u2208 kings, attacks \u27e8i, j\u27e9 k \u2228 \u27e8i, j\u27e9 = k\n\ntheorem chess_kings_placement (board : ChessBoard) :\n  \u2203 (kings : Finset Position),\n    kings.card \u2264 47 \u2227\n    (\u2200 k \u2208 kings, isValidKingPosition board k) \u2227\n    covers board kings :=\n  sorry", "compiled": true, "aligned": true}
{"id": "CombStruct4Lean_68", "informal_problem": "2. On the way to the museum, a group of kindergarteners lined up in pairs, with the number of pairs of two boys being three times the number of pairs of two girls. On the way back, the same group lined up such that the number of pairs of two boys was four times the number of pairs of two girls. Prove that the same group can be lined up so that the number of pairs of two boys is seven times the number of pairs of two girls. (I. Bogdanov)", "formal_statement": "import Mathlib\n\nstructure KindergartenGroup where\n  boys : Nat\n  girls : Nat\n  \n/-- Number of possible pairs of two children of the same gender -/\ndef samePairs (n : Nat) : Nat := n * (n - 1) / 2\n\n/-- Given a group of children, returns the number of boy-boy pairs -/\ndef boyPairs (g : KindergartenGroup) : Nat := samePairs g.boys\n\n/-- Given a group of children, returns the number of girl-girl pairs -/\ndef girlPairs (g : KindergartenGroup) : Nat := samePairs g.girls\n\ntheorem kindergarten_pairs_existence (g : KindergartenGroup)\n  (h1 : boyPairs g = 3 * girlPairs g)  -- first arrangement\n  (h2 : boyPairs g = 4 * girlPairs g)  -- second arrangement\n  : boyPairs g = 7 * girlPairs g :=    -- desired arrangement\n  sorry", "formal_statement_pred": "import Mathlib\n\nstructure KindergartenGroup where\n  boys : Nat\n  girls : Nat\n\n\ndef choose_two (n : Nat) : Nat :=\n  if n < 2 then 0 else n * (n - 1) / 2\n\n\ndef boy_pairs (g : KindergartenGroup) : Nat :=\n  choose_two g.boys\n\n\ndef girl_pairs (g : KindergartenGroup) : Nat :=\n  choose_two g.girls\n\ntheorem kindergarten_pairs_exist (g : KindergartenGroup)\n  (h1 : boy_pairs g = 3 * girl_pairs g)\n  (h2 : boy_pairs g = 4 * girl_pairs g)\n  : boy_pairs g = 7 * girl_pairs g :=\n  sorry", "compiled": true, "aligned": true}
{"id": "CombStruct4Lean_69", "informal_problem": "2. In the country of Euleria, there are 101 cities. Every two cities are connected by a two-way non-stop flight of one of 99 airlines. It is known that from each city, flights of all 99 companies depart. We will call a triangle three cities that are pairwise connected by flights of the same company. Prove that in Euleria there is no more than one triangle. (I. Bogdanov, D. Karpov)", "formal_statement": "import Mathlib\n\nstructure FlightNetwork where\n  -- Number of cities (101)\n  n : Nat\n  -- Number of airlines (99)\n  k : Nat\n  -- Flight assignment: given two cities and an airline, returns whether that airline connects those cities\n  flights : Fin n \u2192 Fin n \u2192 Fin k \u2192 Bool\n  -- Every two cities are connected by exactly one airline\n  unique_connection : \u2200 (i j : Fin n), i \u2260 j \u2192 \u2203! (a : Fin k), flights i j a\n  -- Flights are bidirectional\n  symmetric : \u2200 (i j : Fin n) (a : Fin k), flights i j a = flights j i a\n  -- From each city, flights of all companies depart\n  all_airlines : \u2200 (i : Fin n) (a : Fin k), \u2203 (j : Fin n), flights i j a\n\n-- A triangle is three cities connected by the same airline\ndef isTriangle (net : FlightNetwork) (i j l : Fin net.n) (a : Fin net.k) : Prop :=\n  i \u2260 j \u2227 j \u2260 l \u2227 i \u2260 l \u2227\n  net.flights i j a \u2227 net.flights j l a \u2227 net.flights i l a\n\ntheorem euleria_unique_triangle\n  (net : FlightNetwork)\n  (h1 : net.n = 101)\n  (h2 : net.k = 99) :\n  \u2200 (t1 t2 : Fin net.n \u00d7 Fin net.n \u00d7 Fin net.n \u00d7 Fin net.k),\n    isTriangle net t1.1 t1.2.1 t1.2.2.1 t1.2.2.2 \u2192\n    isTriangle net t2.1 t2.2.1 t2.2.2.1 t2.2.2.2 \u2192\n    (t1.1 = t2.1 \u2227 t1.2.1 = t2.2.1 \u2227 t1.2.2.1 = t2.2.2.1 \u2227 t1.2.2.2 = t2.2.2.2) :=\n  sorry", "formal_statement_pred": "import Mathlib\n\nstructure FlightNetwork where\n\n  numCities : Nat\n\n  numAirlines : Nat\n\n\n  flights : Fin numCities \u2192 Fin numCities \u2192 Fin numAirlines \u2192 Bool\n\n  unique_connection : \u2200 i j, i \u2260 j \u2192\n    \u2203! k, flights i j k = true\n\n  symmetric : \u2200 i j k, flights i j k = flights j i k\n\n  all_airlines : \u2200 i k, \u2203 j, flights i j k = true\n\n\ndef isTriangle (fn : FlightNetwork) (i j l : Fin fn.numCities) (k : Fin fn.numAirlines) : Prop :=\n  i \u2260 j \u2227 j \u2260 l \u2227 i \u2260 l \u2227\n  fn.flights i j k = true \u2227\n  fn.flights j l k = true \u2227\n  fn.flights i l k = true\n\ntheorem euleria_unique_triangle\n  (fn : FlightNetwork)\n  (h_cities : fn.numCities = 101)\n  (h_airlines : fn.numAirlines = 99) :\n  \u2200 t\u2081 t\u2082 : Fin fn.numCities \u00d7 Fin fn.numCities \u00d7 Fin fn.numCities \u00d7 Fin fn.numAirlines,\n    isTriangle fn t\u2081.1 t\u2081.2.1 t\u2081.2.2.1 t\u2081.2.2.2 \u2192\n    isTriangle fn t\u2082.1 t\u2082.2.1 t\u2082.2.2.1 t\u2082.2.2.2 \u2192\n    (t\u2081.1, t\u2081.2.1, t\u2081.2.2.1, t\u2081.2.2.2) = (t\u2082.1, t\u2082.2.1, t\u2082.2.2.1, t\u2082.2.2.2) :=\n  sorry", "compiled": true, "aligned": true}
{"id": "CombStruct4Lean_70", "informal_problem": "3. In a box, there are balls of 10 colors. It is known that you can take out 100 balls from the box so that the remaining balls of all 10 colors are equal. Prove that you can add 900 balls to the box so that the number of balls of all colors becomes equal.", "formal_statement": "import Mathlib\n\nstructure ColoredBalls where\n  initial : Fin 10 \u2192 Nat\n  removed : Fin 10 \u2192 Nat\n  removed_sum : (\u2211 i, removed i) = 100\n  removed_possible : \u2200 i, removed i \u2264 initial i\n  equal_after_removal : \u2200 i j : Fin 10,\n    initial i - removed i = initial j - removed j\n  remainingBalls : Fin 10 \u2192 Nat := fun i => initial i - removed i\n\ntheorem balls_equalization {b : ColoredBalls} :\n  \u2203 (added : Fin 10 \u2192 Nat),\n    (\u2211 i, added i = 900) \u2227\n    \u2203 (target : Nat), \u2200 i : Fin 10,\n      b.remainingBalls i + added i = target :=\n  sorry", "formal_statement_pred": "import Mathlib\n\nstructure ColoredBalls where\n  initial : Fin 10 \u2192 Nat\n  removed : Fin 10 \u2192 Nat\n\n  nonneg : \u2200 i, initial i \u2265 removed i\n\n  total_removed : (\u2211 i, removed i) = 100\n\n  equal_after_removal : \u2200 i j, initial i - removed i = initial j - removed j\n\ndef remaining (b : ColoredBalls) (i : Fin 10) : Nat :=\n  b.initial i - b.removed i\n\ntheorem balls_equalization (b : ColoredBalls) :\n  \u2203 (added : Fin 10 \u2192 Nat),\n    (\u2211 i, added i) = 900 \u2227\n    \u2200 i j, (remaining b i) + added i = (remaining b j) + added j :=\n  sorry", "compiled": true, "aligned": true}
{"id": "CombStruct4Lean_71", "informal_problem": "3. In each cell of a $2012 \\times 2012$ table, either a zero or a one is written, with the condition that in each column and each row there are both zeros and ones. Prove that in this table, there exist two rows and two columns such that at the ends of one of the diagonals of the rectangle they form, there are zeros, and on the other diagonal, there are ones. (I. Rubanov + jury)", "formal_statement": "import Mathlib\n\n-- Type representing a binary table with zeros and ones\nstructure BinaryTable (n : Nat) where\n  -- The table as a function from row and column indices to Bool\n  -- where true represents 1 and false represents 0\n  entries : Fin n \u2192 Fin n \u2192 Bool\n  -- Property ensuring each row has both zeros and ones\n  row_mixed : \u2200 i : Fin n, \u2203 j k : Fin n, \n    entries i j = false \u2227 entries i k = true\n  -- Property ensuring each column has both zeros and ones\n  col_mixed : \u2200 j : Fin n, \u2203 i k : Fin n, \n    entries i j = false \u2227 entries k j = true\n\ntheorem binary_table_diagonal_pattern (table : BinaryTable 2012) :\n  \u2203 (i\u2081 i\u2082 j\u2081 j\u2082 : Fin 2012),\n    i\u2081 \u2260 i\u2082 \u2227 j\u2081 \u2260 j\u2082 \u2227\n    ((table.entries i\u2081 j\u2081 = false \u2227 table.entries i\u2082 j\u2082 = false \u2227\n      table.entries i\u2081 j\u2082 = true \u2227 table.entries i\u2082 j\u2081 = true) \u2228\n     (table.entries i\u2081 j\u2081 = true \u2227 table.entries i\u2082 j\u2082 = true \u2227\n      table.entries i\u2081 j\u2082 = false \u2227 table.entries i\u2082 j\u2081 = false)) :=\n  sorry", "formal_statement_pred": "import Mathlib\n\n\nstructure BinaryTable (n : Nat) where\n  entries : Fin n \u2192 Fin n \u2192 Bool\n  has_both_in_rows : \u2200 i : Fin n, \u2203 j k : Fin n, entries i j = true \u2227 entries i k = false\n  has_both_in_cols : \u2200 j : Fin n, \u2203 i k : Fin n, entries i j = true \u2227 entries k j = false\n\n\nstructure TableRectangle (n : Nat) where\n  row1 : Fin n\n  row2 : Fin n\n  col1 : Fin n\n  col2 : Fin n\n  row_neq : row1 \u2260 row2\n  col_neq : col1 \u2260 col2\n\ntheorem binary_table_diagonal_pattern (table : BinaryTable 2012) :\n  \u2203 rect : TableRectangle 2012,\n    ((table.entries rect.row1 rect.col1 = false \u2227 table.entries rect.row2 rect.col2 = false) \u2227\n     (table.entries rect.row1 rect.col2 = true \u2227 table.entries rect.row2 rect.col1 = true)) \u2228\n    ((table.entries rect.row1 rect.col1 = true \u2227 table.entries rect.row2 rect.col2 = true) \u2227\n     (table.entries rect.row1 rect.col2 = false \u2227 table.entries rect.row2 rect.col1 = false)) :=\n  sorry", "compiled": true, "aligned": true}
{"id": "CombStruct4Lean_72", "informal_problem": "2. In each cell of a 100 x 100 table, one of the numbers 1 or -1 is written. Could it be that the sums of the numbers are negative in exactly 99 rows and positive in exactly 99 columns? (D. Nenashov)", "formal_statement": "import Mathlib\n\nstructure Table100 where\n  -- Each cell contains either 1 or -1\n  cells : Fin 100 \u2192 Fin 100 \u2192 Int\n  cell_values : \u2200 i j, cells i j = 1 \u2228 cells i j = -1\n\ndef row_sum (t : Table100) (i : Fin 100) : Int :=\n  (Finset.univ.sum fun j => t.cells i j)\n\ndef col_sum (t : Table100) (j : Fin 100) : Int :=\n  (Finset.univ.sum fun i => t.cells i j)\n\ndef negative_row_count (t : Table100) : Nat :=\n  (Finset.filter (fun i => row_sum t i < 0) Finset.univ).card\n\ndef positive_col_count (t : Table100) : Nat :=\n  (Finset.filter (fun j => col_sum t j > 0) Finset.univ).card\n\ntheorem table_possibility : \u2203 (t : Table100),\n    negative_row_count t = 99 \u2227 positive_col_count t = 99 :=\n  sorry", "formal_statement_pred": "import Mathlib\n\n\ndef Table := {f : Fin 100 \u2192 Fin 100 \u2192 Int // \u2200 i j, f i j = 1 \u2228 f i j = -1}\n\n\ndef rowSum (t : Table) (i : Fin 100) : Int :=\n  Finset.sum Finset.univ (fun j => t.val i j)\n\n\ndef colSum (t : Table) (j : Fin 100) : Int :=\n  Finset.sum Finset.univ (fun i => t.val i j)\n\n\ndef negativeRowCount (t : Table) : Nat :=\n  (Finset.univ.filter (fun i => rowSum t i < 0)).card\n\n\ndef positiveColCount (t : Table) : Nat :=\n  (Finset.univ.filter (fun j => colSum t j > 0)).card\n\ntheorem nenashov_table_impossible : \u00ac\u2203 (t : Table),\n  negativeRowCount t = 99 \u2227 positiveColCount t = 99 :=\n  sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_73", "informal_problem": "# Task 1.\n\nMaximum 10 points\n\nIn the city of N, there is a correctional facility where there are 100 guards for every 1000 prisoners. Deputy Ivanov, in his pre-election campaign, promised to reduce the number of guards by exactly half, redirecting the freed-up resources to retraining personnel and developing agriculture in the region. According to his proposed scheme, the quality of supervision would not suffer. That is, with 50 guards, each prisoner would still be watched by at least one of them (a guard).\n\nThe proposed scheme: guards are assigned numbers from 00 to 99, and their subordinates from 000 to 999. A prisoner is watched by those guards whose numbers can be obtained by deleting one digit from the prisoner's number (for example, a prisoner with the number 146 is watched by guards 14, 16, 46).\n\na) Will Deputy Ivanov be able to fulfill his promise? Justify your answer.\n\nb) If the answer to the previous question is \"Yes,\" is it possible to further reduce the number of guards without compromising the quality of supervision? If the answer to the question in part (a) is \"No,\" is it possible in principle to reduce the number of guards relative to the initial number without compromising the quality of supervision?", "formal_statement": "import Mathlib\n\n/-- Represents a three-digit number as three separate digits -/\nstructure ThreeDigits where\n  d1 : Fin 10\n  d2 : Fin 10\n  d3 : Fin 10\n\n/-- Represents a two-digit number as two separate digits -/\nstructure TwoDigits where\n  d1 : Fin 10\n  d2 : Fin 10\n\n/-- Convert a prisoner number (0-999) to its digit representation -/\ndef toThreeDigits (n : Fin 1000) : ThreeDigits :=\n  let d3 := n % 10\n  let n' := n / 10\n  let d2 := n' % 10\n  let d1 := n' / 10\n  \u27e8d1, d2, d3\u27e9\n\n/-- Convert a guard number (0-99) to its digit representation -/\ndef toTwoDigits (n : Fin 100) : TwoDigits :=\n  let d2 := n % 10\n  let d1 := n / 10\n  \u27e8d1, d2\u27e9\n\n/-- Determines if a guard watches a prisoner based on digit removal rules -/\ndef guardWatches (guard : Fin 100) (prisoner : Fin 1000) : Prop :=\n  let pDigits := toThreeDigits prisoner\n  let gDigits := toTwoDigits guard\n  -- Guard's number can be obtained by removing one digit from prisoner's number\n  (pDigits.d1 = gDigits.d1 \u2227 pDigits.d2 = gDigits.d2) \u2228  -- Remove d3\n  (pDigits.d1 = gDigits.d1 \u2227 pDigits.d3 = gDigits.d2) \u2228  -- Remove d2\n  (pDigits.d2 = gDigits.d1 \u2227 pDigits.d3 = gDigits.d2)    -- Remove d1\n\nstructure PrisonSystem where\n  guards : Finset (Fin 100)\n  isWatched (prisoner : Fin 1000) : Prop :=\n    \u2203 g \u2208 guards, guardWatches g prisoner\n\ntheorem prison_system_optimization :\n  -- There exists a valid guard assignment with exactly 50 guards\n  \u2203 (system : PrisonSystem), \n    system.guards.card = 50 \u2227 \n    (\u2200 (p : Fin 1000), system.isWatched p) :=\n  sorry", "formal_statement_pred": "import Mathlib\n\n\nstructure GuardNum where\n  tens : Fin 10\n  ones : Fin 10\nderiving Fintype\n\n\nstructure PrisonerNum where\n  hundreds : Fin 10\n  tens : Fin 10\n  ones : Fin 10\nderiving Fintype\n\n\ndef watches (g : GuardNum) (p : PrisonerNum) : Prop :=\n  (g.tens = p.hundreds \u2227 g.ones = p.tens) \u2228\n  (g.tens = p.hundreds \u2227 g.ones = p.ones) \u2228\n  (g.tens = p.tens \u2227 g.ones = p.ones)\n\n\ndef ValidSupervision (guards : Finset GuardNum) : Prop :=\n  \u2200 p : PrisonerNum, \u2203 g \u2208 guards, watches g p\n\ntheorem prison_supervision_optimal :\n\n  (\u2203 (guards : Finset GuardNum), guards.card = 50 \u2227 ValidSupervision guards) \u2227\n\n  (\u2200 (guards : Finset GuardNum), ValidSupervision guards \u2192 guards.card \u2265 50) :=\n  sorry", "compiled": true, "aligned": true}
{"id": "CombStruct4Lean_74", "informal_problem": "# Task 1.\n\nMaximum 10 points\n\nIn the Dark Dungeon, 1000 kind gnomes are held captive by 100 orcs. The chief orc has devised a scheme: orcs are assigned numbers from 00 to 99, and gnomes are assigned numbers from 000 to 999. An orc is assigned to watch a gnome if the orc's number can be obtained by deleting one digit from the gnome's number (for example, the orc with the number 14 watches the gnome with the number 146, as well as the orcs with the numbers 16 and 46).\n\nThe chief orc claims that only 50 orcs are needed to watch the gnomes, and that every gnome will still be watched by at least one orc. The rest of the orcs should be sent to conquer new cities.\n\na) Is the chief orc correct, and will 50 orcs be enough to ensure that no gnome goes unnoticed if they try to escape? Justify your answer.\n\nb) If the answer to the first question is \"Yes,\" is it possible to free more orcs? If the answer to the first question is \"No,\" is it possible to reduce the number of orcs watching the gnomes at all? Justify your answer.", "formal_statement": "import Mathlib\n\n-- Helper function to check if a number can be obtained by removing one digit from another\ndef canObtainByRemovingDigit (orc : Fin 100) (gnome : Fin 1000) : Prop :=\n  let orcNum := orc.val\n  let gnomeNum := gnome.val\n  -- Check if removing any digit from gnome can give orc\n  \u2203 (d : Nat), d < 10 \u2227 \u2203 (pos : Nat), pos < 3 \u2227\n    (gnomeNum = d * (10 ^ pos) + (gnomeNum / (10 ^ (pos + 1))) * (10 ^ (pos + 1)) +\n                (gnomeNum % (10 ^ pos)) \u2227\n     orcNum = (gnomeNum / (10 ^ (pos + 1))) * (10 ^ pos) + (gnomeNum % (10 ^ pos)))\n\nstructure DungeonSystem where\n  (orcs : Finset (Fin 100))\n  (gnomes : Finset (Fin 1000))\n  (isValid : Prop := \u2200 g \u2208 gnomes, \u2203 o \u2208 orcs, canObtainByRemovingDigit o g)\n\ntheorem min_orcs_required :\n  \u2200 (sys : DungeonSystem),\n    sys.gnomes = Finset.filter (fun n => n.val \u2265 0 \u2227 n.val \u2264 999) (Finset.univ) \u2192\n    sys.isValid \u2192\n    sys.orcs.card \u2265 67 :=\n  sorry", "formal_statement_pred": "import Mathlib\n\n\ndef getDigits (n : Fin 1000) : Fin 10 \u00d7 Fin 10 \u00d7 Fin 10 :=\n  (n / 100, (n / 10) % 10, n % 10)\n\n\ndef canWatch (orc : Fin 100) (gnome : Fin 1000) : Bool :=\n  let (d2, d1, d0) := getDigits gnome\n  let o1 := orc / 10\n  let o0 := orc % 10\n  (o1 = d1 && o0 = d0) ||\n  (o1 = d2 && o0 = d0) ||\n  (o1 = d2 && o0 = d1)\n\n\nstructure DungeonSetup where\n  watching_orcs : Finset (Fin 100)\n  every_gnome_watched : \u2200 g : Fin 1000, \u2203 o \u2208 watching_orcs, canWatch o g = true\n\n\ntheorem dungeon_minimal_setup :\n  (\u2203 (setup : DungeonSetup), setup.watching_orcs.card = 50) \u2227\n  (\u2200 (setup : DungeonSetup), setup.watching_orcs.card \u2265 50) :=\n  sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_77", "informal_problem": "8. (40 points) $B$ In the 8-A class, there are $n$ students ( $n \\geq 2$ ). For them, clubs are organized, each of which is attended by at least two students. Any two clubs that have at least two students in common differ in the number of participants. Prove that the number of clubs is no more than $(n-1)^{2}$.", "formal_statement": "import Mathlib\n\nstructure SchoolClubs (n : Nat) where\n  clubs : Finset (Finset (Fin n))\n  h_nonempty : clubs.Nonempty\n  h_min_size : \u2200 c \u2208 clubs, 2 \u2264 c.card\n  h_diff_size_of_common : \u2200 c\u2081 c\u2082, c\u2081 \u2208 clubs \u2192 c\u2082 \u2208 clubs \u2192 \n    2 \u2264 (c\u2081 \u2229 c\u2082).card \u2192 c\u2081.card \u2260 c\u2082.card\n\ntheorem school_clubs_bound {n : Nat} (h_n : 2 \u2264 n) (sc : SchoolClubs n) :\n  sc.clubs.card \u2264 (n - 1)^2 := sorry", "formal_statement_pred": "import Mathlib\n\nstructure ClubSystem where\n  n : Nat\n  clubs : Finset (Finset (Fin n))\n  n_ge_2 : n \u2265 2\n  club_size_ge_2 : \u2200 c, c \u2208 clubs \u2192 c.card \u2265 2\n  club_size_le_n : \u2200 c, c \u2208 clubs \u2192 c.card \u2264 n\n  diff_size_if_common : \u2200 c\u2081 c\u2082, c\u2081 \u2208 clubs \u2192 c\u2082 \u2208 clubs \u2192\n    (c\u2081 \u2229 c\u2082).card \u2265 2 \u2192 c\u2081.card \u2260 c\u2082.card\n\ndef common_students {n : Nat} (c\u2081 c\u2082 : Finset (Fin n)) : Nat :=\n  (c\u2081 \u2229 c\u2082).card\n\ntheorem club_system_bound (sys : ClubSystem) :\n  sys.clubs.card \u2264 ((sys.n - 1) ^ 2) := sorry", "compiled": true, "aligned": true}
{"id": "CombStruct4Lean_78", "informal_problem": "8. (40 points) $B$ In the 8-A class, there are $n$ students ( $n \\geq 2$ ). For them, clubs are organized, each of which is attended by at least two students. Any two clubs that have at least two common students differ in the number of participants. Prove that the number of clubs is no more than $(n-1)^{2}$.", "formal_statement": "import Mathlib\n\nstructure Club (n : Nat) : Type where\n  members : Finset (Fin n)\n  size_ge_2 : members.card \u2265 2\n\nstructure ClubSystem (n : Nat) : Type where\n  clubs : Finset (Club n)\n\n/-- Predicate indicating that a club system satisfies the size difference property -/\ndef hasSizeDiffProperty (n : Nat) (cs : ClubSystem n) : Prop :=\n  \u2200 (c\u2081 c\u2082 : Club n), c\u2081 \u2208 cs.clubs \u2192 c\u2082 \u2208 cs.clubs \u2192 c\u2081 \u2260 c\u2082 \u2192 \n    (c\u2081.members \u2229 c\u2082.members).card \u2265 2 \u2192 c\u2081.members.card \u2260 c\u2082.members.card\n\ntheorem club_system_bound (n : Nat) (cs : ClubSystem n) \n    (hn : n > 1)\n    (hprop : hasSizeDiffProperty n cs) :\n  cs.clubs.card \u2264 (n - 1) ^ 2 := sorry", "formal_statement_pred": "import Mathlib\n\nstructure ClubSystem where\n  n : Nat\n  clubs : Finset (Finset (Fin n))\n  n_ge_2 : n \u2265 2\n  club_size_ge_2 : \u2200 c \u2208 clubs, (c : Finset (Fin n)).card \u2265 2\n  diff_size_if_common : \u2200 c\u2081 \u2208 clubs, \u2200 c\u2082 \u2208 clubs,\n    (c\u2081 \u2229 c\u2082).card \u2265 2 \u2192 c\u2081.card \u2260 c\u2082.card\n  bound : clubs.card \u2264 (Nat.sub n 1)^2\n\ntheorem club_system_bound (cs : ClubSystem) :\n  cs.clubs.card \u2264 (Nat.sub cs.n 1)^2 := sorry", "compiled": true, "aligned": true}
{"id": "CombStruct4Lean_79", "informal_problem": "5. A running track represents a circle with a length of 2 km. Along an arc, which is 100 m long, spectator stands are built. Is it possible to launch 20 runners on this track in the same direction, moving at constant speeds of 10, 11, ..., 29 km/h, so that at any moment in time at least one of the runners is running in front of the stands? (The starting position of each runner can be designated at any point, independently of the other runners.)", "formal_statement": "import Mathlib\n\nstructure RunnerConfig where\n  -- Track length in meters\n  trackLength : \u211d := 2000\n  -- Stand length in meters\n  standLength : \u211d := 100\n  -- Number of runners\n  numRunners : \u2115 := 20\n  -- Initial positions of runners (in meters from arbitrary starting point)\n  initialPos : Fin numRunners \u2192 \u211d\n  -- Speeds of runners in meters per hour\n  speeds : Fin numRunners \u2192 \u211d\n\n/-- Checks if a runner is in front of the stands at a given time -/\ndef isInFrontOfStands (cfg : RunnerConfig) (runnerIdx : Fin cfg.numRunners) (time : \u211d) : Prop :=\n  let pos := (cfg.initialPos runnerIdx + cfg.speeds runnerIdx * time) % cfg.trackLength\n  pos \u2264 cfg.standLength\n\n/-- Checks if at least one runner is in front of the stands at a given time -/\ndef someRunnerInFrontOfStands (cfg : RunnerConfig) (time : \u211d) : Prop :=\n  \u2203 i : Fin cfg.numRunners, isInFrontOfStands cfg i time\n\ntheorem runners_coverage_possible : \u2203 (cfg : RunnerConfig), \n  (\u2200 i : Fin cfg.numRunners, cfg.speeds i = (10000 + i.val * 1000)) \u2192 -- Speeds from 10 to 29 km/h\n  (\u2200 t : \u211d, t \u2265 0 \u2192 someRunnerInFrontOfStands cfg t) :=\n  sorry", "formal_statement_pred": "import Mathlib\n\nstructure RunnerConfig where\n\n  trackLength : \u211d := 2000\n\n  standLength : \u211d := 100\n\n  numRunners : \u2115 := 20\n\n  startPositions : Fin numRunners \u2192 \u211d\n\n  speeds : Fin numRunners \u2192 \u211d\n\n\ndef isInFrontOfStands (cfg : RunnerConfig) (runnerIdx : Fin cfg.numRunners) (time : \u211d) : Prop :=\n  let pos := (cfg.startPositions runnerIdx + cfg.speeds runnerIdx * time) % cfg.trackLength\n  0 \u2264 pos \u2227 pos \u2264 cfg.standLength\n\ntheorem exists_valid_configuration : \u2203 (cfg : RunnerConfig),\n  (\u2200 i : Fin cfg.numRunners, cfg.speeds i = (10000 + i.val * 1000)) \u2192\n  (\u2200 t : \u211d, t \u2265 0 \u2192 \u2203 i : Fin cfg.numRunners, isInFrontOfStands cfg i t) :=\n  sorry", "compiled": true, "aligned": true}
{"id": "CombStruct4Lean_80", "informal_problem": "5. For a parallelepiped $a \\times b \\times c$ with faces divided into unit cells, there is also a large number of five-cell strips, which can be bent along the cell boundaries. For which $a, b$, and $c$ can the three faces of the parallelepiped, sharing a common vertex, be completely covered by the strips without overlaps and gaps, such that the cells of the faces and the strips coincide?", "formal_statement": "import Mathlib\n\nstructure Parallelepiped where\n  a : Nat\n  b : Nat\n  c : Nat\n\n/-- A strip is a sequence of 5 connected unit cells that can be bent along cell boundaries -/\nstructure Strip where\n  cells : Fin 5 \u2192 (Nat \u00d7 Nat)  -- Coordinates of cells in the strip\n\n/-- Represents a covering of three faces of a parallelepiped meeting at a vertex -/\nstructure FaceCovering (p : Parallelepiped) where\n  strips : List Strip\n  -- Each cell in the three faces is covered exactly once\n  covers_exactly : \u2200 (x y : Nat), \n    (x < p.a \u2227 y < b) \u2228 \n    (x < p.a \u2227 y < c) \u2228 \n    (x < p.b \u2227 y < c) \u2192 \n    \u2203! s \u2208 strips, \u2203 i : Fin 5, s.cells i = (x, y)\n\ntheorem parallelepiped_strip_covering_exists (p : Parallelepiped) \n  (ha : p.a > 0) (hb : p.b > 0) (hc : p.c > 0) :\n  (\u2203 covering : FaceCovering p, True) \u2194 \n  (p.a * p.b + p.b * p.c + p.a * p.c) % 5 = 0 :=\n  sorry", "formal_statement_pred": "import Mathlib\n\nstructure Parallelepiped where\n  a : Nat\n  b : Nat\n  c : Nat\n\n\nstructure Strip where\n  cells : Fin 5 \u2192 (Nat \u00d7 Nat)\n\n\nstructure FaceTiling (p : Parallelepiped) where\n\n  strips : List Strip\n\n\n  coverage : (face : Fin 3) \u2192 (x : Nat) \u2192 (y : Nat) \u2192 Option Nat\n\n  valid_dimensions :\n    (x \u2264 p.a \u2227 y \u2264 p.b) \u2228\n    (x \u2264 p.b \u2227 y \u2264 p.c) \u2228\n    (x \u2264 p.c \u2227 y \u2264 p.a)\n  complete_coverage : \u2200 face x y, coverage face x y \u2260 none\n  no_overlaps : \u2200 face x y s\u2081 s\u2082,\n    coverage face x y = some s\u2081 \u2192\n    coverage face x y = some s\u2082 \u2192\n    s\u2081 = s\u2082\n\ntheorem parallelepiped_strip_tiling_exists (p : Parallelepiped)\n  (h\u2081 : p.a > 0) (h\u2082 : p.b > 0) (h\u2083 : p.c > 0) :\n  \u2203 (tiling : FaceTiling p),\n\n    p.a * p.b + p.b * p.c + p.c * p.a = (List.length tiling.strips) * 5 :=\n  sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_81", "informal_problem": "10. (40 points) At a ball, 100 boys and 100 girls, numbered from 1 to 100, arrived. Sometimes boys and girls danced (in a dance, pairs of a boy and a girl participated). After all the dances, it turned out that for each girl, all the boys could be divided into two groups such that the girl danced with the boys from the first group as many times in total as with the boys from the second group. Prove that for some $k$, boy $k$ danced with girl $k$ no more than half of all his dances.", "formal_statement": "import Mathlib\n\nstructure DanceData where\n  n : Nat\n  h : 0 < n\n  h100 : n = 100\n  danceCount : Fin n \u2192 Fin n \u2192 Nat    -- boy \u2192 girl \u2192 count\n  totalDancesFor (b : Fin n) : Nat := \u2211 g : Fin n, danceCount b g\n\n  -- For each girl, boys can be split into two equal-sum groups\n  split_property : \u2200 g : Fin n, \u2203 s : Finset (Fin n),\n    (\u2211 b in s, danceCount b g) = (\u2211 b in (Finset.univ \\ s), danceCount b g)\n\ntheorem exists_boy_with_limited_dances (d : DanceData) :\n  \u2203 k : Fin d.n, d.danceCount k k * 2 < d.totalDancesFor k := sorry", "formal_statement_pred": "import Mathlib\n\n\nstructure DanceData where\n  n : Nat\n  danceCount : Fin n \u2192 Fin n \u2192 Nat\n  h_valid : n = 100\n  h_nonneg : \u2200 b g, danceCount b g \u2265 0\n\n\ndef totalDancesForBoy (d : DanceData) (boy : Fin d.n) : Nat :=\n  \u2211 girl in Finset.univ, d.danceCount boy girl\n\n\ndef hasEqualSplit (d : DanceData) (girl : Fin d.n) : Prop :=\n  \u2203 (group1 : Finset (Fin d.n)),\n    \u2203 (group2 : Finset (Fin d.n)),\n      (group1 \u2229 group2 = \u2205) \u2227\n      (group1 \u222a group2 = Finset.univ) \u2227\n      (\u2211 b in group1, d.danceCount b girl =\n       \u2211 b in group2, d.danceCount b girl)\n\ntheorem exists_boy_with_limited_dances\n  (d : DanceData)\n  (h : \u2200 girl : Fin d.n, hasEqualSplit d girl) :\n  \u2203 k : Fin d.n,\n    2 * d.danceCount k k \u2264 totalDancesForBoy d k :=\n  sorry", "compiled": true, "aligned": true}
{"id": "CombStruct4Lean_82", "informal_problem": "9. (50 points) In the kindergarten's dressing room, in the lost items basket, there are 30 mittens, of which 10 are blue, 10 are green, 10 are red, 15 are right-handed, and 15 are left-handed. Is it always possible to form sets of right and left mittens of the same color for 5 children?", "formal_statement": "import Mathlib\n\nstructure Mitten where\n  color : Fin 3  -- 0 for blue, 1 for green, 2 for red\n  isRight : Bool -- true for right-handed, false for left-handed\n\n/-- A collection of mittens with counts for each color and handedness -/\nstructure MittenCollection where\n  mittens : List Mitten\n  blue_count : Nat\n  green_count : Nat\n  red_count : Nat\n  right_count : Nat\n  left_count : Nat\n  h_blue : blue_count = 10\n  h_green : green_count = 10\n  h_red : red_count = 10\n  h_right : right_count = 15\n  h_left : left_count = 15\n  h_total : mittens.length = 30\n\n/-- A valid pair of mittens consists of a right and left mitten of the same color -/\ndef isValidPair (m1 m2 : Mitten) : Bool :=\n  m1.color = m2.color \u2227 m1.isRight \u2260 m2.isRight\n\ntheorem kindergarten_mittens (mc : MittenCollection) :\n  \u2203 (pairs : List (Mitten \u00d7 Mitten)), \n    pairs.length = 5 \u2227 \n    (\u2200 p \u2208 pairs, isValidPair p.1 p.2) \u2227\n    (\u2200 m \u2208 pairs.map Prod.fst ++ pairs.map Prod.snd, m \u2208 mc.mittens) :=\n  sorry", "formal_statement_pred": "import Mathlib\n\nstructure Mitten where\n  color : Fin 3\n  isRight : Bool\n\n\nstructure MittenCollection where\n  mittens : Finset Mitten\n  blue_count : Nat\n  green_count : Nat\n  red_count : Nat\n  right_count : Nat\n  left_count : Nat\n  total_count : Nat\n  count_constraints :\n    blue_count = 10 \u2227\n    green_count = 10 \u2227\n    red_count = 10 \u2227\n    right_count = 15 \u2227\n    left_count = 15 \u2227\n    total_count = 30\n\n\nstructure ValidPairing where\n  pairs : Fin 5 \u2192 (Mitten \u00d7 Mitten)\n  valid_pairs : \u2200 i : Fin 5,\n    (pairs i).1.color = (pairs i).2.color \u2227\n    (pairs i).1.isRight \u2260 (pairs i).2.isRight\n\ntheorem mitten_pairing_exists (mc : MittenCollection) :\n  \u2203 (vp : ValidPairing), \u2200 i j : Fin 5, i \u2260 j \u2192\n    (vp.pairs i).1 \u2260 (vp.pairs j).1 \u2227\n    (vp.pairs i).1 \u2260 (vp.pairs j).2 \u2227\n    (vp.pairs i).2 \u2260 (vp.pairs j).1 \u2227\n    (vp.pairs i).2 \u2260 (vp.pairs j).2 :=\n  sorry", "compiled": true, "aligned": true}
{"id": "CombStruct4Lean_84", "informal_problem": "8. (40 points) At the beginning of each physical education class, 30 students are divided into 3 teams of 10 each. Prove that there will be two students who were on the same team for three consecutive classes.", "formal_statement": "import Mathlib\n\n/-- Fixed constants for the problem -/\nabbrev NumStudents : Nat := 30\nabbrev NumTeams : Nat := 3\nabbrev TeamSize : Nat := 10\nabbrev Student := Fin NumStudents\nabbrev Team := Fin NumTeams\nabbrev ClassNumber := \u2115\n\n/-- Represents a sequence of team assignments across classes -/\nstructure TeamAssignment where\n  /-- For each class, assigns each student to a team -/\n  assignment : ClassNumber \u2192 Student \u2192 Team\n  /-- Teams form a partition (each student is in exactly one team) -/\n  is_partition : \u2200 (c : ClassNumber),\n    \u2200 (s : Student), \u2203! (t : Team), assignment c s = t\n\n/-- Two students are on the same team in a given class -/\ndef same_team (a : TeamAssignment) (s1 s2 : Student) (c : ClassNumber) : Prop :=\n  a.assignment c s1 = a.assignment c s2\n\ntheorem pigeonhole_teams (a : TeamAssignment) :\n  \u2203 (s1 s2 : Student) (c\u2081 c\u2082 c\u2083 : ClassNumber),\n    s1 \u2260 s2 \u2227\n    c\u2081 < c\u2082 \u2227 c\u2082 < c\u2083 \u2227\n    same_team a s1 s2 c\u2081 \u2227\n    same_team a s1 s2 c\u2082 \u2227\n    same_team a s1 s2 c\u2083 :=\n  sorry", "formal_statement_pred": "import Mathlib\n\nstructure TeamAssignment where\n  assignment : \u2115 \u2192 (Fin 30 \u2192 Fin 3)\n  team_size : \u2200 (day : \u2115) (team : Fin 3),\n    (Finset.filter (fun s => assignment day s = team) (Finset.univ : Finset (Fin 30))).card = 10\n\n\ndef sameTeamOn (ta : TeamAssignment) (s\u2081 s\u2082 : Fin 30) (d : \u2115) : Prop :=\n  s\u2081 \u2260 s\u2082 \u2227 ta.assignment d s\u2081 = ta.assignment d s\u2082\n\n\ndef sameTeamConsecutive (ta : TeamAssignment) (s\u2081 s\u2082 : Fin 30) (d : \u2115) : Prop :=\n  sameTeamOn ta s\u2081 s\u2082 d \u2227\n  sameTeamOn ta s\u2081 s\u2082 (d + 1) \u2227\n  sameTeamOn ta s\u2081 s\u2082 (d + 2)\n\ntheorem exists_three_consecutive_same_team : \u2200 (ta : TeamAssignment),\n  \u2203 (s\u2081 s\u2082 : Fin 30) (d : \u2115), sameTeamConsecutive ta s\u2081 s\u2082 d :=\n  sorry", "compiled": true, "aligned": true}
{"id": "CombStruct4Lean_85", "informal_problem": "1. (3 points) Given 10 different natural numbers, each not exceeding 23. Prove that there exist four different numbers $a, b, c, d$ among them, such that $\\frac{a+b}{2}=\\frac{c+d}{2}$.", "formal_statement": "import Mathlib\n\nstructure NumberSet where\n  nums : Finset \u2115\n  distinct : nums.card = 10\n  bounded : \u2200 n \u2208 nums, n \u2264 23\n\ntheorem exists_equal_averages (S : NumberSet) :\n  \u2203 (a b c d : \u2115),\n    a \u2208 S.nums \u2227 b \u2208 S.nums \u2227 c \u2208 S.nums \u2227 d \u2208 S.nums \u2227\n    a \u2260 b \u2227 a \u2260 c \u2227 a \u2260 d \u2227 b \u2260 c \u2227 b \u2260 d \u2227 c \u2260 d \u2227\n    (a + b : \u211a) / 2 = (c + d : \u211a) / 2 :=\n  sorry", "formal_statement_pred": "import Mathlib\n\nstructure NumberSet where\n  numbers : Finset \u2115\n  distinct : numbers.card = 10\n  bounded : \u2200 n \u2208 numbers, n \u2264 23\n\ntheorem exists_equal_average (s : NumberSet) :\n  \u2203 (a b c d : \u2115),\n    a \u2208 s.numbers \u2227 b \u2208 s.numbers \u2227 c \u2208 s.numbers \u2227 d \u2208 s.numbers \u2227\n    a \u2260 b \u2227 a \u2260 c \u2227 a \u2260 d \u2227 b \u2260 c \u2227 b \u2260 d \u2227 c \u2260 d \u2227\n    (a + b : \u211a) / 2 = (c + d : \u211a) / 2 :=\n  sorry", "compiled": true, "aligned": true}
{"id": "CombStruct4Lean_86", "informal_problem": "1. (3 points) Given 11 different natural numbers, each not exceeding 27. Prove that there exist four different numbers $a, b, c, d$ among them, such that $\\frac{a+b}{5}=\\frac{c+d}{5}$.", "formal_statement": "import Mathlib\n\ndef IsDifferent (a b c d : \u2115) : Prop :=\n  a \u2260 b \u2227 a \u2260 c \u2227 a \u2260 d \u2227 b \u2260 c \u2227 b \u2260 d \u2227 c \u2260 d\n\ndef HasEqualSumPairsDivByFive (nums : Finset \u2115) : Prop :=\n  \u2203 (a b c d : \u2115), a \u2208 nums \u2227 b \u2208 nums \u2227 c \u2208 nums \u2227 d \u2208 nums \u2227\n    IsDifferent a b c d \u2227\n    (a + b : \u2115) = (c + d : \u2115)\n\ntheorem equal_sum_pairs_div_five\n  (nums : Finset \u2115)\n  (h_size : nums.card = 11)\n  (h_bound : \u2200 n \u2208 nums, n \u2264 27) :\n  HasEqualSumPairsDivByFive nums :=\n  sorry", "formal_statement_pred": "import Mathlib\n\ndef ValidNumber (n : \u2115) : Prop := 0 < n \u2227 n \u2264 27\n\nstructure BoundedNumber where\n  val : \u2115\n  property : ValidNumber val\n\ndef HasSameDivision (a b c d : \u2115) : Prop :=\n  (a + b) / 5 = (c + d) / 5\n\ntheorem exists_same_division\n  (nums : Finset BoundedNumber)\n  (h_card : nums.card = 11)\n  (h_distinct : \u2200 (m n : BoundedNumber), m \u2208 nums \u2192 n \u2208 nums \u2192 m \u2260 n) :\n  \u2203 (a b c d : BoundedNumber),\n    a \u2208 nums \u2227 b \u2208 nums \u2227 c \u2208 nums \u2227 d \u2208 nums \u2227\n    a \u2260 b \u2227 a \u2260 c \u2227 a \u2260 d \u2227 b \u2260 c \u2227 b \u2260 d \u2227 c \u2260 d \u2227\n    HasSameDivision a.val b.val c.val d.val :=\n  sorry", "compiled": true, "aligned": true}
{"id": "CombStruct4Lean_87", "informal_problem": "8. We have $n$ integers $0,1,2, \\ldots, n-1$. By rearranging these numbers in a random order, we obtain some permutation $\\left(i_{1}, i_{2}, \\ldots, i_{n}\\right)$. From the original set of numbers $(0,1,2, \\ldots, n-1)$ and this permutation $\\left(i_{1}, i_{2}, \\ldots, i_{n}\\right)$, we obtain a new set of numbers $\\left(a_{1}, a_{2}, \\ldots, a_{n}\\right)$ according to the rule: $a_{1}=r_{n}\\left(0+i_{1}\\right), a_{2}=r_{n}\\left(1+i_{2}\\right), \\ldots, a_{n}=r_{n}\\left((n-1)+i_{n}\\right)$, where $r_{n}(m)$ is the remainder of the division of the number $m$ by the number $n$. (For example, let $n=3$. Then, from the original set $(0,1,2)$ and the permutation $\\left(i_{1}, i_{2}, i_{3}\\right)=$ $(1,2,0)$, we get the set $\\left(a_{1}, a_{2}, a_{3}\\right)=(1,0,2)$, since $r_{3}(0+1)=1, r_{3}(1+2)=0, r_{3}(2+0)=2$. $)$\n\nProve that if $n=6$, then no matter what permutation $\\left(i_{1}, i_{2}, \\ldots, i_{6}\\right)$ we take, there will be identical numbers in the set $\\left(a_{1}, a_{2}, \\ldots, a_{6}\\right)$.", "formal_statement": "import Mathlib\nopen Equiv Fin Function\n\ndef computeSequence (n : \u2115) (h : 0 < n) (p : Perm (Fin n)) (i : Fin n) : Fin n :=\n  \u27e8(i.val + p i).mod n, Nat.mod_lt _ h\u27e9\n\ndef allDistinct (n : \u2115) (f : Fin n \u2192 Fin n) : Prop :=\n  Injective f\n\ntheorem no_distinct_remainder_when_six {n : \u2115} (h : 0 < n) (h6 : n = 6) :\n  \u2200 p : Perm (Fin n), \u00ac(allDistinct n (computeSequence n h p)) :=\n  sorry", "formal_statement_pred": "import Mathlib\n\ndef generate_sequence (n : \u2115) (p : Fin n \u2192 Fin n) (i : Fin n) : Fin n :=\n  Fin.add i (p i)\n\ntheorem permutation_six_has_duplicate (p : Fin 6 \u2192 Fin 6) (h : Function.Bijective p) :\n  \u2203 (i j : Fin 6), i \u2260 j \u2227 generate_sequence 6 p i = generate_sequence 6 p j :=\n  sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_88", "informal_problem": "3. [5] On a line, 2022 points are marked such that every two adjacent points are at the same distance from each other. Half of the points are painted red, and the other half are painted blue. Can the sum of the lengths of all possible segments where the left endpoint is red and the right endpoint is blue equal the sum of the lengths of all segments where the left endpoint is blue and the right endpoint is red? (The endpoints of the considered segments do not necessarily have to be adjacent marked points.)\n\n(A. Hrybalko)", "formal_statement": "import Mathlib\n\ninductive PointColor where\n  | Red\n  | Blue\n  deriving Repr, DecidableEq\n\nstructure ColoredPoints where\n  n : Nat                            -- total number of points\n  d : \u211d                             -- fixed distance between adjacent points\n  colors : Fin n \u2192 PointColor       -- color assignment for each point\n  d_pos : d > 0                     -- distance is positive\n  n_even : Even n                   -- number of points must be even\n  half_red [DecidableEq PointColor] : \n    (Finset.univ.filter (fun i => colors i = PointColor.Red)).card = n / 2\n\n/-- Position of a point on the line given its index -/\ndef position_of (points : ColoredPoints) (i : Fin points.n) : \u211d :=\n  points.d * i.val\n\n/-- Length of segment between two points -/\ndef segment_length (points : ColoredPoints) (i j : Fin points.n) : \u211d :=\n  points.d * |((j.val : Int) - (i.val : Int))|\n\n/-- Sum of lengths of segments from red points to blue points -/\ndef red_to_blue_sum [DecidableEq PointColor] \n    (points : ColoredPoints) \n    [\u2200 (p : Fin points.n \u00d7 Fin points.n), Decidable (p.1.val < p.2.val)] : \u211d :=\n  Finset.sum (Finset.filter \n    (fun p => p.1.val < p.2.val \u2227 \n              points.colors p.1 = PointColor.Red \u2227 \n              points.colors p.2 = PointColor.Blue)\n    (Finset.product Finset.univ Finset.univ))\n    (fun p => segment_length points p.1 p.2)\n\n/-- Sum of lengths of segments from blue points to red points -/\ndef blue_to_red_sum [DecidableEq PointColor] \n    (points : ColoredPoints)\n    [\u2200 (p : Fin points.n \u00d7 Fin points.n), Decidable (p.1.val < p.2.val)] : \u211d :=\n  Finset.sum (Finset.filter \n    (fun p => p.1.val < p.2.val \u2227 \n              points.colors p.1 = PointColor.Blue \u2227 \n              points.colors p.2 = PointColor.Red)\n    (Finset.product Finset.univ Finset.univ))\n    (fun p => segment_length points p.1 p.2)\n\ntheorem colored_segments_sum_equal [DecidableEq PointColor]\n    (points : ColoredPoints)\n    [\u2200 (p : Fin points.n \u00d7 Fin points.n), Decidable (p.1.val < p.2.val)]\n    (h : points.n = 2022) : \n    red_to_blue_sum points = blue_to_red_sum points :=\n  sorry", "formal_statement_pred": "import Mathlib\n\ninductive PointColor\n  | Red\n  | Blue\n  deriving Repr, DecidableEq\n\nstructure ColoredLine where\n  n : \u2115\n  n_pos : 0 < n\n  even_n : Even n\n  unit_spacing : \u211d\n  unit_spacing_pos : 0 < unit_spacing\n  colors : Fin n \u2192 PointColor\n  balanced_colors : (Finset.filter (fun i => colors i = .Red) (Finset.univ)).card = n / 2\n\n  point_pos : Fin n \u2192 \u211d := fun i => i.val * unit_spacing\n\n\ndef red_blue_segments (cl : ColoredLine) : Finset (Fin cl.n \u00d7 Fin cl.n) :=\n  Finset.filter (fun p =>\n    p.1 < p.2 \u2227 cl.colors p.1 = .Red \u2227 cl.colors p.2 = .Blue)\n    (Finset.product Finset.univ Finset.univ)\n\n\ndef blue_red_segments (cl : ColoredLine) : Finset (Fin cl.n \u00d7 Fin cl.n) :=\n  Finset.filter (fun p =>\n    p.1 < p.2 \u2227 cl.colors p.1 = .Blue \u2227 cl.colors p.2 = .Red)\n    (Finset.product Finset.univ Finset.univ)\n\n\ndef segment_sum (cl : ColoredLine) (segments : Finset (Fin cl.n \u00d7 Fin cl.n)) : \u211d :=\n  Finset.sum segments fun p => cl.point_pos p.2 - cl.point_pos p.1\n\ntheorem colored_line_segment_sums_equal (cl : ColoredLine) (h : cl.n = 2022) :\n  segment_sum cl (red_blue_segments cl) = segment_sum cl (blue_red_segments cl) :=\n  sorry", "compiled": true, "aligned": true}
{"id": "CombStruct4Lean_89", "informal_problem": "6. A row of $N$ boxes, numbered consecutively $1,2, \\ldots, N$, stands from left to right. Some of these boxes, standing in a row, will have a ball placed in them, leaving the others empty.\n\nThe instruction consists of a sequence of commands of the form \"swap the contents of box \u2116 $i$ and box \u2116 $j$\", where $i$ and $j$ are numbers. For each $N$, does there exist an instruction with no more than $100 \\mathrm{~N}$ commands, such that for any initial arrangement of the specified type, one can, by deleting some commands from the instruction, obtain an instruction that, after execution, will have all the boxes with balls to the left of the boxes without balls?\n\nI. Mitrofanov", "formal_statement": "import Mathlib\n\n/-- A configuration of N boxes with balls, represented as a function from positions to presence of balls -/\ndef BoxConfig (N : \u2115) := Fin N \u2192 Bool\n\n/-- Swap the contents of two positions in a configuration -/\ndef swap {N : \u2115} (cfg : BoxConfig N) (i j : Fin N) : BoxConfig N := fun k =>\n  if k = i then cfg j\n  else if k = j then cfg i\n  else cfg k\n\n/-- Apply a sequence of swaps to a configuration -/\ndef applySwaps {N : \u2115} (cfg : BoxConfig N) (swaps : List (Fin N \u00d7 Fin N)) : BoxConfig N :=\n  swaps.foldl (fun c \u27e8i, j\u27e9 => swap c i j) cfg\n\n/-- A configuration is sorted if there exists a position k where\n    all positions before k contain balls and all positions after k are empty -/\ndef isSorted {N : \u2115} (cfg : BoxConfig N) : Prop :=\n  \u2203 k : Fin (N + 1), \u2200 i j : Fin N, i.val < j.val \u2192 \n    (i.val < k \u2192 cfg i = true) \u2227 \n    (k \u2264 j.val \u2192 cfg j = false)\n\ntheorem mitrofanov_box_sorting (N : \u2115) :\n  \u2203 (instruction : List (Fin N \u00d7 Fin N)), \n    instruction.length \u2264 N * 100 \u2227\n    \u2200 (initial : BoxConfig N),\n      \u2203 (subseq : List (Fin N \u00d7 Fin N)), \n        List.Sublist subseq instruction \u2227\n        isSorted (applySwaps initial subseq) :=\n  sorry", "formal_statement_pred": "import Mathlib\n\n\nstructure BoxConfiguration (n : Nat) where\n  balls : Finset (Fin n)\n\n\nstructure SwapCommand (n : Nat) where\n  i : Fin n\n  j : Fin n\n\n\nstructure Instruction (n : Nat) where\n  commands : List (SwapCommand n)\n  h_length : commands.length \u2264 100 * n\n\n\ndef applySwap {n : Nat} (config : BoxConfiguration n) (cmd : SwapCommand n) : BoxConfiguration n :=\n  { balls :=\n      if cmd.i \u2208 config.balls\n      then if cmd.j \u2208 config.balls\n           then config.balls\n           else config.balls.erase cmd.i \u222a {cmd.j}\n      else if cmd.j \u2208 config.balls\n           then config.balls.erase cmd.j \u222a {cmd.i}\n           else config.balls }\n\n\ndef isSorted {n : Nat} (config : BoxConfiguration n) : Prop :=\n  \u2200 i j : Fin n, i.val < j.val \u2192 (j \u2208 config.balls \u2192 i \u2208 config.balls)\n\n\ndef isSubInstruction {n : Nat} (sub inst : List (SwapCommand n)) : Prop :=\n  \u2203 (indices : List (Fin inst.length)),\n    (indices.Sorted (\u00b7<\u00b7)) \u2227\n    (sub = indices.map (inst.get \u00b7))\n\ntheorem exists_universal_sorting_instruction (n : Nat) :\n  \u2203 (inst : Instruction n),\n    \u2200 (initial : BoxConfiguration n),\n      \u2203 (subInst : List (SwapCommand n)),\n        isSubInstruction subInst inst.commands \u2227\n        isSorted (subInst.foldl applySwap initial) :=\n  sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_90", "informal_problem": "2. [7] On a line, there are 2019 grasshoppers sitting at points. In one move, one of the grasshoppers jumps over another so that it ends up at the same distance from the other. By jumping only to the right, the grasshoppers can achieve that some two of them are exactly 1 mm apart. Prove that the grasshoppers can achieve the same by jumping only to the left from the initial position.\n\nS. Dorichenko", "formal_statement": "import Mathlib\n\n/-- State of 2019 grasshoppers on a line, tracking their positions -/\nstructure GrasshopperState where\n  positions : Fin 2019 \u2192 \u211d\n\n/-- Create a new state after a grasshopper jumps to a new position -/\ndef GrasshopperState.jump (s : GrasshopperState) (i : Fin 2019) (newPos : \u211d) : GrasshopperState where\n  positions := Function.update s.positions i newPos\n\n/-- Predicate indicating if a jump is valid: the new position must be at the same distance\n    from the grasshopper being jumped over as the original position -/\ndef isValidJump (s : GrasshopperState) (i j : Fin 2019) (newPos : \u211d) : Prop :=\n  |newPos - s.positions j| = |s.positions i - s.positions j| \u2227\n  newPos \u2260 s.positions j\n\n/-- Predicate indicating if any two grasshoppers are exactly 1mm apart -/\ndef hasUnitDistance (s : GrasshopperState) : Prop :=\n  \u2203 i j : Fin 2019, i \u2260 j \u2227 |s.positions i - s.positions j| = 1\n\n/-- Inductive definition of states reachable by right jumps only -/\ninductive ReachableByRightJumps : GrasshopperState \u2192 GrasshopperState \u2192 Prop where\n  | refl (s : GrasshopperState) : ReachableByRightJumps s s\n  | jump (s\u2081 s\u2082 s\u2083 : GrasshopperState) (i j : Fin 2019) :\n      ReachableByRightJumps s\u2081 s\u2082 \u2192\n      (i.val < j.val) \u2192  -- jumping right\n      isValidJump s\u2082 i j (s\u2082.positions j + |s\u2082.positions j - s\u2082.positions i|) \u2192\n      s\u2083 = s\u2082.jump i (s\u2082.positions j + |s\u2082.positions j - s\u2082.positions i|) \u2192\n      ReachableByRightJumps s\u2081 s\u2083\n\n/-- Inductive definition of states reachable by left jumps only -/\ninductive ReachableByLeftJumps : GrasshopperState \u2192 GrasshopperState \u2192 Prop where\n  | refl (s : GrasshopperState) : ReachableByLeftJumps s s\n  | jump (s\u2081 s\u2082 s\u2083 : GrasshopperState) (i j : Fin 2019) :\n      ReachableByLeftJumps s\u2081 s\u2082 \u2192\n      (i.val > j.val) \u2192  -- jumping left\n      isValidJump s\u2082 i j (s\u2082.positions j - |s\u2082.positions j - s\u2082.positions i|) \u2192\n      s\u2083 = s\u2082.jump i (s\u2082.positions j - |s\u2082.positions j - s\u2082.positions i|) \u2192\n      ReachableByLeftJumps s\u2081 s\u2083\n\ntheorem grasshopper_symmetry (initial : GrasshopperState)\n  (h_ordered : \u2200 i j : Fin 2019, i.val < j.val \u2192 initial.positions i < initial.positions j)\n  (h_distinct : \u2200 i j : Fin 2019, i \u2260 j \u2192 initial.positions i \u2260 initial.positions j)\n  (h_right : \u2203 final, ReachableByRightJumps initial final \u2227 hasUnitDistance final) :\n  \u2203 final, ReachableByLeftJumps initial final \u2227 hasUnitDistance final :=\n  sorry", "formal_statement_pred": "import Mathlib\n\nstructure GrasshopperState where\n  positions : Fin 2019 \u2192 \u211d\n  isOrdered : \u2200 i j : Fin 2019, i < j \u2192 positions i < positions j\n\n\ndef jumpRight (state : GrasshopperState) (i j : Fin 2019) : GrasshopperState :=\n  { positions := fun k => if k = i\n                         then state.positions j + (state.positions j - state.positions i)\n                         else state.positions k\n    isOrdered := sorry }\n\n\ndef jumpLeft (state : GrasshopperState) (i j : Fin 2019) : GrasshopperState :=\n  { positions := fun k => if k = i\n                         then state.positions j - (state.positions j - state.positions i)\n                         else state.positions k\n    isOrdered := sorry }\n\n\ndef hasOneMillimeterPair (state : GrasshopperState) : Prop :=\n  \u2203 i j : Fin 2019, i \u2260 j \u2227 |state.positions i - state.positions j| = 1\n\ntheorem grasshopper_symmetry\n  (initial : GrasshopperState)\n  (h : \u2203 (final : GrasshopperState),\n       \u2203 (jumps : List (Fin 2019 \u00d7 Fin 2019)),\n       (\u2200 (jump : Fin 2019 \u00d7 Fin 2019), jump \u2208 jumps \u2192\n         jump.1 < jump.2) \u2227\n       (final = jumps.foldl (fun state jump => jumpRight state jump.1 jump.2) initial) \u2227\n       hasOneMillimeterPair final) :\n  \u2203 (final : GrasshopperState),\n  \u2203 (jumps : List (Fin 2019 \u00d7 Fin 2019)),\n    (\u2200 (jump : Fin 2019 \u00d7 Fin 2019), jump \u2208 jumps \u2192\n      jump.1 > jump.2) \u2227\n    (final = jumps.foldl (fun state jump => jumpLeft state jump.1 jump.2) initial) \u2227\n    hasOneMillimeterPair final :=\n  sorry", "compiled": true, "aligned": true}
{"id": "CombStruct4Lean_93", "informal_problem": "Task 10. In a country, there are 10 cities, some of which are connected by roads (each road connects exactly two cities, there is no more than one road between any two cities, and you can only switch from one road to another in a city). Is it possible that from one city 9 roads lead out, from one - 8, from two - 7 each, from two - 6 each, from two - 4 each, from one - 2, and from one - 1?", "formal_statement": "import Mathlib\n\nstructure RoadNetwork where\n  -- Number of cities is fixed at 10\n  roads : Finset (Fin 10 \u00d7 Fin 10)\n  -- Each road connects different cities\n  different_cities : \u2200 (e : Fin 10 \u00d7 Fin 10), e \u2208 roads \u2192 e.1 \u2260 e.2\n  -- Roads are undirected (if a-b is a road, b-a is the same road)\n  symmetric : \u2200 (a b : Fin 10), (a, b) \u2208 roads \u2194 (b, a) \u2208 roads\n  -- No duplicate roads\n  no_duplicates : \u2200 (a b : Fin 10), (a, b) \u2208 roads \u2192 (b, a) \u2208 roads \u2192 (a, b) = (b, a)\n\n/-- The degree (number of roads) connected to a city -/\ndef city_degree (n : RoadNetwork) (city : Fin 10) : Nat :=\n  (n.roads.filter (fun e => e.1 = city)).card\n\ntheorem road_network_possible : \u2203 (n : RoadNetwork),\n  -- One city with degree 9\n  (\u2203! (c\u2081 : Fin 10), city_degree n c\u2081 = 9) \u2227\n  -- One city with degree 8\n  (\u2203! (c\u2082 : Fin 10), city_degree n c\u2082 = 8) \u2227\n  -- Two cities with degree 7\n  (\u2203 (c\u2083 c\u2084 : Fin 10), c\u2083 \u2260 c\u2084 \u2227 \n    city_degree n c\u2083 = 7 \u2227 city_degree n c\u2084 = 7 \u2227\n    (\u2200 c, city_degree n c = 7 \u2192 c = c\u2083 \u2228 c = c\u2084)) \u2227\n  -- Two cities with degree 6\n  (\u2203 (c\u2085 c\u2086 : Fin 10), c\u2085 \u2260 c\u2086 \u2227 \n    city_degree n c\u2085 = 6 \u2227 city_degree n c\u2086 = 6 \u2227\n    (\u2200 c, city_degree n c = 6 \u2192 c = c\u2085 \u2228 c = c\u2086)) \u2227\n  -- Two cities with degree 4\n  (\u2203 (c\u2087 c\u2088 : Fin 10), c\u2087 \u2260 c\u2088 \u2227 \n    city_degree n c\u2087 = 4 \u2227 city_degree n c\u2088 = 4 \u2227\n    (\u2200 c, city_degree n c = 4 \u2192 c = c\u2087 \u2228 c = c\u2088)) \u2227\n  -- One city with degree 2\n  (\u2203! (c\u2089 : Fin 10), city_degree n c\u2089 = 2) \u2227\n  -- One city with degree 1\n  (\u2203! (c\u2081\u2080 : Fin 10), city_degree n c\u2081\u2080 = 1) :=\n  sorry", "formal_statement_pred": "import Mathlib\n\nstructure CityNetwork where\n\n  n : Nat\n\n  roads : Matrix (Fin n) (Fin n) Bool\n\n  symmetric : \u2200 i j, roads i j = roads j i\n  no_self_loops : \u2200 i, roads i i = false\n\n\ndef CityNetwork.degree (g : CityNetwork) (i : Fin g.n) : Nat :=\n  (List.range g.n).countP (fun j \u21a6 g.roads i \u27e8j, sorry\u27e9)\n\ntheorem city_road_degree_possible :\n  \u2203 (g : CityNetwork),\n    g.n = 10 \u2227\n    (\u2203 (cities : Fin 10 \u2192 Nat),\n\n      (\u2203 i\u2081, g.degree i\u2081 = 9) \u2227\n\n      (\u2203 i\u2082, g.degree i\u2082 = 8) \u2227\n\n      (\u2203 i\u2083 i\u2084, i\u2083 \u2260 i\u2084 \u2227 g.degree i\u2083 = 7 \u2227 g.degree i\u2084 = 7) \u2227\n\n      (\u2203 i\u2085 i\u2086, i\u2085 \u2260 i\u2086 \u2227 g.degree i\u2085 = 6 \u2227 g.degree i\u2086 = 6) \u2227\n\n      (\u2203 i\u2087 i\u2088, i\u2087 \u2260 i\u2088 \u2227 g.degree i\u2087 = 4 \u2227 g.degree i\u2088 = 4) \u2227\n\n      (\u2203 i\u2089, g.degree i\u2089 = 2) \u2227\n\n      (\u2203 i\u2081\u2080, g.degree i\u2081\u2080 = 1)) :=\n  sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_94", "informal_problem": "7.1. In the bakery, there are pies with two fillings (apple and cherry) and of two types (fried and baked). Prove that it is possible to buy two pies that will differ both in filling and in the method of preparation.", "formal_statement": "import Mathlib\n\nstructure Pie where\n  filling : Bool  -- false for apple, true for cherry\n  baked : Bool   -- false for fried, true for baked\n\ndef different_filling (p1 p2 : Pie) : Bool :=\n  p1.filling \u2260 p2.filling\n\ndef different_preparation (p1 p2 : Pie) : Bool :=\n  p1.baked \u2260 p2.baked\n\ntheorem bakery_pigeonhole : \u2203 (p1 p2 : Pie), \n  p1 \u2260 p2 \u2227 different_filling p1 p2 \u2227 different_preparation p1 p2 :=\n  sorry", "formal_statement_pred": "import Mathlib\n\nstructure Pie where\n  filling : Bool\n  baked : Bool\n\ndef different_filling (p1 p2 : Pie) : Bool :=\n  p1.filling \u2260 p2.filling\n\ndef different_preparation (p1 p2 : Pie) : Bool :=\n  p1.baked \u2260 p2.baked\n\ntheorem bakery_pigeonhole : \u2203 (p1 p2 : Pie),\n  different_filling p1 p2 \u2227 different_preparation p1 p2 :=\n  sorry", "compiled": true, "aligned": true}
{"id": "CombStruct4Lean_96", "informal_problem": "7.1. Is it possible that 1000 participants in the olympiad will solve this problem correctly, and among them, there will be 43 more boys than girls?", "formal_statement": "import Mathlib\n\n-- No additional structures needed\n\ntheorem olympiad_participants_parity \n  (total : Nat) (diff : Nat) (h1 : total = 1000) (h2 : diff = 43) :\n  \u00ac(\u2203 (boys girls : Nat), \n    boys + girls = total \u2227 \n    boys - girls = diff) :=\n  sorry", "formal_statement_pred": "import Mathlib\n\n\n\ntheorem olympiad_participants_parity\n  (total : Nat) (diff : Nat) (h1 : total = 1000) (h2 : diff = 43) :\n  \u00ac(\u2203 (boys girls : Nat),\n    boys + girls = total \u2227\n    boys - girls = diff) :=\n  sorry", "compiled": true, "aligned": true}
{"id": "CombStruct4Lean_97", "informal_problem": "7.3. Anna has a 2015 by 2015 grid, in which she wrote real numbers. It turned out that in any three cells forming a corner (see the figure, the corner can be rotated), the sum of the numbers is 3. Prove that Anna put 1 in all cells.", "formal_statement": "import Mathlib\n\nstructure Grid2015 where\n  value : Fin 2015 \u2192 Fin 2015 \u2192 \u211d\n\n/-- Predicate that checks if three cells form a corner in the grid -/\ndef isCorner (i\u2081 j\u2081 i\u2082 j\u2082 i\u2083 j\u2083 : Fin 2015) : Prop :=\n  (i\u2081 = i\u2082 \u2227 j\u2081 = j\u2083) \u2228  -- horizontal-vertical corner\n  (i\u2081 = i\u2083 \u2227 j\u2081 = j\u2082) \u2228  -- vertical-horizontal corner\n  (i\u2082 = i\u2083 \u2227 j\u2082 = j\u2081)    -- another possible corner orientation\n\ntheorem grid_corner_sum_three_implies_all_ones \n  (g : Grid2015)\n  (h : \u2200 i\u2081 j\u2081 i\u2082 j\u2082 i\u2083 j\u2083, isCorner i\u2081 j\u2081 i\u2082 j\u2082 i\u2083 j\u2083 \u2192 \n    g.value i\u2081 j\u2081 + g.value i\u2082 j\u2082 + g.value i\u2083 j\u2083 = 3) :\n  \u2200 i j, g.value i j = 1 :=\n  sorry", "formal_statement_pred": "import Mathlib\n\nstructure Grid2015 where\n  values : Fin 2015 \u2192 Fin 2015 \u2192 \u211d\n\n\ndef isCorner (grid : Grid2015) (i\u2081 j\u2081 i\u2082 j\u2082 i\u2083 j\u2083 : Fin 2015) : Prop :=\n  (i\u2081 = i\u2082 \u2227 j\u2082 = j\u2083) \u2228\n  (i\u2082 = i\u2083 \u2227 j\u2083 = j\u2081) \u2228\n  (i\u2083 = i\u2081 \u2227 j\u2081 = j\u2082)\n\ntheorem all_ones_in_grid (grid : Grid2015)\n  (h : \u2200 i\u2081 j\u2081 i\u2082 j\u2082 i\u2083 j\u2083, isCorner grid i\u2081 j\u2081 i\u2082 j\u2082 i\u2083 j\u2083 \u2192\n    grid.values i\u2081 j\u2081 + grid.values i\u2082 j\u2082 + grid.values i\u2083 j\u2083 = 3) :\n  \u2200 i j, grid.values i j = 1 :=\n  sorry", "compiled": true, "aligned": true}
{"id": "CombStruct4Lean_98", "informal_problem": "9.5. On an 8x8 chessboard, 8 rooks are arranged in such a way that none of them can attack each other. Prove that each of them can be simultaneously moved to one of the diagonally adjacent cells in such a way that none of them will be able to attack each other after the move. Recall that a chess rook attacks all cells in the row and column it occupies.", "formal_statement": "import Mathlib\n\n-- Represents a position on the 8x8 chessboard\nstructure Position where\n  row : Fin 8\n  col : Fin 8\n\n-- Represents a rook on the chessboard\nstructure Rook where\n  pos : Position\n\n-- Checks if two positions are diagonally adjacent\ndef isDiagonallyAdjacent (p1 p2 : Position) : Bool :=\n  let rowDiff := (p1.row.val : Int) - (p2.row.val : Int)\n  let colDiff := (p1.col.val : Int) - (p2.col.val : Int)\n  abs rowDiff = 1 && abs colDiff = 1\n\n-- Checks if two positions are in the same row or column (attacking position)\ndef isAttacking (p1 p2 : Position) : Bool :=\n  p1.row = p2.row || p1.col = p2.col\n\n-- Represents a configuration of 8 rooks\ndef RookConfiguration := Fin 8 \u2192 Rook\n\n-- Checks if a configuration is valid (no rooks attacking each other)\ndef isValidConfiguration (config : RookConfiguration) : Prop :=\n  \u2200 i j : Fin 8, i \u2260 j \u2192 \u00ac(isAttacking (config i).pos (config j).pos)\n\ntheorem rooks_diagonal_move_exists (initial : RookConfiguration) \n  (h : isValidConfiguration initial) :\n  \u2203 (final : RookConfiguration),\n    -- The final configuration is valid\n    isValidConfiguration final \u2227\n    -- Each rook moves to a diagonally adjacent square\n    (\u2200 i : Fin 8, isDiagonallyAdjacent (initial i).pos (final i).pos) :=\n  sorry", "formal_statement_pred": "import Mathlib\n\nstructure ChessPosition where\n  row : Fin 8\n  col : Fin 8\n\nabbrev RookConfiguration := Fin 8 \u2192 ChessPosition\n\n\ndef canAttack (p1 p2 : ChessPosition) : Prop :=\n  p1.row = p2.row \u2228 p1.col = p2.col\n\ndef isDiagonallyAdjacent (p1 p2 : ChessPosition) : Prop :=\n  (Nat.max p1.row.val p2.row.val - Nat.min p1.row.val p2.row.val = 1) \u2227\n  (Nat.max p1.col.val p2.col.val - Nat.min p1.col.val p2.col.val = 1)\n\ndef isValidRookConfiguration (positions : RookConfiguration) : Prop :=\n  \u2200 i j : Fin 8, i \u2260 j \u2192\n    \u00ac(canAttack (positions i) (positions j))\n\ntheorem rooks_diagonal_move_exists (initial_positions : RookConfiguration)\n    (h_initial : isValidRookConfiguration initial_positions) :\n  \u2203 (final_positions : RookConfiguration),\n    (\u2200 i : Fin 8, isDiagonallyAdjacent (initial_positions i) (final_positions i)) \u2227\n    isValidRookConfiguration final_positions :=\n  sorry", "compiled": true, "aligned": true}
{"id": "CombStruct4Lean_99", "informal_problem": "7.5. Given an empty $3 \\times 3$ grid. In one move, it is allowed to choose any three cells forming an L-shape (oriented in any direction) and place one checker in each of them. Can it happen after several moves that each cell contains the same non-zero number of checkers? (Justify your answer.)", "formal_statement": "import Mathlib\n\n-- Position on 3x3 grid\nstructure Pos where\n  row : Fin 3\n  col : Fin 3\nderiving Repr, DecidableEq\n\n-- Define what makes three positions form an L-shape\ndef IsLShape (p1 p2 p3 : Pos) : Prop :=\n  (p1.row = p2.row \u2227 p2.col = p3.col \u2227 \n   ((p1.col = p2.col + 1 \u2228 p2.col = p1.col + 1) \u2227 \n    (p2.row = p3.row + 1 \u2228 p3.row = p2.row + 1))) \u2228\n  (p1.col = p2.col \u2227 p2.row = p3.row \u2227 \n   ((p1.row = p2.row + 1 \u2228 p2.row = p1.row + 1) \u2227 \n    (p2.col = p3.col + 1 \u2228 p3.col = p2.col + 1)))\n\n-- A move is a valid L-shape placement\nstructure Move where\n  pos1 : Pos\n  pos2 : Pos\n  pos3 : Pos\n  valid : IsLShape pos1 pos2 pos3\n\n-- Grid state tracks number of checkers in each position\ndef GridState := Pos \u2192 Nat\n\n-- Apply a move to a grid state\ndef applyMove (state : GridState) (move : Move) : GridState := fun pos =>\n  if pos = move.pos1 \u2228 pos = move.pos2 \u2228 pos = move.pos3\n  then state pos + 1\n  else state pos\n\ntheorem grid_equal_checkers_impossible :\n  \u00ac\u2203 (moves : List Move) (n : Nat),\n    n > 0 \u2227\n    let finalState := moves.foldl applyMove (fun _ => 0)\n    \u2200 pos, finalState pos = n :=\n  sorry", "formal_statement_pred": "import Mathlib\n\nstructure Pos where\n  row : Fin 3\n  col : Fin 3\n\ninductive LShapeOrientation where\n  | NorthEast | NorthWest | SouthEast | SouthWest\n  deriving Repr\n\nstructure LShape where\n  corner : Pos\n  orientation : LShapeOrientation\n\n\nabbrev GridState := Fin 3 \u2192 Fin 3 \u2192 \u2115\n\n\ndef getLShapeCells (l : LShape) : Option (Fin 3 \u00d7 Fin 3 \u00d7 Fin 3 \u00d7 Fin 3 \u00d7 Fin 3 \u00d7 Fin 3) :=\n  match l.orientation with\n  | LShapeOrientation.NorthEast =>\n      some (l.corner.row, l.corner.col,\n            l.corner.row, (l.corner.col + 1),\n            (l.corner.row + 1), l.corner.col)\n  | LShapeOrientation.NorthWest =>\n      some (l.corner.row, l.corner.col,\n            l.corner.row, (l.corner.col - 1),\n            (l.corner.row + 1), l.corner.col)\n  | LShapeOrientation.SouthEast =>\n      some (l.corner.row, l.corner.col,\n            l.corner.row, (l.corner.col + 1),\n            (l.corner.row - 1), l.corner.col)\n  | LShapeOrientation.SouthWest =>\n      some (l.corner.row, l.corner.col,\n            l.corner.row, (l.corner.col - 1),\n            (l.corner.row - 1), l.corner.col)\n\n\ndef isValidLShape (l : LShape) : Prop :=\n  getLShapeCells l \u2260 none\n\n\ndef applyMove (state : GridState) (move : LShape) : GridState :=\n  match getLShapeCells move with\n  | none => state\n  | some (r1, c1, r2, c2, r3, c3) => fun r c =>\n      if (r = r1 && c = c1) || (r = r2 && c = c2) || (r = r3 && c = c3)\n      then state r c + 1\n      else state r c\n\n\ndef applyMoves (moves : List LShape) : GridState :=\n  moves.foldl applyMove (fun _ _ => 0)\n\n\ndef isUniform (state : GridState) (n : \u2115) : Prop :=\n  \u2200 i j : Fin 3, state i j = n\n\ntheorem grid_equal_checkers_impossible :\n  \u00ac\u2203 (moves : List LShape) (n : \u2115),\n    n > 0 \u2227 (\u2200 m \u2208 moves, isValidLShape m) \u2227 isUniform (applyMoves moves) n :=\n  sorry", "compiled": true, "aligned": true}
{"id": "CombStruct4Lean_100", "informal_problem": "7.5. TikTok-House represents a $3 \\times 3$ square of nine rooms, each inhabited by a blogger. On Monday, the bloggers randomly swapped rooms, after which every two people who ended up in adjacent rooms recorded a collaborative TikTok. On Tuesday, the bloggers again swapped rooms and recorded TikToks according to the same rule as the previous day. The same thing happened on Wednesday. Prove that some two bloggers did not record a collaborative TikTok.", "formal_statement": "import Mathlib\n\nstructure TikTokHouse where\n  -- Each day's arrangement is represented as a permutation of bloggers (1-9)\n  monday : Fin 9 \u2192 Fin 9\n  tuesday : Fin 9 \u2192 Fin 9\n  wednesday : Fin 9 \u2192 Fin 9\n  \n-- Define when two positions are adjacent in a 3x3 grid\ndef isAdjacent (p1 p2 : Fin 9) : Bool :=\n  let row1 := p1 / 3\n  let col1 := p1 % 3\n  let row2 := p2 / 3\n  let col2 := p2 % 3\n  (row1 = row2 \u2227 (col1 = col2 + 1 \u2228 col2 = col1 + 1)) \u2228\n  (col1 = col2 \u2227 (row1 = row2 + 1 \u2228 row2 = row1 + 1))\n\n-- Define when two bloggers made a TikTok together on a given day\ndef madeTikTok (arrangement : Fin 9 \u2192 Fin 9) (blogger1 blogger2 : Fin 9) : Bool :=\n  isAdjacent (arrangement blogger1) (arrangement blogger2)\n\ntheorem some_pair_no_tiktok (house : TikTokHouse) : \n  \u2203 (b1 b2 : Fin 9), b1 \u2260 b2 \u2227 \n    \u00ac(madeTikTok house.monday b1 b2 \u2228 \n      madeTikTok house.tuesday b1 b2 \u2228 \n      madeTikTok house.wednesday b1 b2) :=\n  sorry", "formal_statement_pred": "import Mathlib\n\nstructure TikTokHouse where\n\n\n  arrangements : Fin 3 \u2192 (Fin 9 \u2192 Fin 9)\n\n\ndef isAdjacent (p1 p2 : Fin 9) : Bool :=\n  let row1 := p1 / 3\n  let col1 := p1 % 3\n  let row2 := p2 / 3\n  let col2 := p2 % 3\n  (row1 = row2 && (col1 = col2 + 1 || col2 = col1 + 1)) ||\n  (col1 = col2 && (row1 = row2 + 1 || row2 = row1 + 1))\n\n\ndef didRecordTikTok (house : TikTokHouse) (b1 b2 : Fin 9) : Bool :=\n  \u2203 day pos1 pos2,\n    house.arrangements day pos1 = b1 \u2227\n    house.arrangements day pos2 = b2 \u2227\n    isAdjacent pos1 pos2\n\ntheorem some_pair_no_tiktok :\n  \u2203 house : TikTokHouse, \u2203 b1 b2 : Fin 9,\n    b1 \u2260 b2 \u2227 \u00ac(didRecordTikTok house b1 b2) :=\n  sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_101", "informal_problem": "7.2. A square with a side of 6 cells is cut along the grid lines into 8 rectangles. Prove that some two of these rectangles are equal in area.", "formal_statement": "import Mathlib\n\nstructure Rectangle where\n  width : Nat\n  height : Nat\n  x_pos : Nat  -- x coordinate of bottom-left corner\n  y_pos : Nat  -- y coordinate of bottom-left corner\n  h_width : width \u2264 6\n  h_height : height \u2264 6\n  h_pos_x : x_pos + width \u2264 6\n  h_pos_y : y_pos + height \u2264 6\n\ndef area (r : Rectangle) : Nat :=\n  r.width * r.height\n\ndef valid_partition (rects : List Rectangle) : Prop :=\n  rects.length = 8 \u2227  -- exactly 8 rectangles\n  (\u2200 p : Nat \u00d7 Nat, p.1 < 6 \u2227 p.2 < 6 \u2192  -- each point belongs to exactly one rectangle\n    \u2203! r \u2208 rects, r.x_pos \u2264 p.1 \u2227 p.1 < r.x_pos + r.width \u2227\n                   r.y_pos \u2264 p.2 \u2227 p.2 < r.y_pos + r.height)\n\ntheorem square_partition_equal_areas :\n  \u2200 rects : List Rectangle,\n    valid_partition rects \u2192\n    \u2203 r1 r2 : Rectangle, r1 \u2208 rects \u2227 r2 \u2208 rects \u2227 r1 \u2260 r2 \u2227 area r1 = area r2 :=\n  sorry", "formal_statement_pred": "import Mathlib\n\nstructure GridRectangle where\n  x\u2081 : Fin 7\n  y\u2081 : Fin 7\n  x\u2082 : Fin 7\n  y\u2082 : Fin 7\n  valid : x\u2081.val < x\u2082.val \u2227 y\u2081.val < y\u2082.val\n\ndef area (r : GridRectangle) : \u2115 :=\n  (r.x\u2082.val - r.x\u2081.val) * (r.y\u2082.val - r.y\u2081.val)\n\ndef noOverlap (r\u2081 r\u2082 : GridRectangle) : Prop :=\n  r\u2081.x\u2082.val \u2264 r\u2082.x\u2081.val \u2228 r\u2082.x\u2082.val \u2264 r\u2081.x\u2081.val \u2228\n  r\u2081.y\u2082.val \u2264 r\u2082.y\u2081.val \u2228 r\u2082.y\u2082.val \u2264 r\u2081.y\u2081.val\n\ndef coversSquare (rects : List GridRectangle) : Prop :=\n  \u2200 x y : Fin 6, \u2203 r \u2208 rects,\n    r.x\u2081.val \u2264 x.val \u2227 x.val < r.x\u2082.val \u2227\n    r.y\u2081.val \u2264 y.val \u2227 y.val < r.y\u2082.val\n\ndef validPartition (rects : List GridRectangle) : Prop :=\n  rects.length = 8 \u2227\n  List.Pairwise noOverlap rects \u2227\n  (List.map area rects).sum = 36 \u2227\n  coversSquare rects\n\ntheorem square_partition_equal_rectangles :\n  \u2200 (rects : List GridRectangle),\n    validPartition rects \u2192\n    \u2203 (r\u2081 r\u2082 : GridRectangle), r\u2081 \u2208 rects \u2227 r\u2082 \u2208 rects \u2227 r\u2081 \u2260 r\u2082 \u2227 area r\u2081 = area r\u2082 :=\n  sorry", "compiled": true, "aligned": true}
{"id": "CombStruct4Lean_103", "informal_problem": "8.5. In a large aviary, there are a hundred parakeets. At some point, it turned out that each of them had pecked exactly five other parakeets from this aviary during their lifetime. Prove that it is possible to release ten such parakeets into the wild, so that none of them had pecked each other.", "formal_statement": "import Mathlib\n\nstructure Aviary where\n  pecking : Fin 100 \u2192 Finset (Fin 100)  -- Set of parakeets pecked by each parakeet\n  pecks_count : \u2200 i, (pecking i).card = 5\n  no_self_peck : \u2200 i, i \u2209 pecking i\n\ntheorem parakeet_release (av : Aviary) : \n  \u2203 (S : Finset (Fin 100)), \n    S.card = 10 \u2227 \n    \u2200 i \u2208 S, \u2200 j \u2208 S, i \u2260 j \u2192 j \u2209 av.pecking i :=\n  sorry", "formal_statement_pred": "import Mathlib\n\nstructure Aviary where\n  pecked : Fin 100 \u2192 Finset (Fin 100)\n  pecked_count : \u2200 b, (pecked b).card = 5\n  no_self_peck : \u2200 b, b \u2209 pecked b\n  asymmetric_peck : \u2200 b\u2081 b\u2082, b\u2082 \u2208 pecked b\u2081 \u2192 b\u2081 \u2209 pecked b\u2082\n\n\ndef compatible (A : Aviary) (b\u2081 b\u2082 : Fin 100) : Prop :=\n  b\u2081 \u2209 A.pecked b\u2082 \u2227 b\u2082 \u2209 A.pecked b\u2081\n\ntheorem parakeet_release :\n  \u2200 (A : Aviary), \u2203 (release : Finset (Fin 100)),\n    release.card = 10 \u2227\n    \u2200 b\u2081 b\u2082, b\u2081 \u2208 release \u2192 b\u2082 \u2208 release \u2192 b\u2081 \u2260 b\u2082 \u2192 compatible A b\u2081 b\u2082 :=\n  sorry", "compiled": true, "aligned": true}
{"id": "CombStruct4Lean_104", "informal_problem": "7.2. Can a plane be painted in 2016 colors in such a way that among the vertices of any triangle, there will be at least two different colors?", "formal_statement": "import Mathlib\n\n/-- A coloring of the plane using n colors -/\nstructure ColoredPlane (n : \u2115) where\n  coloring : \u211d \u00d7 \u211d \u2192 Fin n\n\n/-- Three points form a triangle if they are distinct and not collinear -/\ndef isTriangle (p1 p2 p3 : \u211d \u00d7 \u211d) : Prop :=\n  p1 \u2260 p2 \u2227 p2 \u2260 p3 \u2227 p1 \u2260 p3 \u2227 \n  \u00ac(\u2203 (t : \u211d), (\n    ((1 - t) * p1.1 + t * p2.1 = p3.1) \u2227 \n    ((1 - t) * p1.2 + t * p2.2 = p3.2)))\n\ntheorem plane_coloring_exists : \n  \u2203 (c : ColoredPlane 2016), \n    \u2200 (p1 p2 p3 : \u211d \u00d7 \u211d), isTriangle p1 p2 p3 \u2192 \n      c.coloring p1 \u2260 c.coloring p2 \u2228 \n      c.coloring p2 \u2260 c.coloring p3 \u2228 \n      c.coloring p1 \u2260 c.coloring p3 :=\n  sorry", "formal_statement_pred": "import Mathlib\n\nstructure ColoredPlane where\n  coloring : \u211d \u00d7 \u211d \u2192 Fin 2016\n\n\ndef isTriangle (p\u2081 p\u2082 p\u2083 : \u211d \u00d7 \u211d) : Prop :=\n  p\u2081 \u2260 p\u2082 \u2227 p\u2082 \u2260 p\u2083 \u2227 p\u2081 \u2260 p\u2083 \u2227\n  \u00ac(\u2203 (t : \u211d), (1 - t) * p\u2081.1 + t * p\u2082.1 = p\u2083.1 \u2227\n                (1 - t) * p\u2081.2 + t * p\u2082.2 = p\u2083.2)\n\ntheorem exists_valid_coloring :\n  \u2203 (c : ColoredPlane), \u2200 (p\u2081 p\u2082 p\u2083 : \u211d \u00d7 \u211d),\n    isTriangle p\u2081 p\u2082 p\u2083 \u2192\n    \u2203 (i j : Fin 2016), i \u2260 j \u2227\n      (c.coloring p\u2081 = i \u2227 c.coloring p\u2082 = j \u2228\n       c.coloring p\u2082 = i \u2227 c.coloring p\u2083 = j \u2228\n       c.coloring p\u2081 = i \u2227 c.coloring p\u2083 = j) :=\n  sorry", "compiled": true, "aligned": true}
{"id": "CombStruct4Lean_106", "informal_problem": "7.5. Ten girls each had ten envelopes. Each girl signed and sent some envelopes to other girls (an envelope cannot be signed twice). As a result, each girl ended up with a different number of envelopes. Prove that at least one girl ended up with more envelopes than she sent out.", "formal_statement": "import Mathlib\n\nstructure EnvelopeExchange (n : Nat) where\n  sent : Fin n \u2192 Nat\n  received : Fin n \u2192 Nat\n  /-- Each girl starts with n envelopes and can't send more than that -/\n  initial_bound : \u2200 i, sent i \u2264 n\n  /-- Each girl receives a different number of envelopes -/\n  distinct_received : \u2200 i j, i \u2260 j \u2192 received i \u2260 received j\n  /-- Conservation of envelopes: total sent equals total received -/\n  conservation : (\u2211 i, sent i) = (\u2211 i, received i)\n\ntheorem envelope_distribution_inequality {n : Nat} (h : n = 10) (e : EnvelopeExchange n) :\n  \u2203 i, e.received i > e.sent i :=\n  sorry", "formal_statement_pred": "import Mathlib\n\nopen Finset\n\nstructure EnvelopeExchange where\n\n  exchanges : Fin 10 \u2192 Fin 10 \u2192 Bool\n\n  total_sent_bound : \u2200 i, (\u2211 j in univ, if exchanges i j then 1 else 0) \u2264 10\n\n  no_self_send : \u2200 i, exchanges i i = false\n\n  distinct_received : \u2200 i j, i \u2260 j \u2192\n    (\u2211 k in univ, if exchanges k i then 1 else 0) \u2260\n    (\u2211 k in univ, if exchanges k j then 1 else 0)\n\n\ndef EnvelopeExchange.received (e : EnvelopeExchange) (i : Fin 10) : \u2115 :=\n  \u2211 k in (univ : Finset (Fin 10)), if e.exchanges k i then 1 else 0\n\n\ndef EnvelopeExchange.sent (e : EnvelopeExchange) (i : Fin 10) : \u2115 :=\n  \u2211 k in (univ : Finset (Fin 10)), if e.exchanges i k then 1 else 0\n\ntheorem envelope_pigeonhole (e : EnvelopeExchange) :\n  \u2203 i : Fin 10, e.received i > e.sent i :=\n  sorry", "compiled": true, "aligned": true}
{"id": "CombStruct4Lean_107", "informal_problem": "7.5. In a club, 50 schoolchildren attended, who sometimes came to classes. It turned out that any two schoolchildren met at some class exactly once. In addition, it is known that not all schoolchildren came to any class at the same time. Prove that there is a schoolchild who attended at least 8 classes.", "formal_statement": "import Mathlib\n\nstructure SchoolMeetings where\n  n : Nat                                     -- total number of children\n  pos_n : 0 < n                              -- number of children is positive\n  classes : Finset (Finset (Fin n))          -- set of classes (finite)\n  nonempty_classes : \u2200 c \u2208 classes, \n    \u2203 i j : Fin n, i \u2260 j \u2227 i \u2208 c \u2227 j \u2208 c    -- each class has at least 2 students\n  meets_once : \u2200 (i j : Fin n), i \u2260 j \u2192 \n    \u2203! c \u2208 classes, i \u2208 c \u2227 j \u2208 c           -- any two children meet exactly once\n  not_all_together : \u2200 c \u2208 classes, \n    \u2203 (i : Fin n), i \u2209 c                     -- not all children attend any single class\n\n/-- Number of classes a student attends -/\ndef attendance_count (s : SchoolMeetings) (i : Fin s.n) : Nat :=\n  (s.classes.filter (fun c => i \u2208 c)).card\n\ntheorem school_meetings_min_attendance \n  (s : SchoolMeetings) (h : s.n = 50) :\n  \u2203 (i : Fin s.n), attendance_count s i \u2265 8 :=\n  sorry", "formal_statement_pred": "import Mathlib\n\n\nstructure SchoolClub where\n  n : Nat\n  h_size : n = 50\n  classes : Finset (Finset (Fin n))\n  met_once : \u2200 (i j : Fin n), i \u2260 j \u2192\n    \u2203! c \u2208 classes, i \u2208 c \u2227 j \u2208 c\n  not_all_together : \u2200 c \u2208 classes, \u2203 i : Fin n, i \u2209 c\n\n\ndef attendance_count (club : SchoolClub) (i : Fin club.n) : Nat :=\n  (club.classes.filter (fun c => i \u2208 c)).card\n\ntheorem school_club_attendance (club : SchoolClub) :\n  \u2203 i : Fin club.n, attendance_count club i \u2265 8 :=\n  sorry", "compiled": true, "aligned": true}
{"id": "CombStruct4Lean_108", "informal_problem": "8.5. After a successful train robbery, 102 bandits divided the obtained rubies, sapphires, and emeralds in such a way that each of them received exactly 100 precious stones in total. Prove that at least one of the following two statements is true:\n\n- There are two bandits who have the same number of rubies, sapphires, and emeralds;\n- There are two bandits who have a different number of rubies, sapphires, and emeralds.", "formal_statement": "import Mathlib\n\nstructure Bandit where\n  rubies : Nat\n  sapphires : Nat\n  emeralds : Nat\n  total_is_100 : rubies + sapphires + emeralds = 100\n\n/-- Returns true if two bandits have exactly the same distribution of stones -/\ndef same_distribution (b1 b2 : Bandit) : Bool :=\n  b1.rubies = b2.rubies \u2227 b1.sapphires = b2.sapphires \u2227 b1.emeralds = b2.emeralds\n\n/-- Returns true if two bandits have completely different distributions of stones -/\ndef different_distribution (b1 b2 : Bandit) : Bool :=\n  b1.rubies \u2260 b2.rubies \u2227 b1.sapphires \u2260 b2.sapphires \u2227 b1.emeralds \u2260 b2.emeralds\n\ntheorem bandit_distribution_property (bandits : Fin 102 \u2192 Bandit) :\n  (\u2203 i j : Fin 102, i \u2260 j \u2227 same_distribution (bandits i) (bandits j)) \u2228\n  (\u2203 i j : Fin 102, i \u2260 j \u2227 different_distribution (bandits i) (bandits j)) :=\n  sorry", "formal_statement_pred": "import Mathlib\n\nstructure Bandit where\n  rubies : Nat\n  sapphires : Nat\n  emeralds : Nat\n  total_is_100 : rubies + sapphires + emeralds = 100\n\n\ndef same_distribution (b1 b2 : Bandit) : Bool :=\n  b1.rubies = b2.rubies \u2227 b1.sapphires = b2.sapphires \u2227 b1.emeralds = b2.emeralds\n\n\ndef different_distribution (b1 b2 : Bandit) : Bool :=\n  b1.rubies \u2260 b2.rubies \u2228 b1.sapphires \u2260 b2.sapphires \u2228 b1.emeralds \u2260 b2.emeralds\n\ntheorem bandit_distribution_property (bandits : Fin 102 \u2192 Bandit) :\n  (\u2203 i j : Fin 102, i \u2260 j \u2227 same_distribution (bandits i) (bandits j)) \u2228\n  (\u2203 i j : Fin 102, i \u2260 j \u2227 different_distribution (bandits i) (bandits j)) :=\n  sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_109", "informal_problem": "9. Two friendly series (from 8th grade, 2 points). Two football teams A and B play football equally well. The coaches agreed on two friendly matches. A team is awarded 2 points for a win, 1 point for a draw, and 0 points for a loss. The probability of a draw in each match is the same and equal to $p$.\n\nThe following year, a similar friendly series of two matches took place. The teams played with the same lineup, they were still equally strong, but the probability $p$ increased. Can we assert that the probability that the teams will score the same number of points has increased?", "formal_statement": "import Mathlib\n\n/-- Represents the outcome from one team's perspective -/\ninductive MatchOutcome\n  | Win \n  | Draw\n  | Loss\n\n/-- Points awarded for each match outcome -/\ndef matchPoints (result : MatchOutcome) : Real :=\n  match result with\n  | MatchOutcome.Win => 2\n  | MatchOutcome.Draw => 1\n  | MatchOutcome.Loss => 0\n\n/-- Represents a series of two matches from one team's perspective -/\nstructure TwoMatchSeries where\n  match1 : MatchOutcome\n  match2 : MatchOutcome\n\n/-- Total points for a team in a series -/\ndef totalPoints (series : TwoMatchSeries) : Real :=\n  matchPoints series.match1 + matchPoints series.match2\n\n/-- Probability of equal points given draw probability p -/\nnoncomputable def equalPointsProb (p : Real) : Real :=\n  let drawProb := p\n  let winProb := (1 - p) / 2\n  -- Probability of two draws\n  p * p +\n  -- Probability of win-loss or loss-win (both give equal points)\n  2 * winProb * winProb\n\ntheorem equal_points_prob_decreasing_exists\n  {p\u2081 p\u2082 : Real} (h\u2081 : 0 \u2264 p\u2081) (h\u2082 : p\u2081 < p\u2082) (h\u2083 : p\u2082 \u2264 1) :\n  equalPointsProb p\u2082 < equalPointsProb p\u2081 :=\n  sorry", "formal_statement_pred": "import Mathlib\n\n\ninductive MatchResult\n  | Win\n  | Draw\n  | Loss\n\n\ndef points (result : MatchResult) : Nat :=\n  match result with\n  | MatchResult.Win => 2\n  | MatchResult.Draw => 1\n  | MatchResult.Loss => 0\n\n\nstructure TwoMatchSeries where\n  match1 : MatchResult\n  match2 : MatchResult\n  p : Real\n  h_p_valid : 0 \u2264 p \u2227 p \u2264 1\n\n\ndef totalPoints (series : TwoMatchSeries) : Nat :=\n  points series.match1 + points series.match2\n\n\ndef equalPointsProbability (p : Real) : Real :=\n  sorry\n\ntheorem equal_points_probability_not_monotonic :\n  \u2203 p\u2081 p\u2082 : Real,\n    0 \u2264 p\u2081 \u2227 p\u2081 < p\u2082 \u2227 p\u2082 \u2264 1 \u2227\n    equalPointsProbability p\u2081 > equalPointsProbability p\u2082 :=\n  sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_112", "informal_problem": "2. Seven children met. Some of them gave gifts to some others (one could not give more than one gift to another). Could it have turned out that everyone received an equal number of gifts, even though they all gave different numbers of gifts (including possibly someone giving no gifts at all)?", "formal_statement": "import Mathlib\nopen Matrix\n\nstructure GiftExchange where\n  n : Nat\n  gifts : Matrix (Fin n) (Fin n) Bool\n\ndef valid_exchange (ge : GiftExchange) : Prop :=\n  \u2200 i : Fin ge.n, ge.gifts i i = false  -- no self-gifts\n\ndef gifts_given (ge : GiftExchange) (i : Fin ge.n) : Nat :=\n  Finset.sum Finset.univ fun j => if ge.gifts i j then 1 else 0\n\ndef gifts_received (ge : GiftExchange) (j : Fin ge.n) : Nat :=\n  Finset.sum Finset.univ fun i => if ge.gifts i j then 1 else 0\n\ndef all_received_equal (ge : GiftExchange) : Prop :=\n  \u2200 i j : Fin ge.n, gifts_received ge i = gifts_received ge j\n\ndef all_gave_different (ge : GiftExchange) : Prop :=\n  \u2200 i j : Fin ge.n, i \u2260 j \u2192 gifts_given ge i \u2260 gifts_given ge j\n\ntheorem gift_exchange_possible : \u2203 (ge : GiftExchange), \n  ge.n = 7 \u2227 \n  valid_exchange ge \u2227\n  all_received_equal ge \u2227\n  all_gave_different ge :=\n  sorry", "formal_statement_pred": "import Mathlib\nimport Mathlib.Data.Matrix.Basic\nimport Mathlib.Data.Fin.Basic\n\nstructure GiftExchange (n : Nat) where\n  gifts : Matrix (Fin n) (Fin n) Bool\n  no_self_gifts : \u2200 i, gifts i i = false\n\ndef gifts_given {n : Nat} (ge : GiftExchange n) (i : Fin n) : Nat :=\n  Finset.sum Finset.univ fun j => if ge.gifts i j then 1 else 0\n\ndef gifts_received {n : Nat} (ge : GiftExchange n) (j : Fin n) : Nat :=\n  Finset.sum Finset.univ fun i => if ge.gifts i j then 1 else 0\n\ntheorem gift_exchange_possible : \u2203 (ge : GiftExchange 7),\n  (\u2200 i j : Fin 7, i \u2260 j \u2192 gifts_given ge i \u2260 gifts_given ge j) \u2227\n  (\u2200 i j : Fin 7, gifts_received ge i = gifts_received ge j)\n  :=\n  sorry", "compiled": true, "aligned": true}
{"id": "CombStruct4Lean_114", "informal_problem": "5. In the cells of a $9 \\times 9$ table, odd integers are written. It is allowed to simultaneously change the sign of all numbers in some row or some column. Prove that using several such operations, one can arrive at a table where the sums of the numbers in any row and any column are positive.", "formal_statement": "import Mathlib\n\nstructure SignChangeTable where\n  -- The table is represented as a 9\u00d79 matrix of integers\n  entries : Matrix (Fin 9) (Fin 9) Int\n  -- All entries are odd numbers\n  odd_entries : \u2200 i j, Odd (entries i j)\n\n/-- Represents a sequence of row and column sign changes -/\nstructure SignChanges where\n  -- For each row/column, true means we flip signs, false means we don't\n  row_changes : Fin 9 \u2192 Bool\n  col_changes : Fin 9 \u2192 Bool\n\n/-- Apply sign changes to a table -/\ndef applyChanges (t : SignChangeTable) (changes : SignChanges) : Matrix (Fin 9) (Fin 9) Int :=\n  fun i j => \n    let sign := if changes.row_changes i = changes.col_changes j then 1 else -1\n    sign * t.entries i j\n\n/-- Sum of numbers in a row after applying changes -/\ndef rowSum (t : SignChangeTable) (changes : SignChanges) (i : Fin 9) : Int :=\n  (Finset.univ.sum fun j => (applyChanges t changes i j))\n\n/-- Sum of numbers in a column after applying changes -/\ndef colSum (t : SignChangeTable) (changes : SignChanges) (j : Fin 9) : Int :=\n  (Finset.univ.sum fun i => (applyChanges t changes i j))\n\ntheorem exists_positive_sums (t : SignChangeTable) : \n  \u2203 (changes : SignChanges),\n    (\u2200 i : Fin 9, rowSum t changes i > 0) \u2227 \n    (\u2200 j : Fin 9, colSum t changes j > 0) :=\n  sorry", "formal_statement_pred": "import Mathlib\n\nstructure SignChangeTable where\n\n  entries : (Fin 9 \u00d7 Fin 9) \u2192 Int\n\n  odd_entries : \u2200 (i j : Fin 9), Odd (entries (i, j))\n\n\nstructure SignChanges where\n\n  row_changes : Fin 9 \u2192 Bool\n  col_changes : Fin 9 \u2192 Bool\n\n\ndef apply_changes (t : SignChangeTable) (c : SignChanges) : SignChangeTable where\n  entries := fun (i, j) =>\n    let sign := if c.row_changes i = c.col_changes j then 1 else -1\n    sign * t.entries (i, j)\n  odd_entries := sorry\n\ntheorem table_positive_sums_exist (t : SignChangeTable) :\n  \u2203 (c : SignChanges),\n\n    (\u2200 i : Fin 9,\n      (\u2211 j : Fin 9, (apply_changes t c).entries (i, j)) > 0) \u2227\n\n    (\u2200 j : Fin 9,\n      (\u2211 i : Fin 9, (apply_changes t c).entries (i, j)) > 0) :=\n  sorry", "compiled": true, "aligned": true}
{"id": "CombStruct4Lean_115", "informal_problem": "5. In a regular 2015-gon, 64 vertices are marked. Prove that among them there exist four points that are the vertices of some trapezoid.", "formal_statement": "import Mathlib\n\n/-- A point in 2D space -/\nstructure Point where\n  x : \u211d \n  y : \u211d\n\n/-- A regular polygon with marked vertices -/\nstructure RegularPolygon where\n  n : \u2115 \n  vertices : Fin n \u2192 Point\n  marked : Finset (Fin n)\n  is_regular : \u2200 i j : Fin n,\n    -- All vertices are equidistant from origin\n    (vertices i).x ^ 2 + (vertices i).y ^ 2 = \n    (vertices j).x ^ 2 + (vertices j).y ^ 2\n    \n/-- Determines if four points form a trapezoid by checking if at least one pair\n    of opposite sides is parallel (using slope equality) -/\ndef FormsTrapezoid (p\u2081 p\u2082 p\u2083 p\u2084 : Point) : Prop :=\n  let slope (p q : Point) := (q.y - p.y) / (q.x - p.x)\n  slope p\u2081 p\u2082 = slope p\u2083 p\u2084 \u2228 slope p\u2081 p\u2084 = slope p\u2082 p\u2083\n\ntheorem marked_vertices_form_trapezoid \n  (p : RegularPolygon)\n  (h\u2081 : p.n = 2015)\n  (h\u2082 : p.marked.card = 64) :\n  \u2203 (v\u2081 v\u2082 v\u2083 v\u2084 : Fin p.n),\n    v\u2081 \u2208 p.marked \u2227 v\u2082 \u2208 p.marked \u2227 v\u2083 \u2208 p.marked \u2227 v\u2084 \u2208 p.marked \u2227\n    FormsTrapezoid (p.vertices v\u2081) (p.vertices v\u2082) (p.vertices v\u2083) (p.vertices v\u2084) :=\n  sorry", "formal_statement_pred": "import Mathlib\n\n\nstructure RegularPolygonPoints where\n  n : Nat\n  marked : Finset (Fin n)\n  h_n : n = 2015\n  h_marked : marked.card = 64\n\n\ndef centralAngle (n : Nat) (v\u2081 v\u2082 : Fin n) : Nat :=\n  min ((v\u2082 - v\u2081 : Nat) % n) ((v\u2081 - v\u2082 : Nat) % n)\n\n\ndef areParallel (n : Nat) (v\u2081 v\u2082 v\u2083 v\u2084 : Fin n) : Prop :=\n  centralAngle n v\u2081 v\u2082 = centralAngle n v\u2083 v\u2084\n\n\ndef isTrapezoid (n : Nat) (v\u2081 v\u2082 v\u2083 v\u2084 : Fin n) : Prop :=\n  v\u2081 \u2260 v\u2082 \u2227 v\u2082 \u2260 v\u2083 \u2227 v\u2083 \u2260 v\u2084 \u2227 v\u2084 \u2260 v\u2081 \u2227\n  ((areParallel n v\u2081 v\u2082 v\u2083 v\u2084) \u2228 (areParallel n v\u2082 v\u2083 v\u2084 v\u2081))\n\ntheorem regular_polygon_trapezoid\n  (P : RegularPolygonPoints) :\n  \u2203 (v\u2081 v\u2082 v\u2083 v\u2084 : Fin P.n),\n    v\u2081 \u2208 P.marked \u2227\n    v\u2082 \u2208 P.marked \u2227\n    v\u2083 \u2208 P.marked \u2227\n    v\u2084 \u2208 P.marked \u2227\n    isTrapezoid P.n v\u2081 v\u2082 v\u2083 v\u2084 :=\n  sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_116", "informal_problem": "4. Can rectangular parallelepipeds of size $2 \\times 2 \\times 1$ be used to form a rectangular parallelepiped of size $3 \\times 4 \\times 5$? Don't forget to justify your answer.", "formal_statement": "import Mathlib\n\nstructure Block where\n  width : Nat\n  length : Nat\n  height : Nat\n\n/-- A tiling represents a way to fill a larger block with smaller blocks -/\nstructure Tiling where\n  target : Block  -- The block we want to fill\n  piece : Block   -- The block we use for filling\n  possible : Bool -- Whether such tiling exists\n\ntheorem rectangular_parallelepiped_tiling_impossible : \n  let small_block := Block.mk 2 2 1\n  let large_block := Block.mk 3 4 5\n  let tiling := Tiling.mk large_block small_block false\n  tiling.possible = false :=\n  sorry", "formal_statement_pred": "import Mathlib\n\nstructure Block where\n  length : Nat\n  width : Nat\n  height : Nat\n\n\nstructure Packing where\n  target : Block\n  piece : Block\n  exists_valid_packing : Bool\n\ntheorem no_valid_packing_3_4_5 :\n  let target : Block := \u27e83, 4, 5\u27e9\n  let piece : Block := \u27e82, 2, 1\u27e9\n  let packing : Packing := \u27e8target, piece, true\u27e9\n  \u00ac packing.exists_valid_packing :=\n  sorry", "compiled": true, "aligned": true}
{"id": "CombStruct4Lean_117", "informal_problem": "5. Thirteen girls and thirteen boys participated in a math competition. Each participant solved no more than four problems. For any girl and boy, there is at least one problem solved by both. Prove that there was a problem solved by no fewer than three girls and no fewer than three boys.", "formal_statement": "import Mathlib\n\nstructure Competition (n : \u2115) where\n  girlSolved : Fin 13 \u2192 Finset (Fin n)\n  boySolved : Fin 13 \u2192 Finset (Fin n)\n  atMostFour : \u2200 x : Fin 13, (girlSolved x).card \u2264 4 \u2227 (boySolved x).card \u2264 4\n  commonProblem : \u2200 (g b : Fin 13), \u2203 p : Fin n, p \u2208 girlSolved g \u2229 boySolved b\n\ntheorem competition_problem {n : \u2115} (comp : Competition n) :\n  \u2203 p : Fin n, \n    (Finset.filter (fun g => p \u2208 comp.girlSolved g) (Finset.univ : Finset (Fin 13))).card \u2265 3 \u2227 \n    (Finset.filter (fun b => p \u2208 comp.boySolved b) (Finset.univ : Finset (Fin 13))).card \u2265 3 :=\n  sorry", "formal_statement_pred": "import Mathlib\n\nstructure Competition (numProblems : \u2115) where\n\n  solved : Fin 13 \u00d7 Bool \u2192 Finset (Fin numProblems)\n\n  atMostFour : \u2200 p, (solved p).card \u2264 4\n\n  sharedProblem : \u2200 g b, \u2203 p, p \u2208 solved (g, true) \u2227 p \u2208 solved (b, false)\n\ntheorem competition_problem {n : \u2115} (comp : Competition n) :\n  \u2203 p : Fin n,\n    (Finset.filter (fun g => p \u2208 comp.solved (g, true)) (Finset.univ : Finset (Fin 13))).card \u2265 3 \u2227\n    (Finset.filter (fun b => p \u2208 comp.solved (b, false)) (Finset.univ : Finset (Fin 13))).card \u2265 3 :=\n  sorry", "compiled": true, "aligned": true}
{"id": "CombStruct4Lean_118", "informal_problem": "7.2 In the class, there are 33 students, and the sum of their ages is 430 years. Prove that there are 20 students in the class whose sum of ages is greater than 260 years.", "formal_statement": "import Mathlib\n\nstructure ClassInfo where\n  students : Finset Nat\n  ages : Nat \u2192 Nat\n  student_count : students.card = 33\n  total_age : (\u2211 i in students, ages i) = 430\n\ntheorem exists_twenty_students_sum_over_260 (c : ClassInfo) :\n  \u2203 (subset : Finset Nat), subset \u2286 c.students \u2227 subset.card = 20 \u2227 \n    (\u2211 i in subset, c.ages i) > 260 :=\n  sorry", "formal_statement_pred": "import Mathlib\n\nstructure ClassInfo where\n  students : List Nat\n  student_count : students.length = 33\n  age_sum : students.sum = 430\n  ages_positive : \u2200 a \u2208 students, a > 0\n\ntheorem exists_twenty_students_sum_over_260 (c : ClassInfo) :\n  \u2203 (subset : List Nat), subset.toFinset \u2286 c.students.toFinset \u2227\n    subset.length = 20 \u2227 subset.sum > 260 :=\n  sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_119", "informal_problem": "3. Potatoes and beets are transported on 79 trucks, not necessarily identical, with each truck loaded either with potatoes or beets. Prove that it is possible to select 40 trucks from these such that they transport no less than $50 \\%$ of all the potatoes and no less than $50 \\%$ of all the beets.", "formal_statement": "import Mathlib\n\nstructure TruckLoad where\n  isPotato : Bool  -- true if truck carries potatoes, false if beets\n  amount : \u211d       -- amount of cargo\n  amount_pos : amount > 0\n\n/-- Total amount of potatoes in a collection of trucks -/\ndef totalPotatoes (trucks : List TruckLoad) : \u211d :=\n  (trucks.filter (\u00b7.isPotato)).map (\u00b7.amount) |>.sum\n\n/-- Total amount of beets in a collection of trucks -/\ndef totalBeets (trucks : List TruckLoad) : \u211d :=\n  (trucks.filter (fun t \u21a6 !t.isPotato)).map (\u00b7.amount) |>.sum\n\ntheorem truck_selection_exists (trucks : List TruckLoad) \n  (h_count : trucks.length = 79) :\n  \u2203 (selected : List TruckLoad),\n    selected.length = 40 \u2227 \n    selected.Subset trucks \u2227\n    totalPotatoes selected \u2265 (totalPotatoes trucks) / 2 \u2227\n    totalBeets selected \u2265 (totalBeets trucks) / 2 :=\n  sorry", "formal_statement_pred": "import Mathlib\n\ninductive CargoType\n| Potatoes (amount : \u211d)\n| Beets (amount : \u211d)\n\nstructure TruckLoad where\n  cargo : CargoType\n  amount_nonneg : match cargo with\n    | CargoType.Potatoes amt => amt \u2265 0\n    | CargoType.Beets amt => amt \u2265 0\n\ndef total_potatoes (trucks : Finset TruckLoad) : \u211d :=\n  trucks.sum (\u03bb t => match t.cargo with\n    | CargoType.Potatoes amt => amt\n    | CargoType.Beets _ => 0)\n\ndef total_beets (trucks : Finset TruckLoad) : \u211d :=\n  trucks.sum (\u03bb t => match t.cargo with\n    | CargoType.Potatoes _ => 0\n    | CargoType.Beets amt => amt)\n\ntheorem truck_selection_theorem\n  (trucks : Finset TruckLoad)\n  (h1 : trucks.card = 79)\n  (h2 : total_potatoes trucks > 0)\n  (h3 : total_beets trucks > 0) :\n  \u2203 selected : Finset TruckLoad,\n    selected \u2286 trucks \u2227\n    selected.card = 40 \u2227\n    total_potatoes selected \u2265 total_potatoes trucks / 2 \u2227\n    total_beets selected \u2265 total_beets trucks / 2 :=\n  sorry", "compiled": true, "aligned": true}
{"id": "CombStruct4Lean_120", "informal_problem": "5. Each point of the plane is painted in one of three colors, and all three colors are used. Is it true that for any such coloring, one can choose a circle on which there are points of all three colors?", "formal_statement": "import Mathlib\n\n-- Define a coloring of the plane as a function from \u211d \u00d7 \u211d to a three-element type\nstructure ThreeColoring where\n  color : \u211d \u00d7 \u211d \u2192 Fin 3\n  all_colors_used : \u2200 (i : Fin 3), \u2203 (p : \u211d \u00d7 \u211d), color p = i\n\n-- Define what it means for a point to lie on a circle\ndef OnCircle (p : \u211d \u00d7 \u211d) (center : \u211d \u00d7 \u211d) (radius : \u211d) : Prop :=\n  (p.1 - center.1)^2 + (p.2 - center.2)^2 = radius^2\n\ntheorem three_color_circle_existence (coloring : ThreeColoring) :\n  \u2203 (center : \u211d \u00d7 \u211d) (radius : \u211d),\n    \u2200 (i : Fin 3), \u2203 (p : \u211d \u00d7 \u211d), \n      OnCircle p center radius \u2227 coloring.color p = i :=\n  sorry", "formal_statement_pred": "import Mathlib\n\n\ninductive Color where\n  | red : Color\n  | blue : Color\n  | green : Color\n\n\ndef PlaneColoring := \u211d \u00d7 \u211d \u2192 Color\n\n\nstructure Circle where\n  center : \u211d \u00d7 \u211d\n  radius : \u211d\n  radius_pos : radius > 0\n\n\ndef lieOnCircle (c : Circle) (p : \u211d \u00d7 \u211d) : Prop :=\n  (p.1 - c.center.1)^2 + (p.2 - c.center.2)^2 = c.radius^2\n\n\ndef colorAppearsOnCircle (col : Color) (c : Circle) (f : PlaneColoring) : Prop :=\n  \u2203 p : \u211d \u00d7 \u211d, lieOnCircle c p \u2227 f p = col\n\ntheorem three_color_circle_existence\n  (f : PlaneColoring)\n  (h_red : \u2203 p, f p = Color.red)\n  (h_blue : \u2203 p, f p = Color.blue)\n  (h_green : \u2203 p, f p = Color.green) :\n  \u2203 c : Circle,\n    colorAppearsOnCircle Color.red c f \u2227\n    colorAppearsOnCircle Color.blue c f \u2227\n    colorAppearsOnCircle Color.green c f :=\n  sorry", "compiled": true, "aligned": true}
{"id": "CombStruct4Lean_121", "informal_problem": "9.3. Can a $12 \\times 12$ checkerboard be divided into corners made of three adjacent cells $\\square$ such that each horizontal and each vertical row of cells on the board intersects the same number of corners? (A row intersects a corner if it contains at least one of its cells.)", "formal_statement": "import Mathlib\n\n/-- Represents the four possible orientations of a corner -/\ninductive CornerOrientation\n  | TopLeft    -- \u231c\n  | TopRight   -- \u231d\n  | BottomLeft -- \u231e\n  | BottomRight -- \u231f\n\n/-- A corner on the 12\u00d712 checkerboard consisting of three adjacent cells -/\nstructure Corner where\n  x : Fin 12      -- x-coordinate of the base cell\n  y : Fin 12      -- y-coordinate of the base cell\n  orientation : CornerOrientation\n\n/-- Predicate indicating whether a given position is part of the corner -/\ndef isInCorner (c : Corner) (x y : Fin 12) : Bool :=\n  match c.orientation with\n  | CornerOrientation.TopLeft => \n      (x = c.x && y = c.y) || \n      (x = c.x && y = c.y + 1) || \n      (x = c.x + 1 && y = c.y)\n  | CornerOrientation.TopRight => \n      (x = c.x && y = c.y) || \n      (x = c.x && y = c.y + 1) || \n      (x = c.x - 1 && y = c.y)\n  | CornerOrientation.BottomLeft => \n      (x = c.x && y = c.y) || \n      (x = c.x && y = c.y - 1) || \n      (x = c.x + 1 && y = c.y)\n  | CornerOrientation.BottomRight => \n      (x = c.x && y = c.y) || \n      (x = c.x && y = c.y - 1) || \n      (x = c.x - 1 && y = c.y)\n\n/-- A valid corner placement is a set of corners that forms a partition -/\ndef isValidPlacement (corners : Finset Corner) : Bool :=\n  -- Every cell belongs to exactly one corner\n  (\u2200 x y : Fin 12, (corners.filter (fun c \u21a6 isInCorner c x y)).card = 1)\n\n/-- Number of corners intersecting a row -/\ndef rowIntersections (corners : Finset Corner) (row : Fin 12) : Nat :=\n  (corners.filter (fun c \u21a6 \u2203 x : Fin 12, isInCorner c x row)).card\n\n/-- Number of corners intersecting a column -/\ndef colIntersections (corners : Finset Corner) (col : Fin 12) : Nat :=\n  (corners.filter (fun c \u21a6 \u2203 y : Fin 12, isInCorner c col y)).card\n\ntheorem checkerboard_corner_partition_impossible :\n  \u00ac\u2203 (corners : Finset Corner),\n    isValidPlacement corners \u2227\n    \u2203 k : \u2115, \n      (\u2200 row : Fin 12, rowIntersections corners row = k) \u2227\n      (\u2200 col : Fin 12, colIntersections corners col = k) :=\n  sorry", "formal_statement_pred": "import Mathlib\n\nstructure Corner where\n  x : Fin 12\n  y : Fin 12\n  orientation : Fin 4\n\n\ndef isValidCorner (c : Corner) : Bool :=\n  match c.orientation with\n  | 0 => c.x < 11 \u2227 c.y < 11\n  | 1 => c.x < 11 \u2227 c.y > 0\n  | 2 => c.x > 0 \u2227 c.y < 11\n  | 3 => c.x > 0 \u2227 c.y > 0\n\n\ndef intersectsRow (c : Corner) (row : Fin 12) : Bool := sorry\n\ndef intersectsCol (c : Corner) (col : Fin 12) : Bool := sorry\n\n\ndef isValidTiling (corners : List Corner) : Bool := sorry\n\ntheorem checkerboard_corner_tiling_existence :\n  \u2203 (corners : List Corner),\n    isValidTiling corners \u2227\n    \u2200 (row col : Fin 12),\n      let rowIntersections := (corners.filter (fun c => intersectsRow c row)).length\n      let colIntersections := (corners.filter (fun c => intersectsCol c col)).length\n      \u2200 (row' col' : Fin 12),\n        rowIntersections = (corners.filter (fun c => intersectsRow c row')).length \u2227\n        colIntersections = (corners.filter (fun c => intersectsCol c col')).length :=\n  sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_123", "informal_problem": "6. Vasya has 19950 chips, painted in 200 different colors. He arranged them in a circle. Prove that there is such a pair of colors that the chips of these colors do not stand next to each other.", "formal_statement": "import Mathlib\n\nstructure ColoredChips where\n  numColors : Nat\n  totalChips : Nat\n  arrangement : Fin totalChips \u2192 Fin numColors\n  isCircular : True  -- Represents that chips are arranged in a circle\n\n/-- Two positions in the circular arrangement are adjacent -/\ndef areAdjacent (n : Nat) (i j : Fin n) : Bool :=\n  i.val + 1 = j.val \u2228 (i.val = n - 1 \u2227 j.val = 0)\n\ntheorem colored_chips_not_adjacent \n  (chips : ColoredChips)\n  (h1 : chips.totalChips = 19950)\n  (h2 : chips.numColors = 200) :\n  \u2203 (c1 c2 : Fin chips.numColors), \n    \u2200 (i j : Fin chips.totalChips), \n      areAdjacent chips.totalChips i j \u2192 \n        \u00ac(chips.arrangement i = c1 \u2227 chips.arrangement j = c2) :=\n  sorry", "formal_statement_pred": "import Mathlib\n\nstructure ColoredChips where\n  totalChips : Nat\n  numColors : Nat\n  arrangement : Fin totalChips \u2192 Fin numColors\n\n\ndef adjacentInCircle {n : Nat} (i j : Fin n) : Bool :=\n  (i.val + 1) % n = j.val \u2228 (j.val + 1) % n = i.val\n\ndef colorsAreAdjacent (chips : ColoredChips) (c1 c2 : Fin chips.numColors) : Bool :=\n  \u2203 i j : Fin chips.totalChips,\n    chips.arrangement i = c1 \u2227\n    chips.arrangement j = c2 \u2227\n    adjacentInCircle i j\n\ntheorem colored_chips_not_adjacent\n  (chips : ColoredChips)\n  (h1 : chips.totalChips = 19950)\n  (h2 : chips.numColors = 200) :\n  \u2203 c1 c2 : Fin chips.numColors,\n    c1 \u2260 c2 \u2227 \u00ac(colorsAreAdjacent chips c1 c2) :=\n  sorry", "compiled": true, "aligned": true}
{"id": "CombStruct4Lean_125", "informal_problem": "7.5. Prove that from any set of 15 positive integers, each of which does not exceed 2020, it is always possible to select two non-intersecting subsets with the same sums of the numbers in these subsets.", "formal_statement": "import Mathlib\n\nstructure DisjointSubsetsWithEqualSum (S : Finset Nat) where\n  subset1 : Finset Nat\n  subset2 : Finset Nat\n  nonempty1 : subset1.Nonempty\n  nonempty2 : subset2.Nonempty\n  disjoint : Disjoint subset1 subset2\n  subsets_valid : subset1 \u2286 S \u2227 subset2 \u2286 S\n  sums_equal : subset1.sum id = subset2.sum id\n\ntheorem exists_disjoint_equal_sum_subsets \n  (S : Finset Nat) \n  (card_S : S.card = 15)\n  (bounded : \u2200 n \u2208 S, n \u2264 2020) :\n  \u2203 (d : DisjointSubsetsWithEqualSum S), True :=\n  sorry", "formal_statement_pred": "import Mathlib\n\nstructure SubsetPair (S : Finset Nat) where\n  subset1 : Finset Nat\n  subset2 : Finset Nat\n  subset1_subset : subset1 \u2286 S\n  subset2_subset : subset2 \u2286 S\n  disjoint : Disjoint subset1 subset2\n  equal_sums : subset1.sum id = subset2.sum id\n  h_bound : \u2200 x \u2208 subset1 \u222a subset2, x \u2264 2020\n  h_positive : \u2200 x \u2208 subset1 \u222a subset2, 0 < x\n\ntheorem equal_sum_disjoint_subsets (S : Finset Nat)\n  (h_size : S.card = 15)\n  (h_bound : \u2200 x \u2208 S, x \u2264 2020)\n  (h_pos : \u2200 x \u2208 S, 0 < x) :\n  \u2203 p : SubsetPair S, True :=\n  sorry", "compiled": true, "aligned": true}
{"id": "CombStruct4Lean_126", "informal_problem": "10.3. In city $\\mathrm{N}$, 50 city olympiads in different subjects were held, with exactly 30 schoolchildren participating in each of these olympiads, but there were no two olympiads with the same set of participants. It is known that for any 30 olympiads, there is a schoolchild who participated in all these 30 olympiads. Prove that there is a schoolchild who participated in all 50 olympiads.\n\n(V. Dolnikov)", "formal_statement": "import Mathlib\n\nstructure OlympiadSystem where\n  numStudents : Nat\n  participants : Fin 50 \u2192 Finset (Fin numStudents)\n  -- Each olympiad has exactly 30 participants\n  size_constraint : \u2200 o : Fin 50, (participants o).card = 30\n  -- No two olympiads have the same set of participants\n  distinct_sets : \u2200 (o\u2081 o\u2082 : Fin 50), o\u2081 \u2260 o\u2082 \u2192 participants o\u2081 \u2260 participants o\u2082\n  -- For any 30 olympiads, there exists a student who participated in all of them\n  thirty_coverage : \u2200 (subset : Finset (Fin 50)), subset.card = 30 \u2192\n    \u2203 s : Fin numStudents, \u2200 o \u2208 subset, s \u2208 participants o\n\ntheorem olympiad_coverage (sys : OlympiadSystem) :\n  \u2203 s : Fin sys.numStudents, \u2200 o : Fin 50, s \u2208 sys.participants o :=\n  sorry", "formal_statement_pred": "import Mathlib\n\nstructure OlympiadSystem where\n\n  numOlympiads : Nat\n\n  numParticipants : Nat\n\n  participants : Fin numOlympiads \u2192 Finset (Fin numParticipants)\n\n  size_constraint : \u2200 o, (participants o).card = 30\n\n  distinct_sets : \u2200 o\u2081 o\u2082, o\u2081 \u2260 o\u2082 \u2192 participants o\u2081 \u2260 participants o\u2082\n\n  thirty_coverage : \u2200 (S : Finset (Fin numOlympiads)),\n    S.card = 30 \u2192 \u2203 p, \u2200 o \u2208 S, p \u2208 participants o\n\ntheorem city_olympiad_problem (sys : OlympiadSystem)\n  (h_num : sys.numOlympiads = 50) :\n  \u2203 p, \u2200 o, p \u2208 sys.participants o :=\n  sorry", "compiled": true, "aligned": true}
{"id": "CombStruct4Lean_127", "informal_problem": "9.1. In a round-robin chess tournament, six people participated: two boys and four girls. Could the boys have scored twice as many points as the girls by the end of the tournament? (In a round-robin chess tournament, each player plays one game against each of the others. A win earns 1 point, a draw 0.5, and a loss 0 points.)", "formal_statement": "import Mathlib\n\n/-- Tournament size -/\ndef n : Nat := 6\n/-- Number of boys -/\ndef num_boys : Nat := 2\n/-- Number of girls -/\ndef num_girls : Nat := 4\n\n/-- Player type enumeration -/\ninductive PlayerType where\n  | Boy\n  | Girl\nderiving Repr, DecidableEq\n\n/-- Core tournament data structure -/\nstructure TournamentData where\n  results : Fin n \u00d7 Fin n \u2192 Rat\n  player_type : Fin n \u2192 PlayerType\n\n/-- Predicate for valid tournament scores (0, 0.5, or 1) -/\ndef valid_scores (t : TournamentData) : Prop :=\n  \u2200 i j, t.results (i, j) = 0 \u2228 t.results (i, j) = (1/2) \u2228 t.results (i, j) = 1\n\n/-- Each pair plays exactly one game with total score 1 -/\ndef valid_games (t : TournamentData) : Prop :=\n  \u2200 i j, t.results (i, j) + t.results (j, i) = 1\n\n/-- No self-play allowed -/\ndef no_self_play (t : TournamentData) : Prop :=\n  \u2200 i, t.results (i, i) = 0\n\n/-- Correct number of players of each type -/\ndef valid_player_counts (t : TournamentData) : Prop :=\n  (Finset.filter (fun i => t.player_type i = PlayerType.Boy) (Finset.univ)).card = num_boys \u2227\n  (Finset.filter (fun i => t.player_type i = PlayerType.Girl) (Finset.univ)).card = num_girls\n\n/-- Combined tournament validity predicate -/\ndef is_valid_tournament (t : TournamentData) : Prop :=\n  valid_scores t \u2227 valid_games t \u2227 no_self_play t \u2227 valid_player_counts t\n\n/-- Calculate score for a specific player type -/\ndef player_score (t : TournamentData) (ptype : PlayerType) : Rat :=\n  Finset.sum (Finset.filter (fun i => t.player_type i = ptype) Finset.univ) fun i =>\n    Finset.sum Finset.univ fun j => t.results (i, j)\n\n/-- In a 6-player round-robin tournament with 2 boys and 4 girls,\n    it's impossible for boys to score exactly twice as many points as girls -/\ntheorem chess_tournament_impossible :\n  \u00ac\u2203 (t : TournamentData), is_valid_tournament t \u2227 \n    player_score t PlayerType.Boy = 2 * player_score t PlayerType.Girl :=\n  sorry", "formal_statement_pred": "import Mathlib\n\n\ndef NUM_PLAYERS : Nat := 6\ndef NUM_BOYS : Nat := 2\ndef NUM_GIRLS : Nat := 4\n\ninductive PlayerType where\n  | Boy : PlayerType\n  | Girl : PlayerType\nderiving Repr, DecidableEq\n\ninductive GameResult where\n  | Win : GameResult\n  | Draw : GameResult\n  | Loss : GameResult\nderiving Repr, DecidableEq\n\ndef GameResult.points : GameResult \u2192 \u211a\n  | Win => 1\n  | Draw => 1/2\n  | Loss => 0\n\nstructure Game where\n  player1 : Fin NUM_PLAYERS\n  player2 : Fin NUM_PLAYERS\n  result : GameResult\n  h1 : player1 \u2260 player2\n\nstructure Tournament where\n  player_types : Fin NUM_PLAYERS \u2192 PlayerType\n  games : Finset Game\n  complete : \u2200 i j, i < j \u2192 \u2203 g \u2208 games, (g.player1 = i \u2227 g.player2 = j) \u2228 (g.player1 = j \u2227 g.player2 = i)\n  player_counts : (Finset.filter (fun i => player_types i = PlayerType.Boy) (Finset.univ)).card = NUM_BOYS \u2227\n                  (Finset.filter (fun i => player_types i = PlayerType.Girl) (Finset.univ)).card = NUM_GIRLS\n\ndef Tournament.getGames (t : Tournament) : Finset Game := t.games\ndef Tournament.getPlayerTypes (t : Tournament) : Fin NUM_PLAYERS \u2192 PlayerType := t.player_types\n\n\ndef Tournament.score_for_type (t : Tournament) (ptype : PlayerType) : \u211a :=\n  let games := t.getGames\n  let player_types := t.getPlayerTypes\n  (games.filter (fun g =>\n    (player_types g.player1 = ptype \u2227 g.result = GameResult.Win) \u2228\n    (player_types g.player2 = ptype \u2227 g.result = GameResult.Loss))).card +\n  ((games.filter (fun g =>\n    (player_types g.player1 = ptype \u2228 player_types g.player2 = ptype) \u2227\n    g.result = GameResult.Draw)).card : \u211a)/2\n\ntheorem chess_tournament_impossible (t : Tournament) :\n  t.score_for_type PlayerType.Boy \u2260 2 * t.score_for_type PlayerType.Girl :=\n  sorry", "compiled": true, "aligned": true}
{"id": "CombStruct4Lean_128", "informal_problem": "9.6. From a chessboard of size $8 \\times 8$, a square of size $2 \\times 2$ was cut out such that the remaining board could be divided into rectangles of size $1 \\times 3$. Determine which square could have been cut out. (List all possible options and prove that there are no others.)", "formal_statement": "import Mathlib\n\n/-- Orientation of a 1\u00d73 rectangle on the board -/\ninductive RectangleOrientation where\n  | horizontal\n  | vertical\n\n/-- Position of the 2\u00d72 cutout on the board -/\nstructure ChessboardCutout where\n  x : Fin 7\n  y : Fin 7\n\n/-- A 1\u00d73 rectangle placement on the board -/\nstructure Rectangle where\n  x : Fin 8\n  y : Fin 8\n  orientation : RectangleOrientation\n  valid : match orientation with\n    | RectangleOrientation.horizontal => x.val + 2 < 8\n    | RectangleOrientation.vertical => y.val + 2 < 8\n\n/-- Checks if a position is within the 2\u00d72 cutout -/\ndef isInCutout (pos : Fin 8 \u00d7 Fin 8) (cutout : ChessboardCutout) : Bool :=\n  let (px, py) := pos\n  let cx := cutout.x.val\n  let cy := cutout.y.val\n  (px.val \u2265 cx \u2227 px.val < cx + 2) \u2227 (py.val \u2265 cy \u2227 py.val < cy + 2)\n\n/-- Checks if a position is covered by a rectangle -/\ndef isPositionCovered (pos : Fin 8 \u00d7 Fin 8) (rect : Rectangle) : Bool :=\n  let (px, py) := pos\n  match rect.orientation with\n  | RectangleOrientation.horizontal =>\n    py.val = rect.y.val \u2227 px.val \u2265 rect.x.val \u2227 px.val < rect.x.val + 3\n  | RectangleOrientation.vertical =>\n    px.val = rect.x.val \u2227 py.val \u2265 rect.y.val \u2227 py.val < rect.y.val + 3\n\n/-- Checks if two rectangles overlap -/\ndef rectanglesOverlap (r1 r2 : Rectangle) : Bool :=\n  \u2203 pos : Fin 8 \u00d7 Fin 8, isPositionCovered pos r1 \u2227 isPositionCovered pos r2\n\n/-- Determines if a cutout position is valid according to the modulo conditions -/\ndef isValidCutoutPosition (x y : Fin 7) : Bool :=\n  (x.val % 3 = 1 \u2227 y.val % 3 = 1) \u2228\n  (x.val % 3 = 1 \u2227 y.val % 3 = 4) \u2228\n  (x.val % 3 = 4 \u2227 y.val % 3 = 1) \u2228\n  (x.val % 3 = 4 \u2227 y.val % 3 = 4)\n\ntheorem chessboard_cutout_tiling_exists (cutout : ChessboardCutout) :\n  (\u2203 (rectangles : List Rectangle),\n    -- List contains exactly 20 rectangles (as (64-4)/3 = 20)\n    rectangles.length = 20 \u2227\n    -- All rectangles are valid and don't overlap with cutout\n    (\u2200 r, r \u2208 rectangles \u2192 \u00acisInCutout (r.x, r.y) cutout) \u2227\n    -- No rectangles overlap with each other\n    (\u2200 r1 r2, r1 \u2208 rectangles \u2192 r2 \u2208 rectangles \u2192 r1 \u2260 r2 \u2192 \u00acrectanglesOverlap r1 r2) \u2227\n    -- Every non-cutout square is covered by exactly one rectangle\n    (\u2200 pos : Fin 8 \u00d7 Fin 8, \u00acisInCutout pos cutout \u2192\n      (\u2203 r, r \u2208 rectangles \u2227 isPositionCovered pos r) \u2227\n      (\u2200 r1 r2, r1 \u2208 rectangles \u2192 r2 \u2208 rectangles \u2192 \n        isPositionCovered pos r1 \u2192 isPositionCovered pos r2 \u2192 r1 = r2))) \u2194\n  -- The cutout position is one of the valid positions\n  isValidCutoutPosition cutout.x cutout.y :=\n  sorry", "formal_statement_pred": "import Mathlib\n\nstructure BoardPos where\n  row : Fin 8\n  col : Fin 8\n  deriving Repr\n\nstructure CutSquare where\n  pos : BoardPos\n  valid : pos.row.val + 1 < 8 \u2227 pos.col.val + 1 < 8\n\ninductive RectOrientation where\n  | horizontal\n  | vertical\n  deriving Repr\n\nstructure Rectangle where\n  start : BoardPos\n  orientation : RectOrientation\n  valid : match orientation with\n    | RectOrientation.horizontal => start.col.val + 2 < 8\n    | RectOrientation.vertical => start.row.val + 2 < 8\n\n\ndef isInCutSquare (pos : BoardPos) (cut : CutSquare) : Prop :=\n  pos.row.val \u2265 cut.pos.row.val \u2227 pos.row.val \u2264 cut.pos.row.val + 1 \u2227\n  pos.col.val \u2265 cut.pos.col.val \u2227 pos.col.val \u2264 cut.pos.col.val + 1\n\n\ndef isInRectangle (pos : BoardPos) (rect : Rectangle) : Prop :=\n  match rect.orientation with\n  | RectOrientation.horizontal =>\n      pos.row.val = rect.start.row.val \u2227\n      pos.col.val \u2265 rect.start.col.val \u2227 pos.col.val \u2264 rect.start.col.val + 2\n  | RectOrientation.vertical =>\n      pos.col.val = rect.start.col.val \u2227\n      pos.row.val \u2265 rect.start.row.val \u2227 pos.row.val \u2264 rect.start.row.val + 2\n\n\ndef isValidTiling (cut : CutSquare) (tiling : Finset Rectangle) : Prop :=\n\n  \u2200 pos : BoardPos, \u00acisInCutSquare pos cut \u2192\n    \u2203! rect \u2208 tiling, isInRectangle pos rect\n\ntheorem valid_cut_positions :\n  {cut : CutSquare | \u2203 tiling, isValidTiling cut tiling} =\n  {\u27e8\u27e80,0\u27e9,sorry\u27e9, \u27e8\u27e80,6\u27e9,sorry\u27e9, \u27e8\u27e86,0\u27e9,sorry\u27e9, \u27e8\u27e86,6\u27e9,sorry\u27e9} :=\n  sorry", "compiled": true, "aligned": true}
{"id": "CombStruct4Lean_129", "informal_problem": "3. Is it possible to color the cells of an 8 x 8 square in 16 colors so that for any two colors, there are cells of these colors that share a side?", "formal_statement": "import Mathlib\n\nstructure ColoredGrid where\n  -- A coloring is a function from positions to colors (represented as Fin 16)\n  coloring : Fin 8 \u00d7 Fin 8 \u2192 Fin 16\n\n-- Two positions are adjacent if they share a side\ndef adjacent (p\u2081 p\u2082 : Fin 8 \u00d7 Fin 8) : Bool :=\n  (p\u2081.1 = p\u2082.1 \u2227 (p\u2081.2.val + 1 = p\u2082.2.val \u2228 p\u2082.2.val + 1 = p\u2081.2.val)) \u2228\n  (p\u2081.2 = p\u2082.2 \u2227 (p\u2081.1.val + 1 = p\u2082.1.val \u2228 p\u2082.1.val + 1 = p\u2081.1.val))\n\n-- Property that for any two colors, there exist adjacent cells with these colors\ndef hasAllColorPairs (grid : ColoredGrid) : Prop :=\n  \u2200 c\u2081 c\u2082 : Fin 16, \u2203 p\u2081 p\u2082 : Fin 8 \u00d7 Fin 8,\n    adjacent p\u2081 p\u2082 \u2227 \n    grid.coloring p\u2081 = c\u2081 \u2227 \n    grid.coloring p\u2082 = c\u2082\n\ntheorem exists_16_coloring : \u2203 (grid : ColoredGrid), hasAllColorPairs grid :=\n  sorry", "formal_statement_pred": "import Mathlib\n\nstructure ColoredGrid where\n\n  coloring : Fin 8 \u00d7 Fin 8 \u2192 Fin 16\n\n\ndef adjacent (p\u2081 p\u2082 : Fin 8 \u00d7 Fin 8) : Bool :=\n  (p\u2081.1 = p\u2082.1 \u2227 (p\u2081.2.val + 1 = p\u2082.2.val \u2228 p\u2082.2.val + 1 = p\u2081.2.val)) \u2228\n  (p\u2081.2 = p\u2082.2 \u2227 (p\u2081.1.val + 1 = p\u2082.1.val \u2228 p\u2082.1.val + 1 = p\u2081.1.val))\n\n\ndef colorsAdjacent (grid : ColoredGrid) (c\u2081 c\u2082 : Fin 16) : Prop :=\n  \u2203 p\u2081 p\u2082 : Fin 8 \u00d7 Fin 8,\n    adjacent p\u2081 p\u2082 \u2227\n    grid.coloring p\u2081 = c\u2081 \u2227\n    grid.coloring p\u2082 = c\u2082\n\ntheorem exists_16_color_grid :\n  \u2203 (grid : ColoredGrid),\n    \u2200 (c\u2081 c\u2082 : Fin 16), c\u2081 \u2260 c\u2082 \u2192 colorsAdjacent grid c\u2081 c\u2082 :=\n  sorry", "compiled": true, "aligned": true}
{"id": "CombStruct4Lean_132", "informal_problem": "5. In a regular 9-gon, all sides and diagonals are painted either red or blue. It turned out that there are no three vertices of the 9-gon connected by segments forming a red triangle. Prove that there will be 4 vertices of the 9-gon forming a quadrilateral, all sides and diagonals of which are painted blue.\n\n#", "formal_statement": "import Mathlib\n\nstructure ColoredRegularPolygon where\n  n : Nat                                    -- number of vertices\n  colors : Fin n \u00d7 Fin n \u2192 Bool             -- True for blue, False for red\n  is_valid_edge (i j : Fin n) : Bool :=     -- checks if i,j form valid edge/diagonal\n    i \u2260 j                                    -- vertices must be different\n  \ndef has_red_triangle (p : ColoredRegularPolygon) : Bool :=\n  \u2203 (i j k : Fin p.n), \n    p.is_valid_edge i j \u2227 p.is_valid_edge j k \u2227 p.is_valid_edge k i \u2227\n    (!p.colors (i, j)) \u2227 (!p.colors (j, k)) \u2227 (!p.colors (k, i))\n\ndef has_blue_quadrilateral (p : ColoredRegularPolygon) : Bool :=\n  \u2203 (i j k l : Fin p.n), \n    i \u2260 j \u2227 j \u2260 k \u2227 k \u2260 l \u2227 l \u2260 i \u2227        -- all vertices different\n    p.colors (i, j) \u2227 p.colors (j, k) \u2227     -- all edges and diagonals blue\n    p.colors (k, l) \u2227 p.colors (l, i) \u2227\n    p.colors (i, k) \u2227 p.colors (j, l)\n\ntheorem nonagon_ramsey \n  (p : ColoredRegularPolygon) \n  (h1 : p.n = 9)                            -- 9-gon\n  (h2 : \u00achas_red_triangle p)                -- no red triangles\n  : has_blue_quadrilateral p := \n  sorry", "formal_statement_pred": "import Mathlib\n\nstructure ColoredPolygon where\n  n : Nat\n  isRegular : Bool\n\n\n  edgeColor : Fin n \u2192 Fin n \u2192 Bool\n\ndef isTriangle (p : ColoredPolygon) (v\u2081 v\u2082 v\u2083 : Fin p.n) : Bool :=\n  v\u2081 \u2260 v\u2082 \u2227 v\u2082 \u2260 v\u2083 \u2227 v\u2083 \u2260 v\u2081\n\ndef isRedTriangle (p : ColoredPolygon) (v\u2081 v\u2082 v\u2083 : Fin p.n) : Bool :=\n  isTriangle p v\u2081 v\u2082 v\u2083 \u2227\n  (!p.edgeColor v\u2081 v\u2082) \u2227 (!p.edgeColor v\u2082 v\u2083) \u2227 (!p.edgeColor v\u2083 v\u2081)\n\ndef isQuadrilateral (p : ColoredPolygon) (v\u2081 v\u2082 v\u2083 v\u2084 : Fin p.n) : Bool :=\n  v\u2081 \u2260 v\u2082 \u2227 v\u2082 \u2260 v\u2083 \u2227 v\u2083 \u2260 v\u2084 \u2227 v\u2084 \u2260 v\u2081 \u2227\n  v\u2081 \u2260 v\u2083 \u2227 v\u2082 \u2260 v\u2084\n\ndef isBlueQuadrilateral (p : ColoredPolygon) (v\u2081 v\u2082 v\u2083 v\u2084 : Fin p.n) : Bool :=\n  isQuadrilateral p v\u2081 v\u2082 v\u2083 v\u2084 \u2227\n  p.edgeColor v\u2081 v\u2082 \u2227 p.edgeColor v\u2082 v\u2083 \u2227\n  p.edgeColor v\u2083 v\u2084 \u2227 p.edgeColor v\u2084 v\u2081 \u2227\n  p.edgeColor v\u2081 v\u2083 \u2227 p.edgeColor v\u2082 v\u2084\n\ntheorem nine_gon_ramsey (p : ColoredPolygon)\n  (h_size : p.n = 9)\n  (h_regular : p.isRegular = true)\n  (h_no_red_triangle : \u2200 (v\u2081 v\u2082 v\u2083 : Fin p.n), \u00acisRedTriangle p v\u2081 v\u2082 v\u2083) :\n  \u2203 (v\u2081 v\u2082 v\u2083 v\u2084 : Fin p.n), isBlueQuadrilateral p v\u2081 v\u2082 v\u2083 v\u2084 :=\n  sorry", "compiled": true, "aligned": true}
{"id": "CombStruct4Lean_134", "informal_problem": "5. Is it possible to color all natural numbers either red or blue so that in any infinite arithmetic progression consisting of natural numbers, there are numbers of both colors? (To color the numbers means to assign each number one of two colors: either red or blue.) Justify your answer.\n\n#", "formal_statement": "import Mathlib\n\n-- A coloring is a function from natural numbers to Bool (True = red, False = blue)\ndef Coloring := \u2115 \u2192 Bool\n\n-- An arithmetic progression is defined by its first term and common difference\nstructure ArithmeticProgression where\n  first : \u2115\n  diff : \u2115\n  diff_pos : diff > 0\n\n-- Function to get the nth term of an arithmetic progression\ndef ArithmeticProgression.nthTerm (ap : ArithmeticProgression) (n : \u2115) : \u2115 :=\n  ap.first + n * ap.diff\n\n-- Predicate to check if an arithmetic progression is monochromatic under a coloring\ndef isMonochromatic (c : Coloring) (ap : ArithmeticProgression) : Prop :=\n  \u2200 n m : \u2115, c (ap.nthTerm n) = c (ap.nthTerm m)\n\ntheorem no_valid_coloring :\n  \u00ac \u2203 (c : Coloring), \u2200 (ap : ArithmeticProgression),\n    \u2203 (n m : \u2115), c (ap.nthTerm n) \u2260 c (ap.nthTerm m) :=\n  sorry", "formal_statement_pred": "import Mathlib\n\n\ndef Coloring := \u2115 \u2192 Bool\n\n\nstructure ArithProg where\n  start : \u2115\n  step : \u2115\n  h_step_pos : step > 0\n\n\ndef belongsToAP (n : \u2115) (ap : ArithProg) : Prop :=\n  \u2203 k : \u2115, n = ap.start + k * ap.step\n\n\ndef isMonochromatic (c : Coloring) (ap : ArithProg) : Prop :=\n  \u2200 n m : \u2115, belongsToAP n ap \u2192 belongsToAP m ap \u2192 c n = c m\n\ntheorem no_valid_coloring :\n  \u00ac\u2203 c : Coloring, \u2200 ap : ArithProg, \u00acisMonochromatic c ap :=\n  sorry", "compiled": true, "aligned": true}
{"id": "CombStruct4Lean_135", "informal_problem": "6. In one company, among any 11 people, there are two people who know each other. Prove that in this company, there will be a group of ten people such that each of the others knows someone in this group.", "formal_statement": "import Mathlib\n\n-- Define a type for representing the acquaintance relation\ndef AcquaintanceGraph (n : \u2115) := Fin n \u2192 Fin n \u2192 Bool\n\n-- Property that two people know each other\ndef knows (g : AcquaintanceGraph n) (i j : Fin n) : Prop :=\n  g i j = true\n\n-- Property that in any group of 11 people, there are two who know each other\ndef has_acquaintance_in_11 (g : AcquaintanceGraph n) : Prop :=\n  \u2200 (s : Finset (Fin n)), s.card = 11 \u2192 \n    \u2203 (i j : Fin n), i \u2208 s \u2227 j \u2208 s \u2227 i \u2260 j \u2227 knows g i j\n\n-- Property that a person knows someone in a given group\ndef knows_someone_in_group (g : AcquaintanceGraph n) (p : Fin n) (group : Finset (Fin n)) : Prop :=\n  \u2203 q \u2208 group, knows g p q\n\ntheorem acquaintance_theorem {n : \u2115} (h : n > 10) (g : AcquaintanceGraph n)\n  (h_11 : has_acquaintance_in_11 g) :\n  \u2203 (group : Finset (Fin n)), group.card = 10 \u2227\n    \u2200 p : Fin n, p \u2209 group \u2192 knows_someone_in_group g p group :=\n  sorry", "formal_statement_pred": "import Mathlib\n\n\ndef is_cover {n : Nat} (G : SimpleGraph (Fin n)) (S : Finset (Fin n)) : Prop :=\n  \u2200 i, i \u2209 S \u2192 \u2203 j \u2208 S, G.Adj i j\n\n\ntheorem acquaintance_cover_exists {n : Nat} (G : SimpleGraph (Fin n))\n  (h_size : n > 10)\n  (h_knows : \u2200 S : Finset (Fin n), S.card = 11 \u2192\n    \u2203 i j, i \u2208 S \u2227 j \u2208 S \u2227 i \u2260 j \u2227 G.Adj i j) :\n  \u2203 S : Finset (Fin n), S.card = 10 \u2227 is_cover G S :=\n  sorry", "compiled": true, "aligned": true}
{"id": "CombStruct4Lean_136", "informal_problem": "9.1. In a quiz, 10 students participated and gave a total of 42 correct answers. Prove that at least 2 students gave the same number of correct answers (possibly zero).", "formal_statement": "import Mathlib\n\n-- No additional structures needed\n\ntheorem quiz_pigeonhole \n  (students : Finset Nat) \n  (answers : Nat \u2192 Nat)  -- maps student ID to their number of correct answers\n  (h_students : students.card = 10)\n  (h_total : (\u2211 i in students, answers i) = 42) :\n  \u2203 i j : Nat, i \u2208 students \u2227 j \u2208 students \u2227 i \u2260 j \u2227 answers i = answers j :=\n  sorry", "formal_statement_pred": "import Mathlib\n\n\n\ntheorem quiz_pigeonhole\n  (students : Finset Nat)\n  (answers : Nat \u2192 Nat)\n  (h_size : students.card = 10)\n  (h_total : (\u2211 i in students, answers i) = 42) :\n  \u2203 i j : Nat, i \u2208 students \u2227 j \u2208 students \u2227 i \u2260 j \u2227 answers i = answers j :=\n  sorry", "compiled": true, "aligned": true}
{"id": "CombStruct4Lean_137", "informal_problem": "10.3. Pasha chose 2017 (not necessarily distinct) natural numbers $a_{1}, a_{2}, \\ldots, a_{2017}$ and plays the following game with himself. Initially, he has an unlimited supply of stones and 2017 large empty boxes. In one move, Pasha adds $a_{1}$ stones to any box (of his choice), $a_{2}$ stones to any of the remaining boxes (of his choice), ..., and finally, $a_{2017}$ stones to the remaining box. Pasha's goal is to achieve a state where, after some move, all the boxes have the same number of stones. Could he have chosen the numbers in such a way that the goal can be achieved in 43 moves, but not in a smaller non-zero number of moves?\n\n(I. Bogdanov)", "formal_statement": "import Mathlib\n\nstructure StoneGame where\n  numbers : Fin 2017 \u2192 Nat\n  boxes : Fin 2017 \u2192 Nat\n  move : Fin 2017 \u2192 Fin 2017 \u2192 Nat\n  -- move i j represents putting numbers[i] stones in box j during a move\n\ndef is_valid_move (g : StoneGame) (m : Fin 2017 \u2192 Fin 2017) : Bool :=\n  Function.Injective m\n\ndef apply_move (g : StoneGame) (m : Fin 2017 \u2192 Fin 2017) : Fin 2017 \u2192 Nat :=\n  fun i => g.boxes i + g.numbers (m i)\n\ndef boxes_equal (boxes : Fin 2017 \u2192 Nat) : Prop :=\n  \u2200 i j : Fin 2017, boxes i = boxes j\n\ndef can_achieve_equal_in_k_moves (g : StoneGame) (k : Nat) : Prop :=\n  \u2203 moves : Fin k \u2192 (Fin 2017 \u2192 Fin 2017),\n    (\u2200 i, is_valid_move g (moves i)) \u2227\n    \u2203 final_boxes, boxes_equal final_boxes\n\ntheorem stone_game_exact_moves : \n  \u2203 g : StoneGame,\n    (can_achieve_equal_in_k_moves g 43) \u2227\n    (\u2200 k : Nat, 0 < k \u2227 k < 43 \u2192 \u00accan_achieve_equal_in_k_moves g k) :=\n  sorry", "formal_statement_pred": "import Mathlib\n\n\nstructure StoneGame where\n  numbers : Fin 2017 \u2192 Nat\n\n\nstructure GameMove where\n  boxAssignment : Fin 2017 \u2192 Fin 2017\n  isValid : Function.Injective boxAssignment\n\n\nstructure GameState where\n  stones : Fin 2017 \u2192 Nat\n  movesUsed : Nat\n\n\ndef boxesEqual (state : GameState) : Prop :=\n  \u2200 i j : Fin 2017, state.stones i = state.stones j\n\n\ndef applyMove (game : StoneGame) (state : GameState) (move : GameMove) : GameState where\n  stones := fun box \u21a6 state.stones box + game.numbers (move.boxAssignment box)\n  movesUsed := state.movesUsed + 1\n\n\ndef reachableIn (game : StoneGame) (state : GameState) (k : Nat) : Prop :=\n  state.movesUsed = k \u2227\n  \u2203 moves : Fin k \u2192 GameMove,\n    \u2200 i : Fin k, Function.Injective (moves i).boxAssignment\n\ntheorem stone_game_solution :\n  \u2203 game : StoneGame,\n\n    (\u2203 finalState : GameState,\n      reachableIn game finalState 43 \u2227\n      boxesEqual finalState) \u2227\n\n    (\u2200 k : Nat, 0 < k \u2192 k < 43 \u2192\n      \u2200 state : GameState,\n        reachableIn game state k \u2192 \u00acboxesEqual state) :=\n  sorry", "compiled": true, "aligned": true}
{"id": "CombStruct4Lean_138", "informal_problem": "5. In a round-robin football tournament (where each team plays every other team once), 12 teams participated. The tournament was not yet completed by November. Could it be that one team played exactly 11 games, three teams played exactly 9 games each, two teams played exactly 6 games each, four teams played exactly 4 games each, and the remaining two teams played exactly one game each?", "formal_statement": "import Mathlib\n\nstructure TournamentState where\n  n : Nat                    -- number of teams\n  gamesPlayed : Fin n \u2192 Nat  -- number of games played by each team\n  isValid : Bool            -- whether this represents a valid partial tournament state\n  \ndef isValidTournamentState (t : TournamentState) : Prop :=\n  -- Each pair of teams contributes exactly one game to both teams' counts\n  \u2200 i j : Fin t.n, i \u2260 j \u2192 \n    (t.gamesPlayed i + t.gamesPlayed j \u2264 1)  -- teams i and j have played at most one game\n    \u2227 (\u2200 k : Fin t.n, t.gamesPlayed k \u2264 t.n - 1) -- no team plays more than n-1 games\n\ntheorem tournament_state_impossible : \u00ac \u2203 (t : TournamentState), \n  t.n = 12 \u2227 \n  isValidTournamentState t \u2227\n  (\u2203 (teams : Fin 12 \u2192 Nat),\n    -- One team played 11 games\n    (\u2203! i, t.gamesPlayed i = 11) \u2227\n    -- Three teams played 9 games each\n    (\u2203 i\u2081 i\u2082 i\u2083, i\u2081 \u2260 i\u2082 \u2227 i\u2082 \u2260 i\u2083 \u2227 i\u2081 \u2260 i\u2083 \u2227 \n      t.gamesPlayed i\u2081 = 9 \u2227 t.gamesPlayed i\u2082 = 9 \u2227 t.gamesPlayed i\u2083 = 9) \u2227\n    -- Two teams played 6 games each\n    (\u2203 i\u2081 i\u2082, i\u2081 \u2260 i\u2082 \u2227 t.gamesPlayed i\u2081 = 6 \u2227 t.gamesPlayed i\u2082 = 6) \u2227\n    -- Four teams played 4 games each\n    (\u2203 i\u2081 i\u2082 i\u2083 i\u2084, i\u2081 \u2260 i\u2082 \u2227 i\u2082 \u2260 i\u2083 \u2227 i\u2083 \u2260 i\u2084 \u2227 i\u2081 \u2260 i\u2083 \u2227 i\u2081 \u2260 i\u2084 \u2227 i\u2082 \u2260 i\u2084 \u2227\n      t.gamesPlayed i\u2081 = 4 \u2227 t.gamesPlayed i\u2082 = 4 \u2227 \n      t.gamesPlayed i\u2083 = 4 \u2227 t.gamesPlayed i\u2084 = 4) \u2227\n    -- Two teams played 1 game each\n    (\u2203 i\u2081 i\u2082, i\u2081 \u2260 i\u2082 \u2227 t.gamesPlayed i\u2081 = 1 \u2227 t.gamesPlayed i\u2082 = 1)) :=\n  sorry", "formal_statement_pred": "import Mathlib\n\nstructure TournamentState where\n  n : Nat\n  games : Finset (Fin n \u00d7 Fin n)\n  games_valid : \u2200 (i j : Fin n), (i, j) \u2208 games \u2192 (j, i) \u2208 games\n  no_self_games : \u2200 i : Fin n, (i, i) \u2209 games\n\n\ndef gamesPlayedByTeam (t : TournamentState) (i : Fin t.n) : Nat :=\n  (Finset.filter (fun p => p.1 = i \u2228 p.2 = i) t.games).card\n\n\ndef teamsWithExactlyKGames (t : TournamentState) (k : Nat) : Nat :=\n  (Finset.filter (fun i => gamesPlayedByTeam t i = k) (Finset.univ : Finset (Fin t.n))).card\n\ntheorem tournament_possible (n : Nat) (h : n = 12) :\n  \u2203 (t : TournamentState),\n    t.n = n \u2227\n    teamsWithExactlyKGames t 11 = 1 \u2227\n    teamsWithExactlyKGames t 9 = 3 \u2227\n    teamsWithExactlyKGames t 6 = 2 \u2227\n    teamsWithExactlyKGames t 4 = 4 \u2227\n    teamsWithExactlyKGames t 1 = 2 :=\n  sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_142", "informal_problem": "9.1. In the country, some pairs of cities are connected by one-way direct flights (there is no more than one flight between any two cities). We say that city $A$ is accessible from city $B$ if it is possible to fly from $B$ to $A$, possibly with layovers. It is known that for any two cities $P$ and $Q$, there exists a city $R$ such that both $P$ and $Q$ are accessible from $R$. Prove that there exists a city from which all cities in the country are accessible. (It is assumed that it is possible to fly from a city to itself.) (V. Dolnikov)", "formal_statement": "import Mathlib\n\nstructure FlightNetwork (\u03b1 : Type u) where\n  -- The directed edge relation representing direct flights between cities\n  hasDirectFlight : \u03b1 \u2192 \u03b1 \u2192 Prop\n  -- At most one direct flight between any ordered pair of cities\n  unique : \u2200 {a b : \u03b1}, hasDirectFlight a b \u2192 hasDirectFlight a b \u2192 a = b\n  -- Every city has a flight to itself (reflexivity)\n  refl : \u2200 (c : \u03b1), hasDirectFlight c c\n  -- Accessibility relation: can reach through sequence of flights\n  isAccessible : \u03b1 \u2192 \u03b1 \u2192 Prop := fun a b => \n    TC hasDirectFlight a b\n\ntheorem exists_universal_source {\u03b1 : Type u} [Nonempty \u03b1] (G : FlightNetwork \u03b1)\n  (h : \u2200 (p q : \u03b1), \u2203 (r : \u03b1), G.isAccessible r p \u2227 G.isAccessible r q) :\n  \u2203 (source : \u03b1), \u2200 (dest : \u03b1), G.isAccessible source dest :=\n  sorry", "formal_statement_pred": "import Mathlib\n\nstructure FlightNetwork (\u03b1 : Type u) where\n  flights : \u03b1 \u2192 \u03b1 \u2192 Bool\n\ninductive Accessible {\u03b1 : Type u} (G : FlightNetwork \u03b1) : \u03b1 \u2192 \u03b1 \u2192 Prop\n  | direct {a b : \u03b1} : G.flights a b \u2192 Accessible G a b\n  | trans {a b c : \u03b1} : Accessible G a b \u2192 Accessible G b c \u2192 Accessible G a c\n\ntheorem exists_universal_source {\u03b1 : Type u} (G : FlightNetwork \u03b1) :\n  (\u2200 p q : \u03b1, \u2203 r : \u03b1, Accessible G r p \u2227 Accessible G r q) \u2192\n  \u2203 s : \u03b1, \u2200 t : \u03b1, Accessible G s t :=\n  sorry", "compiled": true, "aligned": true}
{"id": "CombStruct4Lean_143", "informal_problem": "5. Is it possible to color the cells of an 8 x 8 board in three colors: 21 cells in white, 21 cells in blue, 22 cells in red - so that no diagonal (not only the two main diagonals, but all those parallel to them) contains cells of all three colors simultaneously?", "formal_statement": "import Mathlib\n\n/-- Determines if a position (row,col) lies on a diagonal starting at (start_row, start_col) -/\ndef is_on_diagonal (start_row start_col row col : Fin 8) : Prop :=\n  (row.val : \u2124) - (col.val : \u2124) = (start_row.val : \u2124) - (start_col.val : \u2124)\n\n/-- Count the number of cells of a given color -/\ndef count_cells (coloring : Fin 8 \u2192 Fin 8 \u2192 Fin 3) (c : Fin 3) : \u2115 :=\n  Finset.sum (Finset.univ : Finset (Fin 8)) fun i =>\n    Finset.card (Finset.filter (fun j => coloring i j = c) Finset.univ)\n\n/-- A valid three-coloring of an 8x8 board -/\nstructure BoardColoring where\n  color : Fin 8 \u2192 Fin 8 \u2192 Fin 3\n  white_count : count_cells color 0 = 21\n  blue_count : count_cells color 1 = 21\n  red_count : count_cells color 2 = 22\n\n/-- Checks if a diagonal contains all three colors -/\ndef has_all_colors (coloring : Fin 8 \u2192 Fin 8 \u2192 Fin 3) (start_row start_col : Fin 8) : Prop :=\n  \u2203 (i\u2081 i\u2082 i\u2083 j\u2081 j\u2082 j\u2083 : Fin 8), \n    (is_on_diagonal start_row start_col i\u2081 j\u2081 \u2227 coloring i\u2081 j\u2081 = 0) \u2227\n    (is_on_diagonal start_row start_col i\u2082 j\u2082 \u2227 coloring i\u2082 j\u2082 = 1) \u2227\n    (is_on_diagonal start_row start_col i\u2083 j\u2083 \u2227 coloring i\u2083 j\u2083 = 2)\n\ntheorem three_color_board_possible : \n  \u2203 (board : BoardColoring), \n    \u2200 (start_row start_col : Fin 8), \u00ac(has_all_colors board.color start_row start_col) :=\n  sorry", "formal_statement_pred": "import Mathlib\n\n\nstructure Position where\n  row : Fin 8\n  col : Fin 8\n  deriving Fintype, DecidableEq, Repr\n\n\ninductive Color where\n  | White\n  | Blue\n  | Red\n  deriving Fintype, DecidableEq, Repr\n\n\ndef Coloring := Position \u2192 Color\n\n\nstructure Diagonal where\n  slope : Bool\n  intercept : Int\n  deriving DecidableEq\n\n\ndef on_diagonal (p : Position) (d : Diagonal) : Bool :=\n  if d.slope then\n    (p.row : Int) - (p.col : Int) = d.intercept\n  else\n    (p.row : Int) + (p.col : Int) = d.intercept\n\n\ndef color_count (c : Coloring) (color : Color) : Nat :=\n  Finset.card (Finset.filter (fun p => c p = color) Finset.univ)\n\n\ndef valid_counts (c : Coloring) : Prop :=\n  color_count c Color.White = 21 \u2227\n  color_count c Color.Blue = 21 \u2227\n  color_count c Color.Red = 22\n\n\ndef has_three_colors (c : Coloring) (d : Diagonal) : Prop :=\n  \u2203 (p\u2081 p\u2082 p\u2083 : Position),\n    on_diagonal p\u2081 d \u2227 on_diagonal p\u2082 d \u2227 on_diagonal p\u2083 d \u2227\n    Finset.card (Finset.image c {p\u2081, p\u2082, p\u2083}) = 3\n\ntheorem three_color_board_exists :\n  \u2203 (c : Coloring),\n    valid_counts c \u2227\n    \u2200 (d : Diagonal), \u00achas_three_colors c d :=\n  sorry", "compiled": true, "aligned": true}
{"id": "CombStruct4Lean_144", "informal_problem": "3. In a volleyball tournament, 6 teams participated. Prove that after one round of games (each team played with each other exactly once), there will be a team that won at least $3$ games (there are no draws in volleyball).", "formal_statement": "import Mathlib\n\nstructure VolleyballTournament where\n  n : Nat\n  -- results i j = true means i won against j\n  results : Fin n \u2192 Fin n \u2192 Bool\n  -- No team plays against itself\n  irrefl : \u2200 i, results i i = false\n  -- For each pair of teams, exactly one is the winner\n  antisymm : \u2200 i j, results i j = !(results j i)\n\ntheorem volleyball_tournament_winner (t : VolleyballTournament) (h : t.n = 6) :\n  \u2203 team : Fin t.n, (Finset.sum (Finset.univ.erase team) \n    (fun opponent => if t.results team opponent then 1 else 0)) \u2265 3 :=\n  sorry", "formal_statement_pred": "import Mathlib\n\n\nstructure Game (n : Nat) where\n  team1 : Fin n\n  team2 : Fin n\n  winner : Fin n\n  teams_distinct : team1 \u2260 team2\n  winner_valid : winner = team1 \u2228 winner = team2\n\n\nstructure RoundRobinTournament (n : Nat) where\n  games : List (Game n)\n\n  games_valid : \u2200 g \u2208 games, g.team1 \u2260 g.team2\n\n  games_count : games.length = n * (n-1) / 2\n\n  pairs_once : \u2200 i j : Fin n, i < j \u2192\n    (games.filter (fun g =>\n      (g.team1 = i \u2227 g.team2 = j) \u2228\n      (g.team1 = j \u2227 g.team2 = i))).length = 1\n\n\ndef wins_count {n : Nat} (t : RoundRobinTournament n) (team : Fin n) : Nat :=\n  (t.games.filter (fun g => g.winner = team)).length\n\ntheorem volleyball_tournament_winner {n : Nat} (t : RoundRobinTournament n) (h : n = 6) :\n  \u2203 team : Fin n, wins_count t team \u2265 3 :=\n  sorry", "compiled": true, "aligned": true}
{"id": "CombStruct4Lean_146", "informal_problem": "# 6. CONDITION\n\nCan 2005 non-zero vectors be drawn on a plane such that from any ten of them, three can be chosen with a zero sum?", "formal_statement": "import Mathlib\nopen EuclideanSpace\n\ndef hasZeroSumTriple (s : Finset (EuclideanSpace \u211d (Fin 2))) : Prop :=\n  \u2203 (v\u2081 v\u2082 v\u2083 : EuclideanSpace \u211d (Fin 2)), \n    v\u2081 \u2208 s \u2227 v\u2082 \u2208 s \u2227 v\u2083 \u2208 s \u2227 \n    v\u2081 \u2260 v\u2082 \u2227 v\u2082 \u2260 v\u2083 \u2227 v\u2081 \u2260 v\u2083 \u2227\n    v\u2081 + v\u2082 + v\u2083 = 0\n\ndef isNonzeroVector (v : EuclideanSpace \u211d (Fin 2)) : Prop :=\n  \u2016v\u2016 \u2260 0\n\ntheorem plane_vectors_condition :\n  \u2203 (vectors : Finset (EuclideanSpace \u211d (Fin 2))),\n    vectors.card = 2005 \u2227\n    (\u2200 v \u2208 vectors, isNonzeroVector v) \u2227\n    (\u2200 subset : Finset (EuclideanSpace \u211d (Fin 2)),\n      subset \u2286 vectors \u2192 subset.card = 10 \u2192 hasZeroSumTriple subset) :=\n  sorry", "formal_statement_pred": "import Mathlib\n\nabbrev Vec2D := \u211d \u00d7 \u211d\n\ndef isZeroSum (v\u2081 v\u2082 v\u2083 : Vec2D) : Prop :=\n  v\u2081.1 + v\u2082.1 + v\u2083.1 = 0 \u2227 v\u2081.2 + v\u2082.2 + v\u2083.2 = 0\n\ndef hasZeroSumTriple (S : Finset Vec2D) : Prop :=\n  \u2203 v\u2081 v\u2082 v\u2083, v\u2081 \u2208 S \u2227 v\u2082 \u2208 S \u2227 v\u2083 \u2208 S \u2227\n  v\u2081 \u2260 v\u2082 \u2227 v\u2081 \u2260 v\u2083 \u2227 v\u2082 \u2260 v\u2083 \u2227 isZeroSum v\u2081 v\u2082 v\u2083\n\n\ntheorem plane_vectors_2005 :\n  \u2203 (V : Finset Vec2D),\n    V.card = 2005 \u2227\n    (\u2200 v \u2208 V, v \u2260 (0, 0)) \u2227\n    (\u2200 S \u2286 V, S.card = 10 \u2192 hasZeroSumTriple S) :=\n  sorry", "compiled": true, "aligned": true}
{"id": "CombStruct4Lean_147", "informal_problem": "Task 3. Can positive numbers (not necessarily integers) be placed in a $6 \\times 6$ table so that the product of all numbers in any row, any column, and any $2 \\times 2$ square equals two?", "formal_statement": "import Mathlib\n\nstructure Table where\n  -- entries is a 6\u00d76 matrix of positive real numbers\n  entries : Fin 6 \u2192 Fin 6 \u2192 \u211d\n  -- all entries are positive\n  all_positive : \u2200 i j, entries i j > 0\n  -- product of each row equals 2\n  row_product : \u2200 i, (\u220f j, entries i j) = 2\n  -- product of each column equals 2\n  col_product : \u2200 j, (\u220f i, entries i j) = 2\n  -- product of each 2\u00d72 square equals 2\n  square_product : \u2200 i j, i + 1 < 6 \u2192 j + 1 < 6 \u2192\n    entries i j * entries i (j+1) * entries (i+1) j * entries (i+1) (j+1) = 2\n\ntheorem table_exists : \u2203 t : Table, True :=\n  sorry", "formal_statement_pred": "import Mathlib\n\nstructure Table where\n  entries : Fin 6 \u2192 Fin 6 \u2192 \u211d\n  all_positive : \u2200 i j, entries i j > 0\n\ndef row_product (t : Table) (i : Fin 6) : \u211d :=\n  (Finset.univ.prod fun j => t.entries i j)\n\ndef col_product (t : Table) (j : Fin 6) : \u211d :=\n  (Finset.univ.prod fun i => t.entries i j)\n\ndef square_product (t : Table) (i j : Fin 5) : \u211d :=\n  (t.entries i j) * (t.entries i (j + 1)) *\n  (t.entries (i + 1) j) * (t.entries (i + 1) (j + 1))\n\ntheorem exists_special_table : \u2203 (t : Table),\n  (\u2200 i : Fin 6, row_product t i = 2) \u2227\n  (\u2200 j : Fin 6, col_product t j = 2) \u2227\n  (\u2200 i j : Fin 5, square_product t i j = 2) :=\n  sorry", "compiled": true, "aligned": true}
{"id": "CombStruct4Lean_148", "informal_problem": "4. Is it possible to arrange 10 black and several white chips in a circle such that each black chip has a diametrically opposite white chip and no two white chips are adjacent?", "formal_statement": "import Mathlib\n\nstructure ChipArrangement where\n  n : Nat                     -- Total number of positions (diameter)\n  black_positions : Finset Nat -- Positions of black chips\n  white_positions : Finset Nat -- Positions of white chips\n  valid_positions : black_positions \u222a white_positions \u2286 Finset.range n\n  no_overlap : black_positions \u2229 white_positions = \u2205\n  black_count : black_positions.card = 10\n  opposite_exists : \u2200 p \u2208 black_positions, \n    ((p + n/2) % n) \u2208 white_positions\n  no_adjacent_whites : \u2200 p \u2208 white_positions, \n    ((p + 1) % n) \u2209 white_positions\n\ntheorem circle_arrangement_exists : \u2203 (arr : ChipArrangement), True :=\n  sorry", "formal_statement_pred": "import Mathlib\n\nstructure CircularChips (n : Nat) (hn : n > 0) (heven : Even n) (hsize : n \u2265 20) where\n  blackPositions : Finset (Fin n)\n  whitePositions : Finset (Fin n)\n  disjoint : Disjoint blackPositions whitePositions\n  covers : blackPositions \u222a whitePositions = Finset.univ\n  blackCount : blackPositions.card = 10\n  uniquePositions : blackPositions.card + whitePositions.card = n\n  hasAntipodal : \u2200 b \u2208 blackPositions,\n    \u2203 w \u2208 whitePositions, w.val = (b.val + n/2) % n\n  noAdjacentWhite : \u2200 w\u2081 \u2208 whitePositions, \u2200 w\u2082 \u2208 whitePositions,\n    w\u2081 \u2260 w\u2082 \u2192 w\u2081.val \u2260 (w\u2082.val + 1) % n\n\ntheorem exists_valid_chip_arrangement :\n  \u2203 (n : Nat) (hn : n > 0) (heven : Even n) (hsize : n \u2265 20),\n    Nonempty (CircularChips n hn heven hsize) :=\n  sorry", "compiled": true, "aligned": true}
{"id": "CombStruct4Lean_149", "informal_problem": "6.2. The sixth-grade students went to a party. Each boy had 5 balloons, and each girl had 4 balloons. On the way, the children started to play and pop each other's balloons. (Of course, they did not pop their own balloons.) In the end, each girl popped exactly one balloon, and each boy popped exactly two balloons. Dima counted all the surviving balloons and got 100. Prove that Dima was wrong.", "formal_statement": "import Mathlib\n\nstructure PartySetup where\n  boys : Nat      -- number of boys\n  girls : Nat     -- number of girls\n  \ndef initial_balloons (p : PartySetup) : Nat :=\n  5 * p.boys + 4 * p.girls\n\ndef popped_balloons (p : PartySetup) : Nat :=\n  2 * p.boys + p.girls\n\ndef surviving_balloons (p : PartySetup) : Nat :=\n  initial_balloons p - popped_balloons p\n\ntheorem party_balloon_count_impossible :\n  \u00ac\u2203 (p : PartySetup), surviving_balloons p = 100 :=\n  sorry", "formal_statement_pred": "import Mathlib\n\nstructure PartyBalloons where\n  boys : Nat\n  girls : Nat\n  initial_boy_balloons : Nat := 5\n  initial_girl_balloons : Nat := 4\n  boy_pops : Nat := 2\n  girl_pops : Nat := 1\n  total_surviving : Nat := 100\n\ntheorem party_balloon_impossibility (p : PartyBalloons) :\n  \u00ac(\n\n    p.boys * p.initial_boy_balloons + p.girls * p.initial_girl_balloons -\n    (p.boys * p.boy_pops + p.girls * p.girl_pops) = p.total_surviving\n  ) :=\n  sorry", "compiled": true, "aligned": true}
{"id": "CombStruct4Lean_150", "informal_problem": "11.2. In each cell of a $1001 \\times 1001$ table, a 0 or 1 was placed. It turned out that in any column, there are more zeros than ones. Is it necessarily true that there will be two columns such that the number of rows where the intersections with these two columns contain only zeros is greater than the number of rows where the intersections with these two columns contain only ones?\n\n(I. Bogdanov)", "formal_statement": "import Mathlib\n\nstructure BinaryTable where\n  size : Nat\n  entries : Fin size \u2192 Fin size \u2192 Bool  -- True represents 1, False represents 0\n  more_zeros_in_columns : \u2200 j, \n    (Finset.filter (fun i \u21a6 !entries i j) (Finset.univ : Finset (Fin size))).card > \n    (Finset.filter (fun i \u21a6 entries i j) (Finset.univ : Finset (Fin size))).card\n\ntheorem two_columns_more_zeros (t : BinaryTable) (h : t.size = 1001) :\n  \u2203 j\u2081 j\u2082, j\u2081 \u2260 j\u2082 \u2227 \n    (Finset.filter (fun i \u21a6 !t.entries i j\u2081 \u2227 !t.entries i j\u2082) (Finset.univ : Finset (Fin t.size))).card >\n    (Finset.filter (fun i \u21a6 t.entries i j\u2081 \u2227 t.entries i j\u2082) (Finset.univ : Finset (Fin t.size))).card :=\n  sorry", "formal_statement_pred": "import Mathlib\n\n\nstructure BinaryTable (n : Nat) where\n  entries : Fin n \u2192 Fin n \u2192 Bool\n  more_zeros_in_columns : \u2200 j : Fin n,\n    (Finset.filter (fun i => !entries i j) (Finset.univ : Finset (Fin n))).card >\n    (Finset.filter (fun i => entries i j) (Finset.univ : Finset (Fin n))).card\n\n\ndef count_double_zeros (t : BinaryTable n) (j\u2081 j\u2082 : Fin n) : Nat :=\n  (Finset.filter (fun i => !t.entries i j\u2081 \u2227 !t.entries i j\u2082) (Finset.univ : Finset (Fin n))).card\n\n\ndef count_double_ones (t : BinaryTable n) (j\u2081 j\u2082 : Fin n) : Nat :=\n  (Finset.filter (fun i => t.entries i j\u2081 \u2227 t.entries i j\u2082) (Finset.univ : Finset (Fin n))).card\n\ntheorem binary_table_columns_property :\n  \u2200 (t : BinaryTable 1001),\n  \u2203 (j\u2081 j\u2082 : Fin 1001), j\u2081 \u2260 j\u2082 \u2227\n  count_double_zeros t j\u2081 j\u2082 > count_double_ones t j\u2081 j\u2082 :=\n  sorry", "compiled": true, "aligned": true}
{"id": "CombStruct4Lean_151", "informal_problem": "2. Numbers from 1 to 8 were arranged in some order in a circle, and then the sums of adjacent numbers were recorded. Could it be that 8 consecutive numbers (in some order) were obtained?", "formal_statement": "import Mathlib\n\nstructure CircularArrangement where\n  -- The arrangement of numbers from 1 to 8 in a circle\n  nums : Fin 8 \u2192 Fin 8\n  -- Ensure it's a permutation (bijective)\n  is_perm : Function.Bijective nums\n\n-- Function to get the sum of adjacent numbers at position i\ndef adjacent_sums (arr : CircularArrangement) (i : Fin 8) : Nat :=\n  -- Convert Fin 8 values to Nat and add 1 since we want numbers 1-8\n  (arr.nums i).val + 1 + (arr.nums ((i.val + 1) % 8)).val + 1\n\ntheorem no_consecutive_sums (arr : CircularArrangement) :\n  \u00ac\u2203 (start : Nat), \u2200 (i : Fin 8),\n    (adjacent_sums arr i) = start + i.val :=\n  sorry", "formal_statement_pred": "import Mathlib\n\nstructure CircularArrangement where\n\n  nums : Fin 8 \u2192 Fin 8\n\n  is_perm : Function.Bijective nums\n\n\ndef adjacent_sums (arr : CircularArrangement) (i : Fin 8) : Nat :=\n  (arr.nums i).val + 1 + (arr.nums ((i.val + 1) % 8)).val + 1\n\ntheorem no_consecutive_sums_possible :\n  \u00ac\u2203 (arr : CircularArrangement),\n    \u2203 (start : Nat),\n\n      \u2200 (i : Fin 8),\n        (adjacent_sums arr i) = start + i.val :=\n  sorry", "compiled": true, "aligned": true}
{"id": "CombStruct4Lean_153", "informal_problem": "5. In an internet community of 20 participants, there are friends. Any two participants A and B are either friends themselves or there exists a chain\n\n$\\mathrm{A}-\\mathrm{C}_{1}-\\ldots-\\mathrm{C}_{\\mathrm{k}}-\\mathrm{B}$\n\nwhere adjacent participants in the chain are friends, that is, $\\mathrm{C}_{1}$ is a friend of $\\mathrm{A}, \\mathrm{C}_{2}$ is a friend of $\\mathrm{C}_{1}, \\ldots$ and B is a friend of $\\mathrm{C}_{\\mathrm{k}}$. Prove that it is possible to select 6 participants from the community such that any of the remaining fourteen is either a friend or a friend of a friend of someone among these six.", "formal_statement": "import Mathlib\nopen SimpleGraph\n\nstructure Community where\n  friendship : SimpleGraph (Fin 20)\n  connected : friendship.Connected\n\n/-- A participant is reachable in two steps from a set if they are either:\n    1. In the set\n    2. A direct neighbor of someone in the set\n    3. A neighbor of a neighbor of someone in the set -/\ndef twoStepReachable (c : Community) (selected : Finset (Fin 20)) (p : Fin 20) : Prop :=\n  p \u2208 selected \u2228 \n  (\u2203 s \u2208 selected, c.friendship.Adj s p) \u2228\n  (\u2203 s \u2208 selected, \u2203 f, c.friendship.Adj s f \u2227 c.friendship.Adj f p)\n\ntheorem community_selection_exists (c : Community) :\n  \u2203 selected : Finset (Fin 20),\n    selected.card = 6 \u2227 \n    \u2200 p : Fin 20, twoStepReachable c selected p :=\n  sorry", "formal_statement_pred": "import Mathlib\n\nstructure Community (n : \u2115) where\n  toGraph : SimpleGraph (Fin n)\n\ndef withinTwoSteps {n : \u2115} (g : SimpleGraph (Fin n)) (i j : Fin n) : Prop :=\n  SimpleGraph.dist g i j \u2264 2\n\ndef reachableSet {n : \u2115} (g : SimpleGraph (Fin n)) (v : Fin n) : Set (Fin n) :=\n  {u | withinTwoSteps g v u}\n\ndef reachableFromSet {n : \u2115} (g : SimpleGraph (Fin n)) (s : Finset (Fin n)) : Set (Fin n) :=\n  {v | \u2203 u \u2208 s, withinTwoSteps g v u}\n\ntheorem community_six_participants {n : \u2115} (h : n = 20) (c : Community n) :\n  \u2203 selected : Finset (Fin n), selected.card = 6 \u2227\n    \u2200 p : Fin n, p \u2209 selected \u2192\n      \u2203 s \u2208 selected, withinTwoSteps c.toGraph p s :=\n  sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_154", "informal_problem": "4. In a $25 \\times 25$ table, integers from 1 to 25 are arranged, and in each row, the entire set of numbers appears. The table is symmetric with respect to the diagonal running from the top left to the bottom right. Prove that on this diagonal, all numbers from 1 to 25 also appear.", "formal_statement": "import Mathlib\n\nstructure SymmetricTable where\n  n : Nat\n  entries : Fin n \u2192 Fin n \u2192 Fin n\n  all_rows_complete : \u2200 i : Fin n, Function.Surjective (entries i)\n  symmetric : \u2200 (i j : Fin n), entries i j = entries j i\n\ntheorem diagonal_complete {t : SymmetricTable} (h : t.n = 25) :\n  Function.Surjective (fun i => t.entries i i) :=\n  sorry", "formal_statement_pred": "import Mathlib\n\nstructure SymmetricTable where\n\n  value : Fin 25 \u2192 Fin 25 \u2192 Fin 25\n\n  row_complete : \u2200 i : Fin 25, Function.Surjective (value i)\n\n  symmetric : \u2200 (i j : Fin 25), value i j = value j i\n\ntheorem diagonal_complete (t : SymmetricTable) :\n  Function.Surjective (fun i => t.value i i) :=\n  sorry", "compiled": true, "aligned": true}
{"id": "CombStruct4Lean_156", "informal_problem": "11.5. Natural numbers from 1 to 9 are colored in two colors. Prove that there will be three different numbers of the same color forming an arithmetic progression.", "formal_statement": "import Mathlib\n\ndef isArithmeticProgression (a b c : \u2115) : Prop :=\n  b - a = c - b\n\ndef hasMonochromaticAP (coloring : \u2115 \u2192 Bool) : Prop :=\n  \u2203 (a b c : \u2115), \n    1 \u2264 a \u2227 a < b \u2227 b < c \u2227 c \u2264 9 \u2227\n    isArithmeticProgression a b c \u2227\n    coloring a = coloring b \u2227 coloring b = coloring c\n\ntheorem monochromatic_AP_exists : \n  \u2200 (coloring : \u2115 \u2192 Bool), hasMonochromaticAP coloring :=\n  sorry", "formal_statement_pred": "import Mathlib\n\ndef isArithmeticProgression (a b c : Nat) : Prop :=\n  b - a = c - b\n\ndef hasMonochromaticAP (coloring : Fin 9 \u2192 Bool) : Prop :=\n  \u2203 (a b c : Fin 9),\n    (a.val + 1 < b.val + 1) \u2227\n    (b.val + 1 < c.val + 1) \u2227\n    isArithmeticProgression (a.val + 1) (b.val + 1) (c.val + 1) \u2227\n    coloring a = coloring b \u2227\n    coloring b = coloring c\n\ntheorem monochromatic_AP_exists :\n  \u2200 (coloring : Fin 9 \u2192 Bool), hasMonochromaticAP coloring :=\n  sorry", "compiled": true, "aligned": true}
{"id": "CombStruct4Lean_157", "informal_problem": "10.5. In a tournament, 50 chess players participated. At a certain point in the tournament, 61 games had been played, with each participant having played either two games or three (and no one played the same opponent twice). Could it have been the case that no two players who played three games each played against each other?", "formal_statement": "import Mathlib\n\nstructure ChessTournament where\n  n : Nat                             -- number of players\n  games_played : Nat                  -- total number of games played\n  played_games : Fin n \u2192 Nat          -- number of games each player played\n  opponents : Fin n \u2192 Fin n \u2192 Bool    -- adjacency matrix of who played whom\n\n  player_games : \u2200 i, played_games i = 2 \u2228 played_games i = 3  -- each player played 2 or 3 games\n  no_self_games : \u2200 i, \u00acopponents i i                         -- no self-games\n  symmetric : \u2200 i j, opponents i j = opponents j i            -- symmetry of games\n  count_correct : games_played = (\u2211 i, played_games i) / 2    -- total games count matches\n  no_repeats : \u2200 i j, opponents i j \u2192 (\u2200 k, opponents i k \u2192 k = j) -- no repeated games\n\ntheorem chess_tournament_possible (n : Nat) (h : n = 50) (games : Nat) (h2 : games = 61) :\n  \u00ac\u2203 (t : ChessTournament), \n    t.n = n \u2227 \n    t.games_played = games \u2227 \n    (\u2200 i j, t.played_games i = 3 \u2192 t.played_games j = 3 \u2192 \u00act.opponents i j) :=\n  sorry", "formal_statement_pred": "import Mathlib\n\nstructure ChessTournament where\n  n : Nat\n  games_played : Nat\n  played_games : Fin n \u2192 Nat\n  opponents : Fin n \u2192 Fin n \u2192 Bool\n\n  no_self_games : \u2200 i, \u00acopponents i i\n  symmetric_opponents : \u2200 i j, opponents i j = opponents j i\n  games_count_valid : \u2200 i, played_games i = 2 \u2228 played_games i = 3\n  total_games_correct : games_played * 2 = (\u2211 i, played_games i)\n  no_duplicate_games : \u2200 i j, opponents i j \u2192 (\u2200 k, k \u2260 j \u2192 \u00acopponents i k)\n\ntheorem chess_tournament_possible (n : Nat) (h : n = 50) (g : Nat) (hg : g = 61) :\n  \u00ac\u2203 (t : ChessTournament),\n    t.n = n \u2227\n    t.games_played = g \u2227\n    (\u2200 i j, t.played_games i = 3 \u2192 t.played_games j = 3 \u2192 \u00act.opponents i j) :=\n  sorry", "compiled": true, "aligned": true}
{"id": "CombStruct4Lean_158", "informal_problem": "11.1. Can a rectangle, each side of which is greater than 1, be formed from all rectangles of sizes $1 \\times 1, 1 \\times 3, 1 \\times 5, \\ldots, 1 \\times 2019$, taken exactly once?", "formal_statement": "import Mathlib\n\n-- Define a list of rectangles with dimensions 1 \u00d7 (2k-1) for k from 1 to 1010\ndef rectanglesList : List (Nat \u00d7 Nat) :=\n  List.map (fun k => (1, 2 * k - 1)) (List.range 1010)\n\n-- A function to check if a list of rectangles can form a larger rectangle\ndef canFormRectangle (rectangles : List (Nat \u00d7 Nat)) : Prop :=\n  \u2203 (W H : Nat), \n    W > 1 \u2227 H > 1 \u2227  -- The resulting rectangle should have sides > 1\n    W * H = (rectangles.map (fun r => r.1 * r.2)).sum  -- Total area should match\n\ntheorem rectangle_formation_impossible : \n  \u00ac(canFormRectangle rectanglesList) :=\n  sorry", "formal_statement_pred": "import Mathlib\n\nstructure RectanglePacking where\n\n  width : Nat\n  height : Nat\n\n  pieces : List (Nat \u00d7 Nat)\n\n  width_gt_one : width > 1\n  height_gt_one : height > 1\n\n  valid_pieces : \u2200 p \u2208 pieces, p.1 = 1 \u2227 \u2203 k, p.2 = 2*k - 1 \u2227 k \u2264 1010\n\n  all_pieces : pieces.length = 1010 \u2227\n               \u2200 k \u2264 1010, (1, 2*k - 1) \u2208 pieces \u2227\n               (pieces.count (1, 2*k - 1) = 1)\n\ntheorem rectangle_packing_impossible : \u00ac\u2203 (pack : RectanglePacking),\n\n  pack.width * pack.height = (List.sum (pack.pieces.map (fun p \u21a6 p.1 * p.2))) :=\n  sorry", "compiled": true, "aligned": true}
{"id": "CombStruct4Lean_160", "informal_problem": "5. On the coordinate plane, 2017 points with integer coordinates $(x, y)$ were marked arbitrarily, where $1 \\leq x \\leq 2016$ and $1 \\leq y \\leq 2016$. Prove that there will always be two different segments with endpoints among these points, having the same length.", "formal_statement": "import Mathlib\n\nstructure Point where\n  x : Int\n  y : Int\n  x_bound : 1 \u2264 x \u2227 x \u2264 2016\n  y_bound : 1 \u2264 y \u2227 y \u2264 2016\n\ndef distance_squared (p\u2081 p\u2082 : Point) : Int :=\n  (p\u2081.x - p\u2082.x)^2 + (p\u2081.y - p\u2082.y)^2\n\nstructure Segment where\n  p\u2081 : Point\n  p\u2082 : Point\n  distinct : p\u2081 \u2260 p\u2082\n\ntheorem equal_length_segments_exist (points : Finset Point) \n    (h_size : points.card = 2017)\n    (h_valid : \u2200 p \u2208 points, 1 \u2264 p.x \u2227 p.x \u2264 2016 \u2227 1 \u2264 p.y \u2227 p.y \u2264 2016) :\n    \u2203 (s\u2081 s\u2082 : Segment),\n      s\u2081.p\u2081 \u2208 points \u2227 s\u2081.p\u2082 \u2208 points \u2227\n      s\u2082.p\u2081 \u2208 points \u2227 s\u2082.p\u2082 \u2208 points \u2227\n      s\u2081 \u2260 s\u2082 \u2227\n      distance_squared s\u2081.p\u2081 s\u2081.p\u2082 = distance_squared s\u2082.p\u2081 s\u2082.p\u2082 :=\n  sorry", "formal_statement_pred": "import Mathlib\n\nstructure Point where\n  x : \u2124\n  y : \u2124\n  hx : 1 \u2264 x \u2227 x \u2264 2016\n  hy : 1 \u2264 y \u2227 y \u2264 2016\n\ndef distanceSquared (p\u2081 p\u2082 : Point) : \u2124 :=\n  (p\u2081.x - p\u2082.x)^2 + (p\u2081.y - p\u2082.y)^2\n\nstructure Segment where\n  start : Point\n  endpoint : Point\n  h_distinct : start \u2260 endpoint\n  h_canonical : start.x < endpoint.x \u2228 (start.x = endpoint.x \u2227 start.y < endpoint.y)\n\ntheorem equal_length_segments_exist (points : Finset Point)\n    (h_size : points.card = 2017) :\n    \u2203 (s\u2081 s\u2082 : Segment),\n      s\u2081.start \u2208 points \u2227 s\u2081.endpoint \u2208 points \u2227\n      s\u2082.start \u2208 points \u2227 s\u2082.endpoint \u2208 points \u2227\n      s\u2081 \u2260 s\u2082 \u2227\n      s\u2081.start \u2260 s\u2082.start \u2227 s\u2081.start \u2260 s\u2082.endpoint \u2227\n      s\u2081.endpoint \u2260 s\u2082.start \u2227 s\u2081.endpoint \u2260 s\u2082.endpoint \u2227\n      distanceSquared s\u2081.start s\u2081.endpoint = distanceSquared s\u2082.start s\u2082.endpoint :=\n  sorry", "compiled": true, "aligned": true}
{"id": "CombStruct4Lean_161", "informal_problem": "5. Given $n+1$ pairwise distinct natural numbers, all less than $2n$ ($n>1$). Prove that among them, there exist three numbers such that the sum of two of them equals the third.", "formal_statement": "import Mathlib\n\nstructure NumberSet (n : \u2115) where\n  elements : Finset \u2115\n  size : elements.card = n + 1\n  distinct : elements.card = elements.toSet.toFinset.card\n  bound : \u2200 x \u2208 elements, x < 2 * n\n\ntheorem exists_sum_equals_third {n : \u2115} (h : n > 1) (S : NumberSet n) :\n  \u2203 (a b c : \u2115), a \u2208 S.elements \u2227 b \u2208 S.elements \u2227 c \u2208 S.elements \u2227\n    a \u2260 b \u2227 b \u2260 c \u2227 a \u2260 c \u2227 a + b = c :=\n  sorry", "formal_statement_pred": "import Mathlib\n\nstructure NumberSet (n : \u2115) where\n  nums : Finset \u2115\n  card_prop : nums.card = n + 1\n  bound_prop : \u2200 x \u2208 nums, x < 2 * n\n  distinct : nums.card = (nums.toList.toFinset).card\n\ntheorem exists_sum_equals_third {n : \u2115} (h : n > 1) (S : NumberSet n) :\n  \u2203 (a b c : \u2115), a \u2208 S.nums \u2227 b \u2208 S.nums \u2227 c \u2208 S.nums \u2227\n    a \u2260 b \u2227 b \u2260 c \u2227 a \u2260 c \u2227\n    a + b = c :=\n  sorry", "compiled": true, "aligned": true}
{"id": "CombStruct4Lean_162", "informal_problem": "# Problem 11.2\n\nIn each cell of a $2021 \\cdot 2021$ square table, one of the numbers 1 or -1 is written arbitrarily. Below each column, the product of all numbers in that column is written. To the right of each row, the product of all numbers in that row is written. Prove that the sum of the 4042 written products cannot be zero.\n\n## Number of points 7", "formal_statement": "import Mathlib\n\nstructure SignedTable where\n  size : Nat\n  entries : Fin size \u2192 Fin size \u2192 Int\n  -- Constraint that entries are only 1 or -1\n  entries_valid : \u2200 (i j : Fin size), entries i j = 1 \u2228 entries i j = -1\n\ndef rowProduct (t : SignedTable) (i : Fin t.size) : Int :=\n  (Finset.univ.prod fun j => t.entries i j)\n\ndef colProduct (t : SignedTable) (j : Fin t.size) : Int :=\n  (Finset.univ.prod fun i => t.entries i j)\n\ndef sumOfProducts (t : SignedTable) : Int :=\n  (Finset.univ.sum fun i => rowProduct t i) + \n  (Finset.univ.sum fun j => colProduct t j)\n\ntheorem table_products_nonzero : \n  \u2200 (t : SignedTable), t.size = 2021 \u2192 sumOfProducts t \u2260 0 :=\n  sorry", "formal_statement_pred": "import Mathlib\n\nstructure SignTable where\n  size : Nat\n  entries : Matrix (Fin size) (Fin size) Int\n  h_entries : \u2200 i j, entries i j = 1 \u2228 entries i j = -1\n\ndef SignTable.rowProduct (t : SignTable) (i : Fin t.size) : Int :=\n  Finset.prod (Finset.univ : Finset (Fin t.size)) fun j => t.entries i j\n\ndef SignTable.colProduct (t : SignTable) (j : Fin t.size) : Int :=\n  Finset.prod (Finset.univ : Finset (Fin t.size)) fun i => t.entries i j\n\ndef SignTable.sumOfProducts (t : SignTable) : Int :=\n  Finset.sum (Finset.univ : Finset (Fin t.size)) (t.rowProduct) +\n  Finset.sum (Finset.univ : Finset (Fin t.size)) (t.colProduct)\n\ntheorem sign_table_sum_nonzero (t : SignTable) (h : t.size = 2021) :\n  t.sumOfProducts \u2260 0 :=\n  sorry", "compiled": true, "aligned": true}
{"id": "CombStruct4Lean_163", "informal_problem": "8.4. In the cells of a $15 \\times 15$ table, the numbers $1, 2, \\ldots, 15$ are written. In each row and each column, each of these numbers appears exactly once. In cells symmetric with respect to the main diagonal of the table (running from the top left to the bottom right), the same numbers are written. Prove that all numbers are represented on the main diagonal.", "formal_statement": "import Mathlib\n\nstructure SymmetricLatinSquare (n : Nat) where\n  -- The table is represented as a function from pairs of indices to numbers\n  table : Fin n \u2192 Fin n \u2192 Fin n\n  -- Each row contains each number exactly once\n  row_latin : \u2200 i k : Fin n, \u2203! j : Fin n, table i j = k\n  -- Each column contains each number exactly once\n  col_latin : \u2200 j k : Fin n, \u2203! i : Fin n, table i j = k\n  -- Symmetry across main diagonal\n  symmetric : \u2200 i j : Fin n, table i j = table j i\n\ntheorem symmetric_latin_square_diagonal_complete :\n  \u2200 (s : SymmetricLatinSquare 15),\n  \u2200 k : Fin 15, \u2203 i : Fin 15, s.table i i = k :=\n  sorry", "formal_statement_pred": "import Mathlib\n\nstructure SymmetricLatinSquare (n : Nat) where\n\n  matrix : Fin n \u2192 Fin n \u2192 Fin n\n\n  row_latin : \u2200 i j\u2081 j\u2082, j\u2081 \u2260 j\u2082 \u2192 matrix i j\u2081 \u2260 matrix i j\u2082\n\n  col_latin : \u2200 i\u2081 i\u2082 j, i\u2081 \u2260 i\u2082 \u2192 matrix i\u2081 j \u2260 matrix i\u2082 j\n\n  symmetric : \u2200 i j, matrix i j = matrix j i\n\ntheorem symmetric_latin_square_diagonal_complete (square : SymmetricLatinSquare 15) :\n  \u2200 k : Fin 15, \u2203 i : Fin 15, square.matrix i i = k :=\n  sorry", "compiled": true, "aligned": true}
{"id": "CombStruct4Lean_164", "informal_problem": "5. In the cells of a table with 10 rows and 10 columns, the numbers +1 and -1 are placed. The products of the numbers in each column and each row are taken. Prove that the sum of these 20 products cannot be equal to two.\n\n#", "formal_statement": "import Mathlib\n\nstructure Grid where\n  values : Matrix (Fin 10) (Fin 10) Int\n  valid  : \u2200 i j, values i j = 1 \u2228 values i j = -1\n\ndef rowProduct (g : Grid) (i : Fin 10) : Int :=\n  Finset.univ.prod (fun j => g.values i j)\n\ndef colProduct (g : Grid) (j : Fin 10) : Int :=\n  Finset.univ.prod (fun i => g.values i j)\n\ndef totalProductSum (g : Grid) : Int :=\n  Finset.univ.sum (fun i => rowProduct g i) +\n  Finset.univ.sum (fun j => colProduct g j)\n\ntheorem grid_products_not_two (g : Grid) : \n  totalProductSum g \u2260 2 :=\n  sorry", "formal_statement_pred": "import Mathlib\n\ndef SignMatrix := Fin 10 \u2192 Fin 10 \u2192 Int\n\ndef isValidSignMatrix (m : SignMatrix) : Prop :=\n  \u2200 i j, m i j = 1 \u2228 m i j = -1\n\ndef rowProduct (m : SignMatrix) (i : Fin 10) : Int :=\n  (Finset.univ.prod fun j => m i j)\n\ndef colProduct (m : SignMatrix) (j : Fin 10) : Int :=\n  (Finset.univ.prod fun i => m i j)\n\ndef totalProductSum (m : SignMatrix) : Int :=\n  (Finset.univ.sum fun i => rowProduct m i) +\n  (Finset.univ.sum fun j => colProduct m j)\n\ntheorem sign_matrix_sum_not_two {m : SignMatrix} (h : isValidSignMatrix m) :\n  totalProductSum m \u2260 2 :=\n  sorry", "compiled": true, "aligned": true}
{"id": "CombStruct4Lean_165", "informal_problem": "3. A hexagon is formed from 3 yellow and 3 blue sticks, such that the colors of the sticks alternate along its perimeter. From any three consecutive sticks, a triangle can be formed. Prove that a triangle can also be formed from the sticks of one of the colors.", "formal_statement": "import Mathlib\n\ninductive StickColor\n| yellow\n| blue\nderiving Repr, DecidableEq\n\nstructure ColoredStick where\n  length : \u211d\n  length_pos : length > 0\n  color : StickColor\n\ndef forms_triangle (s\u2081 s\u2082 s\u2083 : \u211d) : Prop :=\n  s\u2081 + s\u2082 > s\u2083 \u2227 s\u2082 + s\u2083 > s\u2081 \u2227 s\u2083 + s\u2081 > s\u2082\n\nstructure AlternatingHexagon where\n  sticks : Fin 6 \u2192 ColoredStick\n  lengths_pos : \u2200 i, (sticks i).length > 0\n  alternating : \u2200 i : Fin 6, \n    (sticks i).color = if i.val % 2 = 0 then StickColor.yellow else StickColor.blue\n  consecutive_triangle : \u2200 i : Fin 6, \n    forms_triangle \n      (sticks i).length\n      (sticks \u27e8(i.val + 1) % 6, by exact Nat.mod_lt _ (by norm_num)\u27e9).length\n      (sticks \u27e8(i.val + 2) % 6, by exact Nat.mod_lt _ (by norm_num)\u27e9).length\n\ntheorem monochromatic_triangle_exists (h : AlternatingHexagon) :\n  \u2203 (s\u2081 s\u2082 s\u2083 : ColoredStick),\n    s\u2081 \u2208 Set.range h.sticks \u2227\n    s\u2082 \u2208 Set.range h.sticks \u2227\n    s\u2083 \u2208 Set.range h.sticks \u2227\n    s\u2081.color = s\u2082.color \u2227\n    s\u2082.color = s\u2083.color \u2227\n    forms_triangle s\u2081.length s\u2082.length s\u2083.length :=\n  sorry", "formal_statement_pred": "import Mathlib\n\n\ndef cyclicSucc (i : Fin 3) : Fin 3 :=\n  \u27e8(i.val + 1) % 3, by sorry\u27e9\n\n\nstructure PosReal where\n  val : \u211d\n  pos : val > 0\n\n\ndef TriangleIneq (a b c : PosReal) : Prop :=\n  a.val + b.val > c.val \u2227 b.val + c.val > a.val \u2227 c.val + a.val > b.val\n\n\nstructure ColoredHexagon where\n  yellow_sticks : Fin 3 \u2192 PosReal\n  blue_sticks : Fin 3 \u2192 PosReal\n  consecutive_triangles : \u2200 i : Fin 3,\n    TriangleIneq\n      (yellow_sticks i)\n      (blue_sticks i)\n      (yellow_sticks (cyclicSucc i))\n\ntheorem hexagon_monochrome_triangle (h : ColoredHexagon) :\n  TriangleIneq (h.yellow_sticks 0) (h.yellow_sticks 1) (h.yellow_sticks 2) \u2228\n  TriangleIneq (h.blue_sticks 0) (h.blue_sticks 1) (h.blue_sticks 2) :=\n  sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_166", "informal_problem": "11.2. Each of 100 schoolchildren has a stack of 101 cards numbered from 0 to 100. The first schoolchild shuffles the stack, then takes one card from the top of the resulting stack, and each time a card is taken (including the first time), writes on the board the arithmetic mean of the numbers on all the cards taken by him at that moment. Thus, he writes down 100 numbers, and when only one card is left in the stack, he returns the cards to the stack, and the next schoolchild, starting with shuffling the stack, does the same, then the third, and so on. Prove that among the 10000 numbers written on the board, there will be two identical numbers.\n\n(A. Gribalko)", "formal_statement": "import Mathlib\n\n/-- Number of cards (0 to 100 inclusive) -/\ndef NUM_CARDS : Nat := 101\n/-- Number of students -/\ndef NUM_STUDENTS : Nat := 100\n\n/-- A stack of cards with values 0 to 100 -/\nstructure CardStack where\n  cards : Fin NUM_CARDS \u2192 Nat\n  valid : \u2200 i, cards i \u2264 100\n  perm : Function.Bijective cards\n\n/-- Sequence of draws for one student, tracking running sum for mean calculation -/\nstructure StudentDraws where\n  draws : Vector Nat 100  -- exactly 100 draws\n  from_valid_stack : \u2200 i, draws.get i \u2264 100\n  all_different : \u2200 i j, i \u2260 j \u2192 draws.get i \u2260 draws.get j\n  running_means : Vector \u211a 100  -- means after each draw\n  means_valid : \u2200 k, running_means.get k = \n    ((draws.toList.take (k+1)).sum : \u211a) / (k+1)\n\ntheorem means_have_duplicate :\n  \u2200 (draws : Fin NUM_STUDENTS \u2192 StudentDraws),\n  \u2203 (i j : Fin NUM_STUDENTS) (k l : Fin 100),\n    (i \u2260 j \u2228 k \u2260 l) \u2227 \n    (draws i).running_means.get k = (draws j).running_means.get l :=\n  sorry", "formal_statement_pred": "import Mathlib\n\n\nstructure Selection where\n  cards : List (Fin 101)\n  deriving Repr\n\n\ndef Selection.mean (s : Selection) : \u211a :=\n  (s.cards.map (\u03bb x => x.val)).sum / s.cards.length\n\n\nstructure ChildSelections where\n  selections : List Selection\n  selections_count : selections.length = 100\n\ntheorem means_pigeonhole (children : Fin 100 \u2192 ChildSelections) :\n  \u2203 (i j : Fin 100) (s\u2081 s\u2082 : Selection),\n    s\u2081 \u2208 (children i).selections \u2227\n    s\u2082 \u2208 (children j).selections \u2227\n    (i \u2260 j \u2228 s\u2081 \u2260 s\u2082) \u2227\n    s\u2081.mean = s\u2082.mean :=\n  sorry", "compiled": true, "aligned": true}
{"id": "CombStruct4Lean_167", "informal_problem": "2. Given a $6 \\times 3$ table. Each cell is filled with a number 0 or 1. If at the intersection of any two rows and any two columns all four numbers are the same, then the table is considered to be filled unsuccessfully. Is it possible to fill the table in such a way to avoid this phenomenon?", "formal_statement": "import Mathlib\n\ndef Table := Fin 6 \u2192 Fin 3 \u2192 Bool\n\ndef is_successful_filling (t : Table) : Prop :=\n  \u2200 (r\u2081 r\u2082 : Fin 6) (c\u2081 c\u2082 : Fin 3),\n    r\u2081 \u2260 r\u2082 \u2192 c\u2081 \u2260 c\u2082 \u2192\n    \u00ac(t r\u2081 c\u2081 = t r\u2081 c\u2082 \u2227 \n      t r\u2081 c\u2081 = t r\u2082 c\u2081 \u2227 \n      t r\u2081 c\u2081 = t r\u2082 c\u2082)\n\ntheorem exists_successful_filling : \n  \u2203 (t : Table), is_successful_filling t :=\n  sorry", "formal_statement_pred": "import Mathlib\n\ndef Table := Fin 6 \u2192 Fin 3 \u2192 Bool\n\ndef is_successful_filling (t : Table) : Prop :=\n  \u2200 (r\u2081 r\u2082 : Fin 6) (c\u2081 c\u2082 : Fin 3),\n    r\u2081 < r\u2082 \u2192 c\u2081 < c\u2082 \u2192\n    \u00ac(t r\u2081 c\u2081 = t r\u2081 c\u2082 \u2227\n      t r\u2081 c\u2081 = t r\u2082 c\u2081 \u2227\n      t r\u2081 c\u2081 = t r\u2082 c\u2082)\n\ntheorem exists_successful_6x3_table :\n  \u2203 (t : Table), is_successful_filling t :=\n  sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_168", "informal_problem": "5. Can a $5 \\times 5$ square be cut into two types of rectangles: $1 \\times 4$ and $1 \\times 3$, so that exactly 8 rectangles are obtained?\n\n7 points are awarded for a complete solution to each problem\n\nThe maximum total score is 35", "formal_statement": "import Mathlib\n\n-- Define valid rectangle types\ninductive RectType where\n  | long  : RectType  -- 1\u00d74 rectangle\n  | short : RectType  -- 1\u00d73 rectangle\n\nstructure PlacedRectangle where\n  rect_type : RectType\n  pos_x : Fin 5\n  pos_y : Fin 5\n  is_valid : pos_y.val + (match rect_type with \n    | RectType.long => 4 \n    | RectType.short => 3) \u2264 5\n\ndef PlacedRectangle.height (r : PlacedRectangle) : Nat :=\n  match r.rect_type with\n  | RectType.long  => 4\n  | RectType.short => 3\n\ndef PlacedRectangle.covers (r : PlacedRectangle) (x y : Fin 5) : Prop :=\n  x = r.pos_x \u2227 \n  y.val \u2265 r.pos_y.val \u2227 \n  y.val < r.pos_y.val + r.height\n\nstructure RectangleTiling where\n  pieces : List PlacedRectangle\n  piece_count : pieces.length = 8\n  covers_all : \u2200 x y : Fin 5, \u2203 p, p \u2208 pieces \u2227 p.covers x y\n  no_overlap : \u2200 p\u2081 p\u2082, p\u2081 \u2208 pieces \u2192 p\u2082 \u2208 pieces \u2192 p\u2081 \u2260 p\u2082 \u2192 \n    \u2200 x y : Fin 5, \u00ac(p\u2081.covers x y \u2227 p\u2082.covers x y)\n\ntheorem five_by_five_tiling_exists : \u2203 t : RectangleTiling, t.pieces \u2260 [] :=\n  sorry", "formal_statement_pred": "import Mathlib\n\nstructure RectangleTiling where\n  rectangles : List (Nat \u00d7 Nat)\n  positions : List (Nat \u00d7 Nat)\n\n  is_valid : rectangles.length = positions.length\n  covers_square : positions.length = 8\n  only_valid_sizes : \u2200 r \u2208 rectangles, (r = (1, 4) \u2228 r = (1, 3))\n  fits_in_square : \u2200 (i : Fin rectangles.length),\n    let (x, y) := positions[i]\n    let (w, h) := rectangles[i]\n    x + w \u2264 5 \u2227 y + h \u2264 5\n  no_overlap : \u2200 (i j : Fin rectangles.length),\n    i \u2260 j \u2192\n    let (x\u2081, y\u2081) := positions[i]\n    let (w\u2081, h\u2081) := rectangles[i]\n    let (x\u2082, y\u2082) := positions[j]\n    let (w\u2082, h\u2082) := rectangles[j]\n    \u00ac(x\u2081 < x\u2082 + w\u2082 \u2227 x\u2082 < x\u2081 + w\u2081 \u2227 y\u2081 < y\u2082 + h\u2082 \u2227 y\u2082 < y\u2081 + h\u2081)\n  covers_all : \u2200 (x y : Fin 5),\n    \u2203 (i : Fin rectangles.length),\n    let (px, py) := positions[i]\n    let (w, h) := rectangles[i]\n    px \u2264 x \u2227 x < px + w \u2227 py \u2264 y \u2227 y < py + h\n\ntheorem five_by_five_tiling_exists : \u2203 (t : RectangleTiling), True :=\n  sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_169", "informal_problem": "4. The King of Beasts, the Lion, announced a volleyball tournament. Several volleyball teams consisting of different animals have gathered. In the tournament, each team plays against each other. Prove that after each game, there will be two teams that have played the same number of matches by this point.", "formal_statement": "import Mathlib\n\nstructure Tournament where\n  teams : Nat              -- number of teams\n  matches_played : Nat \u2192 Nat   -- function mapping team index to number of matches played\n  h_valid_matches : \u2200 t, matches_played t \u2264 (teams - 1)  -- max matches per team is (teams-1)\n  h_teams_positive : teams > 0\n\ntheorem pigeonhole_volleyball {n : Nat} (t : Tournament) (h : t.teams = n) (h_teams : n > 1) :\n  \u2203 i j, i < t.teams \u2227 j < t.teams \u2227 i \u2260 j \u2227 t.matches_played i = t.matches_played j :=\n  sorry", "formal_statement_pred": "import Mathlib\n\nstructure Tournament where\n  teams : Nat\n  matches_played : Nat \u2192 Nat\n  valid_matches : \u2200 i, i < teams \u2192 matches_played i \u2264 (teams - 1)\n\ntheorem pigeonhole_volleyball_tournament (t : Tournament) (h : t.teams > 1) :\n  \u2203 i j, i < t.teams \u2227 j < t.teams \u2227 i \u2260 j \u2227 t.matches_played i = t.matches_played j :=\n  sorry", "compiled": true, "aligned": true}
{"id": "CombStruct4Lean_170", "informal_problem": "3. At the Olympiad, 64 participants arrived. It turned out that each of them had no more than 8 acquaintances among the participants. Prove that there will be 8 participants who are pairwise unfamiliar with each other.", "formal_statement": "import Mathlib\n\nstructure OlympiadParticipants where\n  n : Nat\n  knows : Fin n \u2192 Fin n \u2192 Prop\n  [decKnows : DecidableRel knows]\n  h_size : n \u2265 64\n  knows_symm : \u2200 i j, knows i j \u2194 knows j i\n  knows_irrefl : \u2200 i, \u00acknows i i\n  max_acquaintances : \u2200 i, (Finset.filter (fun j => knows i j) Finset.univ).card \u2264 8\n\ntheorem olympiad_independent_set (p : OlympiadParticipants) (h : p.n = 64) :\n  \u2203 S : Finset (Fin p.n), S.card = 8 \u2227 \n    \u2200 (i j : Fin p.n), i \u2208 S \u2192 j \u2208 S \u2192 i \u2260 j \u2192 \u00acp.knows i j :=\n  sorry", "formal_statement_pred": "import Mathlib\n\nstructure OlympiadParticipants where\n  n : Nat\n\n  acquaintances : Fin n \u2192 Finset (Fin n)\n\n  symm : \u2200 i j, j \u2208 acquaintances i \u2194 i \u2208 acquaintances j\n\n  irrefl : \u2200 i, i \u2209 acquaintances i\n\n  max_size : \u2200 i, (acquaintances i).card \u2264 8\n\ntheorem olympiad_independent_set\n  (participants : OlympiadParticipants)\n  (h : participants.n = 64) :\n  \u2203 (S : Finset (Fin participants.n)),\n    S.card = 8 \u2227\n    \u2200 {i j}, i \u2208 S \u2192 j \u2208 S \u2192 i \u2260 j \u2192 i \u2209 participants.acquaintances j :=\n  sorry", "compiled": true, "aligned": true}
{"id": "CombStruct4Lean_171", "informal_problem": "7.5. At the vertices of a cube, 8 numbers: $1, 2, \\ldots, 8$ were arranged in some order, and then for each of the 12 edges of the cube, the sum of the two numbers at its ends was calculated. Prove that among these sums there are coinciding ones.", "formal_statement": "import Mathlib\n\n/-- The fixed set of edges in a cube, represented as pairs of vertices -/\ndef cubeEdges : List (Fin 8 \u00d7 Fin 8) := [\n  (0, 1), (1, 2), (2, 3), (3, 0),  -- front face\n  (4, 5), (5, 6), (6, 7), (7, 4),  -- back face\n  (0, 4), (1, 5), (2, 6), (3, 7)   -- connecting edges\n]\n\n/-- A valid labeling of cube vertices with numbers 1 through 8 -/\nstructure CubeLabeling where\n  label : Fin 8 \u2192 Nat\n  valid : \u2200 i, 1 \u2264 label i \u2227 label i \u2264 8\n  distinct : \u2200 i j, i \u2260 j \u2192 label i \u2260 label j\n\n/-- Computes the sum of labels at the endpoints of an edge -/\ndef edgeSum (l : CubeLabeling) (e : Fin 8 \u00d7 Fin 8) : Nat :=\n  l.label e.1 + l.label e.2\n\ntheorem cube_edge_sums_not_distinct (l : CubeLabeling) :\n  \u2203 (e\u2081 e\u2082 : Fin 8 \u00d7 Fin 8), \n    e\u2081 \u2208 cubeEdges \u2227 \n    e\u2082 \u2208 cubeEdges \u2227 \n    e\u2081 \u2260 e\u2082 \u2227\n    edgeSum l e\u2081 = edgeSum l e\u2082 :=\n  sorry", "formal_statement_pred": "import Mathlib\n\n\nstructure CubeVertex where\n  x : Bool\n  y : Bool\n  z : Bool\n\n\nstructure CubeEdge where\n  v1 : CubeVertex\n  v2 : CubeVertex\n\n  are_adjacent :\n    (v1.x \u2260 v2.x \u2227 v1.y = v2.y \u2227 v1.z = v2.z) \u2228\n    (v1.x = v2.x \u2227 v1.y \u2260 v2.y \u2227 v1.z = v2.z) \u2228\n    (v1.x = v2.x \u2227 v1.y = v2.y \u2227 v1.z \u2260 v2.z)\n\n\nstructure CubeLabeling where\n  label : CubeVertex \u2192 Fin 8\n  is_bijective : Function.Bijective label\n\n\ndef edgeSum (l : CubeLabeling) (e : CubeEdge) : Nat :=\n  (l.label e.v1).val + (l.label e.v2).val + 2\n\ntheorem cube_edge_sums_not_distinct :\n  \u2200 (l : CubeLabeling),\n  \u2203 (e1 e2 : CubeEdge), e1 \u2260 e2 \u2227 edgeSum l e1 = edgeSum l e2 :=\n  sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_172", "informal_problem": "4. All cells of an infinite grid plane are squares with a side length of 1. Each node of this grid is painted in one of two colors, and there is a node of each color. Prove that there will be two nodes of different colors, the distance between which is 5.", "formal_statement": "import Mathlib\n\n-- A point in the infinite grid is represented by integer coordinates\nstructure GridPoint where\n  x : Int\n  y : Int\n  deriving Repr\n\n-- Basic operations for GridPoint\ndef GridPoint.add (p\u2081 p\u2082 : GridPoint) : GridPoint :=\n  \u27e8p\u2081.x + p\u2082.x, p\u2081.y + p\u2082.y\u27e9\n\ndef GridPoint.sub (p\u2081 p\u2082 : GridPoint) : GridPoint :=\n  \u27e8p\u2081.x - p\u2082.x, p\u2081.y - p\u2082.y\u27e9\n\n-- A coloring of the grid assigns a boolean value to each point\n-- true and false represent the two colors\ndef GridColoring := GridPoint \u2192 Bool\n\n-- Squared distance between two grid points (returns Int)\ndef gridDistanceSquared (p\u2081 p\u2082 : GridPoint) : Int :=\n  let diff := p\u2081.sub p\u2082\n  diff.x * diff.x + diff.y * diff.y\n\ntheorem exists_distance_five_diff_colors \n  (c : GridColoring)\n  (h\u2081 : \u2203 p\u2081, c p\u2081 = true)\n  (h\u2082 : \u2203 p\u2082, c p\u2082 = false) :\n  \u2203 (p\u2081 p\u2082 : GridPoint), \n    c p\u2081 \u2260 c p\u2082 \u2227 \n    gridDistanceSquared p\u2081 p\u2082 = 25 :=\n  sorry", "formal_statement_pred": "import Mathlib\n\n\ninductive Color\n  | red\n  | blue\n\n\ndef GridColoring := \u2124 \u00d7 \u2124 \u2192 Color\n\n\ndef gridDistanceSquared (p\u2081 p\u2082 : \u2124 \u00d7 \u2124) : \u2124 :=\n  (p\u2081.1 - p\u2082.1)^2 + (p\u2081.2 - p\u2082.2)^2\n\ntheorem exists_distance_five (c : GridColoring)\n  (h\u2081 : \u2203 p\u2081 : \u2124 \u00d7 \u2124, c p\u2081 = Color.red)\n  (h\u2082 : \u2203 p\u2082 : \u2124 \u00d7 \u2124, c p\u2082 = Color.blue) :\n  \u2203 (p\u2081 p\u2082 : \u2124 \u00d7 \u2124),\n    c p\u2081 \u2260 c p\u2082 \u2227\n    gridDistanceSquared p\u2081 p\u2082 = 25 :=\n  sorry", "compiled": true, "aligned": true}
{"id": "CombStruct4Lean_173", "informal_problem": "10.4. A cube of size $5 \\times 5 \\times 5$ cells is divided into $1 \\times 1 \\times 1$ cubes, each of which contains a grasshopper. At some moment, each grasshopper moves to an adjacent cube (up, down, left, or right, provided that the cube exists). Will there be a cube that does not contain any grasshopper?", "formal_statement": "import Mathlib\n\n/-- Position in a 5\u00d75\u00d75 cube using zero-based indices -/\nstructure Position where\n  x : Fin 5\n  y : Fin 5\n  z : Fin 5\n\n/-- Checks if two positions are adjacent in the cube -/\ndef isAdjacent (p\u2081 p\u2082 : Position) : Bool :=\n  let dx := (p\u2081.x.val : \u2124) - (p\u2082.x.val : \u2124)\n  let dy := (p\u2081.y.val : \u2124) - (p\u2082.y.val : \u2124)\n  let dz := (p\u2081.z.val : \u2124) - (p\u2082.z.val : \u2124)\n  abs dx + abs dy + abs dz = 1\n\n/-- Represents the movement of all grasshoppers in one step -/\nstructure MovementConfig where\n  final_position : Position \u2192 Position  -- Where each grasshopper moves to\n  moves_adjacent : \u2200 p : Position, isAdjacent p (final_position p) = true\n\n/-- After all grasshoppers move to adjacent positions, there must be at least one empty position -/\ntheorem grasshopper_movement_theorem :\n  \u2200 (config : MovementConfig), \u2203 (p : Position), \n    (\u2200 q : Position, config.final_position q \u2260 p) :=\n  sorry", "formal_statement_pred": "import Mathlib\n\n\nstructure Position where\n  x : Fin 5\n  y : Fin 5\n  z : Fin 5\n\n\ndef isAdjacent (p\u2081 p\u2082 : Position) : Prop :=\n  (p\u2081.x = p\u2082.x \u2227 p\u2081.y = p\u2082.y \u2227 (p\u2081.z.val + 1 = p\u2082.z.val \u2228 p\u2082.z.val + 1 = p\u2081.z.val)) \u2228\n  (p\u2081.x = p\u2082.x \u2227 p\u2081.z = p\u2082.z \u2227 (p\u2081.y.val + 1 = p\u2082.y.val \u2228 p\u2082.y.val + 1 = p\u2081.y.val)) \u2228\n  (p\u2081.y = p\u2082.y \u2227 p\u2081.z = p\u2082.z \u2227 (p\u2081.x.val + 1 = p\u2082.x.val \u2228 p\u2082.x.val + 1 = p\u2081.x.val))\n\n\nstructure Movement where\n  move : Position \u2192 Position\n  valid : \u2200 p, isAdjacent p (move p)\n  injective : Function.Injective move\n\ntheorem grasshopper_movement_empty_cell :\n  \u2200 m : Movement, \u2203 p : Position, \u2200 p\u2080 : Position, m.move p\u2080 \u2260 p :=\n  sorry", "compiled": true, "aligned": true}
{"id": "CombStruct4Lean_174", "informal_problem": "5. There are 12 positive real numbers. It is known that the ratio of any two numbers from this set does not exceed the number 2. Prove that they can be divided into six pairs such that if the sums of the numbers in each pair are calculated, the ratio of any two of the resulting six sums will not exceed $\\frac{3}{2}$.", "formal_statement": "import Mathlib\n\nstructure NumberPairing where\n  numbers : Fin 12 \u2192 \u211d\n  all_positive : \u2200 i, numbers i > 0\n  ratio_bound : \u2200 i j, numbers i / numbers j \u2264 2\n\ndef pair_sum (p : NumberPairing) (pair : Fin 6) (pairing : Fin 6 \u2192 Fin 12 \u00d7 Fin 12) : \u211d :=\n  p.numbers (pairing pair).1 + p.numbers (pairing pair).2\n\ntheorem exists_bounded_pair_sums (p : NumberPairing) :\n  \u2203 (pairing : Fin 6 \u2192 Fin 12 \u00d7 Fin 12),\n    -- Each number appears exactly once in a pair\n    (\u2200 i : Fin 12, \u2203! j : Fin 6, (pairing j).1 = i \u2228 (pairing j).2 = i) \u2227\n    -- The ratio of any two pair sums does not exceed 3/2\n    (\u2200 i j : Fin 6, pair_sum p i pairing / pair_sum p j pairing \u2264 3/2) :=\n  sorry", "formal_statement_pred": "import Mathlib\n\nstructure NumberPairing where\n  numbers : Fin 12 \u2192 \u211d\n  all_positive : \u2200 i, numbers i > 0\n  ratio_bound : \u2200 i j, numbers i / numbers j \u2264 2\n\ndef pair_sum (p : NumberPairing) (pair : Fin 6) (pairing : Fin 6 \u2192 Fin 12 \u00d7 Fin 12) : \u211d :=\n  p.numbers (pairing pair).1 + p.numbers (pairing pair).2\n\ntheorem twelve_numbers_pairing_exists (p : NumberPairing) :\n  \u2203 (pairing : Fin 6 \u2192 Fin 12 \u00d7 Fin 12),\n\n    (\u2200 i : Fin 12, \u2203! j : Fin 6, (pairing j).1 = i \u2228 (pairing j).2 = i) \u2227\n\n    (\u2200 i j : Fin 6, pair_sum p i pairing / pair_sum p j pairing \u2264 3/2) :=\n  sorry", "compiled": true, "aligned": true}
{"id": "CombStruct4Lean_175", "informal_problem": "3. In the chess tournament for the cup of the city of Krasnoyarsk, boys and girls from schools in the city participated. Each player played one game with each other, 1 point was awarded for a win, 0.5 for a draw, and 0 for a loss. At the end of the tournament, it turned out that each participant scored exactly half of their points in games against boys. Prove that the number of participants in the tournament is a square of an integer.", "formal_statement": "import Mathlib\n\nstructure ChessTournament where\n  n : Nat                     -- total number of participants\n  boys : Finset (Fin n)      -- set of boys\n  girls : Finset (Fin n)     -- set of girls\n  scores : Fin n \u2192 Rat       -- scores of each player\n  results : Fin n \u2192 Fin n \u2192 Rat  -- game results between players (1, 0.5, or 0)\n  \n  boys_girls_partition : boys \u222a girls = Finset.univ \u2227 boys \u2229 girls = \u2205  -- boys and girls partition all players\n  valid_results : \u2200 i j, results i j \u2208 ({1, 0.5, 0} : Set Rat)         -- valid game scores\n  antisymmetric_results : \u2200 i j, results i j + results j i = 1         -- one wins, other loses\n  no_self_play : \u2200 i, results i i = 0                                  -- no self-play\n  \n  scores_sum : \u2200 i, scores i = (Finset.univ.filter (\u00b7 \u2260 i)).sum (results i)  -- total score computation\n  boys_half_points : \u2200 i, 2 * (boys.filter (\u00b7 \u2260 i)).sum (results i) = scores i  -- half points against boys\n\ntheorem krasnoyarsk_tournament_square_participants (t : ChessTournament) :\n  \u2203 k : Nat, t.n = k * k :=\n  sorry", "formal_statement_pred": "import Mathlib\n\nstructure ChessTournament where\n  n : Nat\n  h_pos : 0 < n\n  boys : Finset (Fin n)\n  girls : Finset (Fin n)\n  results : Fin n \u2192 Fin n \u2192 Rat\n  boys_disjoint_girls : Disjoint boys girls\n  all_players : boys \u222a girls = univ\n  valid_scores : \u2200 p1 p2 : Fin n, results p1 p2 \u2208 ({0, 0.5, 1} : Set Rat)\n  antisymmetric_games : \u2200 p1 p2 : Fin n, results p1 p2 + results p2 p1 = 1\n  no_self_games : \u2200 p : Fin n, results p p = 0\n  half_score_property : \u2200 p : Fin n,\n    (\u2211 i in univ, results p i) / 2 = (\u2211 b in boys, results p b)\n\ntheorem krasnoyarsk_tournament_square\n  (t : ChessTournament) :\n  \u2203 k : Nat, t.n = k * k :=\n  sorry", "compiled": true, "aligned": true}
{"id": "CombStruct4Lean_177", "informal_problem": "9.5. On the table, there is a pile of 2013 coins. One coin is removed from it and the pile is divided into two (not necessarily equal). Then, from any pile containing more than one coin, one coin is removed again and the pile is divided into two. And so on. Is it possible to leave only piles consisting of three coins on the table after several moves?", "formal_statement": "import Mathlib\n\nstructure GameState where\n  piles : List Nat\n  deriving Repr\n\ndef is_valid_move (s : GameState) (i : Nat) (split : Nat) : Bool :=\n  if h : i < s.piles.length then\n    let pile := (s.piles.get \u27e8i, h\u27e9)\n    pile > 1 \u2227 split > 0 \u2227 split < pile - 1\n  else\n    false\n\ndef make_move (s : GameState) (i : Nat) (split : Nat) : GameState :=\n  if h : i < s.piles.length \u2227 is_valid_move s i split then\n    let pile := (s.piles.get \u27e8i, h.1\u27e9)\n    let new_piles := s.piles.eraseIdx i\n    let split_piles := [split, pile - 1 - split]\n    { piles := new_piles ++ split_piles }\n  else\n    s\n\ndef all_piles_are_three (s : GameState) : Bool :=\n  s.piles.all (\u00b7 = 3)\n\ntheorem coin_splitting_puzzle : \u00ac\u2203 (moves : List (Nat \u00d7 Nat)),\n  let initial := GameState.mk [2013]\n  let final := moves.foldl (fun state (move : Nat \u00d7 Nat) =>\n    make_move state move.1 move.2) initial\n  all_piles_are_three final :=\n  sorry", "formal_statement_pred": "import Mathlib\n\nstructure GameState where\n  piles : List Nat\n  sum_coins : Nat\n  h_piles_nonempty : \u2200 p \u2208 piles, p > 0\n  h_sum_correct : sum_coins = piles.sum\n\nstructure Move where\n  pileIndex : Nat\n  splitAmount : Nat\n\n\ninductive GameStep : GameState \u2192 GameState \u2192 Prop where\n  | split {s\u2081 s\u2082 : GameState} {i split : Nat} {pile : Nat}\n    (h_idx : i < s\u2081.piles.length)\n    (h_pile : s\u2081.piles[i] = pile)\n    (h_pile_valid : pile > 1)\n    (h_split_valid : split > 0 \u2227 split < pile - 1)\n    (h_new_piles : s\u2082.piles = s\u2081.piles.removeNth i ++ [split, pile - 1 - split])\n    (h_sum : s\u2082.sum_coins = s\u2081.sum_coins - 1) : GameStep s\u2081 s\u2082\n\n\ninductive GameReachable : GameState \u2192 GameState \u2192 Prop where\n  | refl (s : GameState) : GameReachable s s\n  | step {s\u2081 s\u2082 s\u2083 : GameState} :\n    GameStep s\u2081 s\u2082 \u2192 GameReachable s\u2082 s\u2083 \u2192 GameReachable s\u2081 s\u2083\n\ndef all_piles_three (s : GameState) : Prop :=\n  \u2200 p \u2208 s.piles, p = 3\n\ntheorem coin_splitting_impossible (initial : GameState)\n    (h_initial : initial.piles = [2013] \u2227 initial.sum_coins = 2013) :\n    \u00ac\u2203 (final : GameState), GameReachable initial final \u2227 all_piles_three final :=\n  sorry", "compiled": true, "aligned": true}
{"id": "CombStruct4Lean_178", "informal_problem": "5. There are 30 students in the class. They sit at 15 desks such that exactly half of all the girls in the class sit with boys. Prove that it is impossible to rearrange them (at the same 15 desks) so that exactly half of all the boys in the class sit with girls.", "formal_statement": "import Mathlib\n\nstructure ClassSeating where\n  numGirls : Nat\n  numBoys : Nat\n  seating : Fin 30 \u2192 Fin 15  -- assigns each student to a desk\n  isGirl : Fin 30 \u2192 Bool     -- true if student is a girl\n  total_count : numGirls + numBoys = 30\n  girls_with_boys_count : Nat  -- number of girls sitting with boys\n  boys_with_girls_count : Nat  -- number of boys sitting with girls\n\n  -- Two students sit together if they share the same desk\n  sit_together (s1 s2 : Fin 30) : Bool :=\n    seating s1 = seating s2\n\n  -- Conditions for the initial arrangement\n  initial_girls_condition : girls_with_boys_count = numGirls / 2\n\ntheorem impossible_rearrangement (c : ClassSeating) :\n  \u00ac\u2203 (new_seating : Fin 30 \u2192 Fin 15),\n    let new_boys_with_girls := c.boys_with_girls_count\n    new_boys_with_girls = c.numBoys / 2 :=\n  sorry", "formal_statement_pred": "import Mathlib\n\nstructure SeatingArrangement where\n  numGirls : Nat\n  numBoys : Nat\n  desks : Fin 15 \u2192 Bool\n  girlsWithBoys : Nat\n  boysWithGirls : Nat\n\n  total_students : numGirls + numBoys = 30\n  valid_mixed_desks : girlsWithBoys = boysWithGirls\n  half_girls_mixed : girlsWithBoys = numGirls / 2\n\ntheorem impossible_rearrangement\n  (s : SeatingArrangement) :\n  \u00ac\u2203 (s' : SeatingArrangement),\n    s'.numGirls = s.numGirls \u2227\n    s'.numBoys = s.numBoys \u2227\n    s'.boysWithGirls = s.numBoys / 2 :=\n  sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_179", "informal_problem": "7.5. On each cell of a chessboard, there is a stack of several chips. In one move, one of the two operations is allowed:\n\n- remove one chip from each stack in any vertical column;\n- double the number of chips in each stack in any horizontal row.\n\nIs it possible to clear the entire board of chips in some number of such operations?", "formal_statement": "import Mathlib\n\nstructure ChessboardState where\n  -- Represents the number of chips in each cell (8x8 matrix)\n  chips : Matrix (Fin 8) (Fin 8) Nat\n\n-- Operation to remove one chip from each stack in a column\ndef removeFromColumn (state : ChessboardState) (col : Fin 8) : ChessboardState where\n  chips := fun i j => if j = col then state.chips i j - 1 else state.chips i j\n\n-- Operation to double chips in a row\ndef doubleRow (state : ChessboardState) (row : Fin 8) : ChessboardState where\n  chips := fun i j => if i = row then 2 * state.chips i j else state.chips i j\n\n-- Predicate to check if board is cleared\ndef isCleared (state : ChessboardState) : Prop :=\n  \u2200 i j, state.chips i j = 0\n\ntheorem chessboard_clearing_impossible (initial : ChessboardState) \n  (h : \u2200 i j, initial.chips i j > 0) : \n  \u00ac \u2203 (moves : List (Sum (Fin 8) (Fin 8))), \n    let final := moves.foldl \n      (fun state move => match move with\n        | Sum.inl col => removeFromColumn state col\n        | Sum.inr row => doubleRow state row) \n      initial\n    isCleared final :=\n  sorry", "formal_statement_pred": "import Mathlib\n\nstructure ChessboardState where\n  chips : Fin 8 \u2192 Fin 8 \u2192 Nat\n\n\ninductive Move\n  | removeColumn (col : Fin 8)\n  | doubleRow (row : Fin 8)\n\n\ndef applyMove (state : ChessboardState) (move : Move) : ChessboardState :=\n  match move with\n  | Move.removeColumn col =>\n      { chips := fun r c => if c = col then state.chips r c - 1 else state.chips r c }\n  | Move.doubleRow row =>\n      { chips := fun r c => if r = row then 2 * state.chips r c else state.chips r c }\n\n\ndef isEmpty (state : ChessboardState) : Prop :=\n  \u2200 r c, state.chips r c = 0\n\ntheorem chessboard_clearing_impossible (initial : ChessboardState)\n  (h : \u2200 r c, initial.chips r c > 0) :\n  \u00ac\u2203 (moves : List Move), isEmpty (moves.foldl applyMove initial) :=\n  sorry", "compiled": true, "aligned": true}
{"id": "CombStruct4Lean_180", "informal_problem": "1. There are 20 apples, and the weight difference between any two apples does not exceed 40 grams. Prove that these apples can be divided into two piles of 10 apples each, such that the weight difference between these piles does not exceed 40 grams.", "formal_statement": "import Mathlib\n\nstructure AppleCollection where\n  weights : Vector \u211d 20\n  (weights_nonneg : \u2200 i, weights.get i \u2265 0)\n  (weight_diff_bound : \u2200 i j, |weights.get i - weights.get j| \u2264 40)\n\ndef pile_weight (weights : Vector \u211d 20) (pile : Fin 20 \u2192 Bool) : \u211d :=\n  Finset.sum Finset.univ (fun i => if pile i then weights.get i else 0)\n\ndef is_valid_partition (weights : Vector \u211d 20) (pile : Fin 20 \u2192 Bool) : Prop :=\n  (Finset.sum Finset.univ (fun i => if pile i then 1 else 0) = 10) \u2227\n  |pile_weight weights pile - pile_weight weights (fun i => !pile i)| \u2264 40\n\ntheorem apple_division_exists (apples : AppleCollection) :\n  \u2203 (pile : Fin 20 \u2192 Bool), is_valid_partition apples.weights pile :=\n  sorry", "formal_statement_pred": "import Mathlib\n\nstructure AppleCollection where\n  weights : Fin 20 \u2192 \u211d\n  weight_diff_bound : \u2200 i j, |weights i - weights j| \u2264 40\n\n  sum_weights (s : Finset (Fin 20)) : \u211d :=\n    s.sum weights\n\n  total_weight : \u211d :=\n    sum_weights Finset.univ\n\ntheorem apple_division_exists (apples : AppleCollection) :\n  \u2203 (pile\u2081 : Finset (Fin 20)),\n    pile\u2081.card = 10 \u2227\n    |apples.sum_weights pile\u2081 - apples.sum_weights (pile\u2081\u1d9c)| \u2264 40 :=\n  sorry", "compiled": true, "aligned": true}
{"id": "CombStruct4Lean_181", "informal_problem": "10.1. In the National Basketball Association, there are 30 teams, each of which plays 82 games with other teams in the regular season. Can the Association's management divide the teams (not necessarily equally) into Eastern and Western Conferences and create a schedule such that games between teams from different conferences make up exactly half of the total number of games?\n\n(A. Gribalko)", "formal_statement": "import Mathlib\n\n-- A game is a pair of distinct teams\nstructure Game (n : Nat) where\n  team1 : Fin n\n  team2 : Fin n\n  distinct : team1 \u2260 team2\n\n-- NBA Schedule with conference division\nstructure NBASchedule (n : Nat) (g : Nat) where\n  -- Conference assignment (true for East, false for West)\n  conference : Fin n \u2192 Bool\n  -- List of all games in the schedule\n  games : List (Game n)\n  -- Each team appears in exactly g games\n  games_per_team : \u2200 t : Fin n,\n    (games.filter (\u03bb game => game.team1 = t \u2228 game.team2 = t)).length = g\n  -- Conferences are non-empty\n  valid_conferences : \u2203 t1 t2 : Fin n, conference t1 \u2260 conference t2\n\ntheorem nba_conference_schedule_exists :\n  \u2203 (s : NBASchedule 30 82),\n    -- Number of inter-conference games equals half of total games\n    let interConfGames := s.games.filter (\u03bb g => s.conference g.team1 \u2260 s.conference g.team2)\n    interConfGames.length = (30 * 82) / 2 :=\n  sorry", "formal_statement_pred": "import Mathlib\n\nstructure Game (n : Nat) where\n  team1 : Fin n\n  team2 : Fin n\n  different : team1 \u2260 team2\n\nstructure NBASchedule where\n  numTeams : Nat\n  gamesPerTeam : Nat\n\n  conference : Fin numTeams \u2192 Bool\n\n  games : List (Game numTeams)\n\n  valid_teams : numTeams = 30\n  valid_games : gamesPerTeam = 82\n\n  valid_size : games.length = numTeams * gamesPerTeam / 2\n\n  valid_count : \u2200 t : Fin numTeams,\n    (games.filter (\u03bb g => g.team1 = t \u2228 g.team2 = t)).length = gamesPerTeam\n\ntheorem nba_conference_schedule_exists : \u2203 (s : NBASchedule),\n\n  (s.games.filter (\u03bb g => s.conference g.team1 \u2260 s.conference g.team2)).length =\n    s.numTeams * s.gamesPerTeam / 4 :=\n  sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_182", "informal_problem": "5. In the company, 11 people gathered. It turned out that each person is friends with at least six of those present. Prove that in this company, there will be three friends (each is friends with the other two).", "formal_statement": "import Mathlib\n\n/-- A simple graph with n vertices represented by adjacency sets -/\nstructure FriendshipGraph (n : Nat) where\n  adj : Fin n \u2192 Finset (Fin n)\n  symm : \u2200 i j, j \u2208 adj i \u2194 i \u2208 adj j\n  no_loops : \u2200 i, i \u2209 adj i\n\n/-- The degree of a vertex in the graph is the size of its adjacency set -/\ndef degree {n : Nat} (G : FriendshipGraph n) (v : Fin n) : Nat :=\n  G.adj v |>.card\n\n/-- A triangle in a graph is a set of three mutually connected vertices -/\ndef hasTriangle {n : Nat} (G : FriendshipGraph n) : Prop :=\n  \u2203 (i j k : Fin n), i \u2260 j \u2227 j \u2260 k \u2227 i \u2260 k \u2227\n    j \u2208 G.adj i \u2227 k \u2208 G.adj j \u2227 k \u2208 G.adj i\n\ntheorem friendship_triangle (G : FriendshipGraph 11)\n    (h_min_degree : \u2200 v, degree G v \u2265 6) : hasTriangle G :=\n  sorry", "formal_statement_pred": "import Mathlib\n\nopen Finset\n\nstructure FriendshipGraph where\n  n : Nat\n  neighbors : Fin n \u2192 Finset (Fin n)\n  symm : \u2200 i j, j \u2208 neighbors i \u2194 i \u2208 neighbors j\n  no_self : \u2200 i, i \u2209 neighbors i\n\n\ndef isTriangle (g : FriendshipGraph) (a b c : Fin g.n) : Prop :=\n  a \u2260 b \u2227 b \u2260 c \u2227 a \u2260 c \u2227\n  b \u2208 g.neighbors a \u2227 c \u2208 g.neighbors b \u2227 c \u2208 g.neighbors a\n\ntheorem friendship_triangle_exists (g : FriendshipGraph)\n    (size_eleven : g.n = 11)\n    (min_six_friends : \u2200 p : Fin g.n, (g.neighbors p).card \u2265 6) :\n    \u2203 (a b c : Fin g.n), isTriangle g a b c :=\n  sorry", "compiled": true, "aligned": true}
{"id": "CombStruct4Lean_183", "informal_problem": "11.5. In a mathematics class, there are 36 students. Exactly one of them recently became a winner of a mathematics olympiad. Each of his classmates has exactly five friends in common with him. Prove that there is a student in the class with an odd number of friends.\n\n#", "formal_statement": "import Mathlib\n\nstructure MathClass where\n  students : Finset (Fin 36)  -- The set of all students\n  winner : Fin 36            -- The olympiad winner\n  friends : Fin 36 \u2192 Finset (Fin 36)  -- For each student, their set of friends\n  friend_symm : \u2200 i j, i \u2208 friends j \u2194 j \u2208 friends i  -- Friendship is symmetric\n  common_with_winner : \u2200 i, i \u2260 winner \u2192 (friends i \u2229 friends winner).card = 5  -- Each non-winner has 5 friends in common with winner\n\ntheorem exists_odd_friends (c : MathClass) : \n  \u2203 i, (c.friends i).card % 2 = 1 :=\n  sorry", "formal_statement_pred": "import Mathlib\n\nstructure MathClass where\n\n  students : Finset (Fin 36)\n\n  friends : Fin 36 \u2192 Fin 36 \u2192 Bool\n\n  winner : Fin 36\n\n\n  symm : \u2200 i j, friends i j = friends j i\n  irrefl : \u2200 i, friends i i = false\n\n\n  common_friends : \u2200 i, i \u2260 winner \u2192\n    (Finset.filter (fun j => friends i j \u2227 friends winner j) students).card = 5\n\ntheorem exists_odd_friends (c : MathClass) :\n  \u2203 i, (Finset.filter (fun j => c.friends i j) c.students).card % 2 = 1 :=\n  sorry", "compiled": true, "aligned": true}
{"id": "CombStruct4Lean_184", "informal_problem": "2. At a mathematics olympiad, each of the 11 seventh-grade students solved 3 problems. It is known that for any two of them, there is a problem that one of them solved and the other did not. Prove that they were offered no fewer than 6 problems.", "formal_statement": "import Mathlib\n\nstructure OlympiadSolutions where\n  numStudents : Nat\n  numProblems : Nat\n  solutions : Fin numStudents \u2192 Finset (Fin numProblems)\n  eachSolvedThree : \u2200 s, (solutions s).card = 3\n  differentSolutions : \u2200 s\u2081 s\u2082, s\u2081 \u2260 s\u2082 \u2192 \n    \u2203 p, (p \u2208 solutions s\u2081 \u2227 p \u2209 solutions s\u2082) \u2228 \n         (p \u2209 solutions s\u2081 \u2227 p \u2208 solutions s\u2082)\n\ntheorem olympiad_min_problems : \n  \u00ac\u2203 (sol : OlympiadSolutions), sol.numStudents = 11 \u2227 sol.numProblems < 6 :=\n  sorry", "formal_statement_pred": "import Mathlib\n\nstructure OlympiadSituation where\n  numProblems : Nat\n  studentSolutions : Fin 11 \u2192 Finset (Fin numProblems)\n  eachSolvedThree : \u2200 s, (studentSolutions s).card = 3\n  differentSolutions : \u2200 s\u2081 s\u2082, s\u2081 \u2260 s\u2082 \u2192\n    \u2203 p, (p \u2208 studentSolutions s\u2081 \u2227 p \u2209 studentSolutions s\u2082) \u2228\n         (p \u2209 studentSolutions s\u2081 \u2227 p \u2208 studentSolutions s\u2082)\n\ntheorem olympiad_min_problems :\n  \u2200 (sit : OlympiadSituation), sit.numProblems \u2265 6 :=\n  sorry", "compiled": true, "aligned": true}
{"id": "CombStruct4Lean_186", "informal_problem": "5. On cards, Petya wrote down three natural numbers, each from 1 to 20. Moreover, there are no two cards with the same set of numbers. Prove that there will be two cards having exactly one common number, if it is known that Petya filled out 21 cards.", "formal_statement": "import Mathlib\n\nstructure Card where\n  nums : Finset Nat\n  h_size : nums.card = 3\n  h_range : \u2200 n \u2208 nums, 1 \u2264 n \u2227 n \u2264 20\n\ndef has_one_common (c1 c2 : Card) : Prop :=\n  (c1.nums \u2229 c2.nums).card = 1\n\ndef are_distinct (c1 c2 : Card) : Prop := \n  c1.nums \u2260 c2.nums\n\ndef is_valid_card (c : Card) : Prop := \n  c.nums.card = 3 \u2227 (\u2200 n \u2208 c.nums, 1 \u2264 n \u2227 n \u2264 20)\n\ntheorem petya_cards_common_number \n  (cards : Finset Card)\n  (h_card_count : cards.card = 21)\n  (h_valid : \u2200 c \u2208 cards, is_valid_card c)\n  (h_distinct : \u2200 (c1 c2 : Card), c1 \u2208 cards \u2192 c2 \u2208 cards \u2192 c1 \u2260 c2 \u2192 are_distinct c1 c2) :\n  \u2203 c1 c2, c1 \u2208 cards \u2227 c2 \u2208 cards \u2227 c1 \u2260 c2 \u2227 has_one_common c1 c2 := sorry", "formal_statement_pred": "import Mathlib\n\n\nabbrev CardNumber := Fin 20\n\n\nstructure Card where\n  nums : Finset CardNumber\n  valid_nums : nums.card = 3\n\n\nstructure CardCollection where\n  cards : Finset Card\n  distinct : \u2200 (c\u2081 c\u2082 : Card), c\u2081 \u2208 cards \u2192 c\u2082 \u2208 cards \u2192 c\u2081 = c\u2082 \u2228 c\u2081.nums \u2260 c\u2082.nums\n  size : cards.card = 21\n\n\ndef commonNumbers (c\u2081 c\u2082 : Card) : Nat := (c\u2081.nums \u2229 c\u2082.nums).card\n\ntheorem petya_cards_common_number\n  (collection : CardCollection) :\n  \u2203 (c\u2081 c\u2082 : Card),\n    c\u2081 \u2208 collection.cards \u2227\n    c\u2082 \u2208 collection.cards \u2227\n    c\u2081 \u2260 c\u2082 \u2227\n    commonNumbers c\u2081 c\u2082 = 1 :=\n  sorry", "compiled": true, "aligned": true}
{"id": "CombStruct4Lean_187", "informal_problem": "9.5. Is it possible to write ones in some cells of an 8 x 8 table and zeros in the others, so that the sums in all columns are different, and the sums in all rows are the same?", "formal_statement": "import Mathlib\n\n-- A binary table is represented as a function from pairs of indices to Bool\nstructure BinaryTable where\n  entries : Fin 8 \u2192 Fin 8 \u2192 Bool\n\n-- Sum of a column in the table\ndef columnSum (t : BinaryTable) (j : Fin 8) : Nat :=\n  (Finset.range 8).sum fun i => if t.entries i j then 1 else 0\n\n-- Sum of a row in the table\ndef rowSum (t : BinaryTable) (i : Fin 8) : Nat :=\n  (Finset.range 8).sum fun j => if t.entries i j then 1 else 0\n\ntheorem binary_table_special_sums : \u00ac\u2203 (t : BinaryTable),\n  -- All column sums are different\n  (\u2200 j\u2081 j\u2082 : Fin 8, j\u2081 \u2260 j\u2082 \u2192 columnSum t j\u2081 \u2260 columnSum t j\u2082) \u2227\n  -- All row sums are equal\n  (\u2200 i\u2081 i\u2082 : Fin 8, rowSum t i\u2081 = rowSum t i\u2082) :=\n  sorry", "formal_statement_pred": "import Mathlib\nopen Matrix\n\nstructure BinaryTable where\n  cells : Matrix (Fin 8) (Fin 8) \u2115\n  valid : \u2200 i j, cells i j = 0 \u2228 cells i j = 1\n\ndef columnSum (t : BinaryTable) (j : Fin 8) : \u2115 :=\n  Finset.sum Finset.univ fun i => t.cells i j\n\ndef rowSum (t : BinaryTable) (i : Fin 8) : \u2115 :=\n  Finset.sum Finset.univ fun j => t.cells i j\n\ndef hasDistinctColumns (t : BinaryTable) : Prop :=\n  \u2200 i j : Fin 8, i \u2260 j \u2192 columnSum t i \u2260 columnSum t j\n\ndef hasEqualRows (t : BinaryTable) : Prop :=\n  \u2200 i j : Fin 8, rowSum t i = rowSum t j\n\ntheorem binary_table_impossible :\n  \u00ac\u2203 (t : BinaryTable), hasDistinctColumns t \u2227 hasEqualRows t :=\n  sorry", "compiled": true, "aligned": true}
{"id": "CombStruct4Lean_188", "informal_problem": "8.2 On a chessboard, 8 rooks were placed so that they do not attack each other. Prove that in any \"square\" rectangle of size $4 \\times 5$ (cells) there is at least one rook.", "formal_statement": "import Mathlib\n\n/-- A 4\u00d75 rectangle on the chessboard is determined by its top-left corner -/\nstructure Rectangle where\n  row : Fin 5  -- allows for 4 rows starting from this position (0-based)\n  col : Fin 4  -- allows for 5 columns starting from this position (0-based)\n\n/-- Predicate checking if a position lies within a given rectangle -/\ndef in_rectangle (rect : Rectangle) (r c : Fin 8) : Prop :=\n  (r.val \u2265 rect.row.val) \u2227 \n  (r.val < rect.row.val + 4) \u2227\n  (c.val \u2265 rect.col.val) \u2227 \n  (c.val < rect.col.val + 5)\n\n/-- For any permutation representing non-attacking rooks and any 4\u00d75 rectangle,\n    there exists a rook within that rectangle -/\ntheorem rook_in_rectangle (rooks : Equiv.Perm (Fin 8)) (rect : Rectangle) :\n  \u2203 r : Fin 8, in_rectangle rect r (rooks r) :=\n  sorry", "formal_statement_pred": "import Mathlib\n\n\nstructure Position where\n  row : Fin 8\n  col : Fin 8\n\n\nstructure Rectangle where\n  baseRow : Fin 8\n  baseCol : Fin 8\n  valid : baseRow.val + 4 \u2264 8 \u2227 baseCol.val + 5 \u2264 8\n\n\ndef Position.in_rectangle (pos : Position) (rect : Rectangle) : Prop :=\n  rect.baseRow.val \u2264 pos.row.val \u2227 pos.row.val < rect.baseRow.val + 4 \u2227\n  rect.baseCol.val \u2264 pos.col.val \u2227 pos.col.val < rect.baseCol.val + 5\n\n\ndef is_non_attacking (rooks : Finset Position) : Prop :=\n  \u2200 r1 r2, r1 \u2208 rooks \u2192 r2 \u2208 rooks \u2192 r1 \u2260 r2 \u2192\n    r1.row \u2260 r2.row \u2227 r1.col \u2260 r2.col\n\n\nstructure RookConfiguration where\n  rooks : Finset Position\n  eight_rooks : rooks.card = 8\n  non_attacking : is_non_attacking rooks\n\ntheorem rook_in_4x5_rectangle (config : RookConfiguration) (rect : Rectangle) :\n  \u2203 pos, (pos \u2208 config.rooks) \u2227 pos.in_rectangle rect :=\n  sorry", "compiled": true, "aligned": true}
{"id": "CombStruct4Lean_189", "informal_problem": "10.6. In the cells of a $9 \\times 9$ table, all natural numbers from 1 to 81 were placed. The products of the numbers in each row of the table were calculated, resulting in a set of nine numbers. Then, the products of the numbers in each column of the table were calculated, also resulting in a set of nine numbers. Could the obtained sets be the same?", "formal_statement": "import Mathlib\n\n-- Define a 9x9 table filled with numbers 1 to 81\nstructure Table where\n  entries : Fin 9 \u2192 Fin 9 \u2192 Fin 81\n  all_distinct : \u2200 i j i' j', entries i j = entries i' j' \u2192 i = i' \u2227 j = j'\n  all_numbers : \u2200 n : Fin 81, \u2203 i j, entries i j = n\n\n-- Helper function to calculate product of numbers in a row\ndef row_product (t : Table) (i : Fin 9) : Nat :=\n  (Finset.univ.prod fun j => (t.entries i j).val + 1)\n\n-- Helper function to calculate product of numbers in a column\ndef col_product (t : Table) (j : Fin 9) : Nat :=\n  (Finset.univ.prod fun i => (t.entries i j).val + 1)\n\n-- Function to get the multiset of row products\ndef row_products (t : Table) : Multiset Nat :=\n  Finset.univ.val.map (row_product t)\n\n-- Function to get the multiset of column products\ndef col_products (t : Table) : Multiset Nat :=\n  Finset.univ.val.map (col_product t)\n\ntheorem nine_by_nine_products_not_equal :\n  \u2200 t : Table, row_products t \u2260 col_products t :=\n  sorry", "formal_statement_pred": "import Mathlib\n\n\ndef TableEntry := { n : Nat // 1 \u2264 n \u2227 n \u2264 81 }\n\nstructure TableArrangement where\n  entries : Fin 9 \u2192 Fin 9 \u2192 TableEntry\n\n  all_different : \u2200 (p q : Fin 9 \u00d7 Fin 9), p \u2260 q \u2192 entries p.1 p.2 \u2260 entries q.1 q.2\n\n  all_used : \u2200 n : TableEntry, \u2203 (p : Fin 9 \u00d7 Fin 9), entries p.1 p.2 = n\n\n\ndef row_product (t : TableArrangement) (i : Fin 9) : Nat :=\n  (Finset.univ.prod fun j => (t.entries i j).val)\n\n\ndef col_product (t : TableArrangement) (j : Fin 9) : Nat :=\n  (Finset.univ.prod fun i => (t.entries i j).val)\n\n\ndef row_products (t : TableArrangement) : Finset Nat :=\n  Finset.image (row_product t) Finset.univ\n\n\ndef col_products (t : TableArrangement) : Finset Nat :=\n  Finset.image (col_product t) Finset.univ\n\ntheorem nine_by_nine_products_not_equal :\n  \u00ac\u2203 (t : TableArrangement), row_products t = col_products t :=\n  sorry", "compiled": true, "aligned": true}
{"id": "CombStruct4Lean_191", "informal_problem": "11.5. Given a natural number $K>2$ and a set of $N$ cards, on which positive numbers are written. It turned out that from them one can choose several cards (possibly one) with the sum of numbers $K$, several cards with the sum of numbers $K^{2}, \\ldots$, several cards with the sum of numbers $K^{K}$. Could it be that $N<K$?", "formal_statement": "import Mathlib\n\nstructure CardSet where\n  cards : Finset Nat        -- the set of card values\n  K : Nat                   -- given number K\n  hK : K > 2               -- condition K > 2\n  hPos : \u2200 n \u2208 cards, n > 0  -- all values are positive\n  hSums : \u2200 i : Nat, i \u2265 1 \u2192 i \u2264 K \u2192 \n    \u2203 subset : Finset Nat, \n      subset \u2286 cards \u2227 \n      (\u2211 x in subset, x) = K^i\n\ntheorem card_set_size_bound {cs : CardSet} : cs.cards.card \u2265 cs.K :=\n  sorry", "formal_statement_pred": "import Mathlib\n\nstructure CardSet where\n  cards : Finset \u2115\n  K : \u2115\n  h_K : K > 2\n  sums_exist : \u2200 p : \u2115,\n    1 \u2264 p \u2192 p \u2264 K \u2192\n    \u2203 subset : Finset \u2115,\n      subset \u2286 cards \u2227\n      Finset.sum subset id = K ^ p \u2227\n      subset.Nonempty\n\ntheorem cards_count_geq_K (cs : CardSet) : Finset.card (CardSet.cards cs) \u2265 CardSet.K cs :=\n  sorry", "compiled": true, "aligned": true}
{"id": "CombStruct4Lean_192", "informal_problem": "7. Airline \"Vpered\" served 50 airports, and there was at least one route from each. Due to a reduction in the number of aircraft, the airline has to cancel some routes. To avoid passenger dissatisfaction, it is required that at least one route remains from each airport. Prove that regardless of the initial route scheme, the routes can be reduced in such a way that there are at least 30 airports from which there is only one route.", "formal_statement": "import Mathlib\n\nstructure AirlineNetwork where\n  routes : Finset (Fin 50 \u00d7 Fin 50)\n  has_route : \u2200 a : Fin 50, \u2203 b, (a, b) \u2208 routes\n\n/-- Count of routes from a given airport in a network -/\ndef routeCount (net : AirlineNetwork) (a : Fin 50) : Nat :=\n  (net.routes.filter (fun p => p.1 = a)).card\n\n/-- The set of airports that have exactly one route in the network -/\ndef singleRouteAirports (net : AirlineNetwork) : Finset (Fin 50) :=\n  Finset.filter (fun a => routeCount net a = 1) Finset.univ\n\n/-- A valid route reduction maintains at least one route from each airport -/\ndef IsValidReduction (original reduced : AirlineNetwork) : Prop :=\n  reduced.routes \u2286 original.routes \u2227\n  \u2200 a : Fin 50, \u2203 b, (a, b) \u2208 reduced.routes\n\ntheorem airline_route_reduction (original : AirlineNetwork) :\n  \u2203 reduced : AirlineNetwork,\n    IsValidReduction original reduced \u2227\n    (singleRouteAirports reduced).card \u2265 30 :=\n  sorry", "formal_statement_pred": "import Mathlib\n\nstructure AirlineNetwork where\n  routes : Finset (Fin 50 \u00d7 Fin 50)\n  has_route : \u2200 a : Fin 50, \u2203 b : Fin 50, (a, b) \u2208 routes\n\n\ndef ValidReduction (n : AirlineNetwork) (reduced : Finset (Fin 50 \u00d7 Fin 50)) : Prop :=\n  reduced \u2286 n.routes \u2227\n  \u2200 a : Fin 50, \u2203 b : Fin 50, (a, b) \u2208 reduced\n\n\ndef HasSingleRoute (n : AirlineNetwork) (routes : Finset (Fin 50 \u00d7 Fin 50))\n    (airport : Fin 50) : Prop :=\n  (\u2203 b : Fin 50, (airport, b) \u2208 routes) \u2227\n  (\u2200 b\u2081 b\u2082 : Fin 50, (airport, b\u2081) \u2208 routes \u2192 (airport, b\u2082) \u2208 routes \u2192 b\u2081 = b\u2082)\n\ntheorem airline_route_reduction (n : AirlineNetwork) :\n  \u2203 reduced : Finset (Fin 50 \u00d7 Fin 50),\n    ValidReduction n reduced \u2227\n    \u2203 airports : Finset (Fin 50),\n      airports.card \u2265 30 \u2227\n      \u2200 a \u2208 airports, HasSingleRoute n reduced a :=\n  sorry", "compiled": true, "aligned": true}
{"id": "CombStruct4Lean_193", "informal_problem": "4. In the nodes of a grid plane, 5 points are marked. Prove that there are two of them, the midpoint of the segment between which also falls on a node.", "formal_statement": "import Mathlib\n\nstructure GridPoint where\n  x : Int\n  y : Int\n\ndef is_midpoint (a b c : GridPoint) : Prop :=\n  2 * c.x = a.x + b.x \u2227 2 * c.y = a.y + b.y\n\ntheorem grid_points_midpoint_exists \n  (points : Fin 5 \u2192 GridPoint) : \n  \u2203 (i j : Fin 5) (h : i \u2260 j), \n    \u2203 (m : GridPoint), is_midpoint (points i) (points j) m :=\n  sorry", "formal_statement_pred": "import Mathlib\n\nstructure GridPoint where\n  x : Int\n  y : Int\n  deriving DecidableEq\n\n\ndef isMidpoint (p1 p2 m : GridPoint) : Prop :=\n  2 * m.x = p1.x + p2.x \u2227 2 * m.y = p1.y + p2.y\n\ntheorem grid_points_midpoint_exists {points : Finset GridPoint}\n  (h : points.card = 5) :\n  \u2203 (p1 p2 m : GridPoint),\n    p1 \u2208 points \u2227 p2 \u2208 points \u2227 p1 \u2260 p2 \u2227\n    isMidpoint p1 p2 m :=\n  sorry", "compiled": true, "aligned": true}
{"id": "CombStruct4Lean_194", "informal_problem": "3. Each node of an infinite grid is painted in one of four colors such that the vertices of each square with side 1 are painted in different colors. Is it true that the nodes of one of the grid lines are painted in only two colors? (The grid is formed by horizontal and vertical lines. The distance between adjacent parallel lines is 1.)", "formal_statement": "import Mathlib\n\n-- Define a coloring of the infinite grid\nstructure GridColoring where\n  -- A coloring maps each point (x,y) to one of four colors (0,1,2,3)\n  color : \u2124 \u00d7 \u2124 \u2192 Fin 4\n  -- Property: adjacent vertices of any unit square have different colors\n  valid_square : \u2200 (x y : \u2124), \n    color (x, y) \u2260 color (x + 1, y) \u2227 \n    color (x, y) \u2260 color (x, y + 1) \u2227 \n    color (x + 1, y) \u2260 color (x + 1, y + 1) \u2227 \n    color (x, y + 1) \u2260 color (x + 1, y + 1) \u2227\n    color (x, y) \u2260 color (x + 1, y + 1) \u2227\n    color (x + 1, y) \u2260 color (x, y + 1)\n\n-- Define what it means for a line to use only two colors\ndef uses_two_colors (c : GridColoring) (horizontal : Bool) (k : \u2124) : Prop :=\n  \u2203 (c\u2081 c\u2082 : Fin 4), \u2200 (t : \u2124),\n    c.color (if horizontal then (t, k) else (k, t)) \u2208 ({c\u2081, c\u2082} : Set (Fin 4))\n\ntheorem grid_coloring_two_colors :\n  \u2200 (c : GridColoring), \n  (\u2203 (k : \u2124), uses_two_colors c true k) \u2228 \n  (\u2203 (k : \u2124), uses_two_colors c false k) :=\n  sorry", "formal_statement_pred": "import Mathlib\n\nstructure ColoredGrid where\n\n  coloring : \u2124 \u00d7 \u2124 \u2192 Fin 4\n\n  valid_coloring : \u2200 (x y : \u2124),\n    let vertices := [(x,y), (x+1,y), (x,y+1), (x+1,y+1)]\n    \u2200 (v\u2081 v\u2082 : \u2124 \u00d7 \u2124), v\u2081 \u2208 vertices \u2192 v\u2082 \u2208 vertices \u2192 v\u2081 \u2260 v\u2082 \u2192\n    coloring v\u2081 \u2260 coloring v\u2082\n\ntheorem exists_two_color_line (g : ColoredGrid) :\n  (\u2203 (y : \u2124), \u2203 (c\u2081 c\u2082 : Fin 4), \u2200 (x : \u2124), g.coloring (x, y) = c\u2081 \u2228 g.coloring (x, y) = c\u2082) \u2228\n  (\u2203 (x : \u2124), \u2203 (c\u2081 c\u2082 : Fin 4), \u2200 (y : \u2124), g.coloring (x, y) = c\u2081 \u2228 g.coloring (x, y) = c\u2082) :=\n  sorry", "compiled": true, "aligned": true}
{"id": "CombStruct4Lean_195", "informal_problem": "3. Points on a line are colored in two colors (each color is present, each point has exactly one color). Prove that there will be three points of the same color, such that one lies exactly in the middle between the other two.", "formal_statement": "import Mathlib\n\nstructure ColoredLine where\n  points : Set \u211d              -- Set of points on the real line\n  color : \u211d \u2192 Bool           -- Coloring function (True/False representing two colors)\n  nonempty_colors : \u2203 p\u2081 p\u2082, p\u2081 \u2208 points \u2227 p\u2082 \u2208 points \u2227 color p\u2081 \u2260 color p\u2082\n  all_colored : \u2200 p \u2208 points, color p = true \u2228 color p = false\n\ntheorem monochromatic_midpoint (L : ColoredLine) : \n  \u2203 (x y z : \u211d), x \u2208 L.points \u2227 y \u2208 L.points \u2227 z \u2208 L.points \u2227 \n    L.color x = L.color y \u2227 L.color y = L.color z \u2227\n    y = (x + z) / 2 :=\n  sorry", "formal_statement_pred": "import Mathlib\n\nstructure ColoredLine where\n  points : Set \u211d\n  color : \u211d \u2192 Bool\n  nonempty_colors : \u2203 p\u2081 p\u2082, p\u2081 \u2208 points \u2227 p\u2082 \u2208 points \u2227 color p\u2081 \u2260 color p\u2082\n  all_colored : \u2200 p \u2208 points, color p = true \u2228 color p = false\n\ntheorem monochromatic_midpoint (L : ColoredLine) :\n  \u2203 (x y z : \u211d), x \u2208 L.points \u2227 y \u2208 L.points \u2227 z \u2208 L.points \u2227\n    L.color x = L.color y \u2227 L.color y = L.color z \u2227\n    y = (x + z) / 2 :=\n  sorry", "compiled": true, "aligned": true}
{"id": "CombStruct4Lean_197", "informal_problem": "9.4 In a company of $2 n+1$ people, for any $n$ people, there is a person different from them who is acquainted with each of them. Prove that there is a person in this company who knows everyone.", "formal_statement": "import Mathlib\n\n-- Define the acquaintance relation\nstructure AcquaintanceGraph where\n  n : Nat  -- half of (total people - 1)\n  knows : Fin (2 * n + 1) \u2192 Fin (2 * n + 1) \u2192 Bool  -- acquaintance relation\n  symm : \u2200 i j, knows i j = knows j i  -- symmetry of acquaintance\n  irrefl : \u2200 i, knows i i = false  -- no one knows themselves\n\ntheorem acquaintance_theorem (g : AcquaintanceGraph) :\n  -- For any n people, there exists someone else who knows all of them\n  (\u2200 (S : Finset (Fin (2 * g.n + 1))), S.card = g.n \u2192\n    \u2203 k, k \u2209 S \u2227 \u2200 i \u2208 S, g.knows k i) \u2192\n  -- Then there exists someone who knows everyone else\n  \u2203 k, \u2200 i, i \u2260 k \u2192 g.knows k i :=\n  sorry", "formal_statement_pred": "import Mathlib\n\n\nstructure AcquaintanceGraph where\n  n : Nat\n  knows : Fin (2 * n + 1) \u2192 Fin (2 * n + 1) \u2192 Bool\n  symm : \u2200 i j, knows i j = knows j i := by sorry\n  irrefl : \u2200 i, knows i i = false := by sorry\n\ntheorem acquaintance_theorem (n : Nat) (g : AcquaintanceGraph) :\n  (\u2200 (S : Finset (Fin (2 * n + 1))), S.card = n \u2192\n    \u2203 (x : Fin (2 * n + 1)), x \u2209 S \u2227 \u2200 y \u2208 S, g.knows x y) \u2192\n  \u2203 (x : Fin (2 * n + 1)), \u2200 y : Fin (2 * n + 1), y \u2260 x \u2192 g.knows x y :=\n  sorry", "compiled": true, "aligned": true}
{"id": "CombStruct4Lean_199", "informal_problem": "2. Given a $7 \\times 3$ table. Each cell is filled with a number 0 or 1. If at the intersection of any two rows and any two columns all four numbers are the same, then the table is considered to be filled unsuccessfully. Is it possible to fill the table in such a way to avoid this phenomenon?", "formal_statement": "import Mathlib\n\n-- A table is represented as a function from positions to Bool\nstructure Table where\n  values : (Fin 7) \u2192 (Fin 3) \u2192 Bool\n\n/-- Check if a 2x2 subtable at given positions has all same values -/\ndef hasAllSameValues (t : Table) (r1 r2 : Fin 7) (c1 c2 : Fin 3) : Bool :=\n  let v := t.values r1 c1\n  v = t.values r1 c2 \u2227 v = t.values r2 c1 \u2227 v = t.values r2 c2\n\n/-- A table is successful if no 2x2 subtable has all same values -/\ndef isSuccessful (t : Table) : Prop :=\n  \u2200 (r1 r2 : Fin 7), \u2200 (c1 c2 : Fin 3),\n    r1 \u2260 r2 \u2192 c1 \u2260 c2 \u2192 \u00ac(hasAllSameValues t r1 r2 c1 c2)\n\ntheorem exists_successful_table :\n  \u2203 (t : Table), isSuccessful t :=\n  sorry", "formal_statement_pred": "import Mathlib\n\ndef Table := Fin 7 \u2192 Fin 3 \u2192 Bool\n\ndef isSuccessfulFilling (t : Table) : Prop :=\n  \u2200 (r\u2081 r\u2082 : Fin 7) (c\u2081 c\u2082 : Fin 3),\n    r\u2081 \u2260 r\u2082 \u2192 c\u2081 \u2260 c\u2082 \u2192\n    \u00ac(t r\u2081 c\u2081 = t r\u2081 c\u2082 \u2227\n      t r\u2081 c\u2081 = t r\u2082 c\u2081 \u2227\n      t r\u2081 c\u2081 = t r\u2082 c\u2082)\n\ntheorem exists_successful_filling :\n  \u2203 (t : Table), isSuccessfulFilling t :=\n  sorry", "compiled": true, "aligned": true}
{"id": "CombStruct4Lean_200", "informal_problem": "5. In a $1000 \\times 1000$ grid, 2000 cells are painted blue. Prove that there exist 4 blue cells such that the centers of these cells are the vertices of a parallelogram.", "formal_statement": "import Mathlib\n\nstructure Point where\n  x : Nat \n  y : Nat\n  isBlue : Bool\n  h_x : x < 1000\n  h_y : y < 1000\n\ndef isParallelogram (p1 p2 p3 p4 : Point) : Prop :=\n  let v1 := (p2.x - p1.x, p2.y - p1.y)\n  let v2 := (p4.x - p3.x, p4.y - p3.y)\n  let v3 := (p3.x - p2.x, p3.y - p2.y)\n  let v4 := (p1.x - p4.x, p1.y - p4.y)\n  v1 = v2 \u2227 v3 = v4\n\ntheorem blue_parallelogram_exists (grid : Finset Point) \n  (h_size : grid.card = 2000)\n  (h_blue : \u2200 p \u2208 grid, p.isBlue = true) :\n  \u2203 (p1 p2 p3 p4 : Point),\n    p1 \u2208 grid \u2227 p2 \u2208 grid \u2227 p3 \u2208 grid \u2227 p4 \u2208 grid \u2227\n    isParallelogram p1 p2 p3 p4 :=\n  sorry", "formal_statement_pred": "import Mathlib\n\n\nstructure GridPoint where\n  x : Fin 1000\n  y : Fin 1000\nderiving Fintype, DecidableEq\n\n\ndef isParallelogram (p1 p2 p3 p4 : GridPoint) : Prop :=\n  let v12 := (p2.x - p1.x, p2.y - p1.y)\n  let v34 := (p4.x - p3.x, p4.y - p3.y)\n  p1 \u2260 p2 \u2227 p2 \u2260 p3 \u2227 p3 \u2260 p4 \u2227 p4 \u2260 p1 \u2227\n  v12 = v34\n\ntheorem blue_parallelogram (blue : Finset GridPoint)\n  (h_count : blue.card = 2000) :\n  \u2203 (p1 p2 p3 p4 : GridPoint),\n    p1 \u2208 blue \u2227 p2 \u2208 blue \u2227 p3 \u2208 blue \u2227 p4 \u2208 blue \u2227\n    isParallelogram p1 p2 p3 p4 :=\n  sorry", "compiled": true, "aligned": true}
{"id": "CombStruct4Lean_201", "informal_problem": "4. Is it possible to arrange balls of seven colors in five boxes standing in a circle so that each box contains three balls of different colors, and no two balls of the same color are in adjacent boxes?", "formal_statement": "import Mathlib\n\nstructure ColorArrangement where\n  -- Each box contains a list of colors (represented as Fin 7)\n  boxes : Fin 5 \u2192 Fin 7 \u00d7 Fin 7 \u00d7 Fin 7\n\ndef isValidArrangement (arr : ColorArrangement) : Prop :=\n  -- All colors in each box are different\n  (\u2200 i : Fin 5, let (c1, c2, c3) := arr.boxes i\n                c1 \u2260 c2 \u2227 c2 \u2260 c3 \u2227 c1 \u2260 c3) \u2227\n  -- No adjacent boxes share colors\n  (\u2200 i : Fin 5, let (c1, c2, c3) := arr.boxes i\n                let (n1, n2, n3) := arr.boxes (i + 1)\n                c1 \u2260 n1 \u2227 c1 \u2260 n2 \u2227 c1 \u2260 n3 \u2227\n                c2 \u2260 n1 \u2227 c2 \u2260 n2 \u2227 c2 \u2260 n3 \u2227\n                c3 \u2260 n1 \u2227 c3 \u2260 n2 \u2227 c3 \u2260 n3)\n\ntheorem exists_valid_color_arrangement :\n  \u2203 (arr : ColorArrangement), isValidArrangement arr :=\n  sorry", "formal_statement_pred": "import Mathlib\nopen Finset\n\ndef IsAdjacent (i j : Fin 5) : Prop :=\n  (i.val + 1) % 5 = j.val \u2228 (j.val + 1) % 5 = i.val\n\nstructure Box (n : Nat) where\n  colors : Finset (Fin n)\n  size_three : colors.card = 3\n\nstructure ColorArrangement where\n  boxes : Fin 5 \u2192 Box 7\n  no_adjacent_same : \u2200 i j, IsAdjacent i j \u2192\n    (boxes i).colors \u2229 (boxes j).colors = \u2205\n  all_colors_used : \u2200 c : Fin 7, \u2203 i : Fin 5,\n    c \u2208 (boxes i).colors\n\ntheorem exists_valid_arrangement : Nonempty ColorArrangement :=\n  sorry", "compiled": true, "aligned": true}
{"id": "CombStruct4Lean_203", "informal_problem": "11.5. Given an infinite grid plane. A teacher and a class of 30 students play a game, taking turns - first the teacher, then each of the students in turn, then the teacher again, and so on. In one move, a player can paint a unit segment that is a boundary between two adjacent cells. Segments cannot be painted more than once. The teacher wins if, after one of the 31 players' moves, there is a grid rectangle $1 \\times 2$ or $2 \\times 1$ such that its entire boundary is painted, but the unit segment inside it is not painted. Can the students prevent the teacher from winning?\n\n(M. Diden, A. Kuznetsov)", "formal_statement": "import Mathlib\n\nstructure Segment where\n  start : \u2124 \u00d7 \u2124\n  direction : Bool  -- true for horizontal, false for vertical\n\nstructure GridGame where\n  painted_segments : Set Segment\n  current_player : Fin 31  -- 0 is teacher, 1-30 are students\n\ndef is_valid_move (game : GridGame) (seg : Segment) : Prop :=\n  seg \u2209 game.painted_segments\n\ndef is_teacher_turn (game : GridGame) : Prop :=\n  game.current_player = 0\n\ndef forms_rectangle (segs : Set Segment) (pos : \u2124 \u00d7 \u2124) (horizontal : Bool) : Prop :=\n  if horizontal then\n    -- 1\u00d72 rectangle at position pos\n    { Segment.mk pos true,                    -- bottom edge\n      Segment.mk pos false,                   -- left edge\n      Segment.mk (pos.1, pos.2 + 1) true,    -- top edge\n      Segment.mk (pos.1 + 1, pos.2) false    -- right edge\n    } \u2286 segs\n  else\n    -- 2\u00d71 rectangle at position pos\n    { Segment.mk pos false,                   -- left edge\n      Segment.mk pos true,                    -- bottom edge\n      Segment.mk (pos.1 + 1, pos.2) false,   -- right edge\n      Segment.mk (pos.1, pos.2 + 1) true     -- top edge\n    } \u2286 segs\n\ndef has_unpainted_middle (game : GridGame) (pos : \u2124 \u00d7 \u2124) (horizontal : Bool) : Prop :=\n  let middle := if horizontal then\n    Segment.mk (pos.1, pos.2) true    -- horizontal middle segment\n  else\n    Segment.mk (pos.1, pos.2) false   -- vertical middle segment\n  middle \u2209 game.painted_segments\n\ndef winning_position (game : GridGame) : Prop :=\n  \u2203 (pos : \u2124 \u00d7 \u2124) (horizontal : Bool),\n    forms_rectangle game.painted_segments pos horizontal \u2227\n    has_unpainted_middle game pos horizontal\n\ntheorem students_cannot_prevent_teacher_win :\n  \u2203 (teacher_strategy : GridGame \u2192 Segment),\n    \u2200 (student_strategies : Fin 30 \u2192 GridGame \u2192 Segment),\n    \u2203 (final_state : GridGame),\n      (\u2200 move, is_valid_move final_state move) \u2192\n      winning_position final_state :=\n  sorry", "formal_statement_pred": "import Mathlib\n\nstructure GridGame where\n\n  Segment : Type := \u2124 \u00d7 \u2124 \u00d7 Bool\n\n\n  painted : Set Segment\n\n\n  turn : \u2115\n\n\n  isValidMove (s : Segment) : Bool\n\n\n  hasWinningRectangle : Bool\n\n\n  numStudents : \u2115 := 30\n\n\n  isTeacherTurn : Bool := turn % (numStudents + 1) = 0\n\ntheorem grid_game_teacher_strategy\n  (game : GridGame)\n  (h : game.numStudents = 30) :\n  \u2203 (strategy : game.Segment \u2192 game.Segment),\n\n    \u2200 (studentMoves : \u2115 \u2192 game.Segment),\n      \u2203 (n : \u2115), game.hasWinningRectangle :=\n  sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_205", "informal_problem": "9.5. There are 23 students in the class. During the year, each student in this class celebrated their birthday once, to which some (at least one, but not all) of their classmates came. Could it be that every two students in this class met at such celebrations the same number of times? (It is assumed that at each party, any two guests met, and the birthday person met with all the guests.)\n\n(I. Bogdanov)", "formal_statement": "import Mathlib\n\nstructure BirthdayParties where\n  n : Nat\n  guests : Fin n \u2192 Finset (Fin n)  -- each party has a set of guests\n  some_guests : \u2200 i, 0 < (guests i).card\n  not_all_guests : \u2200 i, (guests i).card < n - 1\n  host_not_guest : \u2200 i, i \u2209 guests i\n\n/-- Number of times two students met at birthday parties -/\ndef meetCount (bp : BirthdayParties) (s1 s2 : Fin bp.n) : Nat :=\n  let at_s1_party := if s2 \u2208 bp.guests s1 then 1 else 0\n  let at_s2_party := if s1 \u2208 bp.guests s2 then 1 else 0\n  let at_others := Finset.sum Finset.univ fun k =>\n    if s1 \u2208 bp.guests k \u2227 s2 \u2208 bp.guests k then 1 else 0\n  at_s1_party + at_s2_party + at_others\n\ntheorem birthday_meetings_not_equal (bp : BirthdayParties) (h : bp.n = 23) :\n  \u00ac(\u2200 s1 s2 : Fin bp.n, s1 \u2260 s2 \u2192 meetCount bp s1 s2 = meetCount bp s1 s2) :=\n  sorry", "formal_statement_pred": "import Mathlib\n\nopen Finset\n\nstructure BirthdayParties where\n  guests : Fin 23 \u2192 Finset (Fin 23)\n  not_self_attend : \u2200 i, i \u2209 guests i\n  not_all_attend : \u2200 i, (guests i).card < 22\n  some_attend : \u2200 i, (guests i).Nonempty\n\n\ndef countSharedParties (bp : BirthdayParties) (i j : Fin 23) : \u2115 :=\n  (filter (fun k => k \u2260 i \u2227 k \u2260 j \u2227 i \u2208 bp.guests k \u2227 j \u2208 bp.guests k) univ).card\n\n\ndef meetCount (bp : BirthdayParties) (i j : Fin 23) : \u2115 :=\n  if i = j then 0\n  else\n    countSharedParties bp i j +\n    (if j \u2208 bp.guests i then 1 else 0) +\n    (if i \u2208 bp.guests j then 1 else 0)\n\ntheorem no_equal_meetings :\n  \u00ac \u2203 (bp : BirthdayParties) (m : \u2115),\n    (m > 0) \u2227\n    (m < 24) \u2227\n    (\u2200 i j : Fin 23, i \u2260 j \u2192 meetCount bp i j = m) :=\n  sorry", "compiled": true, "aligned": true}
{"id": "CombStruct4Lean_206", "informal_problem": "6. Participants of the summer physics and mathematics camp for schoolchildren received either an orange or a purple T-shirt. The number of participants in the physics group who received an orange T-shirt is equal to the number of participants in the mathematics group who received a purple T-shirt. Who is more - participants in the mathematics group, or those who received an orange T-shirt?", "formal_statement": "import Mathlib\n\nstructure CampParticipants where\n  physics : Finset Nat    -- Set of physics participants\n  math : Finset Nat       -- Set of math participants\n  orange : Finset Nat     -- Set of participants with orange T-shirts\n  purple : Finset Nat     -- Set of participants with purple T-shirts\n  disjoint_groups : Disjoint physics math      -- No one is in both groups\n  all_participants : physics \u222a math = orange \u222a purple  -- Everyone has exactly one T-shirt\n  valid_shirts : Disjoint orange purple        -- No one has both shirts\n\ntheorem camp_comparison (c : CampParticipants)\n  (h : (c.physics \u2229 c.orange).card = (c.math \u2229 c.purple).card) :\n  (c.math.card \u2260 c.orange.card) \u2228 (c.math.card = c.orange.card \u2227 c.physics.card = c.purple.card) :=\n  sorry", "formal_statement_pred": "import Mathlib\n\nstructure CampParticipants where\n  physics : Finset Nat\n  math : Finset Nat\n  orange : Finset Nat\n  purple : Finset Nat\n  disjoint_groups : Disjoint physics math\n  all_participants : physics \u222a math = orange \u222a purple\n  all_have_shirt : Disjoint orange purple\n\ntheorem camp_comparison (c : CampParticipants)\n  (h : (c.physics \u2229 c.orange).card = (c.math \u2229 c.purple).card) :\n  (c.math.card \u2260 c.orange.card) \u2228 (c.math.card = c.orange.card \u2227 c.physics.card = c.purple.card) :=\n  sorry", "compiled": true, "aligned": true}
{"id": "CombStruct4Lean_207", "informal_problem": "5. In each cell of a $25 \\times 25$ square table, one of the numbers 1 or -1 is written arbitrarily. Under each column, the product of all numbers in that column is written. To the right of each row, the product of all numbers in that row is written. Prove that the sum of the 50 written products cannot be zero.", "formal_statement": "import Mathlib\n\n-- Define the type for valid cell entries (1 or -1)\ndef SignEntry := {x : Int // x = 1 \u2228 x = -1}\n\n-- Define the table structure\nstructure SignTable where\n  -- The main table entries\n  entries : Fin 25 \u2192 Fin 25 \u2192 SignEntry\n  -- Column products (product of all entries in each column)\n  colProducts : Fin 25 \u2192 Int := \u03bb j => (\u220f i, (entries i j).val)\n  -- Row products (product of all entries in each row)\n  rowProducts : Fin 25 \u2192 Int := \u03bb i => (\u220f j, (entries i j).val)\n\ntheorem sign_table_products_nonzero (t : SignTable) : \n  (\u2211 i, t.rowProducts i) + (\u2211 j, t.colProducts j) \u2260 0 :=\n  sorry", "formal_statement_pred": "import Mathlib\n\ndef SignMatrix (n : Nat) := Fin n \u2192 Fin n \u2192 Int\n\ndef isValidSignMatrix (n : Nat) (M : SignMatrix n) : Prop :=\n  \u2200 i j, M i j = 1 \u2228 M i j = -1\n\ndef columnProduct (n : Nat) (M : SignMatrix n) (j : Fin n) : Int :=\n  (Finset.univ.prod fun i => M i j)\n\ndef rowProduct (n : Nat) (M : SignMatrix n) (i : Fin n) : Int :=\n  (Finset.univ.prod fun j => M i j)\n\ndef totalSum (n : Nat) (M : SignMatrix n) : Int :=\n  (Finset.univ.sum fun j => columnProduct n M j) +\n  (Finset.univ.sum fun i => rowProduct n M i)\n\ntheorem sign_matrix_sum_nonzero :\n  \u2200 (M : SignMatrix 25), isValidSignMatrix 25 M \u2192 totalSum 25 M \u2260 0 :=\n  sorry", "compiled": true, "aligned": true}
{"id": "CombStruct4Lean_208", "informal_problem": "10.1. 33 heroes go on patrol for 33 days. On the first day, one hero should go out, on the second day two, on the third day three, and so on, on the last day - all the heroes. Can Chernomor the Elder organize the patrols so that all heroes go on patrol an equal number of times?", "formal_statement": "import Mathlib\n\nstructure PatrolSchedule (n : Nat) where\n  assignment : Fin n \u2192 Finset (Fin n)\n  size_constraint : \u2200 d : Fin n, (assignment d).card = d.val + 1\n\ndef count_patrols {n : Nat} (schedule : PatrolSchedule n) (hero : Fin n) : Nat :=\n  (Finset.filter (fun d => hero \u2208 schedule.assignment d) (Finset.univ : Finset (Fin n))).card\n\ntheorem patrol_schedule_impossible : \u00ac\u2203 (schedule : PatrolSchedule 33), \n  (\u2200 h\u2081 h\u2082 : Fin 33, count_patrols schedule h\u2081 = count_patrols schedule h\u2082) :=\n  sorry", "formal_statement_pred": "import Mathlib\n\nstructure PatrolSchedule where\n  schedule : Fin 33 \u2192 Finset (Fin 33)\n  increasing_size : \u2200 d, (schedule d).card = d.val + 1\n\ndef hero_patrol_count (s : PatrolSchedule) (h : Fin 33) : Nat :=\n  (Finset.filter (fun d => h \u2208 s.schedule d) (Finset.univ : Finset (Fin 33))).card\n\ntheorem no_equal_patrol_possible : \u2200 (s : PatrolSchedule),\n  \u2203 h\u2081 h\u2082 : Fin 33, hero_patrol_count s h\u2081 \u2260 hero_patrol_count s h\u2082 :=\n  sorry", "compiled": true, "aligned": true}
{"id": "CombStruct4Lean_209", "informal_problem": "10.6. There are two boxes, one with 2017 candies, and the other with 2018. Two players take turns. On each turn, a player can eat any non-zero number of candies from any one box. The rules of the game do not allow the number of candies in one box to be divisible by the number of candies in the other after any move. The player who cannot make a move without violating this condition loses. Who can win: the player starting the game or the second player, regardless of how their opponent plays?", "formal_statement": "import Mathlib\n\nstructure CandyGame where\n  box1 : Nat\n  box2 : Nat\n  deriving Repr\n\ndef isValidMove (game : CandyGame) (newGame : CandyGame) : Bool :=\n  -- Check if the move is valid:\n  -- 1. Only one box changes\n  -- 2. The changed box decreases\n  -- 3. The new numbers are not divisible by each other\n  let box1Same := game.box1 = newGame.box1\n  let box2Same := game.box2 = newGame.box2\n  let box1Decreases := newGame.box1 < game.box1\n  let box2Decreases := newGame.box2 < game.box2\n  let notDivisible := \n    (newGame.box1 = 0 \u2228 newGame.box2 = 0 \u2228 \n     (newGame.box1 % newGame.box2 \u2260 0 \u2227 newGame.box2 % newGame.box1 \u2260 0))\n  \n  (box1Same \u2260 box2Same) \u2227  -- exactly one box changes\n  ((box1Same \u2227 box2Decreases) \u2228 (box2Same \u2227 box1Decreases)) \u2227\n  notDivisible\n\ntheorem candy_game_second_player_wins : \n  \u2203 (strategy : CandyGame \u2192 CandyGame),\n    let initialGame := CandyGame.mk 2017 2018\n    -- For any valid first move by player 1\n    \u2200 (p1move : CandyGame),\n      isValidMove initialGame p1move \u2192\n      -- There exists a response by player 2\n      isValidMove p1move (strategy p1move) \u2227\n      -- Such that player 2 can force a win\n      \u2200 (subsequent_position : CandyGame),\n        -- No matter what moves follow\n        \u00ac(\u2203 (final_position : CandyGame), \n          isValidMove subsequent_position final_position) :=\n  sorry", "formal_statement_pred": "import Mathlib\n\ninductive Player where\n  | First : Player\n  | Second : Player\n  deriving Repr, DecidableEq\n\ndef Player.next : Player \u2192 Player\n  | First => Second\n  | Second => First\n\nstructure GamePosition where\n  box1 : Nat\n  box2 : Nat\n  h1 : box1 > 0\n  h2 : box2 > 0\n\n\nstructure Move where\n  box : Fin 2\n  amount : Nat\n\n\ndef isDivisibilityValid (pos : GamePosition) : Prop :=\n  \u00ac(pos.box1 \u2223 pos.box2) \u2227 \u00ac(pos.box2 \u2223 pos.box1)\n\n\ndef IsValidMove (pos : GamePosition) (m : Move) : Prop :=\n  let newBox1 := if m.box = 0 then pos.box1 - m.amount else pos.box1\n  let newBox2 := if m.box = 1 then pos.box2 - m.amount else pos.box2\n  (m.amount > 0) \u2227\n  (if m.box = 0 then m.amount \u2264 pos.box1 else m.amount \u2264 pos.box2) \u2227\n  (newBox1 > 0) \u2227 (newBox2 > 0) \u2227\n  \u00ac(newBox1 \u2223 newBox2) \u2227 \u00ac(newBox2 \u2223 newBox1)\n\n\ndef IsWinningPosition (pos : GamePosition) : Prop :=\n  isDivisibilityValid pos \u2227\n  \u2203 m : Move, IsValidMove pos m\n\ntheorem candy_game_first_player_wins :\n  \u2203 (pos : GamePosition) (h1 : pos.box1 = 2017) (h2 : pos.box2 = 2018),\n    IsWinningPosition pos :=\n  sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_213", "informal_problem": "7.1. Masha surveyed her friends from her ensemble and received the following answers: 25 of them study mathematics, 30 have been to Moscow, 28 have traveled by train. Among those who have traveled by train, 18 study mathematics and 17 have been to Moscow. 16 friends study mathematics and have been to Moscow, and among them, 15 have also traveled by train. At the same time, there are only 45 girls in the ensemble. Is this possible?", "formal_statement": "import Mathlib\n\nstructure ValidCounts where\n  math : Nat\n  moscow : Nat\n  train : Nat\n  math_train : Nat\n  moscow_train : Nat\n  math_moscow : Nat\n  math_moscow_train : Nat\n  total : Nat\n  -- Basic size constraints\n  h_total : total = 45\n  h_math_le : math \u2264 total\n  h_moscow_le : moscow \u2264 total\n  h_train_le : train \u2264 total\n  -- Intersection constraints\n  h_math_train_le : math_train \u2264 math\n  h_math_train_le_train : math_train \u2264 train\n  h_moscow_train_le : moscow_train \u2264 moscow\n  h_moscow_train_le_train : moscow_train \u2264 train\n  h_math_moscow_le_math : math_moscow \u2264 math\n  h_math_moscow_le_moscow : math_moscow \u2264 moscow\n  h_triple_le_math_train : math_moscow_train \u2264 math_train\n  h_triple_le_moscow_train : math_moscow_train \u2264 moscow_train\n  h_triple_le_math_moscow : math_moscow_train \u2264 math_moscow\n  -- Inclusion-exclusion constraints\n  h_math_moscow_sum : math_moscow + math_train - math_moscow_train \u2264 math\n  h_moscow_train_sum : moscow_train + math_moscow - math_moscow_train \u2264 moscow\n  h_math_train_sum : math_train + moscow_train - math_moscow_train \u2264 train\n\ntheorem ensemble_possible : \u2203 (counts : ValidCounts), \n  counts.total = 45 \u2227\n  counts.math = 25 \u2227 \n  counts.moscow = 30 \u2227 \n  counts.train = 28 \u2227 \n  counts.math_train = 18 \u2227 \n  counts.moscow_train = 17 \u2227 \n  counts.math_moscow = 16 \u2227 \n  counts.math_moscow_train = 15 :=\n  sorry", "formal_statement_pred": "import Mathlib\n\nstructure EnsembleData where\n  total : Nat\n  math : Finset Nat\n  moscow : Finset Nat\n  train : Finset Nat\n  h_total : total = 45\n  h_math : math.card = 25\n  h_moscow : moscow.card = 30\n  h_train : train.card = 28\n  h_math_train : (math \u2229 train).card = 18\n  h_moscow_train : (moscow \u2229 train).card = 17\n  h_math_moscow : (math \u2229 moscow).card = 16\n  h_all : (math \u2229 moscow \u2229 train).card = 15\n  h_size : (math \u222a moscow \u222a train).card \u2264 total\n\ntheorem ensemble_impossible : \u00ac \u2203 (d : EnsembleData), True :=\n  sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_214", "informal_problem": "10.4 On the Unified State Exam (USE) in mathematics, 333 students made a total of 1000 mistakes. Prove that in this case, the number of students who made more than 5 mistakes is no greater than the number of students who made fewer than 4 mistakes.", "formal_statement": "import Mathlib\n\nstructure ExamResults where\n  totalStudents : Nat\n  totalMistakes : Nat\n  mistakeCount : Fin totalStudents \u2192 Nat\n  sum_constraint : (Finset.sum Finset.univ mistakeCount) = totalMistakes\n\n/-- Number of students who made more than n mistakes -/\ndef studentsAbove (results : ExamResults) (n : Nat) : Nat :=\n  Finset.card (Finset.filter (fun i => results.mistakeCount i > n) Finset.univ)\n\n/-- Number of students who made fewer than n mistakes -/\ndef studentsBelow (results : ExamResults) (n : Nat) : Nat :=\n  Finset.card (Finset.filter (fun i => results.mistakeCount i < n) Finset.univ)\n\ntheorem exam_mistakes_distribution \n  (results : ExamResults)\n  (h1 : results.totalStudents = 333)\n  (h2 : results.totalMistakes = 1000) :\n  studentsAbove results 5 \u2264 studentsBelow results 4 :=\n  sorry", "formal_statement_pred": "import Mathlib\n\nstructure ExamResults where\n  totalStudents : Nat\n  totalMistakes : Nat\n  mistakeCount : Fin totalStudents \u2192 Nat\n\n  sum_constraint : (\u2211 i, mistakeCount i) = totalMistakes\n\n\ndef studentsAbove (results : ExamResults) (n : Nat) : Nat :=\n  (Finset.univ.filter (fun i => results.mistakeCount i > n)).card\n\n\ndef studentsBelow (results : ExamResults) (n : Nat) : Nat :=\n  (Finset.univ.filter (fun i => results.mistakeCount i < n)).card\n\ntheorem exam_mistakes_distribution\n  (results : ExamResults)\n  (h1 : results.totalStudents = 333)\n  (h2 : results.totalMistakes = 1000) :\n  studentsAbove results 5 \u2264 studentsBelow results 4 :=\n  sorry", "compiled": true, "aligned": true}
{"id": "CombStruct4Lean_215", "informal_problem": "5. In the tournament, 49 chess players participated. At a certain point in the tournament, 83 games had been played, and each participant had played either three or four games (and no one played each other twice). Could it have been the case that no two players who played exactly three games played against each other?\n\nAnswer: No.", "formal_statement": "import Mathlib\n\nstructure ChessTournament where\n  n : Nat                                    -- number of players\n  games_played : Nat                         -- total number of games played\n  player_games : Fin n \u2192 Nat                 -- number of games each player played\n  played_against : Fin n \u2192 Fin n \u2192 Bool      -- whether player i played against j\n  \n  no_self_games : \u2200 i, \u00acplayed_against i i  -- players don't play against themselves\n  symmetric : \u2200 i j, played_against i j = played_against j i  -- symmetry of games\n  games_count_valid : \u2200 i, player_games i = 3 \u2228 player_games i = 4  -- each played 3 or 4 games\n  total_games_match : games_played = (\u2211 i, player_games i) / 2  -- total games matches sum of games\n  no_repeats : \u2200 i j, played_against i j \u2192 \u00ac(\u2203 k, k \u2260 j \u2227 played_against i k)  -- no repeated games\n\ntheorem chess_tournament_three_games_must_play \n  (t : ChessTournament) \n  (h1 : t.n = 49) \n  (h2 : t.games_played = 83) : \n  \u2203 i j, i \u2260 j \u2227 \n    t.player_games i = 3 \u2227 \n    t.player_games j = 3 \u2227 \n    t.played_against i j := \n  sorry", "formal_statement_pred": "import Mathlib\nimport Mathlib.Data.Fintype.Basic\n\nstructure ChessTournament (n : Nat) where\n  played_against : Fin n \u2192 Fin n \u2192 Bool\n  games_per_player : Fin n \u2192 Nat\n  total_games : Nat\n\n  symm : \u2200 i j, played_against i j = played_against j i\n  no_self_play : \u2200 i, \u00acplayed_against i i\n  valid_games : \u2200 i, games_per_player i = 3 \u2228 games_per_player i = 4\n\n  count_matches : total_games =\n    (Finset.sum (Finset.univ.product Finset.univ) fun (i, j) =>\n      if played_against i j then (1 : Nat) else 0) / 2\n\n  player_games_count : \u2200 i, games_per_player i =\n    Finset.sum Finset.univ fun j =>\n      if played_against i j then (1 : Nat) else 0\n\ntheorem chess_tournament_impossibility :\n  \u00ac\u2203 (t : ChessTournament 49),\n    ChessTournament.total_games t = 83 \u2227\n    (\u2200 i j, ChessTournament.games_per_player t i = 3 \u2192\n            ChessTournament.games_per_player t j = 3 \u2192\n            \u00acChessTournament.played_against t i j) :=\n  sorry", "compiled": true, "aligned": true}
{"id": "CombStruct4Lean_216", "informal_problem": "9.4. In a volleyball tournament, 110 teams participated, each playing exactly one game with each of the others (there are no ties in volleyball). It turned out that in any group of 55 teams, there is one that lost to no more than four of the other 54 teams in this group. Prove that in the entire tournament, there is a team that lost to no more than four of the other 109 teams. (S. Berlov)", "formal_statement": "import Mathlib\n\n/-- A tournament where each team plays exactly one game against every other team.\n    `games i j = true` means team i won against team j -/\nstructure Tournament (n : Nat) where\n  games : Fin n \u2192 Fin n \u2192 Bool\n  no_self_games : \u2200 i, \u00ac(games i i)\n  antisymmetric : \u2200 i j, i \u2260 j \u2192 games i j = !games j i\n\n/-- Count number of losses for a team against all other teams -/\ndef countLosses {n : Nat} (t : Tournament n) (team : Fin n) (opponents : Finset (Fin n)) : Nat :=\n  (opponents.filter (fun opp => t.games opp team)).card\n\ntheorem volleyball_tournament_property\n  (t : Tournament 110)\n  (h_subgroup : \u2200 (teams : Finset (Fin 110)), teams.card = 55 \u2192 \n    \u2203 team \u2208 teams, countLosses t team teams \u2264 4) :\n  \u2203 team : Fin 110, countLosses t team (Finset.univ) \u2264 4 :=\n  sorry", "formal_statement_pred": "import Mathlib\n\n\nstructure Tournament where\n  n : Nat\n  beats : Fin n \u2192 Fin n \u2192 Bool\n  h_complete : \u2200 i j, i \u2260 j \u2192 beats i j \u2260 beats j i\n  h_no_self : \u2200 i, beats i i = false\n\n\ndef countLosses (t : Tournament) (team : Fin t.n) (group : Finset (Fin t.n)) : Nat :=\n  (group.filter (fun i => t.beats i team)).card\n\ntheorem volleyball_tournament_winner (t : Tournament) (h_size : t.n = 110)\n  (h_group : \u2200 (group : Finset (Fin t.n)), group.card = 55 \u2192\n    \u2203 team \u2208 group, countLosses t team group \u2264 4) :\n  \u2203 team : Fin t.n, countLosses t team (Finset.univ) \u2264 4 :=\n  sorry", "compiled": true, "aligned": true}
{"id": "CombStruct4Lean_217", "informal_problem": "5. Any two strangers in the company have exactly two common acquaintances. Dina and Tolya are acquainted with each other, but they do not have any common acquaintances. Prove that Dina and Tolya have the same number of acquaintances in this company.", "formal_statement": "import Mathlib\n\nstructure Company where\n  people : Type\n  acquainted : people \u2192 people \u2192 Prop\n  -- Acquaintance relation is symmetric\n  symm : \u2200 x y, acquainted x y \u2192 acquainted y x\n  -- No one is acquainted with themselves\n  irrefl : \u2200 x, \u00acacquainted x x\n  -- Two strangers have exactly two common acquaintances\n  two_common : \u2200 x y, \u00acacquainted x y \u2192 \n    \u2203 (s : Finset people), s.card = 2 \u2227 \n    \u2200 z, z \u2208 s \u2194 (acquainted x z \u2227 acquainted y z)\n\n/-- Count of acquaintances for a person -/\ndef acquaintance_count (C : Company) [Fintype C.people] [DecidableRel C.acquainted]\n    (p : C.people) : \u2115 :=\n  (Finset.filter (C.acquainted p) Finset.univ).card\n\ntheorem dina_tolya_same_acquaintances \n  (C : Company) [Fintype C.people] [DecidableRel C.acquainted]\n  (dina tolya : C.people)\n  (are_acquainted : C.acquainted dina tolya)\n  (no_common : \u2200 z, z \u2260 dina \u2192 z \u2260 tolya \u2192 \u00ac(C.acquainted dina z \u2227 C.acquainted tolya z)) :\n  acquaintance_count C dina = acquaintance_count C tolya :=\nsorry", "formal_statement_pred": "import Mathlib\n\nstructure Company where\n  people : Type\n  [fintype : Fintype people]\n  [decidable_eq : DecidableEq people]\n  acquainted : people \u2192 people \u2192 Prop\n  [decidable_rel : DecidableRel acquainted]\n\n  symm : \u2200 x y, acquainted x y \u2194 acquainted y x\n\n  irrefl : \u2200 x, \u00acacquainted x x\n\n\n  common_count : \u2200 x y, x \u2260 y \u2192 \u00acacquainted x y \u2192\n    (Finset.filter (fun z => acquainted x z \u2227 acquainted y z) Finset.univ).card = 2\n\n  no_common_acq : \u2200 x y, acquainted x y \u2192\n    (Finset.filter (fun z => acquainted x z \u2227 acquainted y z) Finset.univ).card = 0\n\n  acquaintance_count (p : people) : \u2115 :=\n    (Finset.filter (fun q => acquainted p q) Finset.univ).card\n\ntheorem same_num_acquaintances (c : Company) (dina tolya : c.people)\n    (h_acq : c.acquainted dina tolya)\n    (h_no_common : \u2200 z, \u00ac(c.acquainted dina z \u2227 c.acquainted tolya z)) :\n    c.acquaintance_count dina = c.acquaintance_count tolya :=\n  sorry", "compiled": true, "aligned": true}
{"id": "CombStruct4Lean_219", "informal_problem": "11.5. From the integers from 0 to 1000, 101 numbers were chosen. Prove that among the absolute values of their pairwise differences, there are ten different numbers not exceeding 100.\n\n(I. Bogdanov)", "formal_statement": "import Mathlib\n\n-- Convert natural numbers to integers and compute absolute difference\ndef absDiff (a b : \u2115) : \u2115 := ((\u2191a - \u2191b : \u2124).natAbs)\n\n-- Set of all pairwise absolute differences for a finite set of naturals\ndef pairwiseDiffs (S : Finset \u2115) : Finset \u2115 :=\n  (S.product S).filter (fun p => p.1 \u2260 p.2)\n    |>.image (fun p => absDiff p.1 p.2)\n\n-- Set of pairwise differences not exceeding given bound\ndef smallDiffs (S : Finset \u2115) (bound : \u2115) : Finset \u2115 :=\n  (pairwiseDiffs S).filter (fun x => x \u2264 bound)\n\ntheorem bogdanov_differences \n  (S : Finset \u2115) \n  (bound : \u2115 := 1000)\n  (h1 : S.card = 101)\n  (h2 : \u2200 x \u2208 S, x \u2264 bound) :\n  \u2203 D : Finset \u2115, \n    D \u2286 smallDiffs S 100 \u2227 \n    D.card = 10 :=\n  sorry", "formal_statement_pred": "import Mathlib\n\ndef pairwiseDifferences (S : Finset \u2124) : Finset \u2124 :=\n  (S.product S).image fun p => |p.1 - p.2|\n\ndef hasTenSmallDifferences (S : Finset \u2124) : Prop :=\n  \u2203 D \u2286 pairwiseDifferences S,\n    D.card = 10 \u2227 \u2200 d \u2208 D, d \u2264 100\n\ntheorem bogdanov_differences\n  (S : Finset \u2124)\n  (h_bound : \u2200 x \u2208 S, 0 \u2264 x \u2227 x \u2264 1000)\n  (h_size : S.card = 101) :\n  hasTenSmallDifferences S :=\n  sorry", "compiled": true, "aligned": true}
{"id": "CombStruct4Lean_220", "informal_problem": "4. There are 15 students in the class. For homework, they were assigned 6 geometry problems. More than half of the students solved each problem.\n\nProve that there will be two students who, together, solved all 6 problems.", "formal_statement": "import Mathlib\n\nopen Finset\n\nstructure HomeworkSolutions where\n  solved : Fin 15 \u2192 Finset (Fin 6)\n  solutions_valid : \u2200 s : Fin 15, solved s \u2286 univ\n  more_than_half : \u2200 p : Fin 6, \n    (univ.filter (fun s => p \u2208 solved s)).card > 7\n\ntheorem homework_pigeonhole (h : HomeworkSolutions) : \n  \u2203 s\u2081 s\u2082 : Fin 15, s\u2081 \u2260 s\u2082 \u2227 (h.solved s\u2081 \u222a h.solved s\u2082) = univ :=\n  sorry", "formal_statement_pred": "import Mathlib\n\nopen Finset\n\nstructure HomeworkSolutions where\n  solutions : Fin 15 \u2192 Finset (Fin 6)\n  more_than_half : \u2200 p : Fin 6,\n    (univ.filter (fun s => p \u2208 solutions s)).card \u2265 8\n\ntheorem homework_pigeonhole (h : HomeworkSolutions) :\n  \u2203 s\u2081 s\u2082 : Fin 15, s\u2081 \u2260 s\u2082 \u2227\n    \u2200 p : Fin 6, p \u2208 h.solutions s\u2081 \u2228 p \u2208 h.solutions s\u2082 :=\n  sorry", "compiled": true, "aligned": true}
{"id": "CombStruct4Lean_221", "informal_problem": "5. 7 ginger and 7 black kittens are drinking water from a round basin. Is it true that there will be a kitten whose both neighbors are black kittens?\n\n#", "formal_statement": "import Mathlib\n\nstructure KittenCircle where\n  black_positions : Finset (Fin 14)\n  count_valid : black_positions.card = 7\n\ndef are_neighbors (i j : Fin 14) : Bool :=\n  i.val = (j.val + 1) % 14 \u2228 j.val = (i.val + 1) % 14\n\ntheorem exists_black_neighbors :\n  \u2200 (c : KittenCircle), \u2203 (i : Fin 14),\n    \u2200 j : Fin 14, are_neighbors i j \u2192 j \u2208 c.black_positions :=\n  sorry", "formal_statement_pred": "import Mathlib\n\ninductive KittenColor where\n  | Black : KittenColor\n  | Ginger : KittenColor\nderiving Repr, DecidableEq\n\nstructure CircularArrangement (n : Nat) where\n  color : Fin n \u2192 KittenColor\n  next (i : Fin n) : Fin n := \u27e8(i.val + 1) % n, sorry\u27e9\n  prev (i : Fin n) : Fin n := \u27e8(i.val + n - 1) % n, sorry\u27e9\n  count_color (c : KittenColor) : Nat :=\n    (Finset.univ.filter (fun i => color i = c)).card\n  h_even : n % 2 = 0\n  h_black : count_color KittenColor.Black = n/2\n  h_ginger : count_color KittenColor.Ginger = n/2\n\ntheorem exists_black_neighbors {n : Nat} (arr : CircularArrangement n) (h : n = 14) :\n  \u2203 (i : Fin n),\n    arr.color (arr.next i) = KittenColor.Black \u2227\n    arr.color (arr.prev i) = KittenColor.Black :=\n  sorry", "compiled": true, "aligned": true}
{"id": "CombStruct4Lean_222", "informal_problem": "11.5. In 50 baskets, there are cucumbers, eggplants, and tomatoes. Prove that it is possible to choose 26 baskets such that they contain no less than half of all cucumbers (by count), no less than half of all eggplants, and no less than half of all tomatoes (also by count).\n\n#", "formal_statement": "import Mathlib\n\nstructure Basket where\n  cucumbers : Nat\n  eggplants : Nat\n  tomatoes : Nat\n\n/-- Given a list of baskets, compute the total count of each vegetable -/\ndef totalVegetables (baskets : List Basket) : Basket :=\n  let total := baskets.foldl (fun acc b => \u27e8\n    acc.cucumbers + b.cucumbers,\n    acc.eggplants + b.eggplants,\n    acc.tomatoes + b.tomatoes\n  \u27e9) \u27e80, 0, 0\u27e9\n  total\n\n/-- Check if a subset of baskets contains at least half of each vegetable type -/\ndef containsHalfOfEach (subset baskets : List Basket) : Prop :=\n  let subTotal := totalVegetables subset\n  let total := totalVegetables baskets\n  2 * subTotal.cucumbers \u2265 total.cucumbers \u2227\n  2 * subTotal.eggplants \u2265 total.eggplants \u2227\n  2 * subTotal.tomatoes \u2265 total.tomatoes\n\ntheorem basket_selection_theorem (baskets : List Basket)\n  (h1 : baskets.length = 50) :\n  \u2203 (subset : List Basket),\n    subset.length = 26 \u2227\n    subset.Sublist baskets \u2227\n    containsHalfOfEach subset baskets :=\n  sorry", "formal_statement_pred": "import Mathlib\n\nstructure Basket where\n  cucumbers : \u2115\n  eggplants : \u2115\n  tomatoes : \u2115\n\n\ndef total_count (baskets : Finset Basket) (get_veg : Basket \u2192 \u2115) : \u2115 :=\n  baskets.sum get_veg\n\n\ntheorem vegetable_basket_majority\n  (baskets : Finset Basket)\n  (h_count : baskets.card = 50) :\n  \u2203 (subset : Finset Basket),\n    subset \u2286 baskets \u2227\n    subset.card = 26 \u2227\n    total_count subset (\u00b7.cucumbers) * 2 \u2265 total_count baskets (\u00b7.cucumbers) \u2227\n    total_count subset (\u00b7.eggplants) * 2 \u2265 total_count baskets (\u00b7.eggplants) \u2227\n    total_count subset (\u00b7.tomatoes) * 2 \u2265 total_count baskets (\u00b7.tomatoes) :=\n  sorry", "compiled": true, "aligned": true}
{"id": "CombStruct4Lean_223", "informal_problem": "9.4. Given 9 different natural numbers, not greater than 19. Prove that among their pairwise differences, there will be three that are the same in absolute value.", "formal_statement": "import Mathlib\n\ndef AbsDiff (a b : \u2115) : \u2115 := \n  if a \u2265 b then a - b else b - a\n\nstructure NumberSelection where\n  nums : Fin 9 \u2192 \u2115 \n  distinct : \u2200 i j, i \u2260 j \u2192 nums i \u2260 nums j\n  bound : \u2200 i, nums i \u2264 19\n\ntheorem three_equal_diffs (sel : NumberSelection) : \n  \u2203 (i\u2081 j\u2081 i\u2082 j\u2082 i\u2083 j\u2083 : Fin 9), \n    i\u2081 \u2260 j\u2081 \u2227 i\u2082 \u2260 j\u2082 \u2227 i\u2083 \u2260 j\u2083 \u2227\n    (i\u2081, j\u2081) \u2260 (i\u2082, j\u2082) \u2227 (i\u2081, j\u2081) \u2260 (i\u2083, j\u2083) \u2227 (i\u2082, j\u2082) \u2260 (i\u2083, j\u2083) \u2227\n    AbsDiff (sel.nums i\u2081) (sel.nums j\u2081) = AbsDiff (sel.nums i\u2082) (sel.nums j\u2082) \u2227\n    AbsDiff (sel.nums i\u2081) (sel.nums j\u2081) = AbsDiff (sel.nums i\u2083) (sel.nums j\u2083) :=\n  sorry", "formal_statement_pred": "import Mathlib\n\nopen Nat\n\ndef absDiff (a b : \u2115) : \u2115 :=\n  if a \u2265 b then a - b else b - a\n\ntheorem nine_numbers_three_same_differences\n  (s : Finset \u2115)\n  (h_card : s.card = 9)\n  (h_bound : \u2200 n \u2208 s, n \u2264 19) :\n  \u2203 (d : \u2115) (a\u2081 b\u2081 a\u2082 b\u2082 a\u2083 b\u2083 : \u2115),\n    a\u2081 \u2208 s \u2227 b\u2081 \u2208 s \u2227 a\u2082 \u2208 s \u2227 b\u2082 \u2208 s \u2227 a\u2083 \u2208 s \u2227 b\u2083 \u2208 s \u2227\n    (a\u2081, b\u2081) \u2260 (a\u2082, b\u2082) \u2227 (a\u2082, b\u2082) \u2260 (a\u2083, b\u2083) \u2227 (a\u2081, b\u2081) \u2260 (a\u2083, b\u2083) \u2227\n    absDiff a\u2081 b\u2081 = d \u2227 absDiff a\u2082 b\u2082 = d \u2227 absDiff a\u2083 b\u2083 = d :=\n  sorry", "compiled": true, "aligned": true}
{"id": "CombStruct4Lean_224", "informal_problem": "5. Katya wrote down the set $X=\\{1,2,3,4,5,6,7,8,9\\}$ in her notebook and decided to split it into two subsets. Prove that no matter how Katya splits the set into two subsets, at least one of the resulting subsets will contain three numbers such that the sum of two of them is twice the third.", "formal_statement": "import Mathlib\n\ndef has_sum_twice_relation (s : Set Nat) : Prop :=\n  \u2203 (a b c : Nat), a \u2208 s \u2227 b \u2208 s \u2227 c \u2208 s \u2227 a + b = 2 * c\n\ntheorem katya_set_split :\n  let X : Set Nat := {1, 2, 3, 4, 5, 6, 7, 8, 9}\n  \u2200 (A B : Set Nat), A \u222a B = X \u2192 A \u2229 B = \u2205 \u2192\n    has_sum_twice_relation A \u2228 has_sum_twice_relation B :=\n  sorry", "formal_statement_pred": "import Mathlib\n\ndef has_sum_twice_relation (s : Set Nat) : Prop :=\n  \u2203 (a b c : Nat), a \u2208 s \u2227 b \u2208 s \u2227 c \u2208 s \u2227 a + b = 2 * c\n\ndef is_valid_partition (X A B : Set Nat) : Prop :=\n  A \u222a B = X \u2227 A \u2229 B = \u2205\n\ntheorem katyas_partition_problem :\n  let X : Set Nat := {1, 2, 3, 4, 5, 6, 7, 8, 9}\n  \u2200 (A B : Set Nat), is_valid_partition X A B \u2192\n    has_sum_twice_relation A \u2228 has_sum_twice_relation B :=\n  sorry", "compiled": true, "aligned": true}
{"id": "CombStruct4Lean_225", "informal_problem": "5. Can a $50 \\times 50$ square be cut into strips of $1 \\times 4$?", "formal_statement": "import Mathlib\n\nstructure Strip where\n  pos_x : Nat\n  pos_y : Nat\n  horizontal : Bool -- true if strip is horizontal, false if vertical\n\ndef validStrip (s : Strip) (n : Nat) : Bool :=\n  if s.horizontal then\n    s.pos_x + 4 \u2264 n \u2227 s.pos_y < n -- horizontal strip must fit within grid\n  else\n    s.pos_x < n \u2227 s.pos_y + 4 \u2264 n -- vertical strip must fit within grid\n\ndef coversSquare (strips : List Strip) (n : Nat) : Prop :=\n  \u2200 (x y : Nat), x < n \u2192 y < n \u2192\n    \u2203 (s : Strip), s \u2208 strips \u2227\n      (if s.horizontal then\n        s.pos_x \u2264 x \u2227 x < s.pos_x + 4 \u2227 s.pos_y = y\n      else\n        s.pos_y \u2264 y \u2227 y < s.pos_y + 4 \u2227 s.pos_x = x)\n\ntheorem square_50_strip_cover : \n  \u2203 (strips : List Strip), \n    (\u2200 s \u2208 strips, validStrip s 50) \u2227 \n    coversSquare strips 50 :=\n  sorry", "formal_statement_pred": "import Mathlib\n\nstructure Point where\n  x : Fin 50\n  y : Fin 50\n\nstructure Strip where\n  start : Point\n  isHorizontal : Bool\n  h_valid : if isHorizontal then\n             (start.x.val + 4 : Nat) \u2264 50\n           else\n             (start.y.val + 4 : Nat) \u2264 50\n\ndef Grid := Fin 50 \u2192 Fin 50 \u2192 Bool\n\ndef point_in_strip (p : Point) (s : Strip) : Prop :=\n  if s.isHorizontal then\n    p.y = s.start.y \u2227\n    (p.x.val \u2265 s.start.x.val \u2227 p.x.val < s.start.x.val + 4)\n  else\n    p.x = s.start.x \u2227\n    (p.y.val \u2265 s.start.y.val \u2227 p.y.val < s.start.y.val + 4)\n\ntheorem fifty_by_fifty_strip_covering :\n  \u2203 (strips : List Strip),\n    (\u2200 p : Point, \u2203 s, s \u2208 strips \u2227 point_in_strip p s) \u2227\n    (\u2200 p : Point, \u2200 s\u2081 s\u2082, s\u2081 \u2208 strips \u2192 s\u2082 \u2208 strips \u2192\n      point_in_strip p s\u2081 \u2192 point_in_strip p s\u2082 \u2192 s\u2081 = s\u2082) :=\n  sorry", "compiled": true, "aligned": true}
{"id": "CombStruct4Lean_227", "informal_problem": "12. The king has 100 greyhounds, and he wants to select three for hunting. He gathered 100 courtiers and asked each one which three dogs they consider the fastest. It turned out that for any two courtiers, there are two dogs that both of them pointed out. Prove that the choice of some two courtiers completely coincided.", "formal_statement": "import Mathlib\n\nstructure CourtierChoice where\n  dogs : Finset (Fin 100)\n  size_is_three : dogs.card = 3\n\nstructure GreyhoundSelection where\n  choices : Finset (Fin 100 \u00d7 CourtierChoice)\n  choices_size : choices.card = 100\n  choices_valid : \u2200 i, \u2203! c, (i, c) \u2208 choices\n  any_two_share_two : \u2200 i j : Fin 100, i \u2260 j \u2192 \n    \u2200 ci cj, (i, ci) \u2208 choices \u2192 (j, cj) \u2208 choices \u2192\n    (ci.dogs \u2229 cj.dogs).card \u2265 2\n\ntheorem greyhound_coincidence (selection : GreyhoundSelection) :\n  \u2203 i j : Fin 100, i \u2260 j \u2227 \n    (\u2203 ci cj, (i, ci) \u2208 selection.choices \u2227 \n              (j, cj) \u2208 selection.choices \u2227 ci = cj) :=\n  sorry", "formal_statement_pred": "import Mathlib\n\nstructure DogSelection where\n  dogs : Finset (Fin 100)\n  size_is_three : dogs.card = 3\n\nstructure CourtierChoices where\n  n_courtiers : Nat\n  n_dogs : Nat\n  selections : Fin n_courtiers \u2192 DogSelection\n  common_dogs : \u2200 i j, i \u2260 j \u2192\n    \u2203 d\u2081 d\u2082, d\u2081 \u2260 d\u2082 \u2227 d\u2081 \u2208 (selections i).dogs \u2227 d\u2081 \u2208 (selections j).dogs \u2227\n              d\u2082 \u2208 (selections i).dogs \u2227 d\u2082 \u2208 (selections j).dogs\n\ntheorem greyhound_selection_problem :\n  \u2200 (c : CourtierChoices), c.n_courtiers = 100 \u2192 c.n_dogs = 100 \u2192\n  \u2203 i j, i \u2260 j \u2227 (c.selections i).dogs = (c.selections j).dogs :=\n  sorry", "compiled": true, "aligned": true}
{"id": "CombStruct4Lean_228", "informal_problem": "44. Let similar sizes be those that differ by no more than $\\sqrt{2}$ times. Prove that it is impossible to make 3 piles from the original pile.", "formal_statement": "import Mathlib\n\nstructure PileSplit where\n  piles : Fin 3 \u2192 \u211d\n  sum_to_original : (\u2211 i, piles i) = 1\n  all_positive : \u2200 i, piles i > 0\n  similar_sizes : \u2200 i j, piles i \u2264 Real.sqrt 2 * piles j\n\ntheorem no_three_similar_piles : \u00ac\u2203 (split : PileSplit), True :=\n  sorry", "formal_statement_pred": "import Mathlib\n\n\ndef isSimilarSize (x y : \u211d) : Prop :=\n  x / y \u2264 Real.sqrt 2 \u2227 y / x \u2264 Real.sqrt 2\n\n\nstructure ThreePileSplit where\n  total : \u211d\n  pile1 : \u211d\n  pile2 : \u211d\n  pile3 : \u211d\n  nonneg1 : pile1 > 0\n  nonneg2 : pile2 > 0\n  nonneg3 : pile3 > 0\n  sum_eq : pile1 + pile2 + pile3 = total\n\ntheorem three_pile_split_impossible (split : ThreePileSplit) :\n  \u00ac(isSimilarSize split.pile1 split.pile2 \u2227\n    isSimilarSize split.pile2 split.pile3 \u2227\n    isSimilarSize split.pile1 split.pile3) :=\n  sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_230", "informal_problem": "1. Prove that if in a country any two schools are connected by exactly one direct route, then this country is harmonious.\n\n#", "formal_statement": "import Mathlib\n\nuniverse u v\n\nstructure Country (School : Type u) (Route : Type v) where\n  schools : Set School\n  routes : Set Route\n  connects : Route \u2192 School \u00d7 School\n  route_exists : \u2200 (s\u2081 s\u2082 : School), s\u2081 \u2208 schools \u2192 s\u2082 \u2208 schools \u2192 s\u2081 \u2260 s\u2082 \u2192\n    \u2203! (r : Route), r \u2208 routes \u2227 (connects r = (s\u2081, s\u2082) \u2228 connects r = (s\u2082, s\u2081))\n  valid_routes : \u2200 (r : Route), r \u2208 routes \u2192\n    let (s\u2081, s\u2082) := connects r\n    s\u2081 \u2208 schools \u2227 s\u2082 \u2208 schools \u2227 s\u2081 \u2260 s\u2082\n\ndef connected {School : Type u} {Route : Type v} (c : Country School Route) \n    (r : Route) (s\u2081 s\u2082 : School) : Prop :=\n  c.connects r = (s\u2081, s\u2082) \u2228 c.connects r = (s\u2082, s\u2081)\n\ndef forms_triangle {School : Type u} {Route : Type v} (c : Country School Route) \n    (s\u2081 s\u2082 s\u2083 : School) : Prop :=\n  s\u2081 \u2208 c.schools \u2227 s\u2082 \u2208 c.schools \u2227 s\u2083 \u2208 c.schools \u2227\n  s\u2081 \u2260 s\u2082 \u2227 s\u2082 \u2260 s\u2083 \u2227 s\u2081 \u2260 s\u2083 \u2227\n  \u2203 (r\u2081 r\u2082 r\u2083 : Route), r\u2081 \u2208 c.routes \u2227 r\u2082 \u2208 c.routes \u2227 r\u2083 \u2208 c.routes \u2227\n    connected c r\u2081 s\u2081 s\u2082 \u2227 connected c r\u2082 s\u2082 s\u2083 \u2227 connected c r\u2083 s\u2081 s\u2083\n\ndef harmonious {School : Type u} {Route : Type v} (c : Country School Route) : Prop :=\n  \u2200 (s\u2081 s\u2082 s\u2083 : School), s\u2081 \u2208 c.schools \u2192 s\u2082 \u2208 c.schools \u2192 s\u2083 \u2208 c.schools \u2192\n  s\u2081 \u2260 s\u2082 \u2192 s\u2082 \u2260 s\u2083 \u2192 s\u2081 \u2260 s\u2083 \u2192 forms_triangle c s\u2081 s\u2082 s\u2083\n\ntheorem country_harmonious {School : Type u} {Route : Type v} \n    (c : Country School Route) : harmonious c :=\n  sorry", "formal_statement_pred": "import Mathlib\nuniverse u\n\nstructure Connection (School : Type u) where\n  from_ : School\n  to_ : School\n  different : from_ \u2260 to_\n\n\nstructure Country (School : Type u) where\n  schools : Set School\n  routes : School \u2192 School \u2192 Bool\n  symmetric : \u2200 s\u2081 s\u2082, routes s\u2081 s\u2082 = routes s\u2082 s\u2081\n  irreflexive : \u2200 s, \u00acroutes s s\n  unique_route : \u2200 s\u2081 s\u2082, s\u2081 \u2208 schools \u2192 s\u2082 \u2208 schools \u2192 s\u2081 \u2260 s\u2082 \u2192 routes s\u2081 s\u2082\n\ntheorem unique_routes_implies_harmonious\n  {School : Type u} (c : Country School) :\n  \u2203 coloring : School \u2192 Bool,\n    \u2200 s\u2081 s\u2082, s\u2081 \u2208 c.schools \u2192 s\u2082 \u2208 c.schools \u2192\n      c.routes s\u2081 s\u2082 \u2192 coloring s\u2081 \u2260 coloring s\u2082 :=\n  sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_232", "informal_problem": "6. In the cells of an infinitely long tape, natural numbers are recorded in order. Vasisuaili Lokhankin and Engineer Ptiburdikov took out cardboard rectangles marked with cells of the same size. Each cut out several cells in one row of their rectangle. At the same time, Vasisuaili cut out one more hole than Ptiburdikov. Now they want to place their figures on the tape so that the cut-out cells overlap the cells of the tape. Prove that this can be done in such a way that the sum of the numbers visible through the holes of one figure coincides with the sum of the numbers visible through the holes of the other.", "formal_statement": "import Mathlib\n\nstructure TapeHoles where\n  startPos : \u2115  -- Starting position on the infinite tape\n  holes : List \u2115 -- List of relative positions of holes from startPos\n\ndef sumAtPosition (t : TapeHoles) : \u2115 :=\n  let tapeNumbers := fun i => i + 1  -- Infinite tape with natural numbers\n  (t.holes.map fun offset => tapeNumbers (t.startPos + offset)).sum\n\ntheorem holes_equal_sum_exists \n  (vHoles vStart pHoles pStart : \u2115) \n  (h_holes : vHoles = pHoles + 1) -- Vasisuaili has one more hole than Ptiburdikov\n  (h_positive : vHoles > 0) :\n  \u2203 (v p : TapeHoles),\n    v.holes.length = vHoles \u2227 \n    p.holes.length = pHoles \u2227\n    sumAtPosition v = sumAtPosition p :=\n  sorry", "formal_statement_pred": "import Mathlib\n\n\nstructure TapeHoles where\n  startPos : \u2115\n  holes : List \u2115\n  valid : List.Sorted (\u00b7 < \u00b7) holes\n  nonempty : holes \u2260 []\nderiving Repr\n\n\ndef tapeFn (n : \u2115) : \u2115 := n + 1\n\n\ndef visibleSum (h : TapeHoles) : \u2115 :=\n  (h.holes.map (fun offset => tapeFn (h.startPos + offset))).sum\n\n\ntheorem holes_equal_sum_exists (vasy pti : TapeHoles)\n  (hlen : vasy.holes.length = pti.holes.length + 1) :\n  \u2203 (newVasyStart newPtiStart : \u2115),\n    visibleSum \u27e8newVasyStart, vasy.holes, vasy.valid, vasy.nonempty\u27e9 =\n    visibleSum \u27e8newPtiStart, pti.holes, pti.valid, pti.nonempty\u27e9 :=\n  sorry", "compiled": true, "aligned": true}
{"id": "CombStruct4Lean_233", "informal_problem": "6. A pile contains 2017 stones. On the $i$-th move, one of the existing piles is split into two non-empty piles, after which $i$ stones are added to one of them. Can it happen that after two or more moves, all piles have an equal number of stones?", "formal_statement": "import Mathlib\n\nstructure GameState where\n  piles : List Nat\n  moveCount : Nat\n\ndef totalStonesAdded (moves : Nat) : Nat :=\n  moves * (moves + 1) / 2\n\ndef totalStones (gs : GameState) (initialStones : Nat) : Nat :=\n  initialStones + totalStonesAdded gs.moveCount\n\ndef allPilesEqual (piles : List Nat) : Prop :=\n  \u2200 x \u2208 piles, \u2200 y \u2208 piles, x = y\n\ndef isValidGameState (gs : GameState) (initialStones : Nat) : Prop :=\n  gs.piles.sum = totalStones gs initialStones\n\ntheorem stone_splitting_game_equal_impossible (initialStones : Nat) (h : initialStones = 2017) :\n  \u00ac\u2203 (gs : GameState),\n    gs.moveCount \u2265 2 \u2227\n    gs.piles.length > 1 \u2227\n    isValidGameState gs initialStones \u2227\n    allPilesEqual gs.piles :=\n  sorry", "formal_statement_pred": "import Mathlib\n\nstructure GameState where\n  piles : List Nat\n  moveCount : Nat\n  sumStones : Nat\n\ndef isValidSplit (gs : GameState) (p1 p2 : Nat) (originalPile : Nat) : Bool :=\n  p1 > 0 \u2227 p2 > 0 \u2227 p1 + p2 = originalPile\n\ndef makeMove (gs : GameState) (pileIndex : Nat) (split1 split2 : Nat)\n    (addToIndex : Nat) : Option GameState :=\n  sorry\n\ndef allPilesEqual (gs : GameState) : Bool :=\n  match gs.piles with\n  | [] => true\n  | h::t => t.all (\u00b7 = h)\n\ntheorem stone_pile_game_impossible (initialStones : Nat)\n    (h : initialStones = 2017) :\n    \u00ac\u2203 (finalState : GameState),\n      finalState.moveCount \u2265 2 \u2227\n      finalState.sumStones = initialStones + finalState.moveCount * (finalState.moveCount + 1) / 2 \u2227\n      allPilesEqual finalState :=\n  sorry", "compiled": true, "aligned": true}
{"id": "CombStruct4Lean_235", "informal_problem": "2. A circle is divided into 1000 sectors, all of which are white. Every minute, some 500 consecutive sectors are repainted - white sectors become red, and red sectors become white. At a certain repainting, the number of white sectors did not change. Prove that for one of the neighboring (previous or next) repaintings - it also did not change.\n\n#", "formal_statement": "import Mathlib\n\nstructure CircleState where\n  sectors : Fin 1000 \u2192 Bool  -- True represents white, False represents red\n  \ndef count_white (state : CircleState) : Nat :=\n  (Finset.univ.filter (fun i => state.sectors i)).card\n\n/-- Represents a repainting operation that flips 500 consecutive sectors -/\ndef repainting (start : Fin 1000) (state : CircleState) : CircleState where\n  sectors := fun i => \n    if (i - start) % 1000 < 500 \n    then !state.sectors i \n    else state.sectors i\n\ntheorem consecutive_unchanged_repaintings \n  (t : Nat) (start : Fin 1000) (state : CircleState)\n  (h : count_white (repainting start state) = count_white state) :\n  \u2203 start_next : Fin 1000,\n    count_white (repainting start_next (repainting start state)) = \n    count_white (repainting start state) \u2228\n    \u2203 start_prev : Fin 1000,\n    count_white (repainting start_prev state) = count_white state :=\n  sorry", "formal_statement_pred": "import Mathlib\n\n\ninductive Color where\n  | White : Color\n  | Red : Color\nderiving Repr, DecidableEq\n\n\nstructure CircleState where\n  sectors : Fin 1000 \u2192 Color\n\n\ndef isInRepaintRange (startPos curr : Fin 1000) : Bool :=\n  let dist := (curr - startPos : Fin 1000)\n  dist < 500\n\n\ndef countWhite (state : CircleState) : Nat :=\n  (Finset.univ.filter (fun i => state.sectors i = Color.White)).card\n\n\ndef repaint (state : CircleState) (startPos : Fin 1000) : CircleState where\n  sectors := fun i =>\n    if isInRepaintRange startPos i then\n      match state.sectors i with\n      | Color.White => Color.Red\n      | Color.Red => Color.White\n    else state.sectors i\n\ntheorem consecutive_repaint_invariant\n  (state : CircleState)\n  (pos : Fin 1000)\n  (h : countWhite (repaint state pos) = countWhite state) :\n  \u2203 pos' : Fin 1000,\n    (((pos' : Nat) + 1 = pos \u2228 pos' = (pos + 1 : Fin 1000)) \u2227\n     pos' \u2260 pos) \u2227\n    countWhite (repaint (repaint state pos) pos') = countWhite (repaint state pos) :=\n  sorry", "compiled": true, "aligned": true}
{"id": "CombStruct4Lean_236", "informal_problem": "7. In a row, there are 50 boys and 50 girls standing in some order. In this row, there is exactly one group of 30 children standing in a row, in which there are an equal number of boys and girls. Prove that there will be a group of 70 children standing in a row, in which there are also an equal number of boys and girls.", "formal_statement": "import Mathlib\n\ninductive Child where\n  | Boy\n  | Girl\n  deriving Repr, DecidableEq\n\nstructure ChildrenRow where\n  arrangement : List Child\n  len : arrangement.length = 100\n  boy_count : arrangement.countP (\u00b7 = Child.Boy) = 50\n\nstructure Segment where\n  start : Nat\n  len : Nat\n  h : start + len \u2264 100\n\n/-- Checks if a segment has equal number of boys and girls -/\ndef isBalanced (row : ChildrenRow) (seg : Segment) : Prop :=\n  let segment := (row.arrangement.drop seg.start).take seg.len\n  segment.countP (\u00b7 = Child.Boy) = segment.countP (\u00b7 = Child.Girl)\n\ntheorem equal_distribution_extension \n  (row : ChildrenRow)\n  (h\u2081 : \u2203 seg : Segment, seg.len = 30 \u2227 isBalanced row seg) :\n  \u2203 seg : Segment, seg.len = 70 \u2227 isBalanced row seg :=\n  sorry", "formal_statement_pred": "import Mathlib\n\nstructure ChildrenRow where\n  n : Nat\n  positions : Fin n \u2192 Bool\n  boy_count : Nat\n  girl_count : Nat\n  count_correct : boy_count + girl_count = n\n  equal_total : boy_count = girl_count\n\ndef subgroup_has_equal_gender (r : ChildrenRow) (start pos : Nat) : Bool :=\n  let subgroup := fun i => r.positions \u27e8start + i, sorry\u27e9\n  let boys := (List.range pos).filter (fun i => subgroup i) |>.length\n  let girls := pos - boys\n  boys = girls\n\ndef has_subgroup_size (r : ChildrenRow) (size : Nat) (equal : Bool) : Prop :=\n  \u2203 start, start + size \u2264 r.n \u2227\n    (equal \u2192 subgroup_has_equal_gender r start size)\n\ntheorem equal_gender_subgroups\n  (r : ChildrenRow)\n  (h1 : r.n = 100)\n  (h2 : r.boy_count = 50)\n  (h3 : r.girl_count = 50)\n  (h4 : has_subgroup_size r 30 true) :\n  has_subgroup_size r 70 true :=\n  sorry", "compiled": true, "aligned": true}
{"id": "CombStruct4Lean_237", "informal_problem": "6. At a masquerade ball, there were 20 people. In each dance, two people participated - a boy and a girl. It turned out that ten of them danced with three partners, two (Sasha and Zhenya) - with five, and the remaining eight - with six. Prove that Sasha and Zhenya are of different genders.", "formal_statement": "import Mathlib\n\nstructure Ball where\n  people : Finset (Fin 20)\n  gender : Fin 20 \u2192 Bool  -- True for boys, False for girls\n  dances : Finset (Fin 20 \u00d7 Fin 20)\n  sasha : Fin 20\n  zhenya : Fin 20\n  \n  -- Each dance involves exactly two people of different genders\n  dance_valid : \u2200 d \u2208 dances, gender d.1 \u2260 gender d.2\n  \n  -- Number of dance partners for each person\n  partners_count : \u2200 p : Fin 20,\n    let count := (dances.filter (fun d \u21a6 d.1 = p \u2228 d.2 = p)).card\n    if p = sasha \u2228 p = zhenya then\n      count = 5\n    else if count = 3 then\n      (people.filter (fun x \u21a6 \n        (dances.filter (fun d \u21a6 d.1 = x \u2228 d.2 = x)).card = 3)).card = 10\n    else\n      count = 6\n\ntheorem sasha_zhenya_different_gender (b : Ball) : \n  b.gender b.sasha \u2260 b.gender b.zhenya :=\n  sorry", "formal_statement_pred": "import Mathlib\n\n\nstructure Dance where\n  boy : Fin 20\n  girl : Fin 20\n\nstructure Ball where\n  gender : Fin 20 \u2192 Bool\n  dances : List Dance\n  sasha : Fin 20\n  zhenya : Fin 20\n\ndef valid_dance (b : Ball) (d : Dance) : Prop :=\n  b.gender d.boy \u2227 \u00acb.gender d.girl\n\ndef partner_count (b : Ball) (person : Fin 20) : Nat :=\n  (b.dances.filter (fun d => d.boy = person \u2228 d.girl = person)).length\n\ndef has_partners (b : Ball) (person : Fin 20) (n : Nat) : Prop :=\n  partner_count b person = n\n\ntheorem sasha_zhenya_different_gender (b : Ball)\n  (h_valid : \u2200 d \u2208 b.dances, valid_dance b d)\n  (h_sasha_five : has_partners b b.sasha 5)\n  (h_zhenya_five : has_partners b b.zhenya 5)\n  (h_ten_three : \u2203 s : Finset (Fin 20),\n    s.card = 10\n    \u2227 b.sasha \u2209 s\n    \u2227 b.zhenya \u2209 s\n    \u2227 (\u2200 i \u2208 s, has_partners b i 3))\n  (h_eight_six : \u2203 s : Finset (Fin 20),\n    s.card = 8\n    \u2227 b.sasha \u2209 s\n    \u2227 b.zhenya \u2209 s\n    \u2227 (\u2200 i \u2208 s, has_partners b i 6)) :\n  b.gender b.sasha \u2260 b.gender b.zhenya := sorry", "compiled": true, "aligned": true}
{"id": "CombStruct4Lean_238", "informal_problem": "4. The castle consists of 81 rooms in a square shape $9 * 9$. In some walls between adjacent rooms, there is one door. There are no doors to the outside, but each room has at least two doors. Prove that in some room, there are at least three doors.", "formal_statement": "import Mathlib\n\nstructure Castle where\n  n : Nat\n  doors : Fin n \u00d7 Fin n \u2192 Fin n \u00d7 Fin n \u2192 Bool  -- True if there's a door between rooms\n  adjacent : Fin n \u00d7 Fin n \u2192 Fin n \u00d7 Fin n \u2192 Bool -- True if rooms are adjacent\n  door_symmetry : \u2200 r\u2081 r\u2082, doors r\u2081 r\u2082 = doors r\u2082 r\u2081\n  door_adjacent : \u2200 r\u2081 r\u2082, doors r\u2081 r\u2082 \u2192 adjacent r\u2081 r\u2082\n  min_two_doors : \u2200 r, (\u2203 r\u2081 r\u2082, r\u2081 \u2260 r\u2082 \u2227 doors r r\u2081 \u2227 doors r r\u2082)\n\ndef door_count (c : Castle) (room : Fin c.n \u00d7 Fin c.n) : Nat :=\n  (Finset.filter (fun r => c.doors room r) (Finset.univ)).card\n\ntheorem castle_doors_existence (c : Castle) (h : c.n = 9) :\n  \u2203 room, door_count c room \u2265 3 :=\n  sorry", "formal_statement_pred": "import Mathlib\n\nstructure Castle where\n  n : Nat\n  doors : Fin n \u00d7 Fin n \u2192 Fin n \u00d7 Fin n \u2192 Bool\n  adjacent : Fin n \u00d7 Fin n \u2192 Fin n \u00d7 Fin n \u2192 Bool\n\n  door_symm : \u2200 r\u2081 r\u2082, doors r\u2081 r\u2082 = doors r\u2082 r\u2081\n  door_adj : \u2200 r\u2081 r\u2082, doors r\u2081 r\u2082 \u2192 adjacent r\u2081 r\u2082\n\ndef doorCount (c : Castle) (room : Fin c.n \u00d7 Fin c.n) : Nat :=\n  (Finset.filter (fun r => c.doors room r) (Finset.univ)).card\n\ntheorem castle_doors_existence (c : Castle) (h\u2081 : c.n = 9)\n    (h\u2082 : \u2200 room, doorCount c room \u2265 2) :\n    \u2203 room, doorCount c room \u2265 3 :=\n  sorry", "compiled": true, "aligned": true}
{"id": "CombStruct4Lean_239", "informal_problem": "5. Each of the 777 bankers has several safes. At a meeting, the Chief Oligarch gave each banker N diamonds and ordered them to distribute them among the safes so that each safe contains a different number of diamonds. The Chief Oligarch is certain that this task is feasible. Prove that the bankers can keep no more than two safes (and destroy the rest) so that the Chief Oligarch's task remains feasible (with the same value of N).\n\n#", "formal_statement": "import Mathlib\n\nstructure Banker where\n  safes : Finset \u2115  -- Set of numbers representing diamonds in each safe\n  total : \u2115        -- Total number of diamonds (N)\n  valid : (\u2211 n in safes, n) = total  -- Sum of diamonds equals N\n\ntheorem bankers_two_safes_sufficient \n  (bankers : Fin 777 \u2192 Banker)  -- 777 bankers\n  (h_valid : \u2200 b, (bankers b).safes.toSet.Pairwise (\u00b7\u2260\u00b7)) -- Different numbers in safes\n  : \u2203 (new_bankers : Fin 777 \u2192 Banker),\n    (\u2200 b, (new_bankers b).total = (bankers b).total) \u2227     -- Same N for each banker\n    (\u2200 b, (new_bankers b).safes.card \u2264 2) \u2227                -- At most 2 safes each\n    (\u2200 b, (new_bankers b).safes.toSet.Pairwise (\u00b7\u2260\u00b7))      -- Still different numbers\n  := sorry", "formal_statement_pred": "import Mathlib\n\nstructure DiamondDistribution where\n  total : \u2115\n  safes : Finset \u2115\n  valid : \u2200 (x y : \u2115), x \u2208 safes \u2192 y \u2208 safes \u2192 x \u2260 y \u2192 x \u2260 y\n  sum_correct : (safes.sum fun x => x) = total\n\n\nstructure BankerSystem where\n  n : \u2115\n  distributions : Fin 777 \u2192 DiamondDistribution\n  all_valid : \u2200 (i : Fin 777), (distributions i).total = n\n\ntheorem reduce_safes (n : \u2115) (sys : BankerSystem) :\n  \u2203 (new_sys : BankerSystem),\n    new_sys.n = sys.n \u2227\n    (\u2200 (i : Fin 777), (new_sys.distributions i).safes.card \u2264 2) :=\n  sorry", "compiled": true, "aligned": true}
{"id": "CombStruct4Lean_240", "informal_problem": "7. At a masquerade ball, there were 20 people. In each dance, two people participated. It turned out that eleven of them danced with three partners, one with five, and the remaining eight with six. Prove that in some dance, people of the same gender participated.", "formal_statement": "import Mathlib\n\nstructure Dance where\n  person1 : Fin 20\n  person2 : Fin 20\n  different : person1 \u2260 person2\n\nstructure BallData where\n  dances : List Dance\n  gender : Fin 20 \u2192 Bool  -- True for one gender, False for the other\n  partners : Fin 20 \u2192 Finset (Fin 20)\n  -- Properties about the number of partners\n  eleven_three : \u2203 people : Finset (Fin 20), \n    people.card = 11 \u2227 \n    \u2200 p \u2208 people, (partners p).card = 3\n  one_five : \u2203 p : Fin 20, (partners p).card = 5\n  eight_six : \u2203 people : Finset (Fin 20),\n    people.card = 8 \u2227\n    \u2200 p \u2208 people, (partners p).card = 6\n\ntheorem masquerade_ball_same_gender \n  (ball : BallData) : \n  \u2203 d : Dance, d \u2208 ball.dances \u2192 ball.gender d.person1 = ball.gender d.person2 :=\n  sorry", "formal_statement_pred": "import Mathlib\n\nstructure Dance where\n  person1 : Fin 20\n  person2 : Fin 20\n  different : person1 \u2260 person2\n\nstructure DanceConfiguration where\n  dances : List Dance\n  gender : Fin 20 \u2192 Bool\n  partners : Fin 20 \u2192 Finset (Fin 20)\n\n  valid_partners : \u2200 i, (partners i).card =\n    if i.val < 11 then 3\n    else if i.val = 11 then 5\n    else 6\n  partners_from_dances : \u2200 i j, j \u2208 partners i \u2194\n    \u2203 d \u2208 dances, (d.person1 = i \u2227 d.person2 = j) \u2228 (d.person1 = j \u2227 d.person2 = i)\n\ntheorem masquerade_ball_same_gender :\n  \u2200 (config : DanceConfiguration),\n  \u2203 (d : Dance), d \u2208 config.dances \u2227 config.gender d.person1 = config.gender d.person2 :=\n  sorry", "compiled": true, "aligned": true}
{"id": "CombStruct4Lean_241", "informal_problem": "6. There is a grid table, in which some cells are shaded. \"I can shade 5 more cells in each row,\" said Yakov, \"and then in each column there will be as many shaded cells as there are in each row now.\" \"And I can erase 3 cells in each column,\" Yuri replied, \"and then in each row there will be as many shaded cells as there are in each column now.\" Prove that one of them is wrong.", "formal_statement": "import Mathlib\n\nstructure Grid (m n : Nat) where\n  shaded : Fin m \u00d7 Fin n \u2192 Bool\n\ndef count_row {m n : Nat} (g : Grid m n) (r : Fin m) : Nat :=\n  Finset.card (Finset.filter (fun c => g.shaded (r, c)) (Finset.univ))\n\ndef count_col {m n : Nat} (g : Grid m n) (c : Fin n) : Nat :=\n  Finset.card (Finset.filter (fun r => g.shaded (r, c)) (Finset.univ))\n\n/-- A grid obtained by adding k shaded cells to each row -/\ndef add_to_rows {m n : Nat} (g : Grid m n) (k : Nat) : Grid m n :=\n  { shaded := fun (r, c) => g.shaded (r, c) } -- actual implementation would add k cells\n\n/-- A grid obtained by removing k shaded cells from each column -/\ndef remove_from_cols {m n : Nat} (g : Grid m n) (k : Nat) : Grid m n :=\n  { shaded := fun (r, c) => g.shaded (r, c) } -- actual implementation would remove k cells\n\ntheorem grid_claims_contradiction {m n : Nat} (g : Grid m n) \n  (h_dims : m > 0 \u2227 n > 0) :\n  \u00ac(\n    -- Yakov's claim: Adding 5 to each row makes them equal to current columns\n    (\u2200 (r : Fin m) (c : Fin n),\n      count_row (add_to_rows g 5) r = count_col g c) \u2227\n    -- Yuri's claim: Removing 3 from each column makes them equal to current rows\n    (\u2200 (r : Fin m) (c : Fin n),\n      count_col (remove_from_cols g 3) c = count_row g r)\n  ) :=\n  sorry", "formal_statement_pred": "import Mathlib\n\n\nstructure Grid where\n  rows : Nat\n  cols : Nat\n  shaded : Finset (Nat \u00d7 Nat)\n  valid : \u2200 p \u2208 shaded, p.1 < rows \u2227 p.2 < cols\n\n\ndef countInRow (g : Grid) (row : Nat) : Nat :=\n  (g.shaded.filter (fun p => p.1 = row)).card\n\n\ndef countInCol (g : Grid) (col : Nat) : Nat :=\n  (g.shaded.filter (fun p => p.2 = col)).card\n\n\ntheorem claims_contradiction (g : Grid) (h_rows : g.rows > 0) (h_cols : g.cols > 0) :\n  \u00ac(\n    (\u2200 r < g.rows, \u2200 c < g.cols, countInRow g r + 5 = countInCol g c) \u2227\n    (\u2200 r < g.rows, \u2200 c < g.cols, countInCol g c - 3 = countInRow g r)\n  ) :=\n  sorry", "compiled": true, "aligned": true}
{"id": "CombStruct4Lean_242", "informal_problem": "6. There is an unpainted board $101 \\times 201$. The first player has a bucket of yellow paint, the second player has a bucket of blue paint. On each turn, each player can paint a row (horizontal or vertical) with their color. When yellow and blue paints mix, they produce green. Further mixing of green with yellow or blue does not change the color. A player cannot paint a row if that row has already been painted by the opponent, nor can they paint a row if no cell on the board will change color. The player who cannot make a move loses. Who can ensure a win?", "formal_statement": "import Mathlib\n\n/-- The possible colors on the board -/\ninductive Color where\n  | unpainted\n  | yellow\n  | blue\n  | green\n  deriving Inhabited, DecidableEq, Fintype\n\n/-- The players in the game -/\ninductive Player where\n  | first\n  | second\n  deriving Inhabited, DecidableEq, Fintype\n\n/-- Get the color associated with a player -/\ndef Player.color : Player \u2192 Color\n  | first => Color.yellow\n  | second => Color.blue\n\n/-- A move is either a horizontal or vertical line -/\ninductive Move where\n  | horizontal (row : Fin 101)\n  | vertical (col : Fin 201)\n  deriving Inhabited, DecidableEq\n\n/-- The game board represented as a function from positions to colors -/\nstructure Board where\n  cells : Fin 101 \u2192 Fin 201 \u2192 Color\n  deriving Inhabited\n\n/-- The result of mixing two colors -/\ndef mixColors (c1 c2 : Color) : Color :=\n  match c1, c2 with\n  | Color.unpainted, c | c, Color.unpainted => c\n  | Color.yellow, Color.blue | Color.blue, Color.yellow => Color.green\n  | Color.green, _ | _, Color.green => Color.green\n  | c1, c2 => if c1 = c2 then c1 else c2\n\n/-- Apply a move to the board -/\ndef applyMove (b : Board) (m : Move) (p : Player) : Board :=\n  let color := p.color\n  match m with\n  | Move.horizontal row =>\n    \u27e8fun r c => if r = row then mixColors (b.cells r c) color else b.cells r c\u27e9\n  | Move.vertical col =>\n    \u27e8fun r c => if c = col then mixColors (b.cells r c) color else b.cells r c\u27e9\n\n/-- Check if a move is valid -/\ndef isValidMove (b : Board) (m : Move) (p : Player) : Prop :=\n  let newBoard := applyMove b m p\n  let oppColor := match p with\n    | Player.first => Color.blue\n    | Player.second => Color.yellow\n  match m with\n  | Move.horizontal row =>\n    (\u2200 col, b.cells row col \u2260 oppColor) \u2227\n    \u2203 col, newBoard.cells row col \u2260 b.cells row col\n  | Move.vertical col =>\n    (\u2200 row, b.cells row col \u2260 oppColor) \u2227\n    \u2203 row, newBoard.cells row col \u2260 b.cells row col\n\n/-- A game state contains the board, current player, and remaining moves -/\nstructure GameState where\n  board : Board\n  currentPlayer : Player\n  movesLeft : Nat  -- For well-founded recursion\n  deriving Inhabited\n\n/-- A strategy is valid if it produces valid moves when possible -/\ndef ValidStrategy (strategy : GameState \u2192 Move) : Prop :=\n  \u2200 gs : GameState, \n    (\u2203 m, isValidMove gs.board m gs.currentPlayer) \u2192\n    isValidMove gs.board (strategy gs) gs.currentPlayer\n\n/-- A strategy is winning if it leads to opponent having no valid moves -/\ndef WinningStrategy (p : Player) (strategy : GameState \u2192 Move) : Prop :=\n  \u2200 gs : GameState,\n    gs.movesLeft > 0 \u2192\n    gs.currentPlayer = p \u2192\n    \u2203 m, isValidMove gs.board m gs.currentPlayer \u2227\n        \u2200 gs' : GameState,\n          gs'.movesLeft < gs.movesLeft \u2192\n          \u00ac\u2203 m', isValidMove gs'.board m' gs'.currentPlayer\n\n/-- One of the players has a winning strategy -/\ntheorem painting_game_winner_exists :\n  \u2203 (p : Player) (strategy : GameState \u2192 Move),\n    ValidStrategy strategy \u2227 WinningStrategy p strategy :=\n  sorry", "formal_statement_pred": "import Mathlib\n\nstructure Board where\n  rows : Nat\n  cols : Nat\n  state : Fin rows \u2192 Fin cols \u2192 Color\n\ninductive Color where\n  | unpainted\n  | yellow\n  | blue\n  | green\n  deriving Repr, DecidableEq\n\ninductive Move where\n  | horizontal : Fin rows \u2192 Color \u2192 Move\n  | vertical : Fin cols \u2192 Color \u2192 Move\n\ndef applyMove (b : Board) (m : Move) : Board := sorry\n\ndef isValidMove (b : Board) (m : Move) : Bool := sorry\n\ndef hasValidMove (b : Board) (color : Color) : Bool := sorry\n\ndef isWinningPosition (b : Board) (color : Color) : Bool := sorry\n\ntheorem painting_game_winner\n  (init : Board)\n  (h1 : init.rows = 101)\n  (h2 : init.cols = 201)\n  (h3 : \u2200 i j, init.state i j = Color.unpainted) :\n  \u2203 (strategy : Board \u2192 Move),\n    isWinningPosition init Color.yellow :=\n  sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_243", "informal_problem": "6.2. Let $k=4, n=100$ and Pasha moves chips from only two cells (one in each strip) on each turn. Prove that Roma can ensure that no more than 50 chips (including those removed) end up in the last cells of their strips.", "formal_statement": "import Mathlib\nopen Fin Vector\n\nstructure GameState where\n  strip1 : Vector (Fin 100) 4  -- First strip of length 4, each cell containing 0-99 chips\n  strip2 : Vector (Fin 100) 4  -- Second strip of length 4\n  removed : Fin 100           -- Number of chips removed from game\n  h_total : (strip1.toList.map Fin.val).sum + \n            (strip2.toList.map Fin.val).sum + \n            removed.val = 100\n\nstructure Move where\n  from1 : Fin 4     -- Position in first strip to move from\n  from2 : Fin 4     -- Position in second strip to move from\n  amount : Nat      -- Number of chips to move\n  h_valid : amount > 0\n\n/-- Checks if a move is valid in the current game state -/\ndef isValidMove (state : GameState) (move : Move) : Prop :=\n  -- Enough chips in source positions\n  move.amount \u2264 (state.strip1.get move.from1).val \u2227\n  move.amount \u2264 (state.strip2.get move.from2).val\n\n/-- Returns the final position chips count (including removed) after a sequence of moves -/\ndef finalChipsCount (state : GameState) : Nat :=\n  (state.strip1.get \u27e83, by simp\u27e9).val +\n  (state.strip2.get \u27e83, by simp\u27e9).val +\n  state.removed.val\n\ntheorem roma_winning_strategy :\n  \u2203 (strategy : GameState \u2192 Move \u2192 Move),\n    \u2200 (state : GameState) (pasha_move : Move),\n    isValidMove state pasha_move \u2192\n    \u2200 (next_state : GameState),\n    finalChipsCount next_state \u2264 50 :=\n  sorry", "formal_statement_pred": "import Mathlib\n\ninductive Player\n  | Pasha\n  | Roma\n\nstructure Move where\n  from1 : Fin 4\n  from2 : Fin 4\n  amount1 : Nat\n  amount2 : Nat\n\nstructure GameState where\n  strip1 : Fin 4 \u2192 Nat\n  strip2 : Fin 4 \u2192 Nat\n  removed : Nat\n  turn : Player\n\ndef initial_state : GameState where\n  strip1 := \u03bb _ => 100\n  strip2 := \u03bb _ => 100\n  removed := 0\n  turn := Player.Pasha\n\ndef is_valid_pasha_move (state : GameState) (move : Move) : Prop :=\n  move.amount1 > 0 \u2227\n  move.amount2 > 0 \u2227\n  move.amount1 \u2264 state.strip1 move.from1 \u2227\n  move.amount2 \u2264 state.strip2 move.from2\n\ndef apply_move (state : GameState) (move : Move) : GameState :=\n  { strip1 := \u03bb i =>\n      if i = move.from1 then state.strip1 i - move.amount1\n      else if i.val = move.from1.val + 1 then state.strip1 i + move.amount1\n      else state.strip1 i,\n    strip2 := \u03bb i =>\n      if i = move.from2 then state.strip2 i - move.amount2\n      else if i.val = move.from2.val + 1 then state.strip2 i + move.amount2\n      else state.strip2 i,\n    removed := state.removed +\n      (if move.from1.val = 3 then move.amount1 else 0) +\n      (if move.from2.val = 3 then move.amount2 else 0),\n    turn := match state.turn with\n      | Player.Pasha => Player.Roma\n      | Player.Roma => Player.Pasha }\n\ntheorem roma_winning_strategy :\n  \u2203 (roma_strategy : GameState \u2192 Move \u2192 Move),\n    \u2200 (state : GameState),\n    state.turn = Player.Roma \u2192\n    \u2200 (pasha_move : Move),\n    is_valid_pasha_move state pasha_move \u2192\n    let final_state := apply_move (apply_move state pasha_move) (roma_strategy state pasha_move)\n    final_state.strip1 3 + final_state.strip2 3 + final_state.removed \u2264 50 :=\n  sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_245", "informal_problem": "6. At the tournament, there were 1000 volleyball teams, some of which played one match against each other. Each team had an equal number of wins and losses (there are no draws in volleyball). It is known that if team A won against team B, then A also won against all the teams that B did not play against. Prove that some team played at least 800 matches.", "formal_statement": "import Mathlib\n\nstructure Tournament (n : Nat) [Fintype (Fin n)] where\n  played : Finset (Fin n \u00d7 Fin n)\n  won : Finset (Fin n \u00d7 Fin n)\n  no_draw : \u2200 i j, (i, j) \u2208 played \u2192 ((i, j) \u2208 won \u2194 (j, i) \u2209 won)\n  equal_record : \u2200 i, \n    (won.filter (fun p => p.1 = i)).card = \n    (won.filter (fun p => p.2 = i)).card\n  transitive_property : \u2200 i j k, \n    (i, j) \u2208 won \u2192 (j, k) \u2209 played \u2192 (i, k) \u2208 won\n\ntheorem tournament_bound (n : Nat) [Fintype (Fin n)] (h : n = 1000) \n  (t : Tournament n) : \n  \u2203 i : Fin n, (t.played.filter (fun p => p.1 = i \u2228 p.2 = i)).card \u2265 800 :=\n  sorry", "formal_statement_pred": "import Mathlib\n\nstructure Tournament {n : Nat} where\n  played : Fin n \u2192 Fin n \u2192 Bool\n  won : Fin n \u2192 Fin n \u2192 Bool\n  h_played_symm : \u2200 i j, played i j = played j i\n  h_won_antisymm : \u2200 i j, won i j \u2192 won j i = false\n  h_played_won : \u2200 i j, won i j \u2192 played i j\n  h_no_self_play : \u2200 i, played i i = false\n  h_win_exclusive : \u2200 i j, played i j \u2192 (won i j \u2228 won j i)\n  h_equal_wins_losses : \u2200 i,\n    (Finset.card (Finset.filter (fun j => won i j) (Finset.univ))) =\n    (Finset.card (Finset.filter (fun j => won j i) (Finset.univ)))\n  h_transitive_property : \u2200 i j k,\n    won i j \u2192 \u00acplayed j k \u2192 won i k\n\ntheorem tournament_matches_bound {n : Nat} (t : Tournament) (h : n = 1000) :\n  \u2203 i : Fin n, Finset.card (Finset.filter (fun j => t.played i j) (Finset.univ)) \u2265 800 :=\n  sorry", "compiled": true, "aligned": true}
{"id": "CombStruct4Lean_246", "informal_problem": "7. 22 football players played three training matches (each time they were divided into two teams of 11 players). Prove that some two players played on different teams all three times.", "formal_statement": "import Mathlib\n\n/-- A match consists of two teams of players -/\nstructure Match where\n  team1 : Finset (Fin 22)\n  team2 : Finset (Fin 22)\n\n/-- A match is valid if teams have 11 players each, are disjoint, and contain all players -/\ndef IsValidMatch (m : Match) : Prop :=\n  m.team1.card = 11 \u2227 \n  m.team2.card = 11 \u2227 \n  m.team1 \u2229 m.team2 = \u2205 \u2227 \n  m.team1 \u222a m.team2 = Finset.univ\n\n/-- Three matches form a valid tournament if each match is valid -/\ndef ValidTournament (m1 m2 m3 : Match) : Prop :=\n  IsValidMatch m1 \u2227 IsValidMatch m2 \u2227 IsValidMatch m3\n\n/-- Two players are always opponents if in every match they play on opposite teams -/\ndef AlwaysOpponents (p1 p2 : Fin 22) (m1 m2 m3 : Match) : Prop :=\n  (p1 \u2208 m1.team1 \u2192 p2 \u2208 m1.team2) \u2227 (p1 \u2208 m1.team2 \u2192 p2 \u2208 m1.team1) \u2227\n  (p1 \u2208 m2.team1 \u2192 p2 \u2208 m2.team2) \u2227 (p1 \u2208 m2.team2 \u2192 p2 \u2208 m2.team1) \u2227\n  (p1 \u2208 m3.team1 \u2192 p2 \u2208 m3.team2) \u2227 (p1 \u2208 m3.team2 \u2192 p2 \u2208 m3.team1)\n\ntheorem football_opponents : \n  \u2200 (m1 m2 m3 : Match), ValidTournament m1 m2 m3 \u2192\n  \u2203 (p1 p2 : Fin 22), p1 \u2260 p2 \u2227 AlwaysOpponents p1 p2 m1 m2 m3 :=\n  sorry", "formal_statement_pred": "import Mathlib\n\nstructure Match where\n  team1 : Finset (Fin 22)\n  team2 : Finset (Fin 22)\n\ndef Match.isValid (m : Match) : Prop :=\n  m.team1.card = 11 \u2227\n  m.team2.card = 11 \u2227\n  m.team1 \u2229 m.team2 = \u2205 \u2227\n  m.team1 \u222a m.team2 = Finset.univ\n\ndef ValidTournament (m1 m2 m3 : Match) : Prop :=\n  m1.isValid \u2227 m2.isValid \u2227 m3.isValid\n\ndef AlwaysOpponents (p1 p2 : Fin 22) (m1 m2 m3 : Match) : Prop :=\n  (p1 \u2208 m1.team1 \u2194 p2 \u2208 m1.team2) \u2227\n  (p1 \u2208 m2.team1 \u2194 p2 \u2208 m2.team2) \u2227\n  (p1 \u2208 m3.team1 \u2194 p2 \u2208 m3.team2)\n\ntheorem football_opponents :\n  \u2200 (m1 m2 m3 : Match), ValidTournament m1 m2 m3 \u2192\n  \u2203 (p1 p2 : Fin 22), p1 \u2260 p2 \u2227 AlwaysOpponents p1 p2 m1 m2 m3 :=\n  sorry", "compiled": true, "aligned": true}
{"id": "CombStruct4Lean_247", "informal_problem": "8. In the foggy city of London, there are exactly $10^{10}$ clubs, and in each club, there are exactly 10 gentlemen. An enemy spy wants to kidnap several gentlemen so that among the kidnapped, there is at least one member of each club. It turns out that for any two clubs, there is a gentleman who is a member of both. Prove that the spy needs to kidnap only 9 gentlemen.", "formal_statement": "import Mathlib\n\nstructure LondonClubs where\n  -- The set of all gentlemen\n  gentlemen : Finset Nat\n  -- Club membership function: maps each club to its set of members\n  members : Fin (10^10) \u2192 Finset Nat\n  -- Each club has exactly 10 members\n  mem_size : \u2200 c, (members c).card = 10\n  -- Each club's members are a subset of all gentlemen\n  mem_subset : \u2200 c, members c \u2286 gentlemen\n  -- Any two clubs share at least one member\n  shared_mem : \u2200 (c\u2081 c\u2082 : Fin (10^10)), \n    \u2203 g \u2208 gentlemen, g \u2208 members c\u2081 \u2227 g \u2208 members c\u2082\n\ntheorem london_clubs_min_kidnap (L : LondonClubs) :\n  \u2203 (S : Finset Nat), \n    S.card = 9 \u2227 \n    S \u2286 L.gentlemen \u2227\n    \u2200 c, \u2203 g \u2208 S, g \u2208 L.members c :=\n  sorry", "formal_statement_pred": "import Mathlib\n\nstructure LondonClubs where\n  gentlemen : Finset Nat\n  clubs : Finset (Finset Nat)\n  clubs_subset : \u2200 c \u2208 clubs, c \u2286 gentlemen\n  club_size : \u2200 c \u2208 clubs, c.card = 10\n  total_clubs : clubs.card = 10^10\n  intersect : \u2200 c\u2081 c\u2082, c\u2081 \u2208 clubs \u2192 c\u2082 \u2208 clubs \u2192 c\u2081 \u2260 c\u2082 \u2192\n    \u2203 x, x \u2208 c\u2081 \u2229 c\u2082\n\ntheorem london_clubs_spy (L : LondonClubs) :\n  \u2203 S : Finset Nat, S.card = 9 \u2227 \u2200 c \u2208 L.clubs, (S \u2229 c).Nonempty :=\n  sorry", "compiled": true, "aligned": true}
{"id": "CombStruct4Lean_248", "informal_problem": "9.3. From 60 numbers $1,2, \\ldots, 60$, 25 numbers were chosen. It is known that the sum of any two of the chosen numbers is not equal to 60. Prove that among the chosen numbers, there are multiples of five.", "formal_statement": "import Mathlib\n\nstructure NumberSelection where\n  numbers : Finset \u2115\n  size_is_25 : numbers.card = 25\n  all_in_range : \u2200 n \u2208 numbers, 0 < n \u2227 n \u2264 60\n  no_sum_60 : \u2200 (a : \u2115) (ha : a \u2208 numbers) (b : \u2115) (hb : b \u2208 numbers), a + b \u2260 60\n\ntheorem exists_multiple_of_five (sel : NumberSelection) : \n  \u2203 n \u2208 sel.numbers, 5 \u2223 n := sorry", "formal_statement_pred": "import Mathlib\n\nopen Finset\n\nstructure NumberSelection where\n  numbers : Finset (Fin 61)\n  size_is_25 : numbers.card = 25\n  elements_nonzero : \u2200 n \u2208 numbers, n.val \u2260 0\n  distinct_elements : numbers.card = numbers.toSet.toFinset.card\n  no_sum_60 : \u2200 a b, a \u2208 numbers \u2227 b \u2208 numbers \u2192 a.val + b.val \u2260 60\n\ntheorem exists_multiple_of_five (selection : NumberSelection) :\n  \u2203 n, n \u2208 selection.numbers \u2227 5 \u2223 n.val :=\n  sorry", "compiled": true, "aligned": true}
{"id": "CombStruct4Lean_249", "informal_problem": "8.4. In grade 8, there are 30 people, among them 22 attend the French language club, 21 - the German language club, and 18 - the Chinese language club. Prove that there is a student in the class who attends all three clubs.", "formal_statement": "import Mathlib\n\n\n\ntheorem exists_student_in_all_clubs \n  (french german chinese : Finset (Fin 30))\n  (hf : french.card = 22)\n  (hg : german.card = 21)\n  (hc : chinese.card = 18) :\n  \u2203 i : Fin 30, i \u2208 french \u2229 german \u2229 chinese :=\n  sorry", "formal_statement_pred": "import Mathlib\n\nstructure LanguageClubs where\n  totalStudents : Nat\n  frenchClub : Finset Nat\n  germanClub : Finset Nat\n  chineseClub : Finset Nat\n  total_size : totalStudents = 30\n  french_size : frenchClub.card = 22\n  german_size : germanClub.card = 21\n  chinese_size : chineseClub.card = 18\n  valid_range : \u2200 s, s \u2208 frenchClub \u222a germanClub \u222a chineseClub \u2192\n                    0 \u2264 s \u2227 s < totalStudents\n\ntheorem exists_student_in_all_clubs (clubs : LanguageClubs) :\n  \u2203 s, s \u2208 clubs.frenchClub \u2229 clubs.germanClub \u2229 clubs.chineseClub :=\n  sorry", "compiled": true, "aligned": true}
{"id": "CombStruct4Lean_251", "informal_problem": "7.5. In the company, 11 people gathered. It turned out that each person is friends with at least six of those present. Prove that in this company, there will be three friends (each is friends with the other two).", "formal_statement": "import Mathlib\nimport Mathlib.Combinatorics.SimpleGraph.Basic\n\nstructure FriendshipGraph where\n  n : Nat\n  friends : Fin n \u2192 Fin n \u2192 Bool\n  symm : \u2200 i j, friends i j = friends j i\n  no_self : \u2200 i, friends i i = false\n\ndef friendCount (g : FriendshipGraph) (i : Fin g.n) : Nat :=\n  (Finset.univ.filter (fun j => g.friends i j)).card\n\ndef hasTriangle (g : FriendshipGraph) (i j k : Fin g.n) : Bool :=\n  i \u2260 j \u2227 j \u2260 k \u2227 i \u2260 k \u2227 \n  g.friends i j \u2227 g.friends j k \u2227 g.friends i k\n\ntheorem friendship_triangle (g : FriendshipGraph) \n  (h1 : g.n = 11)  -- there are 11 people\n  (h2 : \u2200 i : Fin g.n, friendCount g i \u2265 6)  -- each person has at least 6 friends\n  : \u2203 (i j k : Fin g.n), hasTriangle g i j k = true :=\n  sorry", "formal_statement_pred": "import Mathlib\n\nstructure FriendshipGraph where\n  n : Nat\n  friendship : Fin n \u2192 Fin n \u2192 Bool\n  symm : \u2200 i j, friendship i j = friendship j i\n  no_self : \u2200 i, friendship i i = false\n  min_friends : \u2200 i, (((List.range n).filter\n    (fun j \u21a6 friendship i \u27e8j, sorry\u27e9)).length) \u2265 6\n\ntheorem friendship_triangle (g : FriendshipGraph) (h : g.n = 11) :\n  \u2203 (i j k : Fin g.n), i \u2260 j \u2227 j \u2260 k \u2227 i \u2260 k \u2227\n    g.friendship i j \u2227 g.friendship j k \u2227 g.friendship i k :=\n  sorry", "compiled": true, "aligned": true}
{"id": "CombStruct4Lean_254", "informal_problem": "7.4 In a box, there are 25 colored pencils. It is known that among any five pencils, there will be at least two pencils of the same color. Prove that there are 7 pencils of the same color in the box.", "formal_statement": "import Mathlib\n\nstructure ColoredPencils where\n  num_colors : Nat  -- number of possible colors\n  colors : Fin 25 \u2192 Fin num_colors  -- maps each pencil to a finite color\n  pigeonhole_five : \u2200 (s : Finset (Fin 25)), s.card = 5 \u2192 \n    \u2203 (c : Fin num_colors) (i j : Fin 25), \n      i \u2208 s \u2227 j \u2208 s \u2227 i \u2260 j \u2227 colors i = colors j\n\ntheorem colored_pencils_seven \n  (box : ColoredPencils) : \n  \u2203 (c : Fin box.num_colors), \n    (Finset.filter (fun i => box.colors i = c) (Finset.univ : Finset (Fin 25))).card = 7 :=\n  sorry", "formal_statement_pred": "import Mathlib\n\nstructure ColoredPencils where\n  n : Nat\n  k : Nat\n  colorOf : Fin n \u2192 Fin k\n  pigeonhole_five : \u2200 (s : Finset (Fin n)), s.card = 5 \u2192\n    \u2203 (c : Fin k), \u2203 (s' : Finset (Fin n)), s' \u2286 s \u2227 s'.card = 2 \u2227\n      \u2200 i \u2208 s', colorOf i = c\n  deriving Repr\n\ntheorem pencil_color_bound (p : ColoredPencils) (h1 : p.n = 25) :\n  \u2203 (c : Fin p.k), (Finset.filter (fun i => p.colorOf i = c) (Finset.univ)).card \u2265 7 :=\n  sorry", "compiled": true, "aligned": true}
{"id": "CombStruct4Lean_256", "informal_problem": "7.3. Can the 200 consecutive numbers: $1,2, \\ldots, 200$ be rearranged so that adjacent numbers differ by either 3 or $5?$", "formal_statement": "import Mathlib\n\n/-- Absolute difference between two natural numbers -/\ndef natAbsDiff (a b : \u2115) : \u2115 := \n  max a b - min a b\n\n/-- Predicate for valid differences (3 or 5) -/\ndef isValidDiff (n : \u2115) : Prop := n = 3 \u2228 n = 5\n\n/-- Predicate for whether a permutation of numbers 1..200 has valid differences -/\ndef isValidArrangement (p : Equiv.Perm (Fin 201)) : Prop :=\n  \u2200 i : Fin 200, \n    let n1 := (p i).val + 1\n    let n2 := (p (Fin.succ i)).val + 1\n    isValidDiff (natAbsDiff n1 n2)\n\ntheorem exists_valid_arrangement_200 : \n  \u2203 p : Equiv.Perm (Fin 201), isValidArrangement p :=\n  sorry", "formal_statement_pred": "import Mathlib\n\ndef ConsecutiveRange : Finset \u2124 :=\n  Finset.image Int.ofNat (Finset.Icc 1 200)\n\ndef ValidDifference (a b : \u2124) : Prop :=\n  abs (a - b) \u2208 ({3, 5} : Finset \u2124)\n\ndef HasValidLength (arr : List \u2124) : Prop :=\n  arr.length = 200\n\ndef ContainsRange (arr : List \u2124) : Prop :=\n  \u2200 n \u2208 arr, n \u2208 ConsecutiveRange\n\ndef IsValidArrangement (arr : List \u2124) : Prop :=\n  HasValidLength arr\n  \u2227 arr.Nodup\n  \u2227 ContainsRange arr\n  \u2227 List.Pairwise ValidDifference arr\n\ntheorem consecutive_numbers_arrangement :\n  \u2203 (arr : List \u2124), IsValidArrangement arr :=\n  sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_257", "informal_problem": "7.5. Kolya placed 17 kings on a chessboard. Petya must remove 12 kings from the board so that the remaining 5 kings do not attack each other. Can he always do this? (A king attacks all squares adjacent to its square, either by side or corner.)", "formal_statement": "import Mathlib\n\nopen Finset\n\nabbrev File := Fin 8\nabbrev Rank := Fin 8\n\nstructure ChessPosition where\n  file : File\n  rank : Rank\n\ndef is_adjacent (p\u2081 p\u2082 : ChessPosition) : Prop :=\n  let row_diff := max p\u2081.rank.val p\u2082.rank.val - min p\u2081.rank.val p\u2082.rank.val\n  let col_diff := max p\u2081.file.val p\u2082.file.val - min p\u2081.file.val p\u2082.file.val\n  row_diff \u2264 1 \u2227 col_diff \u2264 1 \u2227 \u00ac(p\u2081.rank = p\u2082.rank \u2227 p\u2081.file = p\u2082.file)\n\ndef are_non_attacking (kings : Finset ChessPosition) : Prop :=\n  \u2200 k\u2081 \u2208 kings, \u2200 k\u2082 \u2208 kings, k\u2081 \u2260 k\u2082 \u2192 \u00acis_adjacent k\u2081 k\u2082\n\ndef is_valid_placement (kings : Finset ChessPosition) : Prop :=\n  kings.card \u2264 64 \u2227 are_non_attacking kings\n\ntheorem kings_removal_possible \n  (initial_kings : Finset ChessPosition) \n  (h\u2081 : initial_kings.card = 17) :\n  \u2203 (remaining_kings : Finset ChessPosition),\n    remaining_kings.card = 5 \u2227 \n    remaining_kings \u2286 initial_kings \u2227\n    are_non_attacking remaining_kings :=\n  sorry", "formal_statement_pred": "import Mathlib\n\nstructure ChessPosition where\n  row : Fin 8\n  col : Fin 8\n\ndef chebyshev_distance (p1 p2 : ChessPosition) : \u2115 :=\n  Nat.max (Int.natAbs (p1.row.val - p2.row.val)) (Int.natAbs (p1.col.val - p2.col.val))\n\nstructure KingPlacement where\n  kings : Finset ChessPosition\n  size_eq : kings.card = 17\n\ntheorem kings_removal_possible (initial : KingPlacement) :\n  \u2203 (remaining : Finset ChessPosition),\n    remaining \u2286 initial.kings \u2227\n    remaining.card = 5 \u2227\n    \u2200 k1 k2 : ChessPosition, k1 \u2208 remaining \u2192 k2 \u2208 remaining \u2192 k1 \u2260 k2 \u2192\n      chebyshev_distance k1 k2 > 1 :=\n  sorry", "compiled": true, "aligned": true}
{"id": "CombStruct4Lean_258", "informal_problem": "10.2. On a chessboard, 8 rooks were placed so that they do not attack each other. Prove that in any rectangular cell area of size $4 \\times 5$ (cells) there is at least one rook.", "formal_statement": "import Mathlib\n\n/-- A valid rook placement on an 8\u00d78 chessboard -/\nstructure ChessBoard where\n  rooks : Finset (Fin 8 \u00d7 Fin 8)\n  nonAttacking : \u2200 (r\u2081 r\u2082 : Fin 8 \u00d7 Fin 8), r\u2081 \u2208 rooks \u2192 r\u2082 \u2208 rooks \u2192 r\u2081 \u2260 r\u2082 \u2192 \n    (Prod.fst r\u2081 \u2260 Prod.fst r\u2082) \u2227 (Prod.snd r\u2081 \u2260 Prod.snd r\u2082)\n  exactlyEight : rooks.card = 8\n\n/-- A 4\u00d75 rectangular area on the chessboard -/\nstructure RectArea where\n  startRow : Fin 8\n  startCol : Fin 8\n  valid : startRow + 4 \u2264 8 \u2227 startCol + 5 \u2264 8\n\n/-- Checks if a position is within the given rectangular area -/\ndef inRectArea (pos : Fin 8 \u00d7 Fin 8) (area : RectArea) : Prop :=\n  let (row, col) := pos\n  row \u2265 area.startRow \u2227 row < area.startRow + 4 \u2227\n  col \u2265 area.startCol \u2227 col < area.startCol + 5\n\ntheorem rook_in_rect_area (board : ChessBoard) (area : RectArea) :\n  \u2203 pos \u2208 board.rooks, inRectArea pos area :=\n  sorry", "formal_statement_pred": "import Mathlib\n\nopen Fin\n\nstructure Position where\n  row : Fin 8\n  col : Fin 8\n\ndef attacks (p1 p2 : Position) : Prop :=\n  p1.row = p2.row \u2228 p1.col = p2.col\n\nstructure Rectangle where\n  top_row : Fin 5\n  top_col : Fin 4\n\ndef inRectangle (p : Position) (r : Rectangle) : Prop :=\n  (r.top_row.val : \u2115) \u2264 p.row.val \u2227 p.row.val < (r.top_row.val : \u2115) + 4 \u2227\n  (r.top_col.val : \u2115) \u2264 p.col.val \u2227 p.col.val < (r.top_col.val : \u2115) + 5\n\nstructure ValidRookPlacement where\n  rooks : Finset Position\n  size_eight : rooks.card = 8\n  non_attacking : \u2200 r1 \u2208 rooks, \u2200 r2 \u2208 rooks, r1 \u2260 r2 \u2192 \u00acattacks r1 r2\n\ntheorem rook_in_rectangle (board : ValidRookPlacement) (rect : Rectangle) :\n  \u2203 pos \u2208 board.rooks, inRectangle pos rect := sorry", "compiled": true, "aligned": true}
{"id": "CombStruct4Lean_259", "informal_problem": "# Task 8. (16 points)\n\nIn a class, there are 14 girls. Each of them found out how many girls in the class have the same first name as her, and how many have the same last name, and wrote down two numbers on the board. It turned out that among the numbers on the board, all numbers from 0 to 6 are present. Prove that there will be two girls in the class who have both the same first name and the same last name.\n\n#", "formal_statement": "import Mathlib\n\nstructure Student where\n  firstName : String\n  lastName : String\nderiving DecidableEq\n\ndef countMatchingFirstNames (s : Student) (students : Finset Student) : Nat :=\n  (students.filter (fun t => t.firstName = s.firstName \u2227 t \u2260 s)).card\n\ndef countMatchingLastNames (s : Student) (students : Finset Student) : Nat :=\n  (students.filter (fun t => t.lastName = s.lastName \u2227 t \u2260 s)).card\n\nstructure ClassData where\n  students : Finset Student\n  size_eq : students.card = 14\n  -- For each student, their name counts are determined by actual matches\n  first_count_def : \u2200 (s : Student), s \u2208 students \u2192 \n    countMatchingFirstNames s students \u2264 6\n  last_count_def : \u2200 (s : Student), s \u2208 students \u2192 \n    countMatchingLastNames s students \u2264 6\n  -- All numbers from 0 to 6 appear in the actual counts\n  all_counts_appear : \u2200 n : Nat, n \u2264 6 \u2192 \n    (\u2203 s : Student, s \u2208 students \u2227 countMatchingFirstNames s students = n) \u2228\n    (\u2203 s : Student, s \u2208 students \u2227 countMatchingLastNames s students = n)\n\ntheorem pigeonhole_names (c : ClassData) : \n  \u2203 (s\u2081 s\u2082 : Student), s\u2081 \u2208 c.students \u2227 s\u2082 \u2208 c.students \u2227 s\u2081 \u2260 s\u2082 \u2227 \n    s\u2081.firstName = s\u2082.firstName \u2227 \n    s\u2081.lastName = s\u2082.lastName :=\n  sorry", "formal_statement_pred": "import Mathlib\n\nstructure Student where\n  firstName : String\n  lastName : String\n\nstructure ClassData where\n  students : Finset Student\n  size : Nat\n  size_eq : students.card = size\n  is_14 : size = 14\n\ndef firstNameCount (s : Student) (c : ClassData) : Nat :=\n  (c.students.filter (fun x => x.firstName = s.firstName)).card - 1\n\ndef lastNameCount (s : Student) (c : ClassData) : Nat :=\n  (c.students.filter (fun x => x.lastName = s.lastName)).card - 1\n\ndef allCounts (c : ClassData) : Finset Nat :=\n  c.students.image (fun s => firstNameCount s c) \u222a\n  c.students.image (fun s => lastNameCount s c)\n\ntheorem name_collision_exists\n  (c : ClassData)\n  (h_counts : \u2200 n : Nat, n \u2264 6 \u2192 n \u2208 allCounts c) :\n  \u2203 s\u2081 s\u2082 : Student,\n    s\u2081 \u2208 c.students \u2227\n    s\u2082 \u2208 c.students \u2227\n    s\u2081 \u2260 s\u2082 \u2227\n    s\u2081.firstName = s\u2082.firstName \u2227\n    s\u2081.lastName = s\u2082.lastName :=\n  sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_260", "informal_problem": "# Task 7. (14 points)\n\n281 employees from 7 different branches of the company participated in the conference. In every group of six participants, at least two were of the same age. Prove that among all the participants, you can find five of the same age, of the same gender, and from the same branch of the company.", "formal_statement": "import Mathlib\n\ninductive Gender where\n  | male\n  | female\nderiving Repr, DecidableEq, Ord\n\nstructure Participant where\n  age : Fin 150  -- Reasonable upper bound for age\n  gender : Gender\n  branch : Fin 7\nderiving Repr, DecidableEq\n\n/-- A group of participants sharing the same characteristic (age, gender, or branch) -/\nstructure CharacteristicGroup where\n  members : Finset Participant\n  sameAge : \u2200 p q, p \u2208 members \u2192 q \u2208 members \u2192 p.age = q.age\n  sameGender : \u2200 p q, p \u2208 members \u2192 q \u2208 members \u2192 p.gender = q.gender\n  sameBranch : \u2200 p q, p \u2208 members \u2192 q \u2208 members \u2192 p.branch = q.branch\n\n/-- Predicate indicating that two participants share the same age -/\ndef ShareSameAge (p q : Participant) : Prop := p.age = q.age\n\n/-- Predicate indicating that a group has at least two participants of the same age -/\ndef HasTwoSameAge (group : Finset Participant) : Prop :=\n  \u2203 p q, p \u2208 group \u2227 q \u2208 group \u2227 p \u2260 q \u2227 ShareSameAge p q\n\ntheorem conference_pigeonhole \n  (participants : Finset Participant)\n  (total_count : participants.card = 281)\n  (age_property : \u2200 (group : Finset Participant),\n    group \u2286 participants \u2192 group.card = 6 \u2192 HasTwoSameAge group) :\n  \u2203 (same_group : CharacteristicGroup),\n    same_group.members \u2286 participants \u2227 \n    same_group.members.card = 5 :=\n  sorry", "formal_statement_pred": "import Mathlib\n\n\ninductive Gender\n  | Male\n  | Female\n  deriving Repr, DecidableEq\n\n\nstructure Participant where\n  age : Nat\n  gender : Gender\n  branch : Fin 7\n  deriving DecidableEq\n\n\ndef SameCharacteristics (participants : List Participant) : Prop :=\n  \u2200 p q, p \u2208 participants \u2192 q \u2208 participants \u2192\n    p.age = q.age \u2227 p.gender = q.gender \u2227 p.branch = q.branch\n\n\ntheorem conference_same_characteristics\n  (participants : List Participant)\n  (h_count : participants.length = 281)\n  (h_age_pairs : \u2200 (group : List Participant),\n    group \u2286 participants \u2192 group.length = 6 \u2192\n    \u2203 p q, p \u2208 group \u2227 q \u2208 group \u2227 p \u2260 q \u2227 p.age = q.age) :\n  \u2203 (same_group : List Participant),\n    same_group \u2286 participants \u2227\n    same_group.length = 5 \u2227\n    SameCharacteristics same_group :=\n  sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_261", "informal_problem": "Problem 6. Five friends approached a river and found a boat on the shore that could accommodate all five of them. They decided to go for a ride in the boat. Each time, a group of one or several people would cross from one bank to the other. The friends want to organize the ride so that each possible group crosses exactly once. Will they be able to do this?\n\n[9 points] (A. V. Grigalko)", "formal_statement": "import Mathlib\n\n-- A crossing represents a subset of friends crossing the river\nstructure Crossing where\n  participants : Finset (Fin 5)\n\n-- A sequence of crossings represents the entire boat journey\nstructure BoatJourney where\n  crossings : List Crossing\n  \n-- Helper function to check if a list contains all possible subsets exactly once\ndef containsAllSubsetsOnce (journey : BoatJourney) : Prop :=\n  \u2200 s : Finset (Fin 5), \n    (\u2203! i, journey.crossings.get? i = some \u27e8s\u27e9)\n\ntheorem boat_journey_impossible : \n  \u00ac\u2203 (journey : BoatJourney), containsAllSubsetsOnce journey :=\n  sorry", "formal_statement_pred": "import Mathlib\n\nstructure BoatCrossing where\n  n : Nat\n  crossings : List (Set (Fin n))\n  valid : crossings.length = 2^n - 1\n  distinct : crossings.Nodup\n  complete : \u2200 s : Set (Fin n),\n            s \u2260 \u2205 \u2192 s \u2208 crossings\n\ntheorem boat_crossing_impossible : \u00ac\u2203 (b : BoatCrossing), b.n = 5 :=\n  sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_262", "informal_problem": "Problem 6. A row of 100 coins lies on a table, some showing heads and the rest showing tails. In one operation, it is allowed to select seven coins lying at equal intervals (i.e., seven consecutive coins, or seven coins lying every other coin, etc.), and flip all seven coins. Prove that using such operations, it is possible to have all the coins show heads.\n\n$[9$ points] (S.I. Tokarev, A.V. Shapovalov)", "formal_statement": "import Mathlib\n\n-- Represent a row of coins as a function from positions to bool (true = heads)\nstructure CoinRow where\n  coins : Fin 100 \u2192 Bool\n\n-- Define what it means to flip coins at equal intervals\ndef flipCoinsAtInterval (row : CoinRow) (start : Fin 100) (interval : Nat) : CoinRow where\n  coins := fun i => \n    if \u2203 k : Fin 7, i.val = start.val + k.val * interval \u2227 i.val < 100\n    then !row.coins i\n    else row.coins i\n\n-- Define what it means for all coins to show heads\ndef allHeads (row : CoinRow) : Prop :=\n  \u2200 i : Fin 100, row.coins i = true\n\ntheorem coin_flipping_possible :\n  \u2200 (initial : CoinRow),\n  \u2203 (steps : List (Fin 100 \u00d7 Nat)), \n    let final := steps.foldl (fun row (p) => flipCoinsAtInterval row p.1 p.2) initial\n    allHeads final :=\n  sorry", "formal_statement_pred": "import Mathlib\n\n\ndef CoinConfig := Fin 100 \u2192 Bool\n\n\nstructure FlipOperation where\n  start : Fin 100\n  interval : Nat\n  valid : start.val + 6 * interval < 100\n\n\ndef getAffectedPositions (op : FlipOperation) : Fin 7 \u2192 Fin 100 := fun i =>\n  \u27e8op.start.val + i.val * op.interval, by\n    have h1 : i.val < 7 := i.isLt\n    have h2 : op.start.val + 6 * op.interval < 100 := op.valid\n    sorry\u27e9\n\n\ndef applyFlip (config : CoinConfig) (op : FlipOperation) : CoinConfig := fun pos =>\n  if \u2203 i : Fin 7, getAffectedPositions op i = pos\n  then !config pos\n  else config pos\n\ntheorem coin_flip_possible :\n  \u2200 (initial : CoinConfig),\n  \u2203 (flips : List FlipOperation),\n  (flips.foldl applyFlip initial) = fun _ => true :=\n  sorry", "compiled": true, "aligned": true}
{"id": "CombStruct4Lean_264", "informal_problem": "6. Andrei Mikhailovich wrote on the board all possible sequences of length 2022, consisting of 1011 zeros and 1011 ones. Let's call two sequences compatible if they coincide in exactly 4 positions. Prove that Andrei Mikhailovich can divide all the sequences into 20 groups so that no two compatible sequences end up in the same group.\n\n(A. Raigorodsky)", "formal_statement": "import Mathlib\n\n-- Define a binary sequence of length 2022 with exactly 1011 zeros and ones\nstructure BinarySequence where\n  seq : Fin 2022 \u2192 Bool\n  count_ones : (count_true : Fin 2022 \u2192 Bool) = 1011\n  count_zeros : (count_false : Fin 2022 \u2192 Bool) = 1011\n\n-- Define when two sequences are compatible\ndef compatible (s1 s2 : BinarySequence) : Prop :=\n  (\u2203 (positions : Finset (Fin 2022)), \n    positions.card = 4 \u2227 \n    (\u2200 i : Fin 2022, i \u2208 positions \u2194 s1.seq i = s2.seq i))\n\n-- Define a valid grouping as a function from sequences to group numbers\ndef validGrouping (f : BinarySequence \u2192 Fin 20) : Prop :=\n  \u2200 s1 s2 : BinarySequence, \n    compatible s1 s2 \u2192 f s1 \u2260 f s2\n\ntheorem sequence_grouping_exists : \n  \u2203 (f : BinarySequence \u2192 Fin 20), validGrouping f :=\n  sorry", "formal_statement_pred": "import Mathlib\n\n\ndef Sequence := Fin 2022 \u2192 Bool\n\n\ndef isValid (s : Sequence) : Prop :=\n  (Finset.univ.filter (fun i => s i)).card = 1011\n\n\ndef compatible (s\u2081 s\u2082 : Sequence) : Prop :=\n  (Finset.univ.filter (fun i => s\u2081 i = s\u2082 i)).card = 4\n\ntheorem sequence_grouping_exists :\n  \u2203 (groups : Sequence \u2192 Fin 20),\n    \u2200 s\u2081 s\u2082 : Sequence,\n      isValid s\u2081 \u2192 isValid s\u2082 \u2192 compatible s\u2081 s\u2082 \u2192 groups s\u2081 \u2260 groups s\u2082 :=\n  sorry", "compiled": true, "aligned": true}
{"id": "CombStruct4Lean_265", "informal_problem": "Problem 4. Some cells of a $100 \\times 100$ board are painted black. In all rows and columns where there are black cells, their number is odd. In each row where there are black cells, we place a red chip in the middle black cell. In each column where there are black cells, we place a blue chip in the middle black cell. It turns out that all red chips are in different columns, and all blue chips are in different rows. Prove that there will be a cell where both a blue and a red chip are placed.\n\n$(2022-65$ / Frengkin B.)", "formal_statement": "import Mathlib\n\ndef countBlackCells {n : Nat} (row : Fin n \u2192 Bool) : Nat :=\n  Finset.card (Finset.filter (fun i => row i = true) Finset.univ)\n\nstructure BlackBoard where\n  size : Nat\n  cells : Matrix (Fin size) (Fin size) Bool\n  odd_rows_proof : \u2200 i, Odd (countBlackCells (cells i \u00b7))\n  odd_cols_proof : \u2200 j, Odd (countBlackCells (cells \u00b7 j))\n\ndef hasBlackRow (b : BlackBoard) (i : Fin b.size) : Prop := \n  countBlackCells (b.cells i \u00b7) > 0\n\ndef hasBlackCol (b : BlackBoard) (j : Fin b.size) : Prop := \n  countBlackCells (b.cells \u00b7 j) > 0\n\ndef isMiddleBlackCell {n : Nat} (row : Fin n \u2192 Bool) (pos : Fin n) : Prop :=\n  row pos = true \u2227 \n  \u2200 k : Fin n, k \u2260 pos \u2192 \n    (Finset.card (Finset.filter (fun i => row i \u2227 i < k) Finset.univ)) =\n    (Finset.card (Finset.filter (fun i => row i \u2227 i > k) Finset.univ))\n\nstructure ChipPlacement (b : BlackBoard) where\n  red_pos : {i : Fin b.size // hasBlackRow b i} \u2192 Fin b.size\n  blue_pos : {j : Fin b.size // hasBlackCol b j} \u2192 Fin b.size\n  red_middle : \u2200 (i : {i // hasBlackRow b i}), \n    isMiddleBlackCell (b.cells i.val \u00b7) (red_pos i)\n  blue_middle : \u2200 (j : {j // hasBlackCol b j}), \n    isMiddleBlackCell (b.cells \u00b7 j.val) (blue_pos j)\n  red_injective : Function.Injective red_pos\n  blue_injective : Function.Injective blue_pos\n\ntheorem board_has_intersection (b : BlackBoard) (h : b.size = 100) \n    (chips : ChipPlacement b) :\n  \u2203 (i : {i // hasBlackRow b i}) (j : {j // hasBlackCol b j}),\n    chips.red_pos i = j.val \u2227 chips.blue_pos j = i.val :=\n  sorry", "formal_statement_pred": "import Mathlib\n\nstructure Position where\n  row : Fin 100\n  col : Fin 100\n\ndef blackCellsInRow (black : Finset Position) (row : Fin 100) : Finset (Fin 100) :=\n  (black.filter (fun p \u21a6 p.row = row)).image Position.col\n\ndef blackCellsInCol (black : Finset Position) (col : Fin 100) : Finset (Fin 100) :=\n  (black.filter (fun p \u21a6 p.col = col)).image Position.row\n\ndef middleIndex (s : Finset (Fin 100)) (h_odd : Odd s.card) : Fin 100 :=\n  \u27e8(s.card - 1)/2, sorry\u27e9\n\nstructure BlackBoard where\n  black : Finset Position\n  h_rows_odd : \u2200 row, (blackCellsInRow black row).Nonempty \u2192\n               Odd (blackCellsInRow black row).card\n  h_cols_odd : \u2200 col, (blackCellsInCol black col).Nonempty \u2192\n               Odd (blackCellsInCol black col).card\n\nstructure ChipPlacement (board : BlackBoard) where\n  redChips : Finset Position\n  blueChips : Finset Position\n  h_red_valid : \u2200 {p}, p \u2208 redChips \u2192\n    let row := blackCellsInRow board.black p.row\n    \u2203 (h_odd : Odd row.card),\n      p.col = middleIndex row h_odd\n  h_blue_valid : \u2200 {p}, p \u2208 blueChips \u2192\n    let col := blackCellsInCol board.black p.col\n    \u2203 (h_odd : Odd col.card),\n      p.row = middleIndex col h_odd\n  h_red_diff_cols : \u2200 {p\u2081 p\u2082}, p\u2081 \u2208 redChips \u2192 p\u2082 \u2208 redChips \u2192\n                    p\u2081.row \u2260 p\u2082.row \u2192 p\u2081.col \u2260 p\u2082.col\n  h_blue_diff_rows : \u2200 {p\u2081 p\u2082}, p\u2081 \u2208 blueChips \u2192 p\u2082 \u2208 blueChips \u2192\n                     p\u2081.col \u2260 p\u2082.col \u2192 p\u2081.row \u2260 p\u2082.row\n\ntheorem black_cells_middle_intersection (board : BlackBoard) (chips : ChipPlacement board) :\n  \u2203 p : Position, p \u2208 chips.redChips \u2227 p \u2208 chips.blueChips :=\n  sorry", "compiled": true, "aligned": true}
{"id": "CombStruct4Lean_266", "informal_problem": "Problem 4. Each point on the plane is painted in one of three colors. Is it necessarily true that there exists a triangle of area 1, all vertices of which have the same color?", "formal_statement": "import Mathlib\n\nstructure ColoredPlane where\n  coloring : \u211d \u00d7 \u211d \u2192 Fin 3  -- Maps each point to one of three colors (0, 1, or 2)\n\ndef hasMonochromaticTriangleArea1 (plane : ColoredPlane) : Prop :=\n  \u2203 (p\u2081 p\u2082 p\u2083 : \u211d \u00d7 \u211d),\n    -- All points have the same color\n    plane.coloring p\u2081 = plane.coloring p\u2082 \u2227\n    plane.coloring p\u2082 = plane.coloring p\u2083 \u2227\n    -- Area of triangle is 1\n    abs ((p\u2081.1 * (p\u2082.2 - p\u2083.2) + p\u2082.1 * (p\u2083.2 - p\u2081.2) + p\u2083.1 * (p\u2081.2 - p\u2082.2)) / 2) = 1\n\ntheorem exists_monochromatic_triangle_area1 :\n  \u2200 (plane : ColoredPlane), hasMonochromaticTriangleArea1 plane :=\n  sorry", "formal_statement_pred": "import Mathlib\n\nstructure ColoredPlane where\n  coloring : \u211d \u00d7 \u211d \u2192 Fin 3\n\ndef hasMonochromaticTriangleArea1 (plane : ColoredPlane) : Prop :=\n  \u2203 (p\u2081 p\u2082 p\u2083 : \u211d \u00d7 \u211d),\n\n    plane.coloring p\u2081 = plane.coloring p\u2082 \u2227\n    plane.coloring p\u2082 = plane.coloring p\u2083 \u2227\n\n    abs ((p\u2081.1 * (p\u2082.2 - p\u2083.2) + p\u2082.1 * (p\u2083.2 - p\u2081.2) + p\u2083.1 * (p\u2081.2 - p\u2082.2)) / 2) = 1\n\ntheorem exists_monochromatic_triangle_area1 :\n  \u2203 (plane : ColoredPlane), \u00achasMonochromaticTriangleArea1 plane :=\n  sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_267", "informal_problem": "15.31. A rectangular parallelepiped of size $2 l \\times 2 m \\times 2 n$ is cut into cubes with a side of 1, and each of these cubes is painted in one of 8 colors, with any two cubes that share at least one vertex being painted in different colors. Prove that all corner cubes are painted in different colors.\n\n## \u00a7 4. Lone Problems", "formal_statement": "import Mathlib\n\n/-- A cube in 3D space with integer coordinates -/\nstructure Cube where\n  x : Nat\n  y : Nat\n  z : Nat\n\n/-- Determines if a cube's coordinates are within the bounds of a parallelepiped -/\ndef Cube.inBounds (c : Cube) (l m n : Nat) : Prop :=\n  c.x < 2*l \u2227 c.y < 2*m \u2227 c.z < 2*n\n\n/-- Determines if a cube is at a corner of the parallelepiped -/\ndef Cube.isCorner (c : Cube) (l m n : Nat) : Prop :=\n  (c.x = 0 \u2228 c.x = 2*l - 1) \u2227\n  (c.y = 0 \u2228 c.y = 2*m - 1) \u2227\n  (c.z = 0 \u2228 c.z = 2*n - 1)\n\n/-- Determines if two cubes share at least one vertex -/\ndef Cube.shareVertex (c\u2081 c\u2082 : Cube) : Prop :=\n  let dx := Int.natAbs (Int.ofNat c\u2081.x - Int.ofNat c\u2082.x)\n  let dy := Int.natAbs (Int.ofNat c\u2081.y - Int.ofNat c\u2082.y)\n  let dz := Int.natAbs (Int.ofNat c\u2081.z - Int.ofNat c\u2082.z)\n  dx \u2264 1 \u2227 dy \u2264 1 \u2227 dz \u2264 1 \u2227 \u00ac(dx = 0 \u2227 dy = 0 \u2227 dz = 0)\n\n/-- A colored parallelepiped with given dimensions -/\nstructure ColoredParallelepiped (l m n : Nat) where\n  coloring : Cube \u2192 Option (Fin 8)\n  valid_coords : \u2200 c, c.inBounds l m n \u2192 (coloring c).isSome\n  valid_colors : \u2200 c\u2081 c\u2082, c\u2081.inBounds l m n \u2192 c\u2082.inBounds l m n \u2192 \n    c\u2081.shareVertex c\u2082 \u2192 coloring c\u2081 \u2260 coloring c\u2082\n\ntheorem corner_cubes_different_colors \n  {l m n : Nat} (h\u2081 : l > 0) (h\u2082 : m > 0) (h\u2083 : n > 0)\n  (p : ColoredParallelepiped l m n) :\n  \u2200 c\u2081 c\u2082, c\u2081.inBounds l m n \u2192 c\u2082.inBounds l m n \u2192\n    c\u2081.isCorner l m n \u2192 c\u2082.isCorner l m n \u2192 c\u2081 \u2260 c\u2082 \u2192 \n    p.coloring c\u2081 \u2260 p.coloring c\u2082 :=\n  sorry", "formal_statement_pred": "import Mathlib\n\n\nstructure Position where\n  x : Fin 2\n  y : Fin 2\n  z : Fin 2\n\n\nstructure ColoredCube where\n  coloring : Position \u2192 Fin 8\n\n\ndef shareVertex (p\u2081 p\u2082 : Position) : Prop :=\n  let diff_count := (if p\u2081.x = p\u2082.x then 0 else 1) +\n                    (if p\u2081.y = p\u2082.y then 0 else 1) +\n                    (if p\u2081.z = p\u2082.z then 0 else 1)\n  diff_count = 1\n\n\ndef validColoring (c : ColoredCube) : Prop :=\n  \u2200 pos\u2081 pos\u2082, shareVertex pos\u2081 pos\u2082 \u2192 c.coloring pos\u2081 \u2260 c.coloring pos\u2082\n\ntheorem corner_cubes_different_colors (c : ColoredCube)\n    (h : validColoring c) :\n  \u2200 pos\u2081 pos\u2082, pos\u2081 \u2260 pos\u2082 \u2192 c.coloring pos\u2081 \u2260 c.coloring pos\u2082 :=\n  sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_269", "informal_problem": "13. There were 225 people present at the meeting. Acquaintances exchanged handshakes. Prove that at least one of the participants shook hands with an even number of acquaintances ${ }^{1}$ ).[^2]", "formal_statement": "import Mathlib\n\nstructure Handshakes where\n  n : Nat                            -- number of people\n  shakes : Fin n \u2192 Fin n \u2192 Bool      -- handshake matrix\n  symmetric : \u2200 i j, shakes i j = shakes j i  -- handshakes are symmetric\n  no_self : \u2200 i, shakes i i = false  -- no self-handshakes\n\n/-- Number of handshakes for a person -/\ndef handshake_count (h : Handshakes) (person : Fin h.n) : Nat :=\n  Finset.card (Finset.filter (fun j => h.shakes person j) (Finset.univ))\n\n/-- Total number of handshakes in the meeting -/\ndef total_handshakes (h : Handshakes) : Nat :=\n  Finset.sum Finset.univ (fun i => handshake_count h i) / 2\n\ntheorem exists_even_handshakes (h : Handshakes) (h_count : h.n = 225) :\n  \u2203 person : Fin h.n, Even (handshake_count h person) :=\n  sorry", "formal_statement_pred": "import Mathlib\n\n\nstructure Handshakes where\n  n : Nat\n  shakes : Fin n \u2192 Finset (Fin n)\n  symmetric : \u2200 i j, j \u2208 shakes i \u2194 i \u2208 shakes j\n  no_self : \u2200 i, i \u2209 shakes i\n\n\ndef total_handshakes (h : Handshakes) : Nat :=\n  (Finset.univ.sum fun i => (h.shakes i).card) / 2\n\n\ndef total_handshakes_even (h : Handshakes) : Even (Finset.univ.sum fun i => (h.shakes i).card) :=\n  sorry\n\ntheorem exists_even_handshakes (h : Handshakes) (hn : h.n = 225) :\n  \u2203 i : Fin h.n, Even (h.shakes i).card :=\n  sorry", "compiled": true, "aligned": true}
{"id": "CombStruct4Lean_270", "informal_problem": "25. All vertices on the map have even degree. The rook toured several countries on this map and returned to the starting country (it could have visited some countries more than once). Prove that it made an even number of moves.", "formal_statement": "import Mathlib\n\nstructure Map where\n  countries : Type\n  [fintype : Fintype countries]\n  [dec : DecidableEq countries]\n  edges : Finset (countries \u00d7 countries)\n  adjacent (c\u2081 c\u2082 : countries) : Prop := (c\u2081, c\u2082) \u2208 edges\n  [adj_dec : DecidableRel adjacent]\n  adjacent_sym : \u2200 c\u2081 c\u2082, adjacent c\u2081 c\u2082 \u2194 adjacent c\u2082 c\u2081\n  degree_even : \u2200 c, Even (Finset.filter (adjacent c) Finset.univ).card\n\ninductive ConsecutivelyAdjacent {\u03b1} (adj : \u03b1 \u2192 \u03b1 \u2192 Prop) : List \u03b1 \u2192 Prop\n  | nil : ConsecutivelyAdjacent adj []\n  | singleton (x : \u03b1) : ConsecutivelyAdjacent adj [x]\n  | cons (x y : \u03b1) (rest : List \u03b1) :\n      adj x y \u2192\n      ConsecutivelyAdjacent adj (y::rest) \u2192\n      ConsecutivelyAdjacent adj (x::y::rest)\n\nstructure RookTour (m : Map) where\n  moves : List m.countries\n  nonempty : moves \u2260 []\n  valid_moves : ConsecutivelyAdjacent m.adjacent moves\n  closed : m.adjacent (moves.getLast nonempty) (moves.head nonempty)\n\ntheorem rook_tour_even_moves (m : Map) (tour : RookTour m) :\n  Even tour.moves.length :=\n  sorry", "formal_statement_pred": "import Mathlib\n\n\nclass Map (V : Type) [Fintype V] where\n  E : V \u2192 V \u2192 Bool\n  symm : \u2200 v\u2081 v\u2082, E v\u2081 v\u2082 = E v\u2082 v\u2081\n\n\ndef degree {V : Type} [Fintype V] (m : Map V) (v : V) : Nat :=\n  Finset.card (Finset.filter (fun u => m.E v u) Finset.univ)\n\n\ndef AllEvenDegrees {V : Type} [Fintype V] (m : Map V) : Prop :=\n  \u2200 v, Even (degree m v)\n\n\ndef IsTour {V : Type} [Fintype V] (m : Map V) : List V \u2192 Prop\n  | [] => False\n  | [_] => False\n  | v\u2081 :: v\u2082 :: rest => m.E v\u2081 v\u2082 \u2227 v\u2081 \u2260 v\u2082 \u2227 IsTour m (v\u2082 :: rest)\n\n\ndef IsClosedTour {V : Type} [Fintype V] (m : Map V) (tour : List V) : Prop :=\n  tour.length \u2265 2 \u2227\n  IsTour m tour \u2227\n  (tour.get? 0).isSome \u2227\n  (tour.getLast?).isSome \u2227\n  (tour.get? 0 = tour.getLast?)\n\ntheorem rook_tour_even_moves {V : Type} [Fintype V] (m : Map V)\n  (h_even : AllEvenDegrees m) {tour : List V}\n  (h_closed : IsClosedTour m tour) :\n  Even tour.length :=\n  sorry", "compiled": true, "aligned": true}
{"id": "CombStruct4Lean_271", "informal_problem": "27. All vertices of the map have even multiplicity. Prove that it can be properly colored with two colors (compare problem 83).\n\nProblems 23 and 27 give the following theorem, completely solving the problem of proper two-coloring:\n\nA map can be properly colored with two colors if and only if all its vertices have even multiplicity.\n\n## 8 2. Three-color coloring\n\n", "formal_statement": "import Mathlib\n\nstructure Map where\n  V : Type -- vertices\n  E : Type -- edges\n  vertices : Set V\n  edges : Set E\n  endpoint : E \u2192 V \u00d7 V -- Each edge connects two vertices\n  multiplicity : V \u2192 \u2115 -- Number of edges incident to a vertex\n  even_multiplicity : \u2200 v \u2208 vertices, Even (multiplicity v)\n\n/-- A coloring of a map is an assignment of colors to vertices -/\ndef Coloring (M : Map) := M.V \u2192 Bool\n\n/-- A coloring is proper if adjacent vertices have different colors -/\ndef isProperColoring (M : Map) (c : Coloring M) : Prop :=\n  \u2200 e \u2208 M.edges,\n    let \u27e8v\u2081, v\u2082\u27e9 := M.endpoint e\n    c v\u2081 \u2260 c v\u2082\n\ntheorem even_multiplicity_two_colorable (M : Map) :\n  \u2203 c : Coloring M, isProperColoring M c :=\n  sorry", "formal_statement_pred": "import Mathlib\n\nstructure Map where\n  V : Type\n  E : Type\n  vertices : Set V\n  edges : Set E\n  endpoint : E \u2192 V \u00d7 V\n  multiplicity : V \u2192 \u2115\n\ndef hasEvenMultiplicity (m : Map) : Prop :=\n  \u2200 v \u2208 m.vertices, Even (m.multiplicity v)\n\ndef isProperColoring (m : Map) (c : m.V \u2192 Fin 2) : Prop :=\n  \u2200 e \u2208 m.edges,\n    let \u27e8v\u2081, v\u2082\u27e9 := m.endpoint e\n    c v\u2081 \u2260 c v\u2082\n\ntheorem even_multiplicity_two_colorable (m : Map) :\n  hasEvenMultiplicity m \u2192 \u2203 c : m.V \u2192 Fin 2, isProperColoring m c :=\n  sorry", "compiled": true, "aligned": true}
{"id": "CombStruct4Lean_272", "informal_problem": "134. Let all elements in the $s$-th row of the $m$-ary Pascal triangle, except for the boundary elements, be zeros. Prove that the rows with numbers $s^{2}, s^{3}, \\ldots, s^{k}, \\ldots$ also have this property.", "formal_statement": "import Mathlib\n\n/-- Represents an m-ary Pascal triangle where each element is calculated\n    using modulo m arithmetic -/\nstructure MAryPascalTriangle where\n  m : \u2115\n  coeff : \u2115 \u2192 \u2115 \u2192 \u2115  -- row \u2192 position \u2192 value\n  isValid : \u2200 (n k : \u2115), coeff n k = if k > n then 0 \n    else (if k = 0 \u2228 k = n then 1 \n    else (coeff (n-1) (k-1) + coeff (n-1) k) % m)\n\n/-- Predicate indicating that all non-boundary elements in a row are zero -/\ndef hasZeroInterior (pt : MAryPascalTriangle) (row : \u2115) : Prop :=\n  \u2200 k : \u2115, 0 < k \u2192 k < row \u2192 pt.coeff row k = 0\n\ntheorem zero_interior_power_rows (m s : \u2115) (h_m : m > 1) (h_s : s > 0)\n  (pt : MAryPascalTriangle) (h_pt : pt.m = m)\n  (h_base : hasZeroInterior pt s) :\n  \u2200 k : \u2115, k > 0 \u2192 hasZeroInterior pt (s^k) :=\n  sorry", "formal_statement_pred": "import Mathlib\n\n\ndef maryPascal (m row col : \u2115) : \u2115 :=\n  if col = 0 \u2228 col = row then 1\n  else if col > row then 0\n  else\n    Finset.sum (Finset.range m) fun i =>\n      if col \u2265 i then maryPascal m (row - 1) (col - i)\n      else 0\n\n\ndef hasAllZerosExceptBoundary (m row : \u2115) : Prop :=\n  \u2200 col, 0 < col \u2192 col < row \u2192 maryPascal m row col = 0\n\ntheorem mary_pascal_zero_propagation (m s : \u2115) (hm : m > 1) (hs : s \u2265 2)\n    (hzero : hasAllZerosExceptBoundary m s) :\n    \u2200 k, k > 0 \u2192 hasAllZerosExceptBoundary m (s^k) :=\n  sorry", "compiled": true, "aligned": true}
{"id": "CombStruct4Lean_274", "informal_problem": "7. In the cells of an $m \\times n$ table, some numbers are written. It is allowed to simultaneously change the sign of all numbers in a certain column or a certain row. Prove that by repeatedly performing this operation, the given table can be transformed into one where the sums of the numbers in any column and any row are non-negative.", "formal_statement": "import Mathlib\n\n/-- A table of integers with m rows and n columns -/\nstructure SignTable (m n : Nat) where\n  entries : Matrix (Fin m) (Fin n) Int\nderiving Repr\n\n/-- A configuration of row and column signs (1 or -1) -/\nstructure SignChanges (m n : Nat) where\n  row_sign : Fin m \u2192 Int\n  col_sign : Fin n \u2192 Int\n  row_valid : \u2200 i, row_sign i = 1 \u2228 row_sign i = -1\n  col_valid : \u2200 j, col_sign j = 1 \u2228 col_sign j = -1\nderiving Repr\n\n/-- Sum of numbers in a row -/\ndef rowSum {m n : Nat} (t : SignTable m n) (i : Fin m) : Int :=\n  Finset.sum Finset.univ fun j => t.entries i j\n\n/-- Sum of numbers in a column -/\ndef colSum {m n : Nat} (t : SignTable m n) (j : Fin n) : Int :=\n  Finset.sum Finset.univ fun i => t.entries i j\n\n/-- Apply sign changes to a table -/\ndef applyChanges {m n : Nat} (t : SignTable m n) (f : SignChanges m n) : SignTable m n where\n  entries := Matrix.of fun i j => (f.row_sign i) * (f.col_sign j) * t.entries i j\n\n/-- Predicate indicating that a table has all non-negative row and column sums -/\ndef hasNonNegativeSums {m n : Nat} (t : SignTable m n) : Prop :=\n  (\u2200 i : Fin m, rowSum t i \u2265 0) \u2227 (\u2200 j : Fin n, colSum t j \u2265 0)\n\ntheorem exists_nonnegative_sums {m n : Nat} (hm : 0 < m) (hn : 0 < n)\n  (t : SignTable m n) :\n  \u2203 (f : SignChanges m n), hasNonNegativeSums (applyChanges t f) :=\n  sorry", "formal_statement_pred": "import Mathlib\n\n\ndef applyFlips {m n : \u2115} (mat : Matrix (Fin m) (Fin n) \u2124)\n  (row_flips : Fin m \u2192 Bool) (col_flips : Fin n \u2192 Bool) : Matrix (Fin m) (Fin n) \u2124 :=\n  Matrix.of fun i j =>\n    let row_sign := if row_flips i then -1 else 1\n    let col_sign := if col_flips j then -1 else 1\n    mat i j * row_sign * col_sign\n\n\ndef rowSum {m n : \u2115} (mat : Matrix (Fin m) (Fin n) \u2124) (i : Fin m) : \u2124 :=\n  Finset.sum (Finset.univ : Finset (Fin n)) fun j => mat i j\n\n\ndef colSum {m n : \u2115} (mat : Matrix (Fin m) (Fin n) \u2124) (j : Fin n) : \u2124 :=\n  Finset.sum (Finset.univ : Finset (Fin m)) fun i => mat i j\n\n\ndef hasNonNegativeSums {m n : \u2115} (mat : Matrix (Fin m) (Fin n) \u2124) : Prop :=\n  (\u2200 i : Fin m, rowSum mat i \u2265 0) \u2227 (\u2200 j : Fin n, colSum mat j \u2265 0)\n\ntheorem sign_matrix_nonnegative_sums (m n : \u2115) (h\u2081 : m > 0) (h\u2082 : n > 0)\n  (mat : Matrix (Fin m) (Fin n) \u2124) :\n  \u2203 (row_flips : Fin m \u2192 Bool) (col_flips : Fin n \u2192 Bool),\n    hasNonNegativeSums (applyFlips mat row_flips col_flips) :=\n  sorry", "compiled": true, "aligned": true}
{"id": "CombStruct4Lean_275", "informal_problem": "11. Prove that for any three infinite sequences of natural numbers\n\n$$\n\\begin{aligned}\n& a_{1}, a_{2}, \\ldots, a_{n}, \\ldots \\\\\n& b_{1}, \\quad b_{2}, \\ldots, b_{n}, \\ldots \\\\\n& c_{1}, \\quad c_{2}, \\ldots, c_{n}, \\ldots\n\\end{aligned}\n$$\n\nthere exist indices $p$ and $q$ such that $a_{p} \\geqslant a_{q}, b_{p} \\geqslant b_{q}$, $c_{p} \\geqslant c_{q}$.", "formal_statement": "import Mathlib\n\n-- Define a type for infinite sequences of natural numbers\ndef InfSeq := \u2115 \u2192 \u2115 \n\n-- Define what it means for two indices to satisfy our condition for a single sequence\ndef NonDecreasing (seq : InfSeq) (p q : \u2115) : Prop := seq p \u2265 seq q\n\n-- Define what it means for two indices to satisfy our condition for all three sequences\ndef SatisfiesAllSequences (a b c : InfSeq) (p q : \u2115) : Prop :=\n  NonDecreasing a p q \u2227 NonDecreasing b p q \u2227 NonDecreasing c p q\n\ntheorem exists_common_nondecreasing_indices (a b c : InfSeq) : \n  \u2203 p q : \u2115, SatisfiesAllSequences a b c p q :=\n  sorry", "formal_statement_pred": "import Mathlib\n\n\ndef Sequence := \u2115+ \u2192 \u2115\n\n\ndef IsNonDecreasing (s : Sequence) (p q : \u2115+) : Prop := s p \u2265 s q\n\ntheorem exists_common_nondecreasing_indices\n  (a b c : Sequence) :\n  \u2203 (p q : \u2115+),\n    IsNonDecreasing a p q \u2227\n    IsNonDecreasing b p q \u2227\n    IsNonDecreasing c p q :=\n  sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_277", "informal_problem": "37. Given a regular 45-gon. Is it possible to place the digits $0,1, \\ldots, 9$ at its vertices such that for any pair of different digits, there is a side whose endpoints are labeled with these digits?", "formal_statement": "import Mathlib\n\nstructure RegularPolygonLabeling where\n  n : Nat                              -- number of vertices\n  labels : Fin n \u2192 Fin 10             -- labeling function for vertices\n  \n/-- Check if two vertices are connected by an edge in a regular n-gon -/\ndef areAdjacent (n : Nat) (v\u2081 v\u2082 : Fin n) : Bool :=\n  v\u2081.val + 1 = v\u2082.val \u2228 (v\u2081.val = n - 1 \u2227 v\u2082.val = 0)\n\n/-- Predicate stating that all pairs of digits appear on some edge -/\ndef hasAllPairsOnEdges (l : RegularPolygonLabeling) : Prop :=\n  \u2200 d\u2081 d\u2082 : Fin 10, d\u2081 \u2260 d\u2082 \u2192 \n    \u2203 v\u2081 v\u2082 : Fin l.n, \n      areAdjacent l.n v\u2081 v\u2082 \u2227 \n      l.labels v\u2081 = d\u2081 \u2227 \n      l.labels v\u2082 = d\u2082\n\ntheorem fortyfive_gon_digit_placement : \n  \u00ac\u2203 (l : RegularPolygonLabeling), l.n = 45 \u2227 hasAllPairsOnEdges l :=\n  sorry", "formal_statement_pred": "import Mathlib\n\nstructure RegularPolygonLabeling (n : Nat) where\n\n  labeling : Fin n \u2192 Fin 10\n\n  surjective : Function.Surjective labeling\n\n\ndef isPolygonSide (n : Nat) (v1 v2 : Fin n) : Prop :=\n  v2.val = (v1.val + 1) % n \u2228 v1.val = (v2.val + 1) % n\n\ntheorem regular_45gon_digit_labeling_impossible :\n  \u00ac\u2203 (l : RegularPolygonLabeling 45),\n    (\u2200 (d1 d2 : Fin 10), d1 \u2260 d2 \u2192\n      \u2203 (v1 v2 : Fin 45),\n        isPolygonSide 45 v1 v2 \u2227\n        l.labeling v1 = d1 \u2227\n        l.labeling v2 = d2) :=\n  sorry", "compiled": true, "aligned": true}
{"id": "CombStruct4Lean_278", "informal_problem": "61. In the people's militia, there are 100 people, and every evening three people go on duty. Prove that it is impossible to organize the duty schedule so that any two people are on duty together exactly once.", "formal_statement": "import Mathlib\n\nstructure DutySchedule where\n  n : Nat                    -- total number of people\n  days : Nat                 -- number of days in the schedule\n  duties : Fin days \u2192 Fin n \u00d7 Fin n \u00d7 Fin n  -- assignment of 3 people to each day\n  \n/-- Two people are considered to have served together if they were assigned to the same duty -/\ndef servedTogether (schedule : DutySchedule) (p1 p2 : Fin schedule.n) : Bool :=\n  \u2203 d : Fin schedule.days, let (a, b, c) := schedule.duties d\n                          (p1 = a \u2227 p2 = b) \u2228 (p1 = a \u2227 p2 = c) \u2228 (p1 = b \u2227 p2 = c)\n\ntheorem militia_schedule_impossible : \n  \u00ac\u2203 (schedule : DutySchedule), \n    schedule.n = 100 \u2227 \n    (\u2200 p1 p2 : Fin schedule.n, p1 \u2260 p2 \u2192 \n      (\u2203! d : Fin schedule.days, servedTogether schedule p1 p2)) :=\n  sorry", "formal_statement_pred": "import Mathlib\n\nstructure DutySchedule where\n\n  days : Nat\n\n  assignment : Fin days \u2192 Fin 100 \u00d7 Fin 100 \u00d7 Fin 100\n\n  different_people : \u2200 d, let (p\u2081, p\u2082, p\u2083) := assignment d\n                         p\u2081 \u2260 p\u2082 \u2227 p\u2082 \u2260 p\u2083 \u2227 p\u2081 \u2260 p\u2083\n\n  exactly_once : \u2200 p\u2081 p\u2082, p\u2081 \u2260 p\u2082 \u2192\n    (\u2203! d, let (d\u2081, d\u2082, d\u2083) := assignment d\n          (p\u2081 = d\u2081 \u2227 p\u2082 = d\u2082) \u2228 (p\u2081 = d\u2081 \u2227 p\u2082 = d\u2083) \u2228\n          (p\u2081 = d\u2082 \u2227 p\u2082 = d\u2081) \u2228 (p\u2081 = d\u2082 \u2227 p\u2082 = d\u2083) \u2228\n          (p\u2081 = d\u2083 \u2227 p\u2082 = d\u2081) \u2228 (p\u2081 = d\u2083 \u2227 p\u2082 = d\u2082))\n\ntheorem militia_schedule_impossible : \u00ac\u2203 (s : DutySchedule), True :=\n  sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_279", "informal_problem": "76. On a grid paper, a rectangle $A B C D$ is drawn, with its sides lying on the grid lines, and $A D$ is $k$ times greater than $A B$ ($k$ is an integer). Consider all possible paths that follow the grid lines and lead from $A$ to $C$ in the shortest way. Prove that among these paths, those in which the first segment lies on $A D$ are $k$ times more numerous than those in which the first segment lies on $A B$.", "formal_statement": "import Mathlib\n\nstructure GridRectangle where\n  width : Nat\n  height : Nat\n  k : Nat\n  h_k : height = k * width\n\n/-- A path on the grid is represented as a list of steps, where each step is either Right or Up -/\ninductive GridStep\n  | right : GridStep\n  | up : GridStep\n\n/-- Count paths that start with a specific first step -/\ndef countPathsWithFirstStep (rect : GridRectangle) (firstStep : GridStep) : Nat :=\n  match firstStep with\n  | GridStep.right => Nat.choose (rect.width + rect.height - 1) (rect.width - 1)\n  | GridStep.up => Nat.choose (rect.width + rect.height - 1) rect.width\n\ntheorem grid_paths_ratio (rect : GridRectangle) :\n  countPathsWithFirstStep rect GridStep.up = rect.k * countPathsWithFirstStep rect GridStep.right :=\n  sorry", "formal_statement_pred": "import Mathlib\n\nstructure GridRectangle where\n  width : Nat\n  height : Nat\n  k : Nat\n  h_k : height = k * width\n\n\ninductive GridStep\n  | right : GridStep\n  | up : GridStep\n\n\ndef countPathsWithFirstStep (rect : GridRectangle) (firstStep : GridStep) : Nat :=\n  match firstStep with\n  | GridStep.right => Nat.choose (rect.width + rect.height - 1) (rect.width - 1)\n  | GridStep.up => Nat.choose (rect.width + rect.height - 1) rect.width\n\ntheorem grid_paths_ratio (rect : GridRectangle) :\n  countPathsWithFirstStep rect GridStep.up = rect.k * countPathsWithFirstStep rect GridStep.right :=\n  sorry", "compiled": true, "aligned": true}
{"id": "CombStruct4Lean_280", "informal_problem": "154. a) At vertex $A_{1}$ of a regular 12-sided polygon $A_{1} A_{2} \\ldots A_{12}$, there is a minus sign, while the others have plus signs. It is allowed to simultaneously change the sign to the opposite in any six consecutive vertices of the polygon. Prove that it is impossible to achieve, after several such operations, that vertex $A_{2}$ has a minus sign, and the other vertices have plus signs.\n\nb) Prove the same statement if it is allowed to change the signs in any four consecutive vertices of the polygon.\n\nc) Prove the same statement if it is allowed to simultaneously change the sign in any three consecutive vertices of the polygon.", "formal_statement": "import Mathlib\n\nstructure SignConfiguration where\n  signs : Fin 12 \u2192 Bool  -- True represents '+', False represents '-'\n\ndef is_valid_initial_config (config : SignConfiguration) : Prop :=\n  config.signs 0 = false \u2227 \n  \u2200 i, i \u2260 0 \u2192 config.signs i = true\n\ndef is_target_config (config : SignConfiguration) : Prop :=\n  config.signs 1 = false \u2227 \n  \u2200 i, i \u2260 1 \u2192 config.signs i = true\n\ndef flip_k_consecutive (k : Nat) (start : Fin 12) (config : SignConfiguration) : SignConfiguration where\n  signs := fun i => \n    if (i.val \u2265 start.val \u2227 i.val < start.val + k) \u2228 \n       (start.val + k > 12 \u2227 i.val < (start.val + k) % 12)\n    then !config.signs i\n    else config.signs i\n\ndef can_reach_config (k : Nat) (initial target : SignConfiguration) : Prop :=\n  \u2203 (steps : List (Fin 12)), \n    let final := steps.foldl (fun acc pos => flip_k_consecutive k pos acc) initial\n    final = target\n\ntheorem polygon_sign_flip_impossible \n  (k : Nat) (h : k \u2208 [3, 4, 6]) :\n  \u00ac\u2203 (initial target : SignConfiguration),\n    is_valid_initial_config initial \u2227 \n    is_target_config target \u2227\n    can_reach_config k initial target :=\n  sorry", "formal_statement_pred": "import Mathlib\n\nstructure SignConfiguration where\n  signs : Fin 12 \u2192 Bool\n\ndef is_valid_initial_config (config : SignConfiguration) : Prop :=\n  config.signs 0 = false \u2227\n  \u2200 i, i \u2260 0 \u2192 config.signs i = true\n\ndef is_target_config (config : SignConfiguration) : Prop :=\n  config.signs 1 = false \u2227\n  \u2200 i, i \u2260 1 \u2192 config.signs i = true\n\ndef flip_k_consecutive (k : Nat) (start : Fin 12) (config : SignConfiguration) : SignConfiguration where\n  signs := fun i =>\n    if (i.val \u2265 start.val \u2227 i.val < start.val + k) \u2228\n       (start.val + k > 12 \u2227 i.val < (start.val + k) % 12)\n    then !config.signs i\n    else config.signs i\n\ndef can_reach_from (k : Nat) (start config : SignConfiguration) : Prop :=\n  \u2203 (steps : List (Fin 12)),\n    let final := steps.foldl (fun acc pos => flip_k_consecutive k pos acc) start\n    config = final\n\ntheorem polygon_sign_flip_impossible (k : Nat) (h : k \u2208 [3, 4, 6]) :\n  \u2200 (start target : SignConfiguration),\n    is_valid_initial_config start \u2192\n    is_target_config target \u2192\n    \u00accan_reach_from k start target :=\n  sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_281", "informal_problem": "176. Given $n$ points, $n>4$. Prove that it is possible to connect them with arrows so that from any point to any other point it is possible to get by following either one arrow or two (any two points can be connected by an arrow in only one direction; it is possible to follow an arrow only in the direction indicated on it).", "formal_statement": "import Mathlib\n\nstructure DirectedGraph (n : Nat) where\n  -- edges represented as a function that returns true if there's an edge from i to j\n  edges : Fin n \u2192 Fin n \u2192 Bool\n\n/-- Path of length at most 2 exists between vertices i and j -/\ndef hasPathAtMost2 {n : Nat} (g : DirectedGraph n) (i j : Fin n) : Prop :=\n  g.edges i j \u2228 \u2203 k : Fin n, g.edges i k \u2227 g.edges k j\n\n/-- A valid solution is a directed graph where any two vertices are connected by a path of length \u2264 2 -/\ndef isValidSolution {n : Nat} (g : DirectedGraph n) : Prop :=\n  \u2200 i j : Fin n, i \u2260 j \u2192 hasPathAtMost2 g i j\n\ntheorem directed_graph_exists_solution (n : Nat) (h : n > 4) :\n  \u2203 g : DirectedGraph n, isValidSolution g :=\n  sorry", "formal_statement_pred": "import Mathlib\n\nstructure DirectedGraph (n : Nat) where\n  edges : Fin n \u2192 Fin n \u2192 Bool\n\n\ndef hasPathAtMost2 {n : Nat} (g : DirectedGraph n) (i j : Fin n) : Prop :=\n  g.edges i j \u2228 \u2203 k : Fin n, g.edges i k \u2227 g.edges k j\n\ntheorem directed_graph_connectivity (n : Nat) (h : n > 4) :\n  \u2203 (g : DirectedGraph n), \u2200 (i j : Fin n), i \u2260 j \u2192 hasPathAtMost2 g i j :=\n  sorry", "compiled": true, "aligned": true}
{"id": "CombStruct4Lean_282", "informal_problem": "200. a) Prove that the numbers $1,2,3, \\ldots, 32$ can be arranged in such an order that for no two numbers their half-sum equals any of the numbers placed between them.\n\nb) Can the numbers $1,2,3, \\ldots, 100$ be arranged in such an order that for no two numbers their half-sum equals any of the numbers placed between them?", "formal_statement": "import Mathlib\n\nstructure ValidArrangement (n : Nat) where\n  perm : Fin n \u2192 Nat\n  is_permutation : Function.Bijective perm\n  no_half_sum_between : \u2200 i j : Fin n, i < j \u2192\n    \u2200 k : Fin n, i < k \u2227 k < j \u2192\n      perm k \u2260 (perm i + perm j) / 2\n\ndef is_valid_arrangement (n : Nat) : Prop :=\n  \u2203 arr : ValidArrangement n, \u2200 i : Fin n, arr.perm i \u2208 Finset.range n\n\ntheorem arrangement_existence : \n  (is_valid_arrangement 32) \u2227 \u00ac(is_valid_arrangement 100) :=\n  sorry", "formal_statement_pred": "import Mathlib\n\nstructure ValidArrangement (n : Nat) where\n  perm : Fin n \u2192 Nat\n  is_permutation : Function.Bijective perm\n  no_half_sum_between : \u2200 i j : Fin n, i < j \u2192\n    \u2200 k : Fin n, i < k \u2227 k < j \u2192\n      perm k \u2260 (perm i + perm j) / 2\n  values_in_range : \u2200 i : Fin n, perm i \u2265 1 \u2227 perm i \u2264 n\n\ntheorem arrangement_exists_32 : \u2203 (arr : ValidArrangement 32), True :=\n  sorry\n\ntheorem arrangement_not_exists_100 : \u00ac \u2203 (arr : ValidArrangement 100), True :=\n  sorry", "compiled": true, "aligned": true}
{"id": "CombStruct4Lean_284", "informal_problem": "265*. Given a prime number $p>3$. Consider a set $M$ on the coordinate plane consisting of points with integer coordinates $(x, y)$ such that $0 \\leqslant x < p, 0 \\leqslant y < p$. Prove that it is possible to mark $p$ different points of the set $M$ such that no four of them lie at the vertices of a parallelogram and no three of them lie on the same line.", "formal_statement": "import Mathlib\n\nstructure Point where\n  x : Int\n  y : Int\nderiving Repr, DecidableEq\n\nnamespace Point\ndef sub (a b : Point) : Point :=\n  \u27e8a.x - b.x, a.y - b.y\u27e9\n\ndef isEqual (a b : Point) : Bool :=\n  a.x = b.x \u2227 a.y = b.y\nend Point\n\nstructure Grid (p : Nat) where\n  points : Finset Point\n  valid : \u2200 pt \u2208 points, 0 \u2264 pt.x \u2227 pt.x < p \u2227 0 \u2264 pt.y \u2227 pt.y < p\n\ndef areVectorsEqual (v\u2081 v\u2082 : Point) : Bool :=\n  v\u2081.x = v\u2082.x \u2227 v\u2081.y = v\u2082.y\n\ndef formParallelogram (a b c d : Point) : Prop :=\n  let v\u2081 := Point.sub b a\n  let v\u2082 := Point.sub c b\n  let v\u2083 := Point.sub d c\n  let v\u2084 := Point.sub a d\n  (\u00aca.isEqual b) \u2227 (\u00acb.isEqual c) \u2227 (\u00acc.isEqual d) \u2227 (\u00acd.isEqual a) \u2227\n  ((areVectorsEqual v\u2081 v\u2083 \u2227 areVectorsEqual v\u2082 v\u2084) \u2228\n   (areVectorsEqual v\u2081 v\u2084 \u2227 areVectorsEqual v\u2082 v\u2083))\n\ndef areCollinear (a b c : Point) : Prop :=\n  (\u00aca.isEqual b) \u2227 (\u00acb.isEqual c) \u2227 (\u00acc.isEqual a) \u2227\n  (b.x - a.x) * (c.y - a.y) = (c.x - a.x) * (b.y - a.y)\n\ndef ValidSelection (p : Nat) (pts : Finset Point) : Prop :=\n  -- Set has exactly p points\n  pts.card = p \u2227\n  -- All points are in range\n  (\u2200 pt \u2208 pts, 0 \u2264 pt.x \u2227 pt.x < p \u2227 0 \u2264 pt.y \u2227 pt.y < p) \u2227\n  -- No four points form a parallelogram\n  (\u2200 (a b c d : Point), a \u2208 pts \u2192 b \u2208 pts \u2192 c \u2208 pts \u2192 d \u2208 pts \u2192 \n    \u00acformParallelogram a b c d) \u2227\n  -- No three points are collinear\n  (\u2200 (a b c : Point), a \u2208 pts \u2192 b \u2208 pts \u2192 c \u2208 pts \u2192 \n    \u00acareCollinear a b c)\n\ntheorem exists_valid_selection (p : Nat) (h_prime : Nat.Prime p) (h_gt3 : p > 3) :\n  \u2203 pts : Finset Point, ValidSelection p pts :=\n  sorry", "formal_statement_pred": "import Mathlib\n\nstructure Point (p : Nat) where\n  x : Fin p\n  y : Fin p\n\ndef isParallelogram {p : Nat} (a b c d : Point p) : Prop :=\n\n  (b.x - a.x = d.x - c.x) \u2227\n  (b.y - a.y = d.y - c.y) \u2227\n\n  a \u2260 b \u2227 b \u2260 c \u2227 c \u2260 d \u2227 d \u2260 a \u2227\n\n  (b.x - a.x) * (d.y - c.y) \u2260 (d.x - c.x) * (b.y - a.y)\n\ndef areCollinear {p : Nat} (a b c : Point p) : Prop :=\n  (b.x - a.x) * (c.y - a.y) = (c.x - a.x) * (b.y - a.y)\n\ndef ValidSelection (p : Nat) (points : Finset (Point p)) : Prop :=\n\n  points.card = p \u2227\n\n  (\u2200 a \u2208 points, \u2200 b \u2208 points, \u2200 c \u2208 points, \u2200 d \u2208 points,\n    \u00acisParallelogram a b c d) \u2227\n\n  (\u2200 a \u2208 points, \u2200 b \u2208 points, \u2200 c \u2208 points,\n    a \u2260 b \u2192 b \u2260 c \u2192 c \u2260 a \u2192 \u00acareCollinear a b c)\n\ntheorem exists_valid_selection (p : Nat) (h_prime : Nat.Prime p) (h_gt_3 : p > 3) :\n  \u2203 points : Finset (Point p), ValidSelection p points :=\n  sorry", "compiled": true, "aligned": true}
{"id": "CombStruct4Lean_288", "informal_problem": "314*. Is it possible to color all cells of some rectangular table in white and black so that there are an equal number of white and black cells, and in each row and each column, more than $3 / 4$ of the cells are of one color?", "formal_statement": "import Mathlib\n\nstructure ColoredTable where\n  rows : Nat\n  cols : Nat\n  rowPos : 0 < rows\n  colPos : 0 < cols\n  coloring : Fin rows \u2192 Fin cols \u2192 Bool  -- True for white, False for black\n\ndef countColorInRow (t : ColoredTable) (r : Fin t.rows) (color : Bool) : Nat :=\n  Finset.filter (fun c => t.coloring r c = color) (Finset.univ : Finset (Fin t.cols)) |>.card\n\ndef countColorInCol (t : ColoredTable) (c : Fin t.cols) (color : Bool) : Nat :=\n  Finset.filter (fun r => t.coloring r c = color) (Finset.univ : Finset (Fin t.rows)) |>.card\n\ndef totalColorCount (t : ColoredTable) (color : Bool) : Nat :=\n  Finset.sum (Finset.univ : Finset (Fin t.rows)) (fun r => countColorInRow t r color)\n\ntheorem no_balanced_coloring_exists :\n  \u00ac\u2203 (t : ColoredTable), \n    -- Equal number of white and black cells\n    totalColorCount t true = totalColorCount t false \u2227 \n    -- For each row, one color takes more than 3/4 of cells\n    (\u2200 r : Fin t.rows, \n      4 * countColorInRow t r true > 3 * t.cols \u2228 \n      4 * countColorInRow t r false > 3 * t.cols) \u2227\n    -- For each column, one color takes more than 3/4 of cells\n    (\u2200 c : Fin t.cols,\n      4 * countColorInCol t c true > 3 * t.rows \u2228 \n      4 * countColorInCol t c false > 3 * t.rows) :=\n  sorry", "formal_statement_pred": "import Mathlib\n\nstructure ColoredTable where\n  rows : Nat\n  cols : Nat\n  rowPos : rows > 0\n  colPos : cols > 0\n  coloring : Fin rows \u2192 Fin cols \u2192 Bool\n\ndef countColorInRow (t : ColoredTable) (r : Fin t.rows) (color : Bool) : Nat :=\n  Finset.sum (Finset.univ : Finset (Fin t.cols)) fun c \u21a6\n    if t.coloring r c = color then 1 else 0\n\ndef countColorInCol (t : ColoredTable) (c : Fin t.cols) (color : Bool) : Nat :=\n  Finset.sum (Finset.univ : Finset (Fin t.rows)) fun r \u21a6\n    if t.coloring r c = color then 1 else 0\n\ndef totalColorCount (t : ColoredTable) (color : Bool) : Nat :=\n  Finset.sum (Finset.univ : Finset (Fin t.rows)) fun r \u21a6\n    countColorInRow t r color\n\ndef hasBalancedColors (t : ColoredTable) : Prop :=\n  totalColorCount t true = totalColorCount t false\n\ndef rowSatisfiesThreshold (t : ColoredTable) (r : Fin t.rows) : Prop :=\n  4 * countColorInRow t r true > 3 * t.cols \u2228\n  4 * countColorInRow t r false > 3 * t.cols\n\ndef colSatisfiesThreshold (t : ColoredTable) (c : Fin t.cols) : Prop :=\n  4 * countColorInCol t c true > 3 * t.rows \u2228\n  4 * countColorInCol t c false > 3 * t.rows\n\ntheorem no_balanced_coloring_exists :\n  \u00ac\u2203 (t : ColoredTable),\n    hasBalancedColors t \u2227\n    (\u2200 r : Fin t.rows, rowSatisfiesThreshold t r) \u2227\n    (\u2200 c : Fin t.cols, colSatisfiesThreshold t c) :=\n  sorry", "compiled": true, "aligned": true}
{"id": "CombStruct4Lean_289", "informal_problem": "330. A non-negative real number is assigned to each vertex of a cube, with the sum of all these numbers being 1. Two players play the following game: the first player chooses any face of the cube, the second player chooses another face, and finally, the first player chooses a third face. It is not allowed to choose faces parallel to the already chosen ones. Prove that the first player can play in such a way that the number corresponding to the common vertex of the three chosen faces does not exceed $1 / 6$.", "formal_statement": "import Mathlib\n\nstructure CubeGame where\n  -- Vertex values are non-negative reals assigned to each vertex\n  -- We represent vertices as triples of coordinates (\u00b11, \u00b11, \u00b11)\n  vertex_value : (Fin 2 \u00d7 Fin 2 \u00d7 Fin 2) \u2192 \u211d\n  -- Values are non-negative\n  values_nonneg : \u2200 v, vertex_value v \u2265 0\n  -- Sum of all values is 1\n  sum_one : (\u2211 v, vertex_value v) = 1\n\n-- Helper function to get faces that are not parallel to given faces\ndef valid_face (f\u2081 f\u2082 : Fin 3) : Prop :=\n  f\u2081 \u2260 f\u2082 \u2227 (\u2200 f\u2083, f\u2083 \u2260 f\u2081 \u2227 f\u2083 \u2260 f\u2082)\n\ntheorem cube_game_strategy (game : CubeGame) :\n  \u2203 (f\u2081 : Fin 3), \u2200 (f\u2082 : Fin 3), valid_face f\u2081 f\u2082 \u2192\n    \u2203 (f\u2083 : Fin 3), valid_face f\u2081 f\u2083 \u2227 valid_face f\u2082 f\u2083 \u2227\n      \u2203 (v : Fin 2 \u00d7 Fin 2 \u00d7 Fin 2), \n        (game.vertex_value v \u2264 1/6) :=\n  sorry", "formal_statement_pred": "import Mathlib\n\nstructure CubeGame where\n\n  vertex_values : Fin 8 \u2192 Real\n\n  sum_one : (\u2211 i, vertex_values i) = 1\n\n  non_neg : \u2200 i, vertex_values i \u2265 0\n\n\ninductive CubeFace\n  | front\n  | back\n  | top\n  | bottom\n  | left\n  | right\n\n\ndef are_parallel (f\u2081 f\u2082 : CubeFace) : Bool :=\n  match f\u2081, f\u2082 with\n  | CubeFace.front, CubeFace.back => true\n  | CubeFace.back, CubeFace.front => true\n  | CubeFace.top, CubeFace.bottom => true\n  | CubeFace.bottom, CubeFace.top => true\n  | CubeFace.left, CubeFace.right => true\n  | CubeFace.right, CubeFace.left => true\n  | _, _ => false\n\n\ndef intersection_value (g : CubeGame) (f\u2081 f\u2082 f\u2083 : CubeFace) : Real :=\n\n  sorry\n\ntheorem cube_game_strategy (g : CubeGame) :\n  \u2203 f\u2081 : CubeFace, \u2200 f\u2082 : CubeFace,\n    \u00ac(are_parallel f\u2081 f\u2082) \u2192\n    \u2203 f\u2083 : CubeFace,\n      \u00ac(are_parallel f\u2081 f\u2083) \u2227\n      \u00ac(are_parallel f\u2082 f\u2083) \u2227\n      intersection_value g f\u2081 f\u2082 f\u2083 \u2264 1/6 :=\n  sorry", "compiled": true, "aligned": true}
{"id": "CombStruct4Lean_290", "informal_problem": "345. In a square table of $n \\times n$ cells, $n-1$ cells are marked. Prove that by permuting the rows among themselves and the columns among themselves, it is possible to achieve that all the marked cells lie below the diagonal of the table.", "formal_statement": "import Mathlib\n\nstructure MarkedTable where\n  n : Nat\n  h_pos : n > 0\n  marks : Finset (Fin n \u00d7 Fin n)\n  mark_count : marks.card = n - 1\n\nstructure TablePermutation (n : Nat) where\n  row_perm : Equiv.Perm (Fin n)\n  col_perm : Equiv.Perm (Fin n)\n\ndef below_diagonal {n : Nat} (pos : Fin n \u00d7 Fin n) : Prop :=\n  pos.1.val > pos.2.val\n\ndef apply_permutation {n : Nat} (p : TablePermutation n) (pos : Fin n \u00d7 Fin n) : Fin n \u00d7 Fin n :=\n  (p.row_perm pos.1, p.col_perm pos.2)\n\ntheorem marked_cells_below_diagonal (t : MarkedTable) :\n  \u2203 (p : TablePermutation t.n), \u2200 pos \u2208 t.marks,\n    below_diagonal (apply_permutation p pos) :=\n  sorry", "formal_statement_pred": "import Mathlib\n\nopen Finset\n\nstructure MarkedTable where\n  n : Nat\n  marks : Finset (Fin n \u00d7 Fin n)\n  h_valid : n > 0\n\ndef below_diagonal {n : Nat} (pos : Fin n \u00d7 Fin n) : Prop :=\n  pos.1.val \u2265 pos.2.val\n\ndef permute_marks {n : Nat} (\u03c3_row \u03c3_col : Fin n \u2243 Fin n) (marks : Finset (Fin n \u00d7 Fin n)) :=\n  marks.image (fun pos => (\u03c3_row pos.1, \u03c3_col pos.2))\n\ntheorem exists_valid_permutation (t : MarkedTable) (h_count : t.marks.card = t.n - 1) :\n  \u2203 (\u03c3_row \u03c3_col : Fin t.n \u2243 Fin t.n),\n    \u2200 pos \u2208 permute_marks \u03c3_row \u03c3_col t.marks, below_diagonal pos :=\n  sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_291", "informal_problem": "362. Is it possible to arrange integers in the cells of an infinite grid paper such that in every rectangle of size $4 \\times 6$ cells, with sides along the grid lines, the sum of the numbers is a) 10; b) 1?", "formal_statement": "import Mathlib\n\nstructure InfiniteGrid where\n  value : \u2124 \u00d7 \u2124 \u2192 \u2124  -- Function mapping grid coordinates to integers\n\ndef rectangleSum (grid : InfiniteGrid) (x y : \u2124) : \u2124 :=\n  (Finset.range 4).sum (fun i =>\n    (Finset.range 6).sum (fun j =>\n      grid.value (x + i, y + j)))\n\ndef validGrid (grid : InfiniteGrid) (target : \u2124) : Prop :=\n  \u2200 x y : \u2124, rectangleSum grid x y = target\n\ntheorem infinite_grid_sum_existence (target : \u2124) : \n  target = 10 \u2228 target = 1 \u2192 \n  (\u2203 grid : InfiniteGrid, validGrid grid target) \u2228 \n  (\u00ac\u2203 grid : InfiniteGrid, validGrid grid target) :=\n  sorry", "formal_statement_pred": "import Mathlib\n\n\nstructure InfiniteGrid where\n  value : \u2124 \u00d7 \u2124 \u2192 \u2124\n\n\ndef is4x6Rectangle (x y w h : \u2124) : Bool :=\n  w = x + 3 \u2227 h = y + 5\n\n\ndef rectangleSum (grid : InfiniteGrid) (x y w h : \u2124) : \u2124 :=\n  \u2211 i in Finset.range 4, \u2211 j in Finset.range 6, grid.value (x + i, y + j)\n\ntheorem infinite_grid_rectangle_sum_impossible (target : \u2124) (h : target = 10 \u2228 target = 1) :\n  \u00ac\u2203 (grid : InfiniteGrid), \u2200 (x y w h : \u2124),\n    is4x6Rectangle x y w h \u2192 rectangleSum grid x y w h = target :=\n  sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_292", "informal_problem": "367. Prove that among any $2 m+1$ different integers, not exceeding $2 m-1$ in absolute value, one can find three numbers whose sum is 0.", "formal_statement": "import Mathlib\n\ndef AbsLeq (n : \u2124) (m : \u2115) : Prop := Int.natAbs n \u2264 m\n\nstructure IntegerSelection (m : \u2115) where\n  nums : Finset \u2124\n  size : nums.card = 2 * m + 1\n  bound : \u2200 x \u2208 nums, AbsLeq x (2 * m - 1)\n\ntheorem exists_three_sum_zero (m : \u2115) (h : m > 0) \n  (sel : IntegerSelection m) : \n  \u2203 (a b c : \u2124), a \u2208 sel.nums \u2227 b \u2208 sel.nums \u2227 c \u2208 sel.nums \u2227 \n    a \u2260 b \u2227 b \u2260 c \u2227 a \u2260 c \u2227 \n    a + b + c = 0 :=\n  sorry", "formal_statement_pred": "import Mathlib\n\ndef IsValidSet (m : \u2115) (S : Finset \u2124) : Prop :=\n  S.card = 2*m + 1 \u2227\n  \u2200 x \u2208 S, Int.natAbs x \u2264 2*m - 1\n\ntheorem exists_zero_sum_triple (m : \u2115) (h\u2081 : m > 0) (S : Finset \u2124) (hS : IsValidSet m S) :\n  \u2203 (x y z : \u2124), x \u2208 S \u2227 y \u2208 S \u2227 z \u2208 S \u2227\n    x \u2260 y \u2227 y \u2260 z \u2227 x \u2260 z \u2227\n    x + y + z = 0 :=\n  sorry", "compiled": true, "aligned": true}
{"id": "CombStruct4Lean_293", "informal_problem": "407. There is a cube, a cubic box with a lid of the same size, and six paints. Each paint is used to color one face of the cube and one of the faces of the box. Prove that the cube can be placed in the box in such a way that each face of the cube touches a face of the box painted with a different color.", "formal_statement": "import Mathlib\n\nstructure CubePainting where\n  -- Maps each face (1-6) to its color (1-6)\n  cube_colors : Fin 6 \u2192 Fin 6\n  box_colors : Fin 6 \u2192 Fin 6\n  -- Each color is used exactly once for cube and box\n  cube_bijective : Function.Bijective cube_colors\n  box_bijective : Function.Bijective box_colors\n\n/-- Represents a placement of the cube in the box -/\nstructure CubePlacement where\n  -- Maps each face of the cube (1-6) to the face of the box it touches (1-6)\n  placement : Fin 6 \u2192 Fin 6\n  -- The placement must be bijective (each box face touches exactly one cube face)\n  is_bijective : Function.Bijective placement\n\ntheorem cube_box_painting_exists :\n  \u2200 (p : CubePainting), \u2203 (placement : CubePlacement),\n    \u2200 (face : Fin 6), p.cube_colors face \u2260 p.box_colors (placement.placement face) :=\n  sorry", "formal_statement_pred": "import Mathlib\n\n\nstructure ColorAssignment where\n\n  cube_colors : Fin 6 \u2192 Fin 6\n  box_colors : Fin 6 \u2192 Fin 6\n\n  colors_bijective_cube : Function.Bijective cube_colors\n  colors_bijective_box : Function.Bijective box_colors\n\n\nstructure CubePlacement where\n\n  face_mapping : Fin 6 \u2192 Fin 6\n\n  mapping_bijective : Function.Bijective face_mapping\n\ntheorem cube_box_coloring\n  (ca : ColorAssignment) :\n  \u2203 (placement : CubePlacement),\n    \u2200 (i : Fin 6), ca.cube_colors i \u2260 ca.box_colors (placement.face_mapping i) :=\n  sorry", "compiled": true, "aligned": true}
{"id": "CombStruct4Lean_295", "informal_problem": "429. A cube with edge length $n, n \\geqslant 3$, consists of $n^{3}$ unit cubes. Prove that it is possible to write an integer in each of these unit cubes such that all $n^{3}$ numbers are distinct, and the sums of the numbers in any row parallel to any edge of the cube equal zero.", "formal_statement": "import Mathlib\n\n/-- Direction of a row in the cube -/\ninductive Direction where\n  | X : Direction\n  | Y : Direction\n  | Z : Direction\n\n/-- A labeling of an n\u00d7n\u00d7n cube with integers such that all labels are distinct\n    and sums along any row parallel to any edge equal zero -/\nstructure CubeLabeling (n : Nat) where\n  size_constraint : n \u2265 3\n  labels : Fin n \u2192 Fin n \u2192 Fin n \u2192 Int\n  distinct : \u2200 i\u2081 j\u2081 k\u2081 i\u2082 j\u2082 k\u2082, \n    (i\u2081, j\u2081, k\u2081) \u2260 (i\u2082, j\u2082, k\u2082) \u2192 \n    labels i\u2081 j\u2081 k\u2081 \u2260 labels i\u2082 j\u2082 k\u2082\n\n/-- Get a row of labels in the specified direction -/\ndef getRow (n : Nat) (d : Direction) (i j : Fin n) : \n    Fin n \u2192 Fin n \u00d7 Fin n \u00d7 Fin n :=\n  match d with\n  | Direction.X => fun k => (k, i, j)\n  | Direction.Y => fun k => (i, k, j)\n  | Direction.Z => fun k => (i, j, k)\n\n/-- Sum of labels along a row in any direction -/\ndef rowSum {n : Nat} (c : CubeLabeling n) (d : Direction) (i j : Fin n) : Int :=\n  let coords := getRow n d i j\n  Finset.sum (Finset.univ : Finset (Fin n)) fun k => \n    let (x, y, z) := coords k\n    c.labels x y z\n\ntheorem cube_labeling_exists (n : Nat) (h : n \u2265 3) : \n  \u2203 (c : CubeLabeling n), \u2200 (d : Direction) (i j : Fin n), \n    rowSum c d i j = 0 :=\n  sorry", "formal_statement_pred": "import Mathlib\n\nstructure CubeLabeling where\n  n : Nat\n  h_size : n \u2265 3\n  labels : Fin n \u2192 Fin n \u2192 Fin n \u2192 Int\n  h_distinct : \u2200 (i j k i' j' k' : Fin n),\n    labels i j k = labels i' j' k' \u2192 i = i' \u2227 j = j' \u2227 k = k'\n  h_row_sum_x : \u2200 (j k : Fin n),\n    (\u2211 i : Fin n, labels i j k) = 0\n  h_row_sum_y : \u2200 (i k : Fin n),\n    (\u2211 j : Fin n, labels i j k) = 0\n  h_row_sum_z : \u2200 (i j : Fin n),\n    (\u2211 k : Fin n, labels i j k) = 0\n\ntheorem cube_labeling_exists (n : Nat) (h : n \u2265 3) :\n  \u2203 (labeling : CubeLabeling), labeling.n = n :=\n  sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_298", "informal_problem": "7.8. The floor of a rectangular room $6 \\times 3 \\mu^{2}$ is completely covered by square carpets of different sizes (the edges of the carpets are parallel to the walls). Prove that some of the carpets can be removed so that the remaining carpets do not overlap and cover more than $2 \\mu^{2}$.\n\n## SNAIL AND OBSERVERS", "formal_statement": "import Mathlib\n\nstructure Room where\n  width : \u211d\n  height : \u211d\n  h_pos : width > 0 \u2227 height > 0\n\nstructure SquareCarpet where\n  bottomLeft : \u211d \u00d7 \u211d\n  size : \u211d\n  h_pos : size > 0\n\ndef area (c : SquareCarpet) : \u211d := c.size * c.size\n\ndef carpetInterval (c : SquareCarpet) : Set (\u211d \u00d7 \u211d) :=\n  {p | c.bottomLeft.1 \u2264 p.1 \u2227 p.1 \u2264 c.bottomLeft.1 + c.size \u2227\n       c.bottomLeft.2 \u2264 p.2 \u2227 p.2 \u2264 c.bottomLeft.2 + c.size}\n\ndef inRoom (r : Room) (c : SquareCarpet) : Prop :=\n  c.bottomLeft.1 \u2265 0 \u2227 c.bottomLeft.1 + c.size \u2264 r.width \u2227\n  c.bottomLeft.2 \u2265 0 \u2227 c.bottomLeft.2 + c.size \u2264 r.height\n\ndef overlaps (c\u2081 c\u2082 : SquareCarpet) : Prop :=\n  \u2203 p : \u211d \u00d7 \u211d, p \u2208 carpetInterval c\u2081 \u2227 p \u2208 carpetInterval c\u2082\n\ntheorem carpet_covering_exists (r : Room) (carpets : Finset SquareCarpet)\n    (h_room : r.width = 6 \u2227 r.height = 3)\n    (h_in_room : \u2200 c \u2208 carpets, inRoom r c)\n    (h_covers : \u2200 p : \u211d \u00d7 \u211d, 0 \u2264 p.1 \u2227 p.1 \u2264 r.width \u2192\n                            0 \u2264 p.2 \u2227 p.2 \u2264 r.height \u2192\n                            \u2203 c \u2208 carpets, p \u2208 carpetInterval c) :\n    \u2203 subcarpets : Finset SquareCarpet,\n      subcarpets \u2286 carpets \u2227\n      (\u2200 (c\u2081 c\u2082 : SquareCarpet), c\u2081 \u2208 subcarpets \u2192 c\u2082 \u2208 subcarpets \u2192 c\u2081 \u2260 c\u2082 \u2192 \u00acoverlaps c\u2081 c\u2082) \u2227\n      (\u2211 c in subcarpets, area c : \u211d) > 2 :=\n  sorry", "formal_statement_pred": "import Mathlib\n\n\nstructure Carpet where\n  pos : \u211d \u00d7 \u211d\n  size : \u211d\n  size_pos : size > 0\n  in_bounds : pos.1 + size \u2264 6 \u2227 pos.2 + size \u2264 3\n\n\ndef carpetsOverlap (c\u2081 c\u2082 : Carpet) : Prop :=\n  (c\u2081.pos.1 < c\u2082.pos.1 + c\u2082.size \u2227 c\u2082.pos.1 < c\u2081.pos.1 + c\u2081.size) \u2227\n  (c\u2081.pos.2 < c\u2082.pos.2 + c\u2082.size \u2227 c\u2082.pos.2 < c\u2081.pos.2 + c\u2081.size)\n\n\ndef carpetArea (c : Carpet) : \u211d := c.size * c.size\n\ntheorem carpet_covering_theorem\n  (carpets : Finset Carpet)\n  (h_cover : \u2200 x y : \u211d, 0 \u2264 x \u2227 x \u2264 6 \u2192 0 \u2264 y \u2227 y \u2264 3 \u2192\n    \u2203 c \u2208 carpets,\n      x \u2208 Set.Icc c.pos.1 (c.pos.1 + c.size) \u2227\n      y \u2208 Set.Icc c.pos.2 (c.pos.2 + c.size)) :\n  \u2203 subcarpets : Finset Carpet,\n    subcarpets \u2286 carpets \u2227\n    (\u2200 c\u2081 \u2208 subcarpets, \u2200 c\u2082 \u2208 subcarpets, c\u2081 \u2260 c\u2082 \u2192 \u00accarpetsOverlap c\u2081 c\u2082) \u2227\n    Finset.sum subcarpets carpetArea > (2 : \u211d) :=\n  sorry", "compiled": true, "aligned": true}
{"id": "CombStruct4Lean_301", "informal_problem": "5. In a round-robin tournament, there were no draws; 1 point was awarded for a win, and 0 for a loss. Then, a coefficient for each participant was determined. It was equal to the sum of the points scored by those whom the athlete defeated. It turned out that all participants had equal coefficients. The number of participants in the tournament is greater than two. Prove that all athletes scored the same number of points.", "formal_statement": "import Mathlib\n\nopen Finset\n\nstructure Tournament where\n  n : Nat\n  h_size : n > 2\n  wins : Fin n \u2192 Fin n \u2192 Bool\n  h_no_self : \u2200 i, wins i i = false\n  h_complete : \u2200 i j, i \u2260 j \u2192 wins i j = !wins j i\n\ndef Tournament.points (t : Tournament) (i : Fin t.n) : Nat :=\n  (univ.filter (fun j \u21a6 t.wins i j)).card\n\ndef Tournament.coefficient (t : Tournament) (i : Fin t.n) : Nat :=\n  (univ.filter (fun j \u21a6 t.wins i j)).sum (fun j \u21a6 t.points j)\n\ntheorem tournament_equal_coeffs_impl_equal_points\n  (t : Tournament)\n  (h_equal_coeffs : \u2200 i j : Fin t.n, t.coefficient i = t.coefficient j) :\n  \u2200 i j : Fin t.n, t.points i = t.points j :=\n  sorry", "formal_statement_pred": "import Mathlib\n\nstructure Tournament where\n  n : Nat\n  results : Matrix (Fin n) (Fin n) Bool\n  h_size : n > 2\n  h_valid : \u2200 i j : Fin n, i \u2260 j \u2192\n    (results i j = !results j i)\n  h_diag : \u2200 i : Fin n, results i i = false\n\n\ndef points (t : Tournament) (i : Fin t.n) : Nat :=\n  Finset.sum (Finset.filter (fun j \u21a6 t.results i j) Finset.univ) (fun _ \u21a6 1)\n\n\ndef coefficient (t : Tournament) (i : Fin t.n) : Nat :=\n  Finset.sum (Finset.filter (fun j \u21a6 t.results i j) Finset.univ) (points t)\n\ntheorem tournament_equal_coeffs_implies_equal_points\n  (t : Tournament)\n  (h_coeff : \u2200 i j : Fin t.n, coefficient t i = coefficient t j) :\n  \u2200 i j : Fin t.n, points t i = points t j :=\n  sorry", "compiled": true, "aligned": true}
{"id": "CombStruct4Lean_302", "informal_problem": "4. $2 n$ radii divide a circle into $2 n$ equal sectors: $n$ blue and $n$ red. In the blue sectors, starting from a certain one, the numbers from 1 to $n$ are written counterclockwise. In the red sectors, starting from a certain one, the same numbers are written in the same way, but clockwise. Prove that there will be a semicircle in which all numbers from 1 to $n$ are written.", "formal_statement": "import Mathlib\nopen Finset\n\n-- Helper function to determine if a position is within a semicircle\ndef IsInSemicircle (n : \u2115) (start pos : Fin (2 * n)) : Prop :=\n  (pos.val - start.val) % (2 * n) < n\n\nstructure ColoredCircle (n : \u2115) where\n  -- For each position in the circle (0 to 2n-1), we store:\n  -- The color (true for blue, false for red)\n  colors : Fin (2 * n) \u2192 Bool\n  -- The number written in that position (1 to n)\n  numbers : Fin (2 * n) \u2192 Fin n.succ\n  -- Ensure n positions are blue and n are red\n  color_count : (filter (fun i => colors i = true) (univ : Finset (Fin (2 * n)))).card = n\n  -- Each number appears exactly once in blue sectors\n  blue_numbers_once : \u2200 k : Fin n.succ,\n    (filter (fun i => colors i = true \u2227 numbers i = k) (univ : Finset (Fin (2 * n)))).card = 1\n  -- Each number appears exactly once in red sectors\n  red_numbers_once : \u2200 k : Fin n.succ,\n    (filter (fun i => colors i = false \u2227 numbers i = k) (univ : Finset (Fin (2 * n)))).card = 1\n  -- Blue numbers are written counterclockwise\n  blue_counter_clockwise : \u2200 i j : Fin (2 * n),\n    colors i = true \u2192 colors j = true \u2192\n    (j.val - i.val) % (2 * n) < n \u2192\n    numbers i < numbers j\n  -- Red numbers are written clockwise\n  red_clockwise : \u2200 i j : Fin (2 * n),\n    colors i = false \u2192 colors j = false \u2192\n    (j.val - i.val) % (2 * n) < n \u2192\n    numbers i > numbers j\n\ntheorem colored_circle_semicircle_property (n : \u2115) (h : n > 0)\n  (circle : ColoredCircle n) :\n  \u2203 (start : Fin (2 * n)), \u2200 k : Fin n.succ,\n    \u2203 pos : Fin (2 * n), IsInSemicircle n start pos \u2227 circle.numbers pos = k :=\n  sorry", "formal_statement_pred": "import Mathlib\n\nstructure CircularArrangement (n : \u2115) where\n\n  colors : Fin (2 * n) \u2192 Bool\n\n  numbers : Fin (2 * n) \u2192 Fin n\n\n  blue_contiguous : \u2203 start : Fin (2 * n),\n    \u2200 i : Fin (2 * n), colors i = true \u2194\n      (i.val - start.val) % (2 * n) < n\n\n  blue_count : (Finset.filter (fun i \u21a6 colors \u27e8i, by sorry\u27e9 = true) (Finset.range (2 * n))).card = n\n\n  blue_increasing : \u2200 i j : Fin (2 * n),\n    colors i = true \u2192 colors j = true \u2192\n    (j.val - i.val) % (2 * n) < n \u2192\n    (numbers j).val > (numbers i).val\n\n  red_increasing : \u2200 i j : Fin (2 * n),\n    colors i = false \u2192 colors j = false \u2192\n    (j.val - i.val) % (2 * n) < n \u2192\n    (numbers j).val < (numbers i).val\n\ntheorem semicircle_complete_numbers (n : \u2115) (h : n > 0) :\n  \u2200 c : CircularArrangement n,\n  \u2203 start : Fin (2 * n),\n  let segment := Finset.filter\n    (fun i \u21a6 (i - start.val) % (2 * n) < n)\n    (Finset.range (2 * n))\n  \u2200 k : Fin n, \u2203 pos \u2208 segment, c.numbers \u27e8pos, by sorry\u27e9 = k :=\n  sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_303", "informal_problem": "6. In a chess tournament, each participant played two games with each other: one with white pieces, the other with black. At the end of the tournament, it turned out that everyone had scored the same number of points (1 point for a win, $-1 / 2$ point for a draw, 0 points for a loss). Prove that there will be two participants who won the same number of games with white pieces.\n\n## 9 t h  g r a d e", "formal_statement": "import Mathlib\n\nstructure ChessTournament where\n  n : Nat                             -- number of participants\n  h_pos : n > 0                       -- at least one participant\n  white_wins : Fin n \u2192 Nat            -- number of wins with white pieces for each player\n  black_wins : Fin n \u2192 Nat            -- number of wins with black pieces for each player\n  draws : Fin n \u2192 Nat                 -- number of draws for each player\n  \n  -- Each player plays exactly one game with white and one with black against every other player\n  h_games : \u2200 i, white_wins i + black_wins i + draws i = 2 * (n - 1)\n  \n  -- Total score is the same for all players\n  h_equal_scores : \u2200 i j, \n    white_wins i + black_wins i - draws i / 2 = \n    white_wins j + black_wins j - draws j / 2\n\ntheorem chess_tournament_same_white_wins (t : ChessTournament) : \n  \u2203 i j, i \u2260 j \u2227 t.white_wins i = t.white_wins j :=\n  sorry", "formal_statement_pred": "import Mathlib\n\nstructure ChessTournament where\n  n : Nat\n  h_pos : n > 0\n  white_wins : Fin n \u2192 Nat\n  black_wins : Fin n \u2192 Nat\n  draws : Fin n \u2192 Nat\n\n\n  h_white_games : \u2200 i, white_wins i + (draws i) + (n - 1 - white_wins i - draws i) = n - 1\n\n\n  h_black_games : \u2200 i, black_wins i + (draws i) + (n - 1 - black_wins i - draws i) = n - 1\n\n\n  h_equal_scores : \u2200 i j,\n    (white_wins i + black_wins i : \u211a) + (-1/2 : \u211a) * (draws i) =\n    (white_wins j + black_wins j : \u211a) + (-1/2 : \u211a) * (draws j)\n\ntheorem chess_tournament_pigeonhole (t : ChessTournament) :\n  \u2203 i j, i \u2260 j \u2227 t.white_wins i = t.white_wins j :=\n  sorry", "compiled": true, "aligned": true}
{"id": "CombStruct4Lean_305", "informal_problem": "3-3. From two hundred numbers: $1,2,3,4,5,6,7, \\ldots, 199,200$ one hundred and one numbers are chosen arbitrarily. Prove that among the chosen numbers, there will be two such that one divides the other.", "formal_statement": "import Mathlib\n\ndef isSubset (S : Set Nat) (n : Nat) : Prop :=\n  S \u2286 Finset.range (n + 1) \\ {0}\n\ndef divides_in_set (S : Set Nat) : Prop :=\n  \u2203 a b : Nat, a \u2208 S \u2227 b \u2208 S \u2227 a \u2260 b \u2227 a \u2223 b\n\ntheorem division_in_large_subset :\n  \u2200 S : Set Nat, isSubset S 200 \u2192 S.ncard = 101 \u2192\n  divides_in_set S :=\n  sorry", "formal_statement_pred": "import Mathlib\n\n\n\ntheorem division_property_200 (S : Finset Nat)\n  (h_size : S.card = 101)\n  (h_range : \u2200 x \u2208 S, 1 \u2264 x \u2227 x \u2264 200) :\n  \u2203 (a b : Nat), a \u2208 S \u2227 b \u2208 S \u2227 a \u2260 b \u2227 a \u2223 b :=\n  sorry", "compiled": true, "aligned": true}
{"id": "CombStruct4Lean_306", "informal_problem": "3-3. There are 13 weights, each weighing a whole number of grams. It is known that any 12 of them can be divided into 2 groups of 6 weights each, such that the scales will balance. Prove that all the weights have the same weight.", "formal_statement": "import Mathlib\n\nstructure WeightSet where\n  weights : Fin 13 \u2192 \u2115  -- 13 natural numbers representing weights in grams\n  balanced : \u2200 (excluded : Fin 13),\n    \u2203 (partition : Fin 12 \u2192 Bool),\n    let remaining := {i : Fin 13 | i \u2260 excluded}\n    let group1_sum := \u2211 i in remaining, if partition i then weights i else 0\n    let group2_sum := \u2211 i in remaining, if !partition i then weights i else 0\n    group1_sum = group2_sum \u2227 \n    (\u2211 i in remaining, partition i) = 6 -- Each group has exactly 6 weights\n\ntheorem all_weights_equal (w : WeightSet) : \n  \u2203 (n : \u2115), \u2200 i : Fin 13, w.weights i = n :=\n  sorry", "formal_statement_pred": "import Mathlib\n\n\nstructure WeightSet where\n  weights : Finset \u2115\n  size_eq : Finset.card weights = 13\n\n\ndef isBalancedPartition (S : Finset \u2115) : Prop :=\n  \u2203 (S\u2081 S\u2082 : Finset \u2115),\n    Finset.card S\u2081 = 6 \u2227\n    Finset.card S\u2082 = 6 \u2227\n    S = S\u2081 \u222a S\u2082 \u2227\n    S\u2081 \u2229 S\u2082 = \u2205 \u2227\n    (Finset.sum S\u2081 id) = (Finset.sum S\u2082 id)\n\n\ndef hasBalanceableSubsets (ws : WeightSet) : Prop :=\n  \u2200 w \u2208 ws.weights, isBalancedPartition (ws.weights.erase w)\n\ntheorem all_weights_equal (ws : WeightSet)\n  (h : hasBalanceableSubsets ws) :\n  \u2203 n : \u2115, \u2200 w \u2208 ws.weights, w = n :=\n  sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_307", "informal_problem": "3-4. Can 10 bus routes be laid out in a city and stops be set up on them in such a way that for any 8 routes chosen, there is a stop not lying on any of them, while any 9 routes pass through all stops.", "formal_statement": "import Mathlib\n\nstructure BusSystem where\n  n : Nat -- number of stops\n  stops : Fin n\n  routes : Finset (Finset (Fin n)) -- set of routes, each route is a set of stops\n  route_count : routes.card = 10 -- exactly 10 routes\n  routes_nonempty : \u2200 r \u2208 routes, r.Nonempty -- each route has at least one stop\n\ntheorem bus_system_exists : \u2203 (n : Nat) (bs : BusSystem), \n  (\u2200 S \u2286 bs.routes, S.card = 8 \u2192 \n    \u2203 p : Fin bs.n, \u2200 r \u2208 S, p \u2209 r) \u2227 -- 8-route property\n  (\u2200 S \u2286 bs.routes, S.card = 9 \u2192 \n    \u2200 p : Fin bs.n, \u2203 r \u2208 S, p \u2208 r) -- 9-route property\n  :=\n  sorry", "formal_statement_pred": "import Mathlib\n\nopen Finset\n\nstructure BusSystem where\n  numRoutes : Nat\n  numStops : Nat\n  route_stops : Fin numRoutes \u2192 Finset (Fin numStops)\n\ndef covers_all_stops (bs : BusSystem) (routes : Finset (Fin bs.numRoutes)) : Prop :=\n  \u2200 stop : Fin bs.numStops, \u2203 route \u2208 routes, stop \u2208 bs.route_stops route\n\ndef has_uncovered_stop (bs : BusSystem) (routes : Finset (Fin bs.numRoutes)) : Prop :=\n  \u00ac(covers_all_stops bs routes)\n\ntheorem bus_route_existence : \u2203 (bs : BusSystem),\n  bs.numRoutes = 10 \u2227\n  (\u2200 routes : Finset (Fin bs.numRoutes), card routes = 8 \u2192 has_uncovered_stop bs routes) \u2227\n  (\u2200 routes : Finset (Fin bs.numRoutes), card routes = 9 \u2192 covers_all_stops bs routes) :=\n  sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_308", "informal_problem": "3-\u0447\u0430 3. At the consultation, there were 20 schoolchildren and 20 problems were discussed. It turned out that each of the schoolchildren solved two problems and each problem was solved by two schoolchildren. Prove that it is possible to organize the discussion of the problems in such a way that each schoolchild presents one of the problems they solved and all problems are discussed.", "formal_statement": "import Mathlib\n\nstructure ConsultationGraph where\n  n : Nat\n  h_size : n = 20\n  -- Adjacency relation between students and problems\n  adj : Fin n \u2192 Fin n \u2192 Prop\n  -- Each student solved exactly two problems\n  h_student_solved_two : \u2200 s : Fin n, \u2203 p\u2081 p\u2082, p\u2081 \u2260 p\u2082 \u2227 adj s p\u2081 \u2227 adj s p\u2082 \u2227 \n    \u2200 p\u2083, adj s p\u2083 \u2192 p\u2083 = p\u2081 \u2228 p\u2083 = p\u2082\n  -- Each problem was solved by exactly two students\n  h_problem_solved_by_two : \u2200 p : Fin n, \u2203 s\u2081 s\u2082, s\u2081 \u2260 s\u2082 \u2227 adj s\u2081 p \u2227 adj s\u2082 p \u2227\n    \u2200 s\u2083, adj s\u2083 p \u2192 s\u2083 = s\u2081 \u2228 s\u2083 = s\u2082\n\n/-- A valid presentation matching assigns each student one of their solved problems -/\nstructure PresentationMatching (g : ConsultationGraph) where\n  assignment : Fin g.n \u2192 Fin g.n\n  h_valid : \u2200 s, g.adj s (assignment s)  -- Student presents a problem they solved\n  h_injective : Function.Injective assignment  -- Each problem presented exactly once\n\ntheorem consultation_matching_exists (g : ConsultationGraph) :\n  \u2203 m : PresentationMatching g, True :=\n  sorry", "formal_statement_pred": "import Mathlib\n\nstructure ProblemAssignment (n : Nat) where\n  solved : Fin n \u00d7 Fin n \u2192 Bool\n  solvedTwo : \u2200 i, Fintype.card {j : Fin n | solved (i, j)} = 2\n  twoSolvers : \u2200 j, Fintype.card {i : Fin n | solved (i, j)} = 2\n\nstructure Presentation (n : Nat) where\n  assignment : ProblemAssignment n\n  presenter : Fin n \u2192 Fin n\n  validPresenter : \u2200 j, assignment.solved (presenter j, j)\n  bijective : Function.Bijective presenter\n\ntheorem consultation_presentation_exists (n : Nat) (h\u2081 : n > 0) (h\u2082 : n = 20) :\n  \u2203 (a : ProblemAssignment n) (p : Presentation n), True :=\n  sorry", "compiled": true, "aligned": true}
{"id": "CombStruct4Lean_309", "informal_problem": "3-\u0447\u0430 1. A square \\(17 \\times 17\\) is cut out from a grid paper. The cells of the square are arbitrarily filled with the numbers \\(1,2,3, \\ldots, 70\\), with one and only one number in each cell.\n\nProve that there exist four different cells with centers at points \\(A, B, C, D\\) such that \\(A B=C D, A D=B C\\) and the sum of the numbers in the cells with centers at \\(A\\) and \\(C\\) is equal to the sum of the numbers in the cells with centers at \\(B\\) and \\(D\\).", "formal_statement": "import Mathlib\n\n-- Points on a 17x17 grid\nstructure GridPoint where\n  x : Fin 17\n  y : Fin 17\n\n-- Assignment of numbers 1 to 70 to grid points\nstructure GridAssignment where\n  values : GridPoint \u2192 Fin 71\n  -- Every number from 1 to 70 appears exactly once\n  injective : Function.Injective values\n  range_valid : \u2200 p, (values p).val \u2264 70\n  surjective : \u2200 n : Fin 71, n.val \u2264 70 \u2192 \u2203 p, values p = n\n\n-- Distance between two grid points (squared to avoid Real numbers)\ndef distanceSquared (p q : GridPoint) : \u2115 :=\n  (p.x.val - q.x.val)^2 + (p.y.val - q.y.val)^2\n\n-- Check if four points form a rectangle with equal sides\ndef isRectangle (a b c d : GridPoint) : Prop :=\n  distanceSquared a b = distanceSquared c d \u2227 \n  distanceSquared a d = distanceSquared b c \u2227\n  -- Points are distinct\n  a \u2260 b \u2227 a \u2260 c \u2227 a \u2260 d \u2227 b \u2260 c \u2227 b \u2260 d \u2227 c \u2260 d\n\ntheorem exists_equal_sum_rectangle : \n  \u2200 (g : GridAssignment),\n    \u2203 (a b c d : GridPoint),\n      isRectangle a b c d \u2227 \n      (g.values a).val + (g.values c).val = (g.values b).val + (g.values d).val :=\n  sorry", "formal_statement_pred": "import Mathlib\n\nstructure GridPoint where\n  x : Fin 17\n  y : Fin 17\n\nstructure GridFilling where\n  values : GridPoint \u2192 \u2115\n  values_bound : \u2200 p, values p < 71\n  injective : Function.Injective values\n\ndef distance_squared (a b : GridPoint) : \u2115 :=\n  let dx := (a.x : Int) - (b.x : Int)\n  let dy := (a.y : Int) - (b.y : Int)\n  (dx * dx + dy * dy).toNat\n\ndef isParallelogram (a b c d : GridPoint) : Prop :=\n  distance_squared a b = distance_squared c d \u2227\n  distance_squared a d = distance_squared b c\n\ndef hasEqualSums (g : GridFilling) (a b c d : GridPoint) : Prop :=\n  g.values a + g.values c = g.values b + g.values d\n\ntheorem exists_equal_distances_and_sums (g : GridFilling) :\n  \u2203 (a b c d : GridPoint),\n\n    a \u2260 b \u2227 a \u2260 c \u2227 a \u2260 d \u2227 b \u2260 c \u2227 b \u2260 d \u2227 c \u2260 d \u2227\n\n    isParallelogram a b c d \u2227\n\n    hasEqualSums g a b c d :=\n  sorry", "compiled": true, "aligned": true}
{"id": "CombStruct4Lean_310", "informal_problem": "3-\u0447\u0430 1. A square table with \\(n^{2}\\) cells is filled with numbers from 1 to \\(n\\) such that each row and each column contains all these numbers. If \\(n\\) is odd and the table is symmetric with respect to the diagonal running from the top left corner to the bottom right, then all these numbers \\(1,2,3, \\ldots, n\\) will appear on this diagonal. Prove.", "formal_statement": "import Mathlib\n\nstructure SymmetricTable (n : Nat) where\n  -- The table is represented as a function from coordinates to values\n  values : Fin n \u2192 Fin n \u2192 Fin n\n  -- Each row contains all numbers from 1 to n\n  row_complete : \u2200 i : Fin n, Function.Surjective (values i)\n  -- Each column contains all numbers from 1 to n\n  col_complete : \u2200 j : Fin n, Function.Surjective (fun i => values i j)\n  -- Table is symmetric with respect to main diagonal\n  symmetric : \u2200 (i j : Fin n), values i j = values j i\n\ntheorem diagonal_contains_all_numbers {n : Nat} (h_odd : Odd n) (t : SymmetricTable n) :\n  Function.Surjective (fun i => t.values i i) :=\n  sorry", "formal_statement_pred": "import Mathlib\n\nstructure SymmetricTable (n : Nat) where\n\n  values : Fin n \u2192 Fin n \u2192 Fin n\n\n  row_complete : \u2200 i : Fin n, Function.Surjective (values i)\n\n  col_complete : \u2200 j : Fin n, Function.Surjective (fun i => values i j)\n\n  symmetric : \u2200 (i j : Fin n), values i j = values j i\n\ntheorem diagonal_contains_all_numbers {n : Nat} (h_odd : Odd n) (t : SymmetricTable n) :\n  Function.Surjective (fun i => t.values i i) :=\n  sorry", "compiled": true, "aligned": true}
{"id": "CombStruct4Lean_311", "informal_problem": "3-4. 64 non-negative numbers, the sum of which is 1956, are arranged in the form of a square table: eight numbers in each row and in each column. The sum of the numbers on one of the diagonals is 112. The numbers symmetrically located relative to this diagonal are equal. Prove that the sum of the numbers in any column is less than 1035.", "formal_statement": "import Mathlib\n\nstructure SquareTable where\n  entries : Matrix (Fin 8) (Fin 8) \u211d\n  -- All entries are non-negative\n  non_neg : \u2200 i j, 0 \u2264 entries i j\n  -- Total sum is 1956\n  sum_total : (Finset.univ.sum fun i => Finset.univ.sum fun j => entries i j) = 1956\n  -- Main diagonal sum is 112\n  diag_sum : (Finset.univ.sum fun i => entries i i) = 112\n  -- Symmetry around main diagonal\n  symmetric : \u2200 i j, entries i j = entries j i\n\n/-- Helper definition for column sum -/\ndef columnSum (t : SquareTable) (j : Fin 8) : \u211d :=\n  Finset.univ.sum fun i => t.entries i j\n\ntheorem square_table_column_sum_bound (t : SquareTable) (j : Fin 8) :\n  columnSum t j < 1035 :=\n  sorry", "formal_statement_pred": "import Mathlib\n\nstructure SymmetricTable where\n  entries : Matrix (Fin 8) (Fin 8) NNReal\n  sum_total : (Finset.univ.sum fun i => Finset.univ.sum fun j => entries i j) = 1956\n  diag_sum : (Finset.univ.sum fun i => entries i i) = 112\n  symmetric : \u2200 i j, entries i j = entries j i\n\ndef col_sum (t : SymmetricTable) (j : Fin 8) : NNReal :=\n  Finset.univ.sum fun i => t.entries i j\n\ntheorem square_table_column_sum_bound (t : SymmetricTable) (j : Fin 8) :\n  col_sum t j < 1035 :=\n  sorry", "compiled": true, "aligned": true}
{"id": "CombStruct4Lean_314", "informal_problem": "3-2. In a cube with an edge length of 13, 1956 points are selected. Is it possible to place a cube with an edge length of 1 inside the larger cube so that it does not contain any of the selected points?", "formal_statement": "import Mathlib\n\nstructure Point3D where\n  x : Real\n  y : Real\n  z : Real\n  h_x_bound : 0 \u2264 x \u2227 x \u2264 13\n  h_y_bound : 0 \u2264 y \u2227 y \u2264 13\n  h_z_bound : 0 \u2264 z \u2227 z \u2264 13\n\nstructure UnitCube where\n  corner : Point3D\n  h_x_valid : corner.x + 1 \u2264 13\n  h_y_valid : corner.y + 1 \u2264 13\n  h_z_valid : corner.z + 1 \u2264 13\n\ndef pointInUnitCube (p : Point3D) (c : UnitCube) : Prop :=\n  c.corner.x \u2264 p.x \u2227 p.x \u2264 c.corner.x + 1 \u2227\n  c.corner.y \u2264 p.y \u2227 p.y \u2264 c.corner.y + 1 \u2227\n  c.corner.z \u2264 p.z \u2227 p.z \u2264 c.corner.z + 1\n\ntheorem exists_empty_unit_cube \n  (points : Finset Point3D) \n  (h_count : points.card = 1956) :\n  \u2203 (c : UnitCube), \u2200 p \u2208 points, \u00acpointInUnitCube p c :=\n  sorry", "formal_statement_pred": "import Mathlib\n\nstructure Point3D where\n  x : Real\n  y : Real\n  z : Real\n  h_x : 0 \u2264 x \u2227 x \u2264 13\n  h_y : 0 \u2264 y \u2227 y \u2264 13\n  h_z : 0 \u2264 z \u2227 z \u2264 13\n\nstructure UnitCube where\n  corner : Point3D\n  h_fit : corner.x + 1 \u2264 13 \u2227 corner.y + 1 \u2264 13 \u2227 corner.z + 1 \u2264 13\n\ndef pointInUnitCube (p : Point3D) (c : UnitCube) : Prop :=\n  c.corner.x \u2264 p.x \u2227 p.x \u2264 c.corner.x + 1 \u2227\n  c.corner.y \u2264 p.y \u2227 p.y \u2264 c.corner.y + 1 \u2227\n  c.corner.z \u2264 p.z \u2227 p.z \u2264 c.corner.z + 1\n\ntheorem exists_empty_unit_cube\n  (points : Finset Point3D)\n  (h_count : points.card = 1956) :\n  \u2203 (c : UnitCube), \u2200 p \u2208 points, \u00acpointInUnitCube p c :=\n  sorry", "compiled": true, "aligned": true}
{"id": "CombStruct4Lean_315", "informal_problem": "13.20. Prove that from five vectors, it is always possible to choose two such that the length of their sum does not exceed the length of the sum of the remaining three vectors.", "formal_statement": "import Mathlib\n\nstructure VectorProblem (n : \u2115) (V : Type) [NormedAddCommGroup V] where\n  vectors : Fin n \u2192 V\n\ntheorem vector_sum_inequality {V : Type} [NormedAddCommGroup V] \n  (p : VectorProblem 5 V) : \n  \u2203 (i j : Fin 5), i \u2260 j \u2227 \n    \u2016p.vectors i + p.vectors j\u2016 \u2264 \n    \u2016Finset.sum (Finset.univ.filter (fun k => k \u2260 i \u2227 k \u2260 j)) (fun k => p.vectors k)\u2016 :=\n  sorry", "formal_statement_pred": "import Mathlib\n\n\n\ntheorem vector_sum_inequality {V : Type*} [NormedAddCommGroup V] [CompleteSpace V] (v : Fin 5 \u2192 V) :\n  \u2203 (i j : Fin 5), i \u2260 j \u2227\n    \u2016v i + v j\u2016 \u2264 \u2016\u2211 k in (Finset.univ.filter (\u03bb k => k \u2260 i \u2227 k \u2260 j)), v k\u2016 :=\n  sorry", "compiled": true, "aligned": true}
{"id": "CombStruct4Lean_316", "informal_problem": "14.29. A centrally symmetric figure on graph paper consists of $n$ \"corners\" and $k$ rectangles of size $1 \\times 4$, as shown in Fig. 14.1. Prove that $n$ is even.", "formal_statement": "import Mathlib\n\nstructure GraphPaperFigure where\n  -- The number of corners in the figure\n  corners : Nat\n  -- The number of 1\u00d74 rectangles\n  rectangles : Nat\n  -- Property that the figure is centrally symmetric\n  is_centrally_symmetric : Bool\n  -- All components are properly placed on graph paper\n  valid_placement : Bool\n\n/-- A corner is a shape made of two perpendicular line segments on graph paper -/\nstructure Corner where\n  -- Position of the corner's vertex on the graph paper\n  x : Int\n  y : Int\n  -- Orientation of the corner (which way it points)\n  orientation : Fin 4\n\ntheorem corner_count_even (fig : GraphPaperFigure) \n  (h1 : fig.is_centrally_symmetric = true) \n  (h2 : fig.valid_placement = true) :\n  \u2203 k : Nat, fig.corners = 2 * k :=\n  sorry", "formal_statement_pred": "import Mathlib\n\nstructure GraphPaperFigure where\n  corners : Set (Int \u00d7 Int)\n  rectangles : Set (Int \u00d7 Int \u00d7 Int \u00d7 Int)\n  n : Nat\n  k : Nat\n  is_centrally_symmetric : Bool\n\n\ndef is_valid_corner (c : Int \u00d7 Int) (f : GraphPaperFigure) : Bool :=\n  sorry\n\n\ndef is_valid_rectangle (r : Int \u00d7 Int \u00d7 Int \u00d7 Int) (f : GraphPaperFigure) : Bool :=\n  sorry\n\n\n\ndef has_central_symmetry (f : GraphPaperFigure) : Prop :=\n  \u2200 (x y : Int), (x, y) \u2208 f.corners \u2192 (-x, -y) \u2208 f.corners\n\ntheorem corner_count_even (f : GraphPaperFigure)\n  (h1 : f.is_centrally_symmetric = true)\n  (h2 : \u2200 c \u2208 f.corners, is_valid_corner c f)\n  (h3 : \u2200 r \u2208 f.rectangles, is_valid_rectangle r f)\n  : Even f.n := sorry", "compiled": true, "aligned": true}
{"id": "CombStruct4Lean_318", "informal_problem": "20.30. On the plane, there is an infinite set of rectangles, the vertices of each of which are located at points with coordinates $(0,0)$, $(0, m)$, $(n, 0)$, $(n, m)$, where $n$ and $m$ are positive integers (different for each rectangle). Prove that from these rectangles, two can be chosen such that one is contained within the other.", "formal_statement": "import Mathlib\n\nstructure Rectangle where\n  n : Nat\n  m : Nat\n  pos_n : n > 0\n  pos_m : m > 0\n\n/-- A rectangle R1 is contained within rectangle R2 if R1's width and height\n    are less than or equal to R2's width and height respectively -/\ndef isContainedIn (r1 r2 : Rectangle) : Prop :=\n  r1.n \u2264 r2.n \u2227 r1.m \u2264 r2.m\n\ntheorem infinite_rectangles_containment \n  (S : Set Rectangle) \n  (h_inf : Set.Infinite S) : \n  \u2203 (r1 r2 : Rectangle), r1 \u2208 S \u2227 r2 \u2208 S \u2227 r1 \u2260 r2 \u2227 isContainedIn r1 r2 :=\n  sorry", "formal_statement_pred": "import Mathlib\n\nstructure Rectangle where\n  n : \u2115\n  m : \u2115\n  pos_n : n > 0\n  pos_m : m > 0\n\n\ndef contains (R1 R2 : Rectangle) : Prop :=\n  R1.n \u2264 R2.n \u2227 R1.m \u2264 R2.m\n\ntheorem infinite_rectangles_containment\n  (S : Set Rectangle)\n  (h_inf : Set.Infinite S)\n  (h_form : \u2200 R \u2208 S, R.n > 0 \u2227 R.m > 0) :\n  \u2203 R1 R2 : Rectangle, R1 \u2208 S \u2227 R2 \u2208 S \u2227 R1 \u2260 R2 \u2227 contains R1 R2 :=\n  sorry", "compiled": true, "aligned": true}
{"id": "CombStruct4Lean_319", "informal_problem": "21.1. The nodes of an infinite grid paper are colored in two colors. Prove that there exist two horizontal and two vertical lines, at the intersections of which lie points of the same color.", "formal_statement": "import Mathlib\n\n-- A coloring of the grid is a function from pairs of integers to Bool\n-- where Bool represents the two colors (true and false)\nstructure GridColoring where\n  color : (\u2124 \u00d7 \u2124) \u2192 Bool\n\ntheorem grid_same_color_points (c : GridColoring) :\n  \u2203 (x\u2081 x\u2082 y\u2081 y\u2082 : \u2124) (h\u2081 : x\u2081 \u2260 x\u2082) (h\u2082 : y\u2081 \u2260 y\u2082),\n    let p\u2081\u2081 := (x\u2081, y\u2081)\n    let p\u2081\u2082 := (x\u2081, y\u2082)\n    let p\u2082\u2081 := (x\u2082, y\u2081)\n    let p\u2082\u2082 := (x\u2082, y\u2082)\n    c.color p\u2081\u2081 = c.color p\u2081\u2082 \u2227\n    c.color p\u2081\u2081 = c.color p\u2082\u2081 \u2227\n    c.color p\u2081\u2081 = c.color p\u2082\u2082 :=\n  sorry", "formal_statement_pred": "import Mathlib\n\n\nstructure GridColoring where\n  color : \u2124 \u00d7 \u2124 \u2192 Bool\n\ntheorem grid_same_color_points (c : GridColoring) :\n  \u2203 (x\u2081 x\u2082 y\u2081 y\u2082 : \u2124) (h\u2081 : x\u2081 \u2260 x\u2082) (h\u2082 : y\u2081 \u2260 y\u2082),\n    let p\u2081 := (x\u2081, y\u2081)\n    let p\u2082 := (x\u2081, y\u2082)\n    let p\u2083 := (x\u2082, y\u2081)\n    let p\u2084 := (x\u2082, y\u2082)\n    c.color p\u2081 = c.color p\u2082 \u2227\n    c.color p\u2082 = c.color p\u2083 \u2227\n    c.color p\u2083 = c.color p\u2084 :=\n  sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_320", "informal_problem": "21.19*. On a segment of length 1, several segments are painted, and the distance between any two painted points is not equal to 0.1. Prove that the sum of the lengths of the painted segments does not exceed 0.5.", "formal_statement": "import Mathlib\nopen MeasureTheory\n\n/-- A painted segment on [0,1] represented by its endpoints -/\nstructure PaintedSegment where\n  startPoint : \u211d\n  endPoint : \u211d\n  h_ordered : startPoint \u2264 endPoint\n  h_bounds : startPoint \u2208 Set.Icc (0 : \u211d) (1 : \u211d) \u2227 \n            endPoint \u2208 Set.Icc (0 : \u211d) (1 : \u211d)\n\n/-- A collection of painted segments is valid if no two points from any segments\n    have distance exactly 0.1 -/\ndef ValidPaintedSegments (segments : Finset PaintedSegment) : Prop :=\n  \u2200 s\u2081 \u2208 segments, \u2200 s\u2082 \u2208 segments, \u2200 x \u2208 Set.Icc s\u2081.startPoint s\u2081.endPoint,\n    \u2200 y \u2208 Set.Icc s\u2082.startPoint s\u2082.endPoint, |x - y| \u2260 (1/10 : \u211d)\n\ntheorem painted_segments_bound (segments : Finset PaintedSegment)\n    (h_valid : ValidPaintedSegments segments) :\n    Finset.sum segments (fun s => s.endPoint - s.startPoint) \u2264 (1/2 : \u211d) :=\n  sorry", "formal_statement_pred": "import Mathlib\n\nstructure PaintedSegment where\n  start : Real\n  len : Real\n  h_start : 0 \u2264 start\n  h_end : start + len \u2264 1\n  h_len : len \u2265 0\n\n\nstructure PaintedConfiguration where\n  segments : List PaintedSegment\n  h_valid : \u2200 (p q : Real), (\u2203 s \u2208 segments, p \u2208 [s.start, s.start + s.len]) \u2192\n                            (\u2203 t \u2208 segments, q \u2208 [t.start, t.start + t.len]) \u2192\n                            |p - q| \u2260 0.1\n\ntheorem painted_segments_bound (config : PaintedConfiguration) :\n  (config.segments.map (\u00b7.len)).sum \u2264 0.5 := sorry", "compiled": true, "aligned": true}
{"id": "CombStruct4Lean_322", "informal_problem": "23.14*. In the center of each cell of a chessboard, there is a chip. The chips were rearranged so that the pairwise distances between them did not decrease. Prove that in fact, the pairwise distances did not change.", "formal_statement": "import Mathlib\n\nstructure ChessCoord where\n  x : Fin 8\n  y : Fin 8\n\nstructure BoardPosition where\n  point : \u211d \u00d7 \u211d\n  valid : \u2203 x y : \u2124, \n    point = ((\u2191x : \u211d) + (1/2 : \u211d), (\u2191y : \u211d) + (1/2 : \u211d)) \u2227 \n    0 \u2264 x \u2227 x < 8 \u2227 0 \u2264 y \u2227 y < 8\n\nstructure ChessboardConfiguration where\n  positions : Fin 64 \u2192 BoardPosition\n  distinct : \u2200 i j, i \u2260 j \u2192 positions i \u2260 positions j\n\n/-- Checks if one configuration is a permutation of another -/\ndef is_permutation (c\u2081 c\u2082 : ChessboardConfiguration) : Prop :=\n  \u2203 \u03c3 : Equiv.Perm (Fin 64), \u2200 i, c\u2082.positions i = c\u2081.positions (\u03c3 i)\n\n/-- Checks if one configuration's distances are not smaller than another's -/\ndef has_nondecreasing_distances (c\u2081 c\u2082 : ChessboardConfiguration) : Prop :=\n  \u2200 i j, dist (c\u2081.positions i).point (c\u2081.positions j).point \u2264 \n         dist (c\u2082.positions i).point (c\u2082.positions j).point\n\ntheorem chessboard_rearrangement \n  (initial final : ChessboardConfiguration)\n  (h_perm : is_permutation initial final)\n  (h_dist : has_nondecreasing_distances initial final) :\n  \u2200 i j, dist (initial.positions i).point (initial.positions j).point = \n         dist (final.positions i).point (final.positions j).point :=\nsorry", "formal_statement_pred": "import Mathlib\n\n\nstructure ChessPosition where\n  row : Fin 8\n  col : Fin 8\n\n\ndef squared_distance (p q : ChessPosition) : \u2115 :=\n  (p.row.val - q.row.val)^2 + (p.col.val - q.col.val)^2\n\n\nstructure ChessboardConfiguration where\n  positions : Fin 64 \u2192 ChessPosition\n  injective : Function.Injective positions\n\ntheorem chessboard_rearrangement\n  (initial final : ChessboardConfiguration)\n  (f : Fin 64 \u2192 Fin 64)\n  (h_bij : Function.Bijective f)\n  (h_distances : \u2200 i j : Fin 64, i \u2260 j \u2192\n    squared_distance (initial.positions i) (initial.positions j) \u2264\n    squared_distance (final.positions (f i)) (final.positions (f j))) :\n  \u2200 i j : Fin 64, i \u2260 j \u2192\n    squared_distance (initial.positions i) (initial.positions j) =\n    squared_distance (final.positions (f i)) (final.positions (f j)) :=\n  sorry", "compiled": true, "aligned": true}
{"id": "CombStruct4Lean_323", "informal_problem": "23.20. A beetle sits in each cell of a $5 \\times 5$ board. At some moment, all the beetles crawl to adjacent (horizontally or vertically) cells. Will there necessarily be an empty cell?", "formal_statement": "import Mathlib\n\nstructure Position where\n  row : Fin 5\n  col : Fin 5\nderiving Fintype\n\ndef isAdjacent (p\u2081 p\u2082 : Position) : Prop :=\n  (p\u2081.row = p\u2082.row \u2227 |p\u2081.col - p\u2082.col| = 1) \u2228\n  (p\u2081.col = p\u2082.col \u2227 |p\u2081.row - p\u2082.row| = 1)\n\nstructure Board where\n  beetles : Position \u2192 Bool  -- true means occupied, false means empty\n\nstructure BeetleMove where\n  initial : Board\n  final : Board\n  initial_has_one : \u2200 p : Position, initial.beetles p = true  -- exactly one beetle per position initially\n  valid_moves : \u2200 p\u2081 : Position, initial.beetles p\u2081 = true \u2192 \n    \u2203! p\u2082 : Position, final.beetles p\u2082 = true \u2227 isAdjacent p\u2081 p\u2082  -- each beetle moves to exactly one adjacent cell\n  no_overlap : \u2200 p : Position, final.beetles p \u2192 \n    \u2203! p\u2081 : Position, initial.beetles p\u2081 = true \u2227 isAdjacent p\u2081 p  -- at most one beetle per final position\n\ntheorem beetle_movement_creates_empty_cell :\n  \u2200 (move : BeetleMove), \u2203 p : Position, move.final.beetles p = false :=\n  sorry", "formal_statement_pred": "import Mathlib\n\n\nstructure Pos where\n  row : Fin 5\n  col : Fin 5\n\n\ndef adjacent (p\u2081 p\u2082 : Pos) : Prop :=\n  (p\u2081.row = p\u2082.row \u2227\n    ((p\u2081.col.val + 1 = p\u2082.col.val) \u2228 (p\u2082.col.val + 1 = p\u2081.col.val))) \u2228\n  (p\u2081.col = p\u2082.col \u2227\n    ((p\u2081.row.val + 1 = p\u2082.row.val) \u2228 (p\u2082.row.val + 1 = p\u2081.row.val)))\n\n\nstructure Movement where\n  destination : Pos \u2192 Pos\n  valid_move : \u2200 p, adjacent p (destination p)\n  injective : \u2200 p\u2081 p\u2082, destination p\u2081 = destination p\u2082 \u2192 p\u2081 = p\u2082\n\ntheorem beetle_movement_empty_cell :\n  \u2200 (m : Movement), \u2203 (p : Pos), (\u2200 p\u2080, m.destination p\u2080 \u2260 p) :=\n  sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_324", "informal_problem": "23.27. The bottom of a rectangular box is paved with tiles of size $2 \\times 2$ and $1 \\times 4$. The tiles were spilled out of the box and one $2 \\times 2$ tile was lost. Instead of it, a $1 \\times 4$ tile was taken out. Prove that it is now impossible to pave the bottom of the box with the tiles.", "formal_statement": "import Mathlib\n\nstructure TilingProblem where\n  width : Nat\n  height : Nat\n  tiles_2x2 : Nat      -- number of 2\u00d72 tiles\n  tiles_1x4 : Nat      -- number of 1\u00d74 tiles\n  \n/-- Represents a valid tiling of a rectangle using 2\u00d72 and 1\u00d74 tiles -/\ndef isValidTiling (p : TilingProblem) : Prop :=\n  -- The area covered by all tiles equals the area of the rectangle\n  p.width * p.height = (p.tiles_2x2 * 4 + p.tiles_1x4 * 4)\n\ntheorem impossible_tiling_after_swap \n  (p : TilingProblem) \n  (h_original : isValidTiling p) \n  (h_swap : \u2203 p_new : TilingProblem, \n      p_new.width = p.width \u2227 \n      p_new.height = p.height \u2227 \n      p_new.tiles_2x2 = p.tiles_2x2 - 1 \u2227 \n      p_new.tiles_1x4 = p.tiles_1x4 + 1) : \n  \u00ac isValidTiling (Classical.choose h_swap) :=\nsorry", "formal_statement_pred": "import Mathlib\n\nstructure TilingProblem where\n  width : Nat\n  height : Nat\n  num_2x2 : Nat\n  num_1x4 : Nat\n\n\ndef isValidTiling (p : TilingProblem) : Prop :=\n\n  2 * 2 * p.num_2x2 + 1 * 4 * p.num_1x4 = p.width * p.height\n\ntheorem impossible_tiling_after_swap {w h n\u2081 n\u2082 : Nat}\n  (orig : TilingProblem)\n  (h_orig : isValidTiling orig)\n  (new : TilingProblem)\n  (h_dims : new.width = orig.width \u2227 new.height = orig.height)\n  (h_tiles : new.num_2x2 + 1 = orig.num_2x2 \u2227 new.num_1x4 = orig.num_1x4 + 1) :\n  \u00ac isValidTiling new :=\n  sorry", "compiled": true, "aligned": true}
{"id": "CombStruct4Lean_326", "informal_problem": "23.31. On a grid paper, there are $n$ arbitrary cells. Prove that from them, one can select at least $n / 4$ cells that do not share any common points.", "formal_statement": "import Mathlib\n\n/-- A cell on a finite grid paper with natural number coordinates -/\nstructure GridCell where\n  x : \u2115 \n  y : \u2115\nderiving Repr, BEq, Ord\n\n/-- Two grid cells share a point if they share a vertex or edge -/\ndef share_point (c1 c2 : GridCell) : Prop :=\n  (c1.x = c2.x \u2227 (c1.y = c2.y + 1 \u2228 c1.y = c2.y - 1)) \u2228\n  (c1.y = c2.y \u2227 (c1.x = c2.x + 1 \u2228 c1.x = c2.x - 1)) \u2228\n  (c1.x = c2.x \u2227 c1.y = c2.y)\n\n/-- A set of cells is independent if no two distinct cells share a point -/\ndef is_independent (cells : Finset GridCell) : Prop :=\n  \u2200 (c1 c2 : GridCell), c1 \u2208 cells \u2192 c2 \u2208 cells \u2192 c1 \u2260 c2 \u2192 \u00ac(share_point c1 c2)\n\ntheorem grid_independent_selection {m n : \u2115} (cells : Finset GridCell)\n  (h_size : cells.card = n)\n  (h_bound : \u2200 c \u2208 cells, c.x < m \u2227 c.y < m) :\n  \u2203 (selected : Finset GridCell),\n    selected \u2286 cells \u2227 \n    is_independent selected \u2227 \n    selected.card \u2265 n / 4 :=\n  sorry", "formal_statement_pred": "import Mathlib\n\n\nstructure GridCell where\n  x : \u2115\n  y : \u2115\n  deriving DecidableEq, Repr\n\n\ndef vertically_adjacent (c1 c2 : GridCell) : Bool :=\n  c1.x = c2.x && (c1.y + 1 = c2.y || c2.y + 1 = c1.y)\n\n\ndef horizontally_adjacent (c1 c2 : GridCell) : Bool :=\n  c1.y = c2.y && (c1.x + 1 = c2.x || c2.x + 1 = c1.x)\n\n\ndef diagonally_adjacent (c1 c2 : GridCell) : Bool :=\n  (c1.x + 1 = c2.x || c2.x + 1 = c1.x) && (c1.y + 1 = c2.y || c2.y + 1 = c1.y)\n\n\ndef share_point (c1 c2 : GridCell) : Bool :=\n  (c1.x = c2.x && c1.y = c2.y) ||\n  vertically_adjacent c1 c2 ||\n  horizontally_adjacent c1 c2 ||\n  diagonally_adjacent c1 c2\n\n\ndef independent_cells (cells : Finset GridCell) : Prop :=\n  \u2200 c1 \u2208 cells, \u2200 c2 \u2208 cells, c1 \u2260 c2 \u2192 \u00ac(share_point c1 c2)\n\ntheorem grid_independent_cells (n : \u2115) (cells : Finset GridCell)\n  (h0 : 0 < n)\n  (h1 : cells.card = n) :\n  \u2203 (selected : Finset GridCell),\n    selected.card \u2265 n / 4 \u2227\n    selected \u2286 cells \u2227\n    independent_cells selected :=\n  sorry", "compiled": true, "aligned": true}
{"id": "CombStruct4Lean_328", "informal_problem": "23.35. A plane is colored in two colors. Prove that there are two points of the same color, the distance between which is 1.", "formal_statement": "import Mathlib\n\nopen Real\n\nstructure Point where\n  x : \u211d\n  y : \u211d\n\ndef PlaneColoring (\u03b1 : Type) := Point \u2192 \u03b1\n\nnoncomputable def distance (p\u2081 p\u2082 : Point) : \u211d :=\n  sqrt ((p\u2081.x - p\u2082.x)^2 + (p\u2081.y - p\u2082.y)^2)\n\ntheorem exists_same_color_unit_distance {\u03b1 : Type} (c : PlaneColoring \u03b1) \n    [Fintype \u03b1] [DecidableEq \u03b1] (h : Fintype.card \u03b1 = 2) :\n  \u2203 (p\u2081 p\u2082 : Point), c p\u2081 = c p\u2082 \u2227 distance p\u2081 p\u2082 = 1 :=\n  sorry", "formal_statement_pred": "import Mathlib\n\nstructure Point where\n  x : \u211d\n  y : \u211d\n\ndef PlaneColoring (\u03b1 : Type) := Point \u2192 \u03b1\n\nnoncomputable def distance (p\u2081 p\u2082 : Point) : \u211d :=\n  Real.sqrt ((p\u2081.x - p\u2082.x)^2 + (p\u2081.y - p\u2082.y)^2)\n\ntheorem exists_same_color_unit_distance (c : PlaneColoring Bool) :\n  \u2203 (p\u2081 p\u2082 : Point), c p\u2081 = c p\u2082 \u2227 distance p\u2081 p\u2082 = 1 :=\n  sorry", "compiled": true, "aligned": true}
{"id": "CombStruct4Lean_329", "informal_problem": "23.36*. A plane is painted in three colors. Prove that there are two points of the same color, the distance between which is 1.", "formal_statement": "import Mathlib\n\nstructure ColoredPlane where\n  coloring : \u211d \u00d7 \u211d \u2192 Fin 3\n  -- A function that assigns one of three colors (0, 1, or 2) to each point in \u211d\u00b2\n\ntheorem monocromatic_unit_distance (p : ColoredPlane) : \n  \u2203 (x y : \u211d \u00d7 \u211d), \n    x \u2260 y \u2227 \n    p.coloring x = p.coloring y \u2227 \n    Real.sqrt ((x.1 - y.1)^2 + (x.2 - y.2)^2) = 1 :=\n  sorry", "formal_statement_pred": "import Mathlib\n\nstructure ColoredPlane where\n  coloring : \u211d \u00d7 \u211d \u2192 Fin 3\n\ntheorem exists_same_color_unit_distance (p : ColoredPlane) :\n  \u2203 (x y : \u211d \u00d7 \u211d),\n    p.coloring x = p.coloring y \u2227\n    Real.sqrt ((x.1 - y.1)^2 + (x.2 - y.2)^2) = 1 :=\n  sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_330", "informal_problem": "23.41*. Several circles of the same radius were placed on a table so that no two overlap. Prove that the circles can be colored with four colors so that any two touching circles are of different colors.", "formal_statement": "import Mathlib\n\nstructure CircleConfiguration (\u03b1 : Type*) [MetricSpace \u03b1] where\n  centers : Set \u03b1\n  radius : \u211d\n  radius_pos : radius > 0\n  no_overlap : \u2200 (c\u2081 c\u2082 : {c // c \u2208 centers}), c\u2081 \u2260 c\u2082 \u2192\n    dist c\u2081.val c\u2082.val \u2265 2 * radius\n\ndef Coloring {\u03b1 : Type*} [MetricSpace \u03b1] (cfg : CircleConfiguration \u03b1) := \n  {c // c \u2208 cfg.centers} \u2192 Fin 4\n\ndef TouchingCircles {\u03b1 : Type*} [MetricSpace \u03b1] (cfg : CircleConfiguration \u03b1) \n    (c\u2081 c\u2082 : {c // c \u2208 cfg.centers}) : Prop :=\n  c\u2081 \u2260 c\u2082 \u2227 dist c\u2081.val c\u2082.val = 2 * cfg.radius\n\ntheorem circle_four_coloring {\u03b1 : Type*} [MetricSpace \u03b1] (cfg : CircleConfiguration \u03b1) :\n  \u2203 (coloring : Coloring cfg),\n    \u2200 (c\u2081 c\u2082 : {c // c \u2208 cfg.centers}), \n      TouchingCircles cfg c\u2081 c\u2082 \u2192 coloring c\u2081 \u2260 coloring c\u2082 :=\n  sorry", "formal_statement_pred": "import Mathlib\n\nstructure Point where\n  x : \u211d\n  y : \u211d\n\nnoncomputable def distance (p\u2081 p\u2082 : Point) : \u211d :=\n  Real.sqrt ((p\u2081.x - p\u2082.x)^2 + (p\u2081.y - p\u2082.y)^2)\n\nstructure Circle where\n  center : Point\n  radius : \u211d\n  radius_pos : radius > 0\n\nstructure CircleConfiguration (\u03b1 : Type) [Fintype \u03b1] where\n  circles : \u03b1 \u2192 Circle\n  same_radius : \u2200 (i j : \u03b1), (circles i).radius = (circles j).radius\n  no_overlap : \u2200 (i j : \u03b1), i \u2260 j \u2192\n    distance (circles i).center (circles j).center \u2265 2 * (circles i).radius\n\ndef areTouching {\u03b1 : Type} [Fintype \u03b1] (cfg : CircleConfiguration \u03b1) (i j : \u03b1) : Prop :=\n  i \u2260 j \u2227 distance (cfg.circles i).center (cfg.circles j).center = 2 * (cfg.circles i).radius\n\ntheorem circle_four_coloring {\u03b1 : Type} [Fintype \u03b1] (cfg : CircleConfiguration \u03b1) :\n  \u2203 (coloring : \u03b1 \u2192 Fin 4), \u2200 (i j : \u03b1), areTouching cfg i j \u2192 coloring i \u2260 coloring j :=\n  sorry", "compiled": true, "aligned": true}
{"id": "CombStruct4Lean_331", "informal_problem": "25.46*. A segment of length 1 is covered by several segments lying on it. Prove that among them, one can choose several pairwise non-intersecting segments, the sum of the lengths of which is not less than 0.5.", "formal_statement": "import Mathlib\n\nstructure Segment : Type where\n  start : Real\n  len : Real\n  h_pos : len > 0\n  h_in_unit : start \u2265 0 \u2227 start + len \u2264 1\n  \ndef Segment.endpoint (s : Segment) : Real := s.start + s.len\n\ndef disjoint (s\u2081 s\u2082 : Segment) : Prop :=\n  s\u2081.endpoint \u2264 s\u2082.start \u2228 s\u2082.endpoint \u2264 s\u2081.start\n\ntheorem segment_covering_selection {S : Set Segment} \n  (h_nonempty : Set.Nonempty S)\n  (h_cover : \u2200 x : Real, 0 \u2264 x \u2227 x \u2264 1 \u2192 \u2203 s \u2208 S, s.start \u2264 x \u2227 x < s.endpoint) :\n  \u2203 (T : Finset Segment), \n    (\u2200 s \u2208 T, s \u2208 S) \u2227 \n    (\u2200 s\u2081 s\u2082, s\u2081 \u2208 T \u2227 s\u2082 \u2208 T \u2227 s\u2081 \u2260 s\u2082 \u2192 disjoint s\u2081 s\u2082) \u2227\n    (\u2211 s in T, s.len) \u2265 (1/2 : Real) :=\n  sorry", "formal_statement_pred": "import Mathlib\n\nstructure Segment where\n  start : \u211d\n  len : \u211d\n  length_positive : len > 0\n  within_unit_interval : start \u2265 0 \u2227 start + len \u2264 1\n\n\ndef disjoint (s\u2081 s\u2082 : Segment) : Prop :=\n  s\u2081.start + s\u2081.len \u2264 s\u2082.start \u2228 s\u2082.start + s\u2082.len \u2264 s\u2081.start\n\n\ndef total_length (segments : Finset Segment) : \u211d :=\n  Finset.sum segments (fun s \u21a6 s.len)\n\ntheorem segment_covering_selection (segments : Finset Segment)\n  (h_cover : \u2200 x : \u211d, 0 \u2264 x \u2227 x \u2264 1 \u2192 \u2203 s \u2208 segments, s.start \u2264 x \u2227 x \u2264 s.start + s.len) :\n  \u2203 selected : Finset Segment,\n    selected \u2286 segments \u2227\n    (\u2200 (s\u2081 s\u2082 : Segment), s\u2081 \u2208 selected \u2192 s\u2082 \u2208 selected \u2192 s\u2081 \u2260 s\u2082 \u2192 disjoint s\u2081 s\u2082) \u2227\n    (total_length selected \u2265 0.5) :=\n  sorry", "compiled": true, "aligned": true}
{"id": "CombStruct4Lean_335", "informal_problem": "54. Prove that in Pascal's triangle, the sum of the numbers in the $(n+1)$-th row is equal to $2^{n}$.", "formal_statement": "import Mathlib\n\ndef binomSum (n : \u2115) : \u2115 := \n  Finset.sum (Finset.range (n + 1)) (fun k => Nat.choose n k)\n\ntheorem pascal_row_sum (n : \u2115) : \n  binomSum n = 2^n :=\n  sorry", "formal_statement_pred": "import Mathlib\n\ndef binomSum (n : \u2115) : \u2115 :=\n  Finset.sum (Finset.range (n + 1)) (fun k => Nat.choose n k)\n\ntheorem pascal_row_sum (n : \u2115) :\n  binomSum n = 2^n :=\n  sorry", "compiled": true, "aligned": true}
{"id": "CombStruct4Lean_336", "informal_problem": "63. Let $C_{n}^{k}$ denote the number of ways to light $k$ bulbs out of $n$ (each bulb can be in two states). Prove that the number $C_{n}^{k}$ is located at the $(k+1)$-th position in the $(n+1)$-th row of Pascal's Triangle.", "formal_statement": "import Mathlib\n\n-- A bulb configuration is equivalent to choosing k elements from n elements\nstructure BulbSelection (n : \u2115) where\n  k : \u2115\n  h_valid : k \u2264 n\n\n/-- The position in Pascal's triangle (0-based indexing) -/\ndef pascalPosition (n k : \u2115) : \u2115 \u00d7 \u2115 := (n, k)\n\ntheorem bulb_selection_pascal_triangle (n k : \u2115) (h : k \u2264 n) :\n  Nat.choose n k = Nat.choose (n + 1) k - Nat.choose n (k - 1) :=\n  sorry", "formal_statement_pred": "import Mathlib\n\n\ndef BulbConfig (n : \u2115) := Finset (Fin n)\n\n\ndef pascalTriangleEntry (n k : \u2115) : \u2115 := Nat.choose n k\n\ntheorem bulb_configurations_pascal_triangle (n k : \u2115) (h : k \u2264 n) :\n  (Finset.filter (fun config => config.card = k) (Finset.powerset (Finset.range n))).card =\n  Nat.choose n k :=\n  sorry", "compiled": true, "aligned": true}
{"id": "CombStruct4Lean_337", "informal_problem": "92. In the library, there is a certain number of readers (i.e., people who have read at least one book from this library). For any $k$ books ( $1 \\leqslant k \\leqslant \\boldsymbol{n}$ ), it is known how many readers have read all of them. How can we find out how many readers are in the library? (There are a total of $n$ books in the library.)", "formal_statement": "import Mathlib\n\nstructure LibraryData (n : \u2115) where\n  -- For each subset of books, counts readers who have read all books in that subset\n  readersCount : (s : Finset (Fin n)) \u2192 (0 < s.card \u2227 s.card \u2264 n) \u2192 \u2115\n  -- If t contains s, then readers who read all of t also read all of s\n  mono : \u2200 (s t : Finset (Fin n)) \n         (hs : 0 < s.card \u2227 s.card \u2264 n) \n         (ht : 0 < t.card \u2227 t.card \u2264 n),\n         s \u2286 t \u2192 readersCount t ht \u2264 readersCount s hs\n\ntheorem find_total_readers (n : \u2115) (h : n > 0) (data : LibraryData n) :\n  \u2203! total : \u2115,\n    -- total is the number of readers who read at least one book\n    (\u2200 (s : Finset (Fin n)) (hs : 0 < s.card \u2227 s.card \u2264 n),\n      data.readersCount s hs \u2264 total) \u2227\n    -- total is minimal with this property and consistent with inclusion-exclusion\n    (\u2203 (s : Finset (Fin n)) (hs : 0 < s.card \u2227 s.card \u2264 n),\n      data.readersCount s hs = total) :=\n  sorry", "formal_statement_pred": "import Mathlib\n\nstructure LibraryData (n : \u2115) where\n  readersCount : Finset (Fin n) \u2192 \u2115\n  mono : \u2200 (A B : Finset (Fin n)), A \u2286 B \u2192 readersCount B \u2264 readersCount A\n\ntheorem find_total_readers (n : \u2115) (h : n > 0) (data : LibraryData n) :\n  \u2203! total : \u2115, total = Finset.sum (Finset.powerset (Finset.univ : Finset (Fin n)))\n    (fun S => (-1 : \u2124)^(Finset.card S) * data.readersCount S) :=\n  sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_338", "informal_problem": "1.3. (Czechoslovakia, 52; England, 65). In an infinite \"triangular\" table\n\n\\[\n\\begin{aligned}\n& a_{1,0} \\Leftrightarrow \\&, \\\\\n& a_{2,-1} a_{2,0} a_{2, i} \\\\\n& a_{3,-2} a_{3,-1} a_{3,0} a_{3,1} \\quad a_{3,2} \\\\\n& a_{4,-3} a_{4,-2} a_{4,-1} a_{4,0} a_{4,1} a_{4,2} a_{4,3}\n\\end{aligned}\n\\]\n\n$a_{i, 0}=1$, and each number $a_{n, k}$, located in the $n$-th row $(n \\in \\mathbf{N}, n>1)$ at the $k$-th position $(k \\in \\mathbf{Z},|k|<n)$, is equal to the sum of\n$a_{n-1, k-1}+a_{n-1, k}+a_{n-1, k+1}$ of three numbers from the previous row (if any of these numbers are absent in the table, they are replaced by zero in the sum). Prove that in each row, starting from the \"third\", there is at least one even number.", "formal_statement": "import Mathlib\n\nstructure TriangularArray where\n  table : \u2115 \u2192 \u2124 \u2192 \u2115\n  middle_one : \u2200 n, table n 0 = 1\n  bounds : \u2200 n k, Int.natAbs k \u2265 n \u2192 table n k = 0\n  sum_rule : \u2200 n k, n > 1 \u2192 Int.natAbs k < n \u2192\n    table n k = (if k = 0 then 1 \n                else table (n-1) (k-1) + table (n-1) k + table (n-1) (k+1))\n\ndef isValidPos (n : \u2115) (k : \u2124) : Prop := k < n \u2227 k > -n\n\ntheorem exists_even_number_from_third_row (A : TriangularArray) (n : \u2115) (h : n \u2265 3) :\n  \u2203 k : \u2124, isValidPos n k \u2227 Even (A.table n k) :=\n  sorry", "formal_statement_pred": "import Mathlib\n\n\ndef validIndex (n : \u2115) (k : \u2124) : Prop := -n \u2264 k \u2227 k \u2264 n\n\n\nstructure TriangularTable where\n  value : (n : \u2115) \u2192 (k : \u2124) \u2192 \u2115\n  valid_index : \u2200 n k, value n k \u2260 0 \u2192 validIndex n k\n  middle_one : \u2200 n, value n 0 = 1\n  sum_rule : \u2200 n k, k \u2260 0 \u2192 validIndex (n + 1) k \u2192\n    value (n + 1) k = value n (k - 1) + value n k + value n (k + 1)\n\ntheorem triangular_table_even_exists (t : TriangularTable) (n : \u2115) (h : n \u2265 3) :\n  \u2203 k : \u2124, validIndex n k \u2227 Even (t.value n k) :=\n  sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_339", "informal_problem": "3.4. (USA, 82). Prove that for any value of $n \\in \\mathbf{N}$, the following equality holds:\n\n$$\n\\sum_{k=0}^{n} \\frac{(2 n)!}{(k!)^{2}((n-k)!)^{2}}=\\left(C_{2 n}^{n}\\right)^{2}\n$$", "formal_statement": "import Mathlib\n\ndef binomialSum (n : \u2115) : \u211a :=\n  (Finset.range (n + 1)).sum (fun k => \n    (Nat.factorial (2 * n)) / \n    ((Nat.factorial k)^2 * (Nat.factorial (n - k))^2))\n\ntheorem usa_82_binomial_sum_equality (n : \u2115) : \n  binomialSum n = (Nat.choose (2 * n) n)^2 :=\n  sorry", "formal_statement_pred": "import Mathlib\n\ndef summand (n k : \u2115) : \u211a :=\n  \u2191(Nat.factorial (2 * n)) / (\u2191(Nat.factorial k)^2 * \u2191(Nat.factorial (n - k))^2)\n\ntheorem usa_1982_3_4 (n : \u2115) :\n  \u2211 k in Finset.range (n + 1), summand n k = (\u2191(Nat.choose (2 * n) n))^2 := sorry", "compiled": true, "aligned": true}
{"id": "CombStruct4Lean_340", "informal_problem": "3.6. (New York, 74). Prove that for any natural values $n \\geqslant k$ the greatest common divisor of the numbers $C_{n}^{k}, C_{n+1}^{k}, \\ldots, C_{n+k}^{k}$ is 1.", "formal_statement": "import Mathlib\n\ndef binomialGCD (n k : \u2115) : \u2115 :=\n  let coeffs := (List.range (k + 1)).map (fun i => Nat.choose (n + i) k)\n  match coeffs with\n  | [] => 1\n  | (x :: xs) => xs.foldl Nat.gcd x\n\ntheorem binomial_gcd_one (n k : \u2115) (h\u2081 : k \u2265 0) (h\u2082 : n \u2265 k) : \n  binomialGCD n k = 1 :=\n  sorry", "formal_statement_pred": "import Mathlib\n\ndef binomialSequence (n k : \u2115) : List \u2115 :=\n  (List.range (k + 1)).map (fun i => Nat.choose (n + i) k)\n\ndef binomialSequenceGcd (n k : \u2115) : \u2115 :=\n  match binomialSequence n k with\n  | [] => 1\n  | x :: xs => List.foldl Nat.gcd x xs\n\ntheorem binomial_sequence_gcd_one (n k : \u2115) (hk : k > 0) (h : n \u2265 k) :\n  binomialSequenceGcd n k = 1 :=\n  sorry", "compiled": true, "aligned": true}
{"id": "CombStruct4Lean_341", "informal_problem": "3.12*. (NBR, 68). Prove that the number $C_{n}^{\\prime 2}$ is odd if and only if the numbers $n, k \\in \\mathbf{N}$ satisfy the condition: if in some digit of the binary representation of the number $k$ there is a 1, then in the same digit of the binary representation of the number $n$ there is also a 1.", "formal_statement": "import Mathlib\n\ndef hasBitImplication (n k : Nat) : Prop :=\n  \u2200 i : Nat, Nat.bit k i = true \u2192 Nat.bit n i = true\n\ntheorem binomial_odd_iff_bit_implication (n k : Nat) :\n  Odd (Nat.choose n 2) \u2194 hasBitImplication n k :=\n  sorry", "formal_statement_pred": "import Mathlib\n\ndef binary_contains (n k : \u2115) : Prop :=\n  \u2200 i, Nat.testBit k i = true \u2192 Nat.testBit n i = true\n\n\ndef stirling1 (n k : \u2115) : \u2115 :=\n  if n = 0 \u2227 k = 0 then 1\n  else if n = 0 \u2228 k = 0 then 0\n  else stirling1 (n-1) (k-1) - (n-1) * stirling1 (n-1) k\n\ntheorem stirling_one_two_odd_iff (n k : \u2115) :\n  Odd (stirling1 n 2) \u2194 binary_contains n k :=\n  sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_342", "informal_problem": "4.1. (SRP, 78). Prove that for any partition of the set\n\n$$\nX=\\{1 ; 2 ; 3 ; 4 ; 5 ; 6 ; 7 ; 8 ; 9\\}\n$$\n\ninto two subsets, at least one of the resulting subsets contains 3 numbers such that the sum of two of them is twice the third.", "formal_statement": "import Mathlib\n\ndef has_sum_twice_relation (s : Set Nat) : Prop :=\n  \u2203 (a b c : Nat), a \u2208 s \u2227 b \u2208 s \u2227 c \u2208 s \u2227 a + b = 2 * c\n\ntheorem partition_contains_sum_twice :\n  let X : Set Nat := {1, 2, 3, 4, 5, 6, 7, 8, 9}\n  \u2200 (A B : Set Nat), A \u222a B = X \u2192 A \u2229 B = \u2205 \u2192 \n    has_sum_twice_relation A \u2228 has_sum_twice_relation B :=\n  sorry", "formal_statement_pred": "import Mathlib\n\ndef has_sum_twice_relation (s : Set Nat) : Prop :=\n  \u2203 (a b c : Nat), a \u2208 s \u2227 b \u2208 s \u2227 c \u2208 s \u2227 a + b = 2 * c\n\ndef is_partition (A B : Set Nat) (X : Set Nat) : Prop :=\n  A \u222a B = X \u2227 A \u2229 B = \u2205\n\ntheorem partition_contains_sum_twice :\n  let X : Set Nat := {1, 2, 3, 4, 5, 6, 7, 8, 9}\n  \u2200 A B : Set Nat, is_partition A B X \u2192\n    has_sum_twice_relation A \u2228 has_sum_twice_relation B :=\n  sorry", "compiled": true, "aligned": true}
{"id": "CombStruct4Lean_344", "informal_problem": "4.20*. (Jury, Finland, 79). A set $\\left(a_{1} ; \\ldots ; a_{n}\\right)$ of natural numbers satisfying the equation\n\n$$\na_{1}+2 a_{2}+\\ldots+n a_{n}=1979\n$$\n\nis called even if the number $r$ is even, and is called odd if the number $n$ is odd. Prove that there are as many even sets as there are odd sets.", "formal_statement": "import Mathlib\n\nstructure NumberSet where\n  n : Nat\n  n_pos : 0 < n\n  seq : Fin n \u2192 Nat\n  sum_eq : (\u2211 i : Fin n, (i.val + 1) * seq i) = 1979\n\ndef isEvenSet (s : NumberSet) : Prop := Even s.n\ndef isOddSet (s : NumberSet) : Prop := Odd s.n\n\ntheorem even_odd_sets_equal :\n  \u2203 (f : NumberSet \u2192 NumberSet) (g : NumberSet \u2192 NumberSet),\n    (\u2200 s, isEvenSet s \u2192 isOddSet (f s)) \u2227\n    (\u2200 s, isOddSet s \u2192 isEvenSet (g s)) \u2227\n    (\u2200 s, g (f s) = s) \u2227 (\u2200 s, f (g s) = s) :=\n  sorry", "formal_statement_pred": "import Mathlib\n\nstructure WeightedSum where\n  n : \u2115\n  sequence : Fin n \u2192 \u2115\n  n_pos : 0 < n\n  sum_property : (\u2211 i : Fin n, (i.val + 1) * sequence i) = 1979\n\ndef EvenSolutions := {s : WeightedSum // s.n % 2 = 0}\ndef OddSolutions := {s : WeightedSum // s.n % 2 = 1}\n\ntheorem solutions_cardinality [Fintype EvenSolutions] [Fintype OddSolutions] :\n  Fintype.card EvenSolutions = Fintype.card OddSolutions :=\n  sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_345", "informal_problem": "17.9. (Jury, France, 82). Let all members of the sequences $\\left\\{a_{n}\\right\\}$ and $\\left\\{b_{n}\\right\\}$ be natural numbers. Prove that there exists a pair of indices $p<q$, for which the inequalities $a_{p} \\leqslant a_{q}$ and $b_{p} \\leqslant b_{q}$ hold.", "formal_statement": "import Mathlib\n\nstructure FiniteSequences where\n  n : \u2115\n  a : \u2115 \u2192 \u2115\n  b : \u2115 \u2192 \u2115\n\ntheorem exists_nondecreasing_pair {s : FiniteSequences} :\n  \u2203 (p q : \u2115), p < q \u2227 s.a p \u2264 s.a q \u2227 s.b p \u2264 s.b q :=\n  sorry", "formal_statement_pred": "import Mathlib\n\n\n\ntheorem exists_nondecreasing_pair (a b : \u2115 \u2192 \u2115) :\n  \u2203 p q : \u2115, p < q \u2227 a p \u2264 a q \u2227 b p \u2264 b q :=\n  sorry", "compiled": true, "aligned": true}
{"id": "CombStruct4Lean_346", "informal_problem": "24.5. (England, 76). Let 50 subsets $A_{1}, \\ldots, A_{50}$ be chosen in a finite set $X$, each of which contains more than half of the elements of the set $X$. Prove that one can find a subset $B \\subset X$, containing no more than 5 elements and having at least one element in common with each of the sets $A_{1}, \\ldots, A_{50}$.", "formal_statement": "import Mathlib\n\nstructure SubsetSystem (X : Type u) [Finite X] where\n  subsets : Fin 50 \u2192 Set X\n  subset_size_prop : \u2200 i, 2 * Cardinal.mk (subsets i) > Cardinal.mk X\n\ntheorem england_76 {X : Type u} [Finite X] (sys : SubsetSystem X) :\n  \u2203 B : Set X, Cardinal.mk B \u2264 5 \u2227 \u2200 i : Fin 50, Set.Nonempty (sys.subsets i \u2229 B) :=\n  sorry", "formal_statement_pred": "import Mathlib\n\nstructure SubsetSystem where\n  X : Type\n  [decEq : DecidableEq X]\n  [fintype : Fintype X]\n  n : \u2115\n  subsets : Fin n \u2192 Finset X\n  large_subsets : \u2200 i, 2 * (subsets i).card > Fintype.card X\n\ntheorem england_76 (sys : SubsetSystem) (h : sys.n = 50) :\n  \u2203 B : Finset sys.X, B.card \u2264 5 \u2227 \u2200 i : Fin sys.n, \u2203 x \u2208 B, x \u2208 sys.subsets i :=\n  sorry", "compiled": true, "aligned": true}
{"id": "CombStruct4Lean_347", "informal_problem": "25.7. (Yugoslavia, 75). In a certain society, any two acquaintances do not have common acquaintances, and any two non-acquaintances have exactly two common acquaintances. Prove that in this society everyone has the same number of acquaintances.", "formal_statement": "import Mathlib\n\n/-- A society where relationships between people follow specific acquaintance rules -/\nstructure Society (Person : Type) [Fintype Person] [Nonempty Person] where\n  acquainted : Person \u2192 Person \u2192 Prop\n  [decRel : DecidableRel acquainted]\n  -- Basic relationship properties\n  basic_props : \n    (\u2200 p, \u00acacquainted p p) \u2227 \n    (\u2200 p\u2081 p\u2082, acquainted p\u2081 p\u2082 \u2194 acquainted p\u2082 p\u2081)\n  -- Core society properties\n  society_props :\n    (\u2200 p\u2081 p\u2082, acquainted p\u2081 p\u2082 \u2192 \u2200 p\u2083, \u00ac(acquainted p\u2081 p\u2083 \u2227 acquainted p\u2082 p\u2083)) \u2227\n    (\u2200 p\u2081 p\u2082, \u00acacquainted p\u2081 p\u2082 \u2192 \n      \u2203! (s : Finset Person), (\u2200 p \u2208 s, acquainted p\u2081 p \u2227 acquainted p\u2082 p) \u2227 s.card = 2)\n\n/-- Counts the number of people who are acquainted with a given person -/\ndef acquaintance_count {Person : Type} [Fintype Person] [Nonempty Person] \n    (S : Society Person) (x : Person) : Nat := \n  have := S.decRel\n  (Finset.univ.filter (fun y => S.acquainted x y)).card\n\n/-- In a society with at least two people where:\n    1) any two acquaintances have no common acquaintances\n    2) any two non-acquaintances have exactly two common acquaintances\n    everyone has the same number of acquaintances -/\ntheorem all_same_acquaintance_count {Person : Type} [Fintype Person] [Nonempty Person]\n    (S : Society Person) (h : 2 \u2264 Fintype.card Person) :\n    \u2200 p\u2081 p\u2082 : Person, acquaintance_count S p\u2081 = acquaintance_count S p\u2082 :=\n  sorry", "formal_statement_pred": "import Mathlib\n\nstructure Society (\u03b1 : Type) [Fintype \u03b1] where\n  acquainted : \u03b1 \u2192 \u03b1 \u2192 Bool\n\n  nontrivial : 2 \u2264 Fintype.card \u03b1\n\n  symm : \u2200 p\u2081 p\u2082, acquainted p\u2081 p\u2082 = acquainted p\u2082 p\u2081\n\n  no_self : \u2200 p, acquainted p p = false\n\n  acq_no_common : \u2200 p\u2081 p\u2082, acquainted p\u2081 p\u2082 = true \u2192\n    \u2200 p\u2083, \u00ac(acquainted p\u2081 p\u2083 = true \u2227 acquainted p\u2082 p\u2083 = true)\n\n  non_acq_two_common : \u2200 p\u2081 p\u2082, acquainted p\u2081 p\u2082 = false \u2192\n    (Finset.filter (fun x => acquainted p\u2081 x = true \u2227 acquainted p\u2082 x = true) Finset.univ).card = 2\n\n\ndef acquaintance_count {\u03b1 : Type} [Fintype \u03b1] (S : Society \u03b1) (p : \u03b1) : \u2115 :=\n  (Finset.filter (fun x => S.acquainted p x = true) Finset.univ).card\n\ntheorem all_same_acquaintance_count {\u03b1 : Type} [Fintype \u03b1] (S : Society \u03b1) :\n  \u2200 p\u2081 p\u2082 : \u03b1, acquaintance_count S p\u2081 = acquaintance_count S p\u2082 :=\n  sorry", "compiled": true, "aligned": true}
{"id": "CombStruct4Lean_348", "informal_problem": "25.8. (VNR, 77). In each of three schools, there are $n$ students. Any student has a total of $n+1$ acquaintances among students from the other two schools. Prove that it is possible to choose one student from each school such that all three chosen students are acquainted with each other.", "formal_statement": "import Mathlib\n\nstructure ThreeSchools (n : \u2115) where\n  acq12 : Fin n \u2192 Finset (Fin n)  -- School 1 \u2192 School 2\n  acq21 : Fin n \u2192 Finset (Fin n)  -- School 2 \u2192 School 1\n  acq23 : Fin n \u2192 Finset (Fin n)  -- School 2 \u2192 School 3\n  acq32 : Fin n \u2192 Finset (Fin n)  -- School 3 \u2192 School 2\n  acq13 : Fin n \u2192 Finset (Fin n)  -- School 1 \u2192 School 3\n  acq31 : Fin n \u2192 Finset (Fin n)  -- School 3 \u2192 School 1\n  symm12 : \u2200 x y, y \u2208 acq12 x \u2194 x \u2208 acq21 y\n  symm23 : \u2200 x y, y \u2208 acq23 x \u2194 x \u2208 acq32 y\n  symm13 : \u2200 x y, y \u2208 acq13 x \u2194 x \u2208 acq31 y\n  acq_count : \u2200 x : Fin n,\n    (acq12 x).card + (acq13 x).card = n + 1 \u2227    -- School 1 student\n    (acq21 x).card + (acq23 x).card = n + 1 \u2227    -- School 2 student\n    (acq31 x).card + (acq32 x).card = n + 1      -- School 3 student\n\ntheorem three_schools_acquaintance \n    (n : \u2115) \n    (h1 : n > 0) \n    (h2 : n + 1 \u2264 2*n)  -- Ensures n+1 acquaintances is possible\n    (schools : ThreeSchools n) :\n  \u2203 (s1 s2 s3 : Fin n), \n    s2 \u2208 schools.acq12 s1 \u2227 \n    s3 \u2208 schools.acq23 s2 \u2227 \n    s3 \u2208 schools.acq13 s1 :=\n  sorry", "formal_statement_pred": "import Mathlib\n\nstructure ThreeSchools (n : \u2115) where\n\n\n  acq12 : Fin n \u2192 Fin n \u2192 Bool\n  acq23 : Fin n \u2192 Fin n \u2192 Bool\n  acq13 : Fin n \u2192 Fin n \u2192 Bool\n\n\n  acq_count_12 : \u2200 x : Fin n, (((List.finRange n).filter (fun y \u21a6 acq12 x y)).length +\n                               ((List.finRange n).filter (fun y \u21a6 acq13 x y)).length) = n + 1\n  acq_count_23 : \u2200 x : Fin n, (((List.finRange n).filter (fun y \u21a6 acq23 x y)).length +\n                               ((List.finRange n).filter (fun y \u21a6 acq12 y x)).length) = n + 1\n  acq_count_31 : \u2200 x : Fin n, (((List.finRange n).filter (fun y \u21a6 acq13 y x)).length +\n                               ((List.finRange n).filter (fun y \u21a6 acq23 y x)).length) = n + 1\n\ntheorem three_schools_acquaintance (n : \u2115) (h : n > 0) (schools : ThreeSchools n) :\n  \u2203 (x y z : Fin n), schools.acq12 x y \u2227 schools.acq23 y z \u2227 schools.acq13 x z :=\n  sorry", "compiled": true, "aligned": true}
{"id": "CombStruct4Lean_349", "informal_problem": "26.2. (Jury, NRB, 79). On a grid paper, $n$ cells are marked arbitrarily. Prove that it is always possible to select at least $n / 4$ cells from them, such that no two selected cells touch each other (cells are considered touching if they share at least one vertex).", "formal_statement": "import Mathlib\n\n/-- A cell on the grid paper is represented by its coordinates -/\nstructure GridCell where\n  x : Int\n  y : Int\n\n/-- Two cells are touching if they share at least one vertex -/\ndef touching (c1 c2 : GridCell) : Prop :=\n  max (abs (c1.x - c2.x)) (abs (c1.y - c2.y)) \u2264 1\n\n/-- A set of cells is independent if no two cells in the set are touching -/\ndef isIndependent (cells : Finset GridCell) : Prop :=\n  \u2200 c1 c2, c1 \u2208 cells \u2192 c2 \u2208 cells \u2192 c1 \u2260 c2 \u2192 \u00actouching c1 c2\n\ntheorem grid_independent_cells {n : \u2115} (marked : Finset GridCell)\n    (h : marked.card = n) :\n    \u2203 (selected : Finset GridCell),\n      selected \u2286 marked \u2227\n      isIndependent selected \u2227\n      selected.card \u2265 n / 4 :=\n  sorry", "formal_statement_pred": "import Mathlib\n\n\nstructure MarkedCell where\n  x : Int\n  y : Int\nderiving Inhabited, DecidableEq, Ord\n\n\ndef areTouching (c1 c2 : MarkedCell) : Prop :=\n  max (Int.natAbs (c1.x - c2.x)) (Int.natAbs (c1.y - c2.y)) \u2264 1\n\n\ndef isIndependentSet (cells : Finset MarkedCell) : Prop :=\n  \u2200 (c1 c2 : MarkedCell), c1 \u2208 cells \u2192 c2 \u2208 cells \u2192 c1 \u2260 c2 \u2192 \u00ac(areTouching c1 c2)\n\ntheorem grid_independent_set_exists (n : \u2115+) (marked : Finset MarkedCell)\n    (h_card : marked.card = n) :\n    \u2203 (independent : Finset MarkedCell),\n      independent \u2286 marked \u2227\n      isIndependentSet independent \u2227\n      independent.card \u2265 n / 4 :=\n  sorry", "compiled": true, "aligned": true}
{"id": "CombStruct4Lean_350", "informal_problem": "26.14. (USA, 76). a) Let each cell of a rectangular board of size $4 \\times 7$ be colored either white or black. Prove that there must be a rectangle on the board, formed by horizontal and vertical lines of the board, all four corner cells of which are colored the same color.\n\nb) Provide an example of a coloring of a rectangular board of size $4 \\times 6$ for which the rectangle mentioned in part a) does not exist.", "formal_statement": "import Mathlib\n\n-- Represent a board coloring as a function from positions to Bool\n-- where True represents white and False represents black\nstructure BoardColoring (m n : Nat) where\n  color : Fin m \u2192 Fin n \u2192 Bool\n\n-- Define what it means to have a monochromatic rectangle\ndef hasMonochromaticRectangle (m n : Nat) (board : BoardColoring m n) : Prop :=\n  \u2203 (r\u2081 r\u2082 : Fin m) (c\u2081 c\u2082 : Fin n),\n    r\u2081 < r\u2082 \u2227 c\u2081 < c\u2082 \u2227\n    (board.color r\u2081 c\u2081 = board.color r\u2081 c\u2082) \u2227\n    (board.color r\u2081 c\u2081 = board.color r\u2082 c\u2081) \u2227\n    (board.color r\u2081 c\u2081 = board.color r\u2082 c\u2082)\n\ntheorem board_4x7_has_monochromatic_rectangle :\n  \u2200 (board : BoardColoring 4 7), hasMonochromaticRectangle 4 7 board :=\n  sorry", "formal_statement_pred": "import Mathlib\n\nstructure ColoredBoard where\n  rows : Nat\n  cols : Nat\n  coloring : Fin rows \u2192 Fin cols \u2192 Bool\n\ndef hasMonochromaticRectangle (board : ColoredBoard) : Prop :=\n  \u2203 (r\u2081 r\u2082 : Fin board.rows) (c\u2081 c\u2082 : Fin board.cols),\n    r\u2081 < r\u2082 \u2227 c\u2081 < c\u2082 \u2227\n    (board.coloring r\u2081 c\u2081 = board.coloring r\u2081 c\u2082 \u2227\n     board.coloring r\u2082 c\u2081 = board.coloring r\u2082 c\u2082 \u2227\n     board.coloring r\u2081 c\u2081 = board.coloring r\u2082 c\u2081)\n\ntheorem four_by_seven_monochromatic_rectangle :\n  \u2200 (board : ColoredBoard),\n    board.rows = 4 \u2227 board.cols = 7 \u2192\n    hasMonochromaticRectangle board :=\n  sorry", "compiled": true, "aligned": true}
{"id": "CombStruct4Lean_351", "informal_problem": "26.15. (Sweden, 82). On a plane with a rectangular coordinate system, consider the set $M$ of points $(x, y)$, where $x, y \\in \\mathbf{N}$, and $x \\leqslant 12, y \\leqslant 12$. Each of these 144 points is colored either red, white, or blue. Prove that there exists a rectangle (with sides parallel to the axes) all of whose vertices belong to the set $M$ and are of the same color.", "formal_statement": "import Mathlib\n\n-- Define a color type for the three possible colors\ninductive Color where\n  | Red : Color\n  | White : Color\n  | Blue : Color\n  deriving Repr, DecidableEq\n\n-- Define a coloring as a function from coordinates to colors\ndef Coloring := (Fin 13 \u00d7 Fin 13) \u2192 Color\n\n-- Define what it means to have a monochromatic rectangle\ndef HasMonochromaticRectangle (c : Coloring) : Prop :=\n  \u2203 (x\u2081 x\u2082 : Fin 13) (y\u2081 y\u2082 : Fin 13),\n    x\u2081 < x\u2082 \u2227 y\u2081 < y\u2082 \u2227\n    c (x\u2081, y\u2081) = c (x\u2081, y\u2082) \u2227\n    c (x\u2081, y\u2081) = c (x\u2082, y\u2081) \u2227\n    c (x\u2081, y\u2081) = c (x\u2082, y\u2082)\n\ntheorem sweden_1982 :\n  \u2200 c : Coloring, HasMonochromaticRectangle c :=\n  sorry", "formal_statement_pred": "import Mathlib\n\ninductive Color where\n  | Red : Color\n  | White : Color\n  | Blue : Color\n\nstructure ColoredGrid where\n  coloring : Fin 13 \u2192 Fin 13 \u2192 Color\n\ndef isMonochromaticRectangle (grid : ColoredGrid) (x\u2081 y\u2081 x\u2082 y\u2082 : Fin 13) : Prop :=\n  x\u2081 < x\u2082 \u2227 y\u2081 < y\u2082 \u2227\n  grid.coloring x\u2081 y\u2081 = grid.coloring x\u2081 y\u2082 \u2227\n  grid.coloring x\u2081 y\u2081 = grid.coloring x\u2082 y\u2081 \u2227\n  grid.coloring x\u2081 y\u2081 = grid.coloring x\u2082 y\u2082\n\ntheorem exists_monochromatic_rectangle :\n  \u2200 (grid : ColoredGrid),\n  \u2203 (x\u2081 y\u2081 x\u2082 y\u2082 : Fin 13),\n  isMonochromaticRectangle grid x\u2081 y\u2081 x\u2082 y\u2082 :=\n  sorry", "compiled": true, "aligned": true}
{"id": "CombStruct4Lean_355", "informal_problem": "19*. In the country of Dolphinia, there are $n$ cities, each pair of which is connected by a highway, and movement along all highways is one-way. Prove that if $n \\neq 2$ or 4, the directions of movement along the highways can be chosen such that from any city to any other city, one can travel with no more than one intermediate stop; if, however, $n=2$ or 4, such movement cannot be organized.", "formal_statement": "import Mathlib\n\nopen Function\n\n/-- A directed graph where each pair of vertices has exactly one directed edge -/\nstructure DirectedGraph (n : Nat) where\n  edges : Fin n \u2192 Fin n \u2192 Prop                   -- directed edges as propositions\n  exclusive : \u2200 i j, i \u2260 j \u2192                     -- exactly one direction between distinct vertices\n    (edges i j \u2194 \u00acedges j i)\n  no_self_loops : \u2200 i, \u00acedges i i               -- no self-loops\n\n/-- A path of length exactly k exists between two vertices -/\ndef PathOfLength (G : DirectedGraph n) (k : Nat) (i j : Fin n) : Prop :=\n  match k with\n  | 0 => i = j\n  | 1 => G.edges i j\n  | 2 => \u2203 v, G.edges i v \u2227 G.edges v j\n  | _ => False\n\n/-- There exists a path of length at most 2 between vertices -/\ndef HasShortPath (G : DirectedGraph n) (i j : Fin n) : Prop :=\n  \u2203 k \u2264 2, PathOfLength G k i j\n\n/-- For n \u2260 2,4, a directed graph exists where all paths are \u2264 2; \n    for n = 2,4, no such graph exists -/\ntheorem dolphinia_cities :\n  \u2200 n : Nat, (n = 2 \u2228 n = 4) \u2194 \n    \u00ac\u2203 (G : DirectedGraph n), \u2200 i j : Fin n, HasShortPath G i j :=\n  sorry", "formal_statement_pred": "import Mathlib\n\nstructure DirectedGraph (n : Nat) where\n  edge : Fin n \u2192 Fin n \u2192 Prop\n  one_way : \u2200 i j, i \u2260 j \u2192 (edge i j \u2194 \u00acedge j i)\n  no_self_loops : \u2200 i, \u00acedge i i\n\ndef hasPathAtMostLength2 {n : Nat} (g : DirectedGraph n) (i j : Fin n) : Prop :=\n  i \u2260 j \u2227 (\n    g.edge i j \u2228\n    \u2203 k, k \u2260 i \u2227 k \u2260 j \u2227 g.edge i k \u2227 g.edge k j\n  )\n\ntheorem dolphinia_routing :\n  \u2200 n, (n = 2 \u2228 n = 4) \u2194\n    \u00ac\u2203 (g : DirectedGraph n),\n      \u2200 i j : Fin n, hasPathAtMostLength2 g i j :=\n  sorry", "compiled": true, "aligned": true}
{"id": "CombStruct4Lean_356", "informal_problem": "173. A square table of $n^{2}$ cells is filled with integers from 1 to $n$ such that each row and each column of the table contains all numbers from 1 to $n$. Prove that if the table is symmetric with respect to the diagonal leading from its upper left corner to the lower right corner, and $n$ is odd, then all numbers from 1 to $n$ will appear on this diagonal. Will this statement also be true when $n$ is even?", "formal_statement": "import Mathlib\n\nstructure SymmetricTable (n : Nat) where\n  -- The table represented as a function from row and column indices to values\n  values : Fin n \u2192 Fin n \u2192 Fin n\n  -- Each row contains all numbers from 1 to n\n  row_complete : \u2200 i : Fin n, Function.Surjective (values i)\n  -- Each column contains all numbers from 1 to n\n  col_complete : \u2200 j : Fin n, Function.Surjective (fun i => values i j)\n  -- Table is symmetric across main diagonal\n  symmetric : \u2200 (i j : Fin n), values i j = values j i\n\ntheorem diagonal_contains_all_odd (n : Nat) (h : n > 0) (hodd : Odd n) \n  (t : SymmetricTable n) : Function.Surjective (fun i => t.values i i) :=\n  sorry", "formal_statement_pred": "import Mathlib\n\nstructure SquareTable (n : \u2115) where\n\n  entries : Fin n \u2192 Fin n \u2192 Fin n\n\n  row_complete : \u2200 i : Fin n, Function.Surjective (entries i)\n\n  col_complete : \u2200 j : Fin n, Function.Surjective (fun i => entries i j)\n\n  symmetric : \u2200 (i j : Fin n), entries i j = entries j i\n\n\ndef mainDiagonal {n : \u2115} (t : SquareTable n) : Fin n \u2192 Fin n :=\n  fun i => t.entries i i\n\ntheorem diagonal_contains_all_odd (n : \u2115) (h_odd : Odd n) (t : SquareTable n) :\n  Function.Surjective (mainDiagonal t) :=\n  sorry", "compiled": true, "aligned": true}
{"id": "CombStruct4Lean_357", "informal_problem": "103*. a) Show that there exist nine pairwise distinct squares from which a certain rectangle can be formed.\n\nb) From 10 pairwise distinct squares, form a rectangle with sides 47 and 65.\n\nc) Show that for any number $n$, greater than eight, it is always possible to find $n$ pairwise distinct squares from which a rectangle can be formed.", "formal_statement": "import Mathlib\n\n-- Part (a) and (b) are specific instances of part (c), so we'll formalize the general case\n\n/-- A configuration of squares that form a rectangle -/\nstructure SquareRectConfig where\n  n : \u2115                     -- number of squares\n  squares : Fin n \u2192 \u2115       -- the side lengths of the squares\n  distinct : \u2200 i j, i \u2260 j \u2192 squares i \u2260 squares j  -- squares are pairwise distinct\n  width : \u2115                 -- width of the rectangle\n  height : \u2115                -- height of the rectangle\n  forms_rectangle : width * height = (\u2211 i, (squares i) ^ 2)  -- squares form the rectangle\n\ntheorem squares_form_rectangle (n : \u2115) (h : n > 8) : \n  \u2203 (config : SquareRectConfig), config.n = n :=\n  sorry", "formal_statement_pred": "import Mathlib\n\nstructure SquareSet where\n  squares : List Nat\n  distinct : squares.Pairwise (\u00b7\u2260\u00b7)\n  all_squares : \u2200 x \u2208 squares, \u2203 n, x = n * n\n\nstructure Rectangle where\n  width : Nat\n  height : Nat\n  area : Nat\n  area_eq : area = width * height\n\ndef canFormRectangle (s : List Nat) : Prop :=\n  \u2203 (w h : Nat), w > 0 \u2227 h > 0 \u2227 w * h = s.sum\n\ntheorem square_rectangle_existence\n  (n : Nat) (h : n \u2265 9) :\n  \u2203 (s : SquareSet),\n    s.squares.length = n \u2227\n    canFormRectangle s.squares :=\n  sorry", "compiled": true, "aligned": true}
{"id": "CombStruct4Lean_358", "informal_problem": "8. Prove that in any group of six schoolchildren, there are always either three schoolchildren who are all acquainted with each other, or three schoolchildren, each of whom is not acquainted with the other two.", "formal_statement": "import Mathlib\n\n-- Define a type for representing acquaintance relationships\nstructure AcquaintanceGraph where\n  -- A function that returns true if two children are acquainted\n  knows : Fin 6 \u2192 Fin 6 \u2192 Bool\n  -- The relation is symmetric\n  symm : \u2200 i j, knows i j = knows j i\n  -- A child cannot be acquainted with themselves\n  irrefl : \u2200 i, knows i i = false\n\ntheorem ramsey_acquaintance_theorem (g : AcquaintanceGraph) :\n  (\u2203 (a b c : Fin 6), \n    -- Either there are three children who all know each other\n    (g.knows a b \u2227 g.knows b c \u2227 g.knows a c) \u2228\n    -- Or there are three children who all don't know each other\n    (\u00acg.knows a b \u2227 \u00acg.knows b c \u2227 \u00acg.knows a c)) :=\n  sorry", "formal_statement_pred": "import Mathlib\n\n\nstructure AcquaintanceGraph where\n  n : Nat\n  knows : Fin n \u2192 Fin n \u2192 Bool\n  symm : \u2200 i j, knows i j = knows j i\n  irrefl : \u2200 i, knows i i = false\n\n\ndef hasTriangle (g : AcquaintanceGraph) : Prop :=\n  \u2203 i j k : Fin g.n, i \u2260 j \u2227 j \u2260 k \u2227 i \u2260 k \u2227\n    g.knows i j \u2227 g.knows j k \u2227 g.knows i k\n\n\ndef hasAntiTriangle (g : AcquaintanceGraph) : Prop :=\n  \u2203 i j k : Fin g.n, i \u2260 j \u2227 j \u2260 k \u2227 i \u2260 k \u2227\n    \u00acg.knows i j \u2227 \u00acg.knows j k \u2227 \u00acg.knows i k\n\ntheorem ramsey_r33 (g : AcquaintanceGraph) (h : g.n = 6) :\n  hasTriangle g \u2228 hasAntiTriangle g :=\n  sorry", "compiled": true, "aligned": true}
{"id": "CombStruct4Lean_359", "informal_problem": "9. In a chess tournament, $n$ chess players, including grandmasters and masters, participated. After the tournament, it turned out that each participant scored exactly half of their points in games against masters. Prove that $\\sqrt{n}$ is an integer.", "formal_statement": "import Mathlib\n\nstructure ChessPlayer where\n  isMaster : Bool\n  points : Nat\n  gamesAgainstMasters : Nat\n  pointsAgainstMasters : Nat\n\nstructure ChessTournament where\n  n : Nat\n  players : Fin n \u2192 ChessPlayer\n  -- Each player's total points is twice their points against masters\n  points_condition : \u2200 i, (players i).points = 2 * (players i).pointsAgainstMasters\n\ntheorem chess_tournament_sqrt_integer (t : ChessTournament) :\n  \u2203 k : Nat, t.n = k * k :=\n  sorry", "formal_statement_pred": "import Mathlib\n\ninductive PlayerClass\n  | Master\n  | NonMaster\n  deriving Repr, DecidableEq\n\nstructure ChessTournament where\n  n : Nat\n  pos_n : n > 0\n  master_count : Nat\n  master_count_valid : master_count \u2264 n\n  players : Fin n \u2192 PlayerClass\n  games : Matrix (Fin n) (Fin n) Rat\n\n\n  valid_scores : \u2200 i j, 0 \u2264 games i j \u2227 games i j \u2264 1\n  antisymmetric_scores : \u2200 i j, games i j + games j i = 1\n  no_self_games : \u2200 i, games i i = 0\n\n\n  half_points : \u2200 i,\n    (\u2211 j, if players j = PlayerClass.Master then games i j else 0) =\n    (1/2 : Rat) * (\u2211 j, games i j)\n\ntheorem chess_tournament_perfect_square (t : ChessTournament) :\n  \u2203 k : Nat, t.n = k * k :=\n  sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_360", "informal_problem": "22**. A circle is divided into 256 sectors. Prove that it is possible to write an eight-digit number, consisting only of ones and twos (for example, 12212111, 22121121), in each sector such that: a) any two numbers will be different, b) any two numbers in adjacent sectors will differ in exactly one digit.", "formal_statement": "import Mathlib\n\n-- Define valid digits (1 or 2)\ndef Digit := {n : Nat // n = 1 \u2228 n = 2}\n\n-- An 8-digit number is a function from positions to digits\ndef Number := Fin 8 \u2192 Digit\n\n-- Helper to check if two numbers differ in exactly one position\ndef differsInOneDigit (n1 n2 : Number) : Prop :=\n  \u2203! pos : Fin 8, n1 pos \u2260 n2 pos\n\n-- Main structure representing the circular arrangement\nstructure CircularArrangement where\n  -- Assignment of numbers to sectors\n  numbers : Fin 256 \u2192 Number\n  -- All numbers must be different\n  all_different : \u2200 i j : Fin 256, i \u2260 j \u2192 numbers i \u2260 numbers j\n  -- Adjacent sectors differ in exactly one digit\n  adjacent_differ : \u2200 i : Fin 256,\n    differsInOneDigit (numbers i) (numbers ((i.val + 1) % 256))\n\ntheorem circular_arrangement_exists : \u2203 arr : CircularArrangement, True :=\n  sorry", "formal_statement_pred": "import Mathlib\n\n\nstructure BinaryNumber where\n  digits : Fin 8 \u2192 Fin 2\n\n\n\ndef differByOneDigit (n\u2081 n\u2082 : BinaryNumber) : Prop :=\n  \u2203 (pos : Fin 8),\n    (\u2200 (i : Fin 8), i \u2260 pos \u2192 n\u2081.digits i = n\u2082.digits i) \u2227\n    n\u2081.digits pos \u2260 n\u2082.digits pos\n\n\nstructure SectorAssignment where\n  numbers : Fin 256 \u2192 BinaryNumber\n  all_different : \u2200 (i j : Fin 256), i \u2260 j \u2192 numbers i \u2260 numbers j\n  adjacent_differ_by_one : \u2200 (i : Fin 256),\n    differByOneDigit (numbers i) (numbers ((i + 1) % 256))\n\ntheorem circle_sector_assignment_exists : \u2203 (assignment : SectorAssignment), True :=\n  sorry", "compiled": true, "aligned": true}
{"id": "CombStruct4Lean_361", "informal_problem": "28**. In the Martian language, the alphabet consists of the letters $A$ and O. Any two words of the same length differ in at least three positions. Prove that the number of words of length $n$ is no more than $2^{n} /(n+1)$.", "formal_statement": "import Mathlib\n\ndef hamming_distance {n : Nat} (w\u2081 w\u2082 : Fin n \u2192 Bool) : Nat :=\n  (Finset.filter (fun i => w\u2081 i \u2260 w\u2082 i) (Finset.univ : Finset (Fin n))).card\n\nstructure MartianLanguage where\n  n : Nat\n  words : Finset (Fin n \u2192 Bool)\n  valid_distance : \u2200 w\u2081 w\u2082, w\u2081 \u2208 words \u2192 w\u2082 \u2208 words \u2192 w\u2081 \u2260 w\u2082 \u2192\n    hamming_distance w\u2081 w\u2082 \u2265 3\n\ntheorem martian_language_bound (n : Nat) (L : MartianLanguage) :\n  L.words.card * (n + 1) \u2264 2^n := sorry", "formal_statement_pred": "import Mathlib\n\ndef hammingDistance {n : Nat} (w\u2081 w\u2082 : Fin n \u2192 Fin 2) : Nat :=\n  Finset.card (Finset.filter (fun i => w\u2081 i \u2260 w\u2082 i) (Finset.univ))\n\nstructure MartianLanguage where\n  n : Nat\n  words : Finset (Fin n \u2192 Fin 2)\n  valid_distance : \u2200 w\u2081 w\u2082, w\u2081 \u2208 words \u2192 w\u2082 \u2208 words \u2192 w\u2081 \u2260 w\u2082 \u2192\n    hammingDistance w\u2081 w\u2082 \u2265 3\n\ntheorem martian_language_bound {n : Nat} (L : MartianLanguage) (h : L.n = n) :\n  (L.words).card \u2264 2^n/(n+1) := sorry", "compiled": true, "aligned": true}
{"id": "CombStruct4Lean_362", "informal_problem": "38. In class 4A, there are 30 students. During a dictation, one student made 12 mistakes, and the others made fewer. Prove that there are at least three students in the class who made the same number of mistakes.", "formal_statement": "import Mathlib\n\nstructure DictationClass where\n  numStudents : \u2115\n  mistakes : Fin numStudents \u2192 \u2115\n\ntheorem pigeonhole_dictation\n  (c : DictationClass)\n  (h_size : c.numStudents = 30)\n  (h_bound : \u2200 i, c.mistakes i \u2264 12) :\n  \u2203 m : \u2115, \u2203 s : Finset (Fin c.numStudents),\n    s.card = 3 \u2227 \n    (\u2200 i \u2208 s, c.mistakes i = m) :=\n  sorry", "formal_statement_pred": "import Mathlib\n\nstructure MistakeCount where\n  count_map : Fin 30 \u2192 Nat\n  bound : \u2200 i, count_map i \u2264 12\n  has_max : \u2203 i, count_map i = 12\n\ntheorem mistake_pigeonhole (mc : MistakeCount) :\n  \u2203 m : Nat, \u2203 i j k : Fin 30,\n    i \u2260 j \u2227 j \u2260 k \u2227 i \u2260 k \u2227\n    mc.count_map i = m \u2227 mc.count_map j = m \u2227 mc.count_map k = m :=\n  sorry", "compiled": true, "aligned": true}
{"id": "CombStruct4Lean_363", "informal_problem": "39. 30 teams participate in a football championship. Each pair of teams must play one match against each other. Prove that at any moment during the competitions, there are two teams that have played the same number of matches up to that point.", "formal_statement": "import Mathlib\n\n-- A team's state in the championship is represented by the number of matches played\nstructure TeamState where\n  matches_played : Nat\n\n-- The championship state tracks the number of matches played by each team\nstructure ChampionshipState where\n  n_teams : Nat\n  team_states : Fin n_teams \u2192 TeamState\n  -- Each pair of teams must eventually play one match\n  total_matches_constraint : n_teams = 30\n\ntheorem pigeonhole_in_championship (state : ChampionshipState) :\n  \u2203 (i j : Fin state.n_teams), i \u2260 j \u2227\n    (state.team_states i).matches_played = (state.team_states j).matches_played :=\n  sorry", "formal_statement_pred": "import Mathlib\n\n\nstructure MatchConfiguration where\n  n : Nat\n  matches_played : Fin n \u2192 Nat\n  h_valid : \u2200 i : Fin n, matches_played i \u2264 (n - 1)\n\ntheorem football_matches_pigeonhole\n  (config : MatchConfiguration)\n  (h_teams : config.n = 30) :\n  \u2203 (i j : Fin config.n), i \u2260 j \u2227 config.matches_played i = config.matches_played j :=\n  sorry", "compiled": true, "aligned": true}
{"id": "CombStruct4Lean_366", "informal_problem": "72. Seven mushroom pickers collected a total of 100 mushrooms, and each of the seven collected a different number of mushrooms. Prove that there are three mushroom pickers who together collected no fewer than 50 mushrooms.", "formal_statement": "import Mathlib\n\nstructure MushroomCollection where\n  pickers : Fin 7 \u2192 Nat\n  total_is_100 : (\u2211 i, pickers i) = 100\n  all_different : \u2200 i j, i \u2260 j \u2192 pickers i \u2260 pickers j\n\ntheorem mushroom_pickers_theorem (c : MushroomCollection) :\n  \u2203 (i j k : Fin 7), i \u2260 j \u2227 j \u2260 k \u2227 i \u2260 k \u2227\n    c.pickers i + c.pickers j + c.pickers k \u2265 50 :=\n  sorry", "formal_statement_pred": "import Mathlib\n\nstructure MushroomCollection where\n  pickers : Fin 7 \u2192 Nat\n  total_is_100 : (\u2211 i, pickers i) = 100\n  all_different : \u2200 i j, i \u2260 j \u2192 pickers i \u2260 pickers j\n\ntheorem mushroom_pickers_theorem (c : MushroomCollection) :\n  \u2203 (i j k : Fin 7), i \u2260 j \u2227 j \u2260 k \u2227 i \u2260 k \u2227\n    c.pickers i + c.pickers j + c.pickers k \u2265 50 :=\n  sorry", "compiled": true, "aligned": true}
{"id": "CombStruct4Lean_367", "informal_problem": "76**. Several numbers are arranged around a circle, the sum of which is positive. Prove that one can choose such a number that it itself is positive, the sum of it and the next one in the clockwise direction is positive, and so on.", "formal_statement": "import Mathlib\n\nstructure CircularArrangement (n : \u2115) [NeZero n] where\n  numbers : ZMod n \u2192 \u211d\n  sum_pos : (Finset.sum (Finset.univ : Finset (ZMod n)) numbers) > 0\n\ndef consecutive_sum {n : \u2115} [NeZero n] (numbers : ZMod n \u2192 \u211d) (start : ZMod n) (k : \u2115) : \u211d :=\n  Finset.sum (Finset.range k) fun i => numbers (start + i)\n\ntheorem exists_positive_consecutive_sums {n : \u2115} [NeZero n] (arr : CircularArrangement n) :\n  \u2203 start : ZMod n, \u2200 k : \u2115, k \u2264 n \u2192 consecutive_sum arr.numbers start k > 0 :=\n  sorry", "formal_statement_pred": "import Mathlib\n\nstructure CircularArrangement (n : \u2115) where\n  numbers : Fin n \u2192 \u211d\n  size_pos : n > 0\n  sum_pos : (\u2211 i, numbers i) > 0\n\n\ndef consecutive_sum {n : \u2115} (arr : CircularArrangement n) (start len : \u2115) : \u211d :=\n  \u2211 i in Finset.range len, arr.numbers \u27e8(start + i) % n, sorry\u27e9\n\ntheorem exists_good_start {n : \u2115} (arr : CircularArrangement n) :\n  \u2203 start : Fin n, \u2200 len : \u2115, len \u2264 n \u2192 consecutive_sum arr start.val len \u2265 0 :=\n  sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_368", "informal_problem": "Example 9. Prove the recurrence formula for binomial probabilities:\n\n$$\nP_{n}(k+1)=\\frac{p}{q} \\frac{n-k}{k+1} P_{n}(k)\n$$", "formal_statement": "import Mathlib\n\ndef binomialProb (n k : \u2115) (p : \u211d) : \u211d :=\n  (n.choose k) * p^k * (1-p)^(n-k)\n\ntheorem binomial_prob_recurrence \n  (n k : \u2115) (p q : \u211d) \n  (h1 : k < n)\n  (h2 : p + q = 1) \n  (h3 : p \u2260 0) \n  (h4 : q \u2260 0) :\n  binomialProb n (k+1) p = (p/q) * ((n-k)/(k+1)) * binomialProb n k p :=\n  sorry", "formal_statement_pred": "import Mathlib\n\ndef binomialProb (n k : \u2115) (p : \u211d) : \u211d :=\n  (n.choose k) * p^k * (1-p)^(n-k)\n\ntheorem binomial_prob_recurrence\n  (n k : \u2115) (p : \u211d) (h1 : 0 < p) (h2 : p < 1) (h3 : k + 1 \u2264 n) :\n  binomialProb n (k+1) p = (p/(1-p)) * ((n-k)/(k+1)) * binomialProb n k p :=\n  sorry", "compiled": true, "aligned": true}
{"id": "CombStruct4Lean_369", "informal_problem": "17. (\u00abMatching Problem\u00bb.) Suppose there are $n$ letters and $n$ envelopes. The letters are placed into the envelopes \"randomly,\" meaning that the assignment of probabilities is done according to the \"classical\" method of defining probabilities. Let $P_{(m)}$ be the probability that exactly $m$ letters end up in their \"correct\" envelopes.\n\nShow that\n\n$$\nP_{(m)}=\\frac{1}{m!}\\left(1+\\sum_{j=1}^{n-m} \\frac{(-1)^{j}}{j!}\\right)\n$$", "formal_statement": "import Mathlib\n\n/-- The probability of exactly m letters being correctly placed in n envelopes\n    under the classical probability model (uniform distribution over permutations).\n    This is computed as (number of permutations with m fixed points) / n! -/\ndef matching_probability (n m : \u2115) : \u211a :=\n  let derangement_sum (k : \u2115) : \u211a := \u2211 j in Finset.range (k + 1), ((-1 : \u211a)^j / (Nat.factorial j : \u211a))\n  let derangement (k : \u2115) : \u211a := (Nat.factorial k : \u211a) * derangement_sum k\n  (Nat.choose n m : \u211a) * derangement (n - m) / (Nat.factorial n : \u211a)\n\ntheorem matching_probability_formula (n m : \u2115) (h\u2081 : m \u2264 n) (h\u2082 : n > 0) :\n  matching_probability n m = \n    1 / (Nat.factorial m : \u211a) * \n      (1 + \u2211 j in Finset.range (n - m), ((-1 : \u211a)^j / (Nat.factorial j : \u211a))) :=\n  sorry", "formal_statement_pred": "import Mathlib\n\n\ndef countFixedPoints (n : \u2115) (\u03c3 : Equiv.Perm (Fin n)) : \u2115 :=\n  Finset.card (Finset.filter (fun i => \u03c3 i = i) Finset.univ)\n\n\ndef countPermsWithFixedPoints (n m : \u2115) : \u2115 :=\n  Finset.card (Finset.filter (fun \u03c3 => countFixedPoints n \u03c3 = m) (Finset.univ))\n\n\ndef MatchingProbability (n m : \u2115) : \u211a\u22650 :=\n  \u27e8(\u2191(countPermsWithFixedPoints n m) : \u211a) / \u2191(Nat.factorial n),\n   by sorry\u27e9\n\ntheorem matching_probability_formula (n m : \u2115)\n  (h\u2081 : m \u2264 n) (h\u2082 : m \u2260 0) (h\u2083 : n > 0) :\n  (MatchingProbability n m).val =\n    (1 : \u211a) / \u2191(Nat.factorial m) *\n    (1 + \u2211 j in Finset.range (n - m), ((-1 : \u211a) ^ j) / \u2191(Nat.factorial j)) :=\n  sorry", "compiled": true, "aligned": true}
{"id": "CombStruct4Lean_370", "informal_problem": "22. From an urn containing $M$ balls numbered $1, \\ldots, M$, a \"random\" selection is made $n$ times with replacement. Consider the event $A_{k}$, which consists of the maximum number of the drawn balls being $k$. Show that\n\n$$\n\\mathrm{P}\\left(A_{k}\\right)=\\frac{k^{n}-(k-1)^{n}}{N^{n}}\n$$\n\nAlso show that if the selection is made without replacement, then\n\n$$\n\\mathrm{P}\\left(A_{k}\\right)=\\frac{C_{k-1}^{n-1}}{C_{N}^{k}}, \\quad n \\leqslant k \\leqslant N .\n$$", "formal_statement": "import Mathlib\n\nstructure DrawingExperiment where\n  M : \u2115                 -- Total number of balls in urn\n  n : \u2115                 -- Number of draws\n  k : \u2115                 -- Maximum number considered\n  h1 : k \u2264 M           -- Maximum number must be less than or equal to total balls\n  h2 : n > 0           -- Number of draws must be positive\n\n/-- Probability of maximum number being k in n draws with replacement -/\ndef probWithReplacement (e : DrawingExperiment) : \u211a :=\n  (e.k ^ e.n - (e.k - 1) ^ e.n) / e.M ^ e.n\n\n/-- Probability of maximum number being k in n draws without replacement -/\ndef probWithoutReplacement (e : DrawingExperiment) : \u211a :=\n  Nat.choose (e.k - 1) (e.n - 1) / Nat.choose e.M e.k\n\ntheorem drawing_probability_correct (e : DrawingExperiment) :\n  let withRepl := probWithReplacement e\n  let withoutRepl := probWithoutReplacement e\n  (withRepl = (e.k ^ e.n - (e.k - 1) ^ e.n) / e.M ^ e.n) \u2227\n  (e.n \u2264 e.k \u2192 withoutRepl = Nat.choose (e.k - 1) (e.n - 1) / Nat.choose e.M e.k) :=\n  sorry", "formal_statement_pred": "import Mathlib\n\nstructure DrawingExperiment where\n  M : \u2115\n  n : \u2115\n  k : \u2115\n  h1 : k \u2264 M\n  h2 : n > 0\n\n\ndef prob_with_replacement (e : DrawingExperiment) : \u211a :=\n  (e.k ^ e.n - (e.k - 1) ^ e.n) / e.M ^ e.n\n\n\ndef prob_without_replacement (e : DrawingExperiment) : \u211a :=\n  Nat.choose (e.k - 1) (e.n - 1) / Nat.choose e.M e.k\n\ntheorem drawing_probability_theorem (e : DrawingExperiment) :\n  let with_repl := prob_with_replacement e\n  let without_repl := prob_without_replacement e\n  (with_repl = (e.k ^ e.n - (e.k - 1) ^ e.n) / e.M ^ e.n) \u2227\n  (e.n \u2264 e.k \u2192 without_repl = Nat.choose (e.k - 1) (e.n - 1) / Nat.choose e.M e.k) :=\n  sorry", "compiled": true, "aligned": true}
{"id": "CombStruct4Lean_371", "informal_problem": "8. Prove the following duality property of Stirling numbers of the first and second kind:\n\n$$\n\\sum_{n \\geqslant 0} S_{N}^{n} s_{n}^{M}=\\delta_{N M}\n$$\n\nwhere $\\delta_{a b}$ is the Kronecker delta ( $\\delta_{a a}=1, \\delta_{a b}=0$, if $a \\neq b$ ).", "formal_statement": "import Mathlib\n\ndef StirlingFirst (n k : \u2115) : \u2124 :=\n  if n = 0 \u2227 k = 0 then 1\n  else if k = 0 \u2228 n = 0 then 0\n  else StirlingFirst (n-1) (k-1) - (n-1) * StirlingFirst (n-1) k\n\ndef StirlingSecond (n k : \u2115) : \u2124 :=\n  if n = 0 \u2227 k = 0 then 1\n  else if k = 0 \u2228 n = 0 then 0\n  else StirlingSecond (n-1) (k-1) + k * StirlingSecond (n-1) k\n\ndef KroneckerDelta (a b : \u2115) : \u2124 :=\n  if a = b then 1 else 0\n\ntheorem stirling_duality (N M : \u2115) :\n  (\u2211' (n : \u2115), (StirlingFirst N n) * (StirlingSecond n M)) = KroneckerDelta N M :=\n  sorry", "formal_statement_pred": "import Mathlib\n\ndef StirlingFirst (n k : \u2115) : \u2124 :=\n  if n = 0 \u2227 k = 0 then 1\n  else if k = 0 \u2228 n = 0 then 0\n  else StirlingFirst (n-1) (k-1) - (n-1) * StirlingFirst (n-1) k\n\ndef StirlingSecond (n k : \u2115) : \u2124 :=\n  if n = 0 \u2227 k = 0 then 1\n  else if k = 0 \u2228 n = 0 then 0\n  else StirlingSecond (n-1) (k-1) + k * StirlingSecond (n-1) k\n\ndef KroneckerDelta (a b : \u2115) : \u2124 :=\n  if a = b then 1 else 0\n\ntheorem stirling_duality (N M : \u2115) :\n  (\u2211' n, (StirlingFirst N n) * (StirlingSecond n M)) = KroneckerDelta N M :=\n  sorry", "compiled": true, "aligned": true}
{"id": "CombStruct4Lean_372", "informal_problem": "16. Let $P_{N}=\\sum_{n=0}^{N}(N)_{n}$ be the total number of arrangements of $N$ elements $\\left((N)_{0}=1,(N)_{n}=N(N-1) \\ldots(N-n+1)\\right), N \\geqslant 1$. Show that the numbers $P_{N}$ satisfy the following recurrence relations ( $P_{0}=1$ ):\n\n$$\nP_{N}=N P_{N-1}+1, \\quad N \\geqslant 1\n$$\n\nShow also that\n\n$$\nP_{N}=N!\\sum_{n=0}^{N} \\frac{1}{n!}\n$$\n\nand that $P_{N}$ is the nearest integer to $e N!$.", "formal_statement": "import Mathlib\n\nopen Nat BigOperators\n\ndef falling_factorial (N n : \u2115) : \u2115 := \n  if n = 0 then 1\n  else Finset.prod (Finset.range n) fun i => (N - i)\n\ndef P (N : \u2115) : \u2115 := \n  Finset.sum (Finset.range (N + 1)) fun n => falling_factorial N n\n\ntheorem P_recurrence_and_sum_and_nearest {N : \u2115} (h : 0 < N) : \n  -- First part: recurrence relation\n  P N = N * P (N-1) + 1 \u2227 \n  -- Second part: factorial sum representation\n  (P N : \u211d) = N.factorial * \u2211 n in Finset.range (N + 1), 1 / n.factorial \u2227\n  -- Third part: nearest integer to e\u22c5N!\n  |P N - Real.exp 1 * N.factorial| \u2264 1/2 :=\n  sorry", "formal_statement_pred": "import Mathlib\n\ndef P (N : \u2115) : \u2115 :=\n  if N = 0 then 1\n  else \u2211 n in Finset.range (N + 1), (Nat.descFactorial N n)\n\n\ndef factorialSum (N : \u2115) : \u211a :=\n  \u2211 n in Finset.range (N + 1), 1 / (Nat.factorial n)\n\ntheorem P_properties (N : \u2115) :\n  (N \u2265 1 \u2192 P N = N * P (N-1) + 1) \u2227\n  P N = N! * (factorialSum N) \u2227\n  |P N - (Real.exp 1) * N!| < (1/2) :=\n  sorry", "compiled": true, "aligned": true}
{"id": "CombStruct4Lean_374", "informal_problem": "32. Let sets $A_{1}, \\ldots, A_{N} \\subset\\{1, \\ldots, n\\}$ be such that none of them is a subset of any other. Prove Sperner's lemma, which states that\n\n$$\nN \\leqslant C_{n}^{[n / 2]}\n$$\n\nwhere $[x]$ is the integer part of $x \\in \\mathbb{R}$.", "formal_statement": "import Mathlib\n\n\n\ntheorem sperner_lemma {\u03b1 : Type*} [Fintype \u03b1] (\ud835\udc9c : Finset (Finset \u03b1))\n  (h : IsAntichain (\u00b7 \u2286 \u00b7) (\ud835\udc9c : Set (Finset \u03b1))) :\n  \ud835\udc9c.card \u2264 (Fintype.card \u03b1).choose (Fintype.card \u03b1 / 2) :=\n  sorry", "formal_statement_pred": "import Mathlib\n\nstructure SpernerFamily where\n  n : \u2115\n  sets : Finset (Finset \u2115)\n  universe_bound : \u2200 A \u2208 sets, \u2200 x \u2208 A, x \u2208 Finset.range (n + 1)\n  sperner_property : \u2200 A \u2208 sets, \u2200 B \u2208 sets, A \u2260 B \u2192 \u00ac(A \u2286 B)\n\ntheorem sperner_lemma {n : \u2115} (F : SpernerFamily) (h : F.n = n) :\n  F.sets.card \u2264 Nat.choose n (n / 2) :=\n  sorry", "compiled": true, "aligned": true}
{"id": "CombStruct4Lean_375", "informal_problem": "56. 17 scientists are corresponding with each other. The correspondence is conducted on three scientific topics. Each pair of scientists corresponds with each other on one topic. Prove that at least three scientists correspond with each other on the same topic.", "formal_statement": "import Mathlib\n\nstructure Correspondence where\n  scientists : Finset (Fin 17)  -- Set of 17 scientists\n  topics : Fin 3               -- Three topics\n  topic_assignment : (Fin 17 \u00d7 Fin 17) \u2192 Fin 3  -- Assignment of topics to pairs\n  valid : \u2200 (i j : Fin 17), i \u2260 j \u2192 \n    topic_assignment (i, j) = topic_assignment (j, i)  -- Symmetric correspondence\n\ntheorem ramsey_correspondence : \n  \u2200 (c : Correspondence), \u2203 (topic : Fin 3) (s1 s2 s3 : Fin 17),\n    s1 \u2260 s2 \u2227 s2 \u2260 s3 \u2227 s1 \u2260 s3 \u2227\n    c.topic_assignment (s1, s2) = topic \u2227\n    c.topic_assignment (s2, s3) = topic \u2227\n    c.topic_assignment (s1, s3) = topic :=\n  sorry", "formal_statement_pred": "import Mathlib\n\nstructure Correspondence where\n\n  n : Nat\n  scientists : Fin n\n\n  topic : Fin n \u2192 Fin n \u2192 Fin 3\n\n\ndef haveCommonTopic (c : Correspondence) (s1 s2 s3 : Fin c.n) (t : Fin 3) : Prop :=\n  c.topic s1 s2 = t \u2227 c.topic s2 s3 = t \u2227 c.topic s1 s3 = t\n\ntheorem correspondence_ramsey\n  (c : Correspondence)\n  (h1 : c.n = 17)\n  (h2 : \u2200 s1 s2 : Fin c.n, s1 \u2260 s2 \u2192 c.topic s1 s2 = c.topic s2 s1)\n  : \u2203 (s1 s2 s3 : Fin c.n) (t : Fin 3),\n    s1 \u2260 s2 \u2227 s2 \u2260 s3 \u2227 s1 \u2260 s3 \u2227\n    haveCommonTopic c s1 s2 s3 t :=\n  sorry", "compiled": true, "aligned": true}
{"id": "CombStruct4Lean_376", "informal_problem": "22. Network of Squares. A plane can be covered with equal squares; the nodes of this network in mathematics are called an integer lattice.\n\nCan the nodes be labeled with the letters $a, b, c, d$ such that each composite square has all four letters at its vertices and such that every column and every row of the lattice also contains all four letters?", "formal_statement": "import Mathlib\n\n-- Define the type for our labels\ninductive Label\n  | a | b | c | d\n\n-- A labeling is a function from integer coordinates to labels\nstructure LatticeLabeling\u1d62 where\n  label : \u2124 \u00d7 \u2124 \u2192 Label\n\n-- Check if a 1\u00d71 square has all different labels\ndef hasAllLabels (f : LatticeLabeling\u1d62) (x y : \u2124) : Prop :=\n  let vertices := [(x,y), (x+1,y), (x+1,y+1), (x,y+1)]\n  \u2200 l : Label, \u2203 v \u2208 vertices, f.label v = l\n\n-- Check if a row contains all labels\ndef rowHasAllLabels (f : LatticeLabeling\u1d62) (y : \u2124) : Prop :=\n  \u2200 l : Label, \u2203 x : \u2124, f.label (x,y) = l\n\n-- Check if a column contains all labels\ndef colHasAllLabels (f : LatticeLabeling\u1d62) (x : \u2124) : Prop :=\n  \u2200 l : Label, \u2203 y : \u2124, f.label (x,y) = l\n\ntheorem network_of_squares_labeling :\n  \u2203 (f : LatticeLabeling\u1d62),\n    (\u2200 x y : \u2124, hasAllLabels f x y) \u2227 \n    (\u2200 y : \u2124, rowHasAllLabels f y) \u2227\n    (\u2200 x : \u2124, colHasAllLabels f x) :=\n  sorry", "formal_statement_pred": "import Mathlib\n\n\ninductive Label\n  | a | b | c | d\n  deriving DecidableEq, Fintype\n\n\nstructure Square where\n  x : \u2124\n  y : \u2124\n\n\nstructure LatticeLabeling where\n  label : \u2124 \u00d7 \u2124 \u2192 Label\n\n\n  square_labels (s : Square) : List Label :=\n    [ label (s.x, s.y),\n      label (s.x + 1, s.y),\n      label (s.x, s.y + 1),\n      label (s.x + 1, s.y + 1) ]\n\n\n  square_distinct : \u2200 s : Square,\n    (label (s.x, s.y) \u2260 label (s.x + 1, s.y)) \u2227\n    (label (s.x, s.y) \u2260 label (s.x, s.y + 1)) \u2227\n    (label (s.x, s.y) \u2260 label (s.x + 1, s.y + 1)) \u2227\n    (label (s.x + 1, s.y) \u2260 label (s.x, s.y + 1)) \u2227\n    (label (s.x + 1, s.y) \u2260 label (s.x + 1, s.y + 1)) \u2227\n    (label (s.x, s.y + 1) \u2260 label (s.x + 1, s.y + 1))\n\n\n  row_complete : \u2200 y : \u2124, \u2200 l : Label,\n    \u2203 x : \u2124, label (x, y) = l\n\n\n  column_complete : \u2200 x : \u2124, \u2200 l : Label,\n    \u2203 y : \u2124, label (x, y) = l\n\ntheorem network_of_squares_labeling :\n  \u2203 (l : LatticeLabeling), True :=\n  sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_377", "informal_problem": "77. Chessboard. Let a square or rectangular chessboard have an odd number of cells (for example, 49 or 63). Cells that share a side will be called adjacent.\n\nOn each cell of the chessboard, we place one pawn, then collect the pawns and place them again on the cells of the chessboard.\n\nIs it possible for each pawn to end up in a cell adjacent to the one it originally occupied?", "formal_statement": "import Mathlib\n\nstructure ChessBoard where\n  rows : Nat\n  cols : Nat\n  total_odd : (rows * cols) % 2 = 1\n\nstructure PawnPlacement (board : ChessBoard) where\n  initial : Fin (board.rows * board.cols) \u2192 Fin (board.rows * board.cols)\n  final : Fin (board.rows * board.cols) \u2192 Fin (board.rows * board.cols)\n  bijective_initial : Function.Bijective initial\n  bijective_final : Function.Bijective final\n\ndef adjacent (board : ChessBoard) (pos1 pos2 : Fin (board.rows * board.cols)) : Prop :=\n  let row1 := pos1 / board.cols\n  let col1 := pos1 % board.cols\n  let row2 := pos2 / board.cols\n  let col2 := pos2 % board.cols\n  (row1 = row2 \u2227 (col1 + 1 = col2 \u2228 col2 + 1 = col1)) \u2228\n  (col1 = col2 \u2227 (row1 + 1 = row2 \u2228 row2 + 1 = row1))\n\ntheorem no_adjacent_rearrangement (board : ChessBoard) :\n  \u00ac\u2203 (p : PawnPlacement board), \u2200 (i : Fin (board.rows * board.cols)),\n    adjacent board (p.initial i) (p.final i) :=\n  sorry", "formal_statement_pred": "import Mathlib\n\nstructure ChessBoard where\n  rows : Nat\n  cols : Nat\n  rows_pos : 0 < rows\n  cols_pos : 0 < cols\n  total_odd : rows * cols % 2 = 1\n\nstructure Position (board : ChessBoard) where\n  row : Fin board.rows\n  col : Fin board.cols\n\ndef adjacent (board : ChessBoard) (p1 p2 : Position board) : Prop :=\n  (p1.row = p2.row \u2227 (p1.col.val + 1 = p2.col.val \u2228 p2.col.val + 1 = p1.col.val)) \u2228\n  (p1.col = p2.col \u2227 (p1.row.val + 1 = p2.row.val \u2228 p2.row.val + 1 = p1.row.val))\n\nstructure PawnPlacement where\n  board : ChessBoard\n  movement : Equiv (Position board) (Position board)\n\ntheorem no_all_adjacent_moves :\n  \u2200 (p : PawnPlacement),\n    \u00ac(\u2200 pos : Position p.board, adjacent p.board pos (p.movement pos)) :=\n  sorry", "compiled": true, "aligned": true}
{"id": "CombStruct4Lean_378", "informal_problem": "Example 2. In each cell of a square table of size $25 \\times 25$, one of the numbers +1 or -1 is written arbitrarily. Under each column, the product of all numbers in that column is recorded, and to the right of each row, the product of all numbers in that row is recorded. Prove that the sum of all fifty products cannot be zero.", "formal_statement": "import Mathlib\n\ndef SignMatrix (n : Nat) := Fin n \u2192 Fin n \u2192 Int\n\ndef isValidSignMatrix (n : Nat) (m : SignMatrix n) : Prop :=\n  \u2200 i j, m i j = 1 \u2228 m i j = -1\n\ndef columnProduct (n : Nat) (m : SignMatrix n) (j : Fin n) : Int :=\n  \u220f i, m i j\n\ndef rowProduct (n : Nat) (m : SignMatrix n) (i : Fin n) : Int :=\n  \u220f j, m i j\n\ntheorem sign_matrix_products_nonzero :\n  \u2200 (m : SignMatrix 25), isValidSignMatrix 25 m \u2192\n    (\u2211 i, rowProduct 25 m i) + (\u2211 j, columnProduct 25 m j) \u2260 0 :=\n  sorry", "formal_statement_pred": "import Mathlib\n\ndef SignMatrix (n : Nat) := Fin n \u2192 Fin n \u2192 Int\n\ndef isValidSignMatrix (n : Nat) (m : SignMatrix n) : Prop :=\n  \u2200 i j, m i j = 1 \u2228 m i j = -1\n\ndef columnProduct (n : Nat) (m : SignMatrix n) (j : Fin n) : Int :=\n  \u220f i, m i j\n\ndef rowProduct (n : Nat) (m : SignMatrix n) (i : Fin n) : Int :=\n  \u220f j, m i j\n\ntheorem sign_matrix_products_nonzero :\n  \u2200 (m : SignMatrix 25), isValidSignMatrix 25 m \u2192\n    (\u2211 i, rowProduct 25 m i) + (\u2211 j, columnProduct 25 m j) \u2260 0 :=\n  sorry", "compiled": true, "aligned": true}
{"id": "CombStruct4Lean_379", "informal_problem": "7. Points on a Line. Several points are located on a line. Then, between each pair of adjacent points, another point was placed. This process was repeated several times, after which all the marked points were counted. Could the total number of points be 1998?", "formal_statement": "import Mathlib\n\ndef insert_points (n : Nat) : Nat :=\n  2 * n - 1\n\ndef iterate_insertion (initial_points : Nat) (iterations : Nat) : Nat :=\n  match iterations with\n  | 0 => initial_points\n  | k + 1 => iterate_insertion (insert_points initial_points) k\n\ntheorem points_on_line_1998 : \u00ac\u2203 (initial_points iterations : Nat), \n    initial_points > 0 \u2227 iterate_insertion initial_points iterations = 1998 :=\n  sorry", "formal_statement_pred": "import Mathlib\n\ndef points_after_insertions (initial_points : Nat) (iterations : Nat) : Nat :=\n  initial_points + (initial_points - 1) * (2 ^ iterations - 1)\n\ntheorem points_cannot_be_1998 :\n  \u2200 (initial_points iterations : Nat),\n  initial_points > 0 \u2192\n  points_after_insertions initial_points iterations \u2260 1998 :=\n  sorry", "compiled": true, "aligned": true}
{"id": "CombStruct4Lean_380", "informal_problem": "9. Tetromino. Can a \"chessboard\" $10 \\times 10$ be covered with 25 rectangular tiles of size $4 \\times 1$?", "formal_statement": "import Mathlib\n\nstructure Board where\n  covered : Fin 10 \u2192 Fin 10 \u2192 Bool\n  tiles : Fin 25 \u2192 (Fin 4 \u2192 (Fin 10 \u00d7 Fin 10))\n\n/-- Predicate that checks if a tile placement is valid (no overlaps and within bounds) -/\ndef isValidTilePlacement (b : Board) : Prop :=\n  -- Each tile must be placed horizontally or vertically\n  (\u2200 t : Fin 25, \n    (\u2200 i j : Fin 4, i \u2260 j \u2192 \n      ((b.tiles t i).1 = (b.tiles t j).1 \u2227 ((b.tiles t j).2 - (b.tiles t i).2).val = (j - i).val) \u2228\n      ((b.tiles t i).2 = (b.tiles t j).2 \u2227 ((b.tiles t j).1 - (b.tiles t i).1).val = (j - i).val))) \u2227\n  -- No overlapping tiles\n  (\u2200 t1 t2 : Fin 25, \u2200 i j : Fin 4,\n    t1 \u2260 t2 \u2192 b.tiles t1 i \u2260 b.tiles t2 j) \u2227\n  -- All squares are covered\n  (\u2200 x : Fin 10, \u2200 y : Fin 10,\n    \u2203 t : Fin 25, \u2203 i : Fin 4,\n      b.tiles t i = (x, y))\n\ntheorem tetromino_covering_impossible : \u00ac\u2203 (b : Board), isValidTilePlacement b :=\n  sorry", "formal_statement_pred": "import Mathlib\n\nstructure TilePlacement where\n  x : Fin 10\n  y : Fin 10\n  horizontal : Bool\n\nstructure TetrominoCovering where\n  positions : Fin 25 \u2192 TilePlacement\n\ndef squares_covered (p : TilePlacement) : Set (Fin 10 \u00d7 Fin 10) :=\n  if p.horizontal then\n    {pos | \u2203 i : Fin 4, pos = (p.x + i, p.y)}\n  else\n    {pos | \u2203 i : Fin 4, pos = (p.x, p.y + i)}\n\ndef is_valid_placement (p : TilePlacement) : Prop :=\n  if p.horizontal then\n    p.x + 4 \u2264 10\n  else\n    p.y + 4 \u2264 10\n\ndef tiles_overlap (p1 p2 : TilePlacement) : Prop :=\n  \u2203 pos, pos \u2208 squares_covered p1 \u2227 pos \u2208 squares_covered p2\n\ndef is_complete_covering (c : TetrominoCovering) : Prop :=\n  \u2200 x y : Fin 10, \u2203 t : Fin 25, (x, y) \u2208 squares_covered (c.positions t)\n\ntheorem tetromino_covering_impossible :\n  \u00ac\u2203 (c : TetrominoCovering),\n    (\u2200 t : Fin 25, is_valid_placement (c.positions t)) \u2227\n    (\u2200 t1 t2 : Fin 25, t1 \u2260 t2 \u2192 \u00actiles_overlap (c.positions t1) (c.positions t2)) \u2227\n    is_complete_covering c\n  :=\n  sorry", "compiled": true, "aligned": true}
{"id": "CombStruct4Lean_382", "informal_problem": "1. A plane is painted in 2 colors. Prove that there are two points 1 meter apart that are painted the same color.", "formal_statement": "import Mathlib\n\ndef ColoredPlane := \u211d \u00d7 \u211d \u2192 Bool\n\nnoncomputable def distance (p q : \u211d \u00d7 \u211d) : \u211d :=\n  Real.sqrt ((p.1 - q.1)^2 + (p.2 - q.2)^2)\n\ntheorem same_color_points_exist (coloring : ColoredPlane) :\n  \u2203 (p q : \u211d \u00d7 \u211d), distance p q = 1 \u2227 coloring p = coloring q :=\n  sorry", "formal_statement_pred": "import Mathlib\n\ndef PlanePainting (\u03b1 : Type) := EuclideanSpace \u211d (Fin 2) \u2192 \u03b1\n\ntheorem two_points_same_color :\n  \u2200 (f : PlanePainting Bool), \u2203 (p\u2081 p\u2082 : EuclideanSpace \u211d (Fin 2)),\n    p\u2081 \u2260 p\u2082 \u2227 dist p\u2081 p\u2082 = 1 \u2227 f p\u2081 = f p\u2082 :=\n  sorry", "compiled": true, "aligned": true}
