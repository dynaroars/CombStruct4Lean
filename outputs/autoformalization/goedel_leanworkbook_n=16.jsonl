{"id": "CombStruct4Lean_3", "informal_problem": "\nC3. We have two piles with 2000 and 2017 coins respectively. Ann and Bob take alternate turns making the following moves: The player whose turn is to move picks a pile with at least two coins, removes from that pile $t$ coins for some $2 \\leqslant t \\leqslant 4$, and adds to the other pile 1 coin. The players can choose a different $t$ at each turn, and the player who cannot make a move loses. If Ann plays first determine which player has a winning strategy.\n", "formal_statement": "import Mathlib\n\n/-- Players in the game -/\ninductive Player where\n  | Ann\n  | Bob\n  deriving Repr, DecidableEq\n\n/-- Represents which pile a player can choose -/\ninductive Pile where\n  | One\n  | Two\n  deriving Repr, DecidableEq\n\n/-- Valid number of coins to remove (between 2 and 4) -/\nstructure ValidCoins where\n  n : Nat\n  h : 2 \u2264 n \u2227 n \u2264 4\n\n/-- A game state consists of two piles of coins and tracks whose turn it is -/\nstructure GameState where\n  pile1 : Nat\n  pile2 : Nat\n  turn : Player\n\n/-- A move in the game consists of choosing a pile and a valid number of coins to remove -/\nstructure Move where\n  pile : Pile\n  coins : ValidCoins\n\n/-- Measure function for termination proof -/\ndef gameSize (state : GameState) : Nat :=\n  state.pile1 + state.pile2\n\n/-- Represents a strategy for playing the game -/\ndef Strategy := GameState \u2192 Option Move\n\n/-- Predicate indicating if a move is valid in a given state -/\ndef isValidMove (state : GameState) (move : Move) : Prop :=\n  match move.pile with\n  | Pile.One => state.pile1 \u2265 move.coins.n\n  | Pile.Two => state.pile2 \u2265 move.coins.n\n\n/-- Apply a move to the current game state -/\ndef makeMove (state : GameState) (move : Move) : GameState :=\n  match move.pile with\n  | Pile.One => \u27e8\n      state.pile1 - move.coins.n,\n      state.pile2 + 1,\n      match state.turn with\n      | Player.Ann => Player.Bob\n      | Player.Bob => Player.Ann\n    \u27e9\n  | Pile.Two => \u27e8\n      state.pile1 + 1,\n      state.pile2 - move.coins.n,\n      match state.turn with\n      | Player.Ann => Player.Bob\n      | Player.Bob => Player.Ann\n    \u27e9\n\n/-- Predicate indicating if a strategy is winning for a player -/\ninductive IsWinningStrategy (player : Player) (strat : Strategy) : GameState \u2192 Prop where\n  | winning_move {state : GameState} (move : Move)\n    (h_valid : isValidMove state move)\n    (h_next : IsWinningStrategy player strat (makeMove state move))\n    : IsWinningStrategy player strat state\n  | opponent_loses {state : GameState}\n    (h_no_moves : \u2200 move, \u00acisValidMove state move)\n    : IsWinningStrategy player strat state\n\ntheorem ann_has_winning_strategy :\n  \u2203 (strat : Strategy),\n    IsWinningStrategy Player.Ann strat \u27e82000, 2017, Player.Ann\u27e9 :=\n  sorry", "formal_statement_pred": "theorem lean_workbook_plus_49072 (h\u2081 : \u2200 x, 2 \u2264 x \u2227 x \u2264 4) (h\u2082 : \u2200 x, 0 \u2264 x) : (\u2200 a b, a \u2264 2000 \u2227 b \u2264 2017 \u2227 a + b = 2000 + 2017 \u2192 (\u2200 n, 0 \u2264 n \u2227 n < a \u2228 0 \u2264 n \u2227 n < b \u2192 a + 1 \u2264 2000 \u2227 b + 1 \u2264 2017))   :=  by sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_26", "informal_problem": "XXXVII OM - II - Problem 2\n\nIn a chess tournament, 66 players participate, each playing one game against every other player, and the matches take place in four cities. Prove that there exists a trio of players who play all their games against each other in the same city.", "formal_statement": "import Mathlib\n\nstructure Tournament where\n  players : Finset Nat\n  num_players : players.card = 66\n  cities : Finset Nat\n  num_cities : cities.card = 4\n  game_location : Nat \u2192 Nat \u2192 Nat\n  valid_location : \u2200 p1 p2, p1 \u2208 players \u2192 p2 \u2208 players \u2192 p1 \u2260 p2 \u2192 game_location p1 p2 \u2208 cities\n\ntheorem tournament_trio_exists (t : Tournament) : \n  \u2203 (p1 p2 p3 : Nat) (c : Nat), \n    p1 \u2208 t.players \u2227 p2 \u2208 t.players \u2227 p3 \u2208 t.players \u2227 \n    p1 \u2260 p2 \u2227 p2 \u2260 p3 \u2227 p1 \u2260 p3 \u2227\n    c \u2208 t.cities \u2227\n    t.game_location p1 p2 = c \u2227 \n    t.game_location p2 p3 = c \u2227 \n    t.game_location p1 p3 = c :=\n  sorry", "formal_statement_pred": "theorem lean_workbook_plus_60307    (f : Fin 66 \u2192 Fin 66 \u2192 Fin 4)\n    (h\u2080 : \u2200 a b, a \u2260 b \u2192 f a b = f b a) :\n    \u2203 a b c, a \u2260 b \u2227 b \u2260 c \u2227 c \u2260 a \u2227 f a b = f b c \u2227 f b c = f c a   :=  by sorry", "compiled": true, "aligned": true}
{"id": "CombStruct4Lean_27", "informal_problem": "LIX OM - III - Task 4\n\nEach point in the plane with both integer coordinates has been painted either white or black. Prove that from the set of all painted points, an infinite subset can be selected which has a center of symmetry and all of whose points have the same color.", "formal_statement": "import Mathlib\n\n-- Define a point in Z \u00d7 Z\nstructure IntPoint where\n  x : Int\n  y : Int\n\n-- Define a coloring of the integer lattice\ndef Coloring := IntPoint \u2192 Bool  -- Bool represents black (true) and white (false)\n\n-- Define center of symmetry for a set of points\ndef hasCenterOfSymmetry (S : Set IntPoint) : Prop :=\n  \u2203 c : IntPoint, \u2200 p \u2208 S, \n    let sym := IntPoint.mk (2 * c.x - p.x) (2 * c.y - p.y)\n    sym \u2208 S\n\n-- Define a monochromatic set\ndef isMonochromatic (S : Set IntPoint) (col : Coloring) : Prop :=\n  \u2203 b : Bool, \u2200 p \u2208 S, col p = b\n\ntheorem infinite_symmetric_monochromatic \n  (col : Coloring) : \n  \u2203 S : Set IntPoint, \n    Set.Infinite S \u2227 \n    hasCenterOfSymmetry S \u2227 \n    isMonochromatic S col :=\n  sorry", "formal_statement_pred": "theorem lean_workbook_plus_46061 {p : \u2124 \u00d7 \u2124 \u2192 Fin 2} : \u2203 q : \u2124 \u00d7 \u2124 \u2192 Fin 2, \u2200 c : \u2124, \u2203 c' : \u2124, q (c, c') = q (c', c)   :=  by sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_34", "informal_problem": "XXXIII OM - I - Problem 5\n\nIn a certain workplace, each employee is a member of exactly one of 100 trade unions. The employees are to elect a director from among two candidates. Members of each union agree on whether to abstain from voting or which of the two candidates they will vote for. Prove that there exists a union such that if its members abstain from voting, and members of all other unions vote for one of the two candidates, the candidates for director will not receive an equal number of votes.", "formal_statement": "import Mathlib\n\ninductive VoteChoice\n  | abstain\n  | candidate1\n  | candidate2\n  deriving Repr, DecidableEq\n\nstructure VotingSystem where\n  unionSize : Fin 100 \u2192 Nat\n  votingChoice : Fin 100 \u2192 VoteChoice\n  size_pos : \u2200 i, unionSize i > 0\n  total_finite : (Finset.univ.sum unionSize) > 0\n\n/-- Predicate indicating if a voting configuration is valid:\n    all unions except possibly one must vote for a candidate -/\ndef isValidConfig (vs : VotingSystem) (abstaining : Option (Fin 100)) : Prop :=\n  \u2200 i : Fin 100, \n    if abstaining = some i \n    then vs.votingChoice i = VoteChoice.abstain\n    else vs.votingChoice i = VoteChoice.candidate1 \u2228 \n         vs.votingChoice i = VoteChoice.candidate2\n\n/-- Count votes for a specific candidate in a voting configuration -/\ndef countVotes (vs : VotingSystem) (c : VoteChoice) : Nat :=\n  Finset.sum Finset.univ fun i => \n    if vs.votingChoice i = c then vs.unionSize i else 0\n\ntheorem exists_decisive_union (vs : VotingSystem) :\n  \u2203 (k : Fin 100),\n    \u2200 (new_vs : VotingSystem),\n      isValidConfig new_vs (some k) \u2192\n      (\u2200 i \u2260 k, vs.unionSize i = new_vs.unionSize i) \u2192\n      countVotes new_vs VoteChoice.candidate1 \u2260 \n      countVotes new_vs VoteChoice.candidate2 :=\n  sorry", "formal_statement_pred": "theorem lean_workbook_plus_30598 (u : Fin 100) (h\u2081 : \u2200 u, 0 < u) : \u2203 u, \u2200 a b, (a < b \u2227 b < 100) \u2192 a^u \u2260 b^u   :=  by sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_34", "informal_problem": "XXXIII OM - I - Problem 5\n\nIn a certain workplace, each employee is a member of exactly one of 100 trade unions. The employees are to elect a director from among two candidates. Members of each union agree on whether to abstain from voting or which of the two candidates they will vote for. Prove that there exists a union such that if its members abstain from voting, and members of all other unions vote for one of the two candidates, the candidates for director will not receive an equal number of votes.", "formal_statement": "import Mathlib\n\ninductive VoteChoice\n  | abstain\n  | candidate1\n  | candidate2\n  deriving Repr, DecidableEq\n\nstructure VotingSystem where\n  unionSize : Fin 100 \u2192 Nat\n  votingChoice : Fin 100 \u2192 VoteChoice\n  size_pos : \u2200 i, unionSize i > 0\n  total_finite : (Finset.univ.sum unionSize) > 0\n\n/-- Predicate indicating if a voting configuration is valid:\n    all unions except possibly one must vote for a candidate -/\ndef isValidConfig (vs : VotingSystem) (abstaining : Option (Fin 100)) : Prop :=\n  \u2200 i : Fin 100, \n    if abstaining = some i \n    then vs.votingChoice i = VoteChoice.abstain\n    else vs.votingChoice i = VoteChoice.candidate1 \u2228 \n         vs.votingChoice i = VoteChoice.candidate2\n\n/-- Count votes for a specific candidate in a voting configuration -/\ndef countVotes (vs : VotingSystem) (c : VoteChoice) : Nat :=\n  Finset.sum Finset.univ fun i => \n    if vs.votingChoice i = c then vs.unionSize i else 0\n\ntheorem exists_decisive_union (vs : VotingSystem) :\n  \u2203 (k : Fin 100),\n    \u2200 (new_vs : VotingSystem),\n      isValidConfig new_vs (some k) \u2192\n      (\u2200 i \u2260 k, vs.unionSize i = new_vs.unionSize i) \u2192\n      countVotes new_vs VoteChoice.candidate1 \u2260 \n      countVotes new_vs VoteChoice.candidate2 :=\n  sorry", "formal_statement_pred": "theorem lean_workbook_plus_41885 : \u2200 u : Fin 100 \u2192 Fin 2, \u2203 i : Fin 100, \u00ac(u i = u 0)   :=  by sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_34", "informal_problem": "XXXIII OM - I - Problem 5\n\nIn a certain workplace, each employee is a member of exactly one of 100 trade unions. The employees are to elect a director from among two candidates. Members of each union agree on whether to abstain from voting or which of the two candidates they will vote for. Prove that there exists a union such that if its members abstain from voting, and members of all other unions vote for one of the two candidates, the candidates for director will not receive an equal number of votes.", "formal_statement": "import Mathlib\n\ninductive VoteChoice\n  | abstain\n  | candidate1\n  | candidate2\n  deriving Repr, DecidableEq\n\nstructure VotingSystem where\n  unionSize : Fin 100 \u2192 Nat\n  votingChoice : Fin 100 \u2192 VoteChoice\n  size_pos : \u2200 i, unionSize i > 0\n  total_finite : (Finset.univ.sum unionSize) > 0\n\n/-- Predicate indicating if a voting configuration is valid:\n    all unions except possibly one must vote for a candidate -/\ndef isValidConfig (vs : VotingSystem) (abstaining : Option (Fin 100)) : Prop :=\n  \u2200 i : Fin 100, \n    if abstaining = some i \n    then vs.votingChoice i = VoteChoice.abstain\n    else vs.votingChoice i = VoteChoice.candidate1 \u2228 \n         vs.votingChoice i = VoteChoice.candidate2\n\n/-- Count votes for a specific candidate in a voting configuration -/\ndef countVotes (vs : VotingSystem) (c : VoteChoice) : Nat :=\n  Finset.sum Finset.univ fun i => \n    if vs.votingChoice i = c then vs.unionSize i else 0\n\ntheorem exists_decisive_union (vs : VotingSystem) :\n  \u2203 (k : Fin 100),\n    \u2200 (new_vs : VotingSystem),\n      isValidConfig new_vs (some k) \u2192\n      (\u2200 i \u2260 k, vs.unionSize i = new_vs.unionSize i) \u2192\n      countVotes new_vs VoteChoice.candidate1 \u2260 \n      countVotes new_vs VoteChoice.candidate2 :=\n  sorry", "formal_statement_pred": "theorem lean_workbook_plus_27934 (f: Fin 100 \u2192 Nat \u2192 Fin 2) (hf: \u2200 i, \u2200 j, f i j = f i 0) : \u2203 i j, f i j \u2260 f i 0   :=  by sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_39", "informal_problem": "LIV OM - I - Task 10\n\nWe have a deck of 52 cards. Shuffling will be called the execution of the following actions: an arbitrary division of the deck into an upper and a lower part, and then an arbitrary mixing of the cards while maintaining the order within each part. Formally, shuffling is any mixing of the cards where the $i$-th card from the top moves to position $p_i$, with the condition that there exists some $m \\in \\{1, 2, 3, \\ldots, 51\\}$ such that $p_i < p_{i+1}$ for $i < m$ and for $i > m$.\nDetermine whether, starting from a fixed initial ordering of the cards, any other ordering can be achieved by performing five shuffles.", "formal_statement": "import Mathlib\nopen Equiv Fin\n\nstructure Shuffle where\n  perm : Perm (Fin 52)\n  split_point : Fin 52\n  lower_ordered : \u2200 i j : Fin 52, i < j \u2192 j < split_point \u2192 perm i < perm j\n  upper_ordered : \u2200 i j : Fin 52, split_point \u2264 i \u2192 i < j \u2192 perm i < perm j\n\n/-- Verifies that a sequence of 5 shuffles transforms the initial arrangement into the target -/\ndef ValidShuffleSequence (initial target : Perm (Fin 52)) (shuffles : List Shuffle) : Prop :=\n  shuffles.length = 5 \u2227\n  (shuffles.foldr (fun s acc => acc.trans s.perm) initial) = target\n\ntheorem five_shuffles_reach_all (initial target : Perm (Fin 52)) :\n  \u2203 shuffles : List Shuffle, ValidShuffleSequence initial target shuffles :=\n  sorry", "formal_statement_pred": "theorem lean_workbook_plus_63711 (c : \u2115 \u2192 \u2115) (hc : c = id) (f : \u2115 \u2192 \u2115) (hf: f = id) : (c \u2218 f) = id   :=  by sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_41", "informal_problem": "XXXV OM - III - Task 6\n\nThe towns $ P_1, \\ldots, P_{1025} $ are served by the airlines $ A_1, \\ldots, A_{10} $, such that for any towns $ P_k $ and $ P_m $ ($ k \\neq m $) there exists an airline whose planes fly directly from $ P_k $ to $ P_m $ and directly from $ P_m $ to $ P_k $. Prove that one of these airlines can offer a trip with an odd number of landings starting and ending in the same town.", "formal_statement": "import Mathlib\n\nstructure AirlineGraph where\n  carrier : SimpleGraph (Fin 1025)\n\n/-- A system of airlines where each pair of distinct cities is connected\n    by at least one airline in both directions -/\nstructure AirlineSystem where\n  airlines : Fin 10 \u2192 AirlineGraph\n  complete : \u2200 (i j : Fin 1025), i \u2260 j \u2192\n    \u2203 (a : Fin 10), (airlines a).carrier.Adj i j \u2227 (airlines a).carrier.Adj j i\n\n/-- A cycle in an airline's route network with specified length -/\ndef hasOddCycle (g : SimpleGraph (Fin 1025)) :=\n  \u2203 (n : \u2115) (c : Fin (2 * n + 1) \u2192 Fin 1025),\n    (\u2200 i : Fin (2 * n), g.Adj (c i) (c (i.succ))) \u2227\n    c 0 = c (Fin.last (2 * n + 1))\n\ntheorem exists_airline_with_odd_cycle (sys : AirlineSystem) :\n  \u2203 (a : Fin 10), hasOddCycle (sys.airlines a).carrier :=\n  sorry", "formal_statement_pred": "theorem lean_workbook_plus_17019 (P : Fin 1025 \u2192 Fin 10 \u2192 Fin 1025) (hP : \u2200 k m, k \u2260 m \u2192 \u2203 a : Fin 10, P k a = m \u2227 P m a = k) : \u2203 a : Fin 10, \u2203 n : Fin 1025, P n a = n   :=  by sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_44", "informal_problem": "4. (13 points) In a large online chess tournament, each player had exactly three friends among the participants. Each player played one game with all the participants except for their three friends. Could exactly 404 games have been played?", "formal_statement": "import Mathlib\n\n/- Structure representing a chess tournament where each player has exactly 3 friends -/\nstructure ChessTournament where\n  n : Nat\n  /- Set of friends for each player -/\n  friends : Fin n \u2192 Finset (Fin n)\n  /- Each player has exactly 3 friends -/\n  three_friends : \u2200 p, (friends p).card = 3\n  /- Friendship relation is symmetric -/\n  symmetric : \u2200 p q, q \u2208 friends p \u2194 p \u2208 friends q\n  /- Players cannot be friends with themselves -/\n  not_self_friend : \u2200 p, p \u2209 friends p\n  /- Number of players must be at least 4 -/\n  min_players : n \u2265 4\n\n/-- Total number of possible games between n players -/\ndef total_possible_games (n : Nat) : Nat := (n * (n - 1))/2\n\n/-- Total number of friend pairs in the tournament -/\ndef total_friend_pairs (t : ChessTournament) : Nat := (3 * t.n)/2\n\ntheorem chess_tournament_404_possible : \u2203 (t : ChessTournament),\n  total_possible_games t.n - total_friend_pairs t = 404 :=\n  sorry", "formal_statement_pred": "theorem lean_workbook_plus_50777 : (\u2203 n, n * (n - 1) / 2 - n * (n - 3) = 404)   :=  by sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_44", "informal_problem": "4. (13 points) In a large online chess tournament, each player had exactly three friends among the participants. Each player played one game with all the participants except for their three friends. Could exactly 404 games have been played?", "formal_statement": "import Mathlib\n\n/- Structure representing a chess tournament where each player has exactly 3 friends -/\nstructure ChessTournament where\n  n : Nat\n  /- Set of friends for each player -/\n  friends : Fin n \u2192 Finset (Fin n)\n  /- Each player has exactly 3 friends -/\n  three_friends : \u2200 p, (friends p).card = 3\n  /- Friendship relation is symmetric -/\n  symmetric : \u2200 p q, q \u2208 friends p \u2194 p \u2208 friends q\n  /- Players cannot be friends with themselves -/\n  not_self_friend : \u2200 p, p \u2209 friends p\n  /- Number of players must be at least 4 -/\n  min_players : n \u2265 4\n\n/-- Total number of possible games between n players -/\ndef total_possible_games (n : Nat) : Nat := (n * (n - 1))/2\n\n/-- Total number of friend pairs in the tournament -/\ndef total_friend_pairs (t : ChessTournament) : Nat := (3 * t.n)/2\n\ntheorem chess_tournament_404_possible : \u2203 (t : ChessTournament),\n  total_possible_games t.n - total_friend_pairs t = 404 :=\n  sorry", "formal_statement_pred": "theorem lean_workbook_plus_25224 (n : \u2115) : \u2203 n, n > 0 \u2227 n % 4 = 0 \u2227 n * (n - 3) / 2 = 404   :=  by sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_45", "informal_problem": "9.5. There are 64 checkers of three colors, divided into pairs such that the colors of the checkers in each pair are different. Prove that all the checkers can be arranged on a chessboard so that the checkers in each two-square rectangle are of different colors.", "formal_statement": "import Mathlib\n\ndef isAdjacent (p\u2081 p\u2082 : Fin 8 \u00d7 Fin 8) : Prop := \n  let (i\u2081, j\u2081) := p\u2081\n  let (i\u2082, j\u2082) := p\u2082\n  (i\u2081 = i\u2082 \u2227 j\u2082.val = j\u2081.val + 1) \u2228 \n  (j\u2081 = j\u2082 \u2227 i\u2082.val = i\u2081.val + 1)\n\n@[ext]\nstructure CheckerBoard where\n  color : (i j : Fin 8) \u2192 Fin 3\n  pairs : Finset ((Fin 8 \u00d7 Fin 8) \u00d7 (Fin 8 \u00d7 Fin 8))\n  pairs_valid : \n    -- Each position appears in exactly one pair\n    (\u2200 pos : Fin 8 \u00d7 Fin 8, \u2203! p \u2208 pairs, \n      pos = p.1 \u2228 pos = p.2) \u2227\n    -- Pairs have different colors\n    (\u2200 p \u2208 pairs, color p.1.1 p.1.2 \u2260 color p.2.1 p.2.2) \u2227\n    -- Total number of pairs is 32 (64/2)\n    Finset.card pairs = 32\n\ntheorem checker_arrangement_exists : \n  \u2203 (board : CheckerBoard),\n    \u2200 p\u2081 p\u2082 : Fin 8 \u00d7 Fin 8,\n      isAdjacent p\u2081 p\u2082 \u2192\n      board.color p\u2081.1 p\u2081.2 \u2260 board.color p\u2082.1 p\u2082.2 :=\n  sorry", "formal_statement_pred": "theorem lean_workbook_plus_57246 (c : Fin 64 \u2192 Fin 3) (h : \u2200 i j, i = j \u2192 c i \u2260 c j) : \u2203 f : Fin 64 \u2192 Fin 2, \u2200 i j, i = j \u2192 f i \u2260 f j \u2227 c i \u2260 c j   :=  by sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_45", "informal_problem": "9.5. There are 64 checkers of three colors, divided into pairs such that the colors of the checkers in each pair are different. Prove that all the checkers can be arranged on a chessboard so that the checkers in each two-square rectangle are of different colors.", "formal_statement": "import Mathlib\n\ndef isAdjacent (p\u2081 p\u2082 : Fin 8 \u00d7 Fin 8) : Prop := \n  let (i\u2081, j\u2081) := p\u2081\n  let (i\u2082, j\u2082) := p\u2082\n  (i\u2081 = i\u2082 \u2227 j\u2082.val = j\u2081.val + 1) \u2228 \n  (j\u2081 = j\u2082 \u2227 i\u2082.val = i\u2081.val + 1)\n\n@[ext]\nstructure CheckerBoard where\n  color : (i j : Fin 8) \u2192 Fin 3\n  pairs : Finset ((Fin 8 \u00d7 Fin 8) \u00d7 (Fin 8 \u00d7 Fin 8))\n  pairs_valid : \n    -- Each position appears in exactly one pair\n    (\u2200 pos : Fin 8 \u00d7 Fin 8, \u2203! p \u2208 pairs, \n      pos = p.1 \u2228 pos = p.2) \u2227\n    -- Pairs have different colors\n    (\u2200 p \u2208 pairs, color p.1.1 p.1.2 \u2260 color p.2.1 p.2.2) \u2227\n    -- Total number of pairs is 32 (64/2)\n    Finset.card pairs = 32\n\ntheorem checker_arrangement_exists : \n  \u2203 (board : CheckerBoard),\n    \u2200 p\u2081 p\u2082 : Fin 8 \u00d7 Fin 8,\n      isAdjacent p\u2081 p\u2082 \u2192\n      board.color p\u2081.1 p\u2081.2 \u2260 board.color p\u2082.1 p\u2082.2 :=\n  sorry", "formal_statement_pred": "theorem lean_workbook_plus_41357 (h : 64 / 2 = 32) (h1 : 32 % 2 = 0) : \u2203 f : \u2115 \u00d7 \u2115 \u2192 \u2115, \u2200 a b c d : \u2115 \u00d7 \u2115, a \u2260 b \u2227 a \u2260 c \u2227 a \u2260 d \u2227 b \u2260 c \u2227 b \u2260 d \u2227 c \u2260 d \u2192 f a \u2260 f b \u2227 f a \u2260 f c \u2227 f a \u2260 f d \u2227 f b \u2260 f c \u2227 f b \u2260 f d \u2227 f c \u2260 f d   :=  by sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_45", "informal_problem": "9.5. There are 64 checkers of three colors, divided into pairs such that the colors of the checkers in each pair are different. Prove that all the checkers can be arranged on a chessboard so that the checkers in each two-square rectangle are of different colors.", "formal_statement": "import Mathlib\n\ndef isAdjacent (p\u2081 p\u2082 : Fin 8 \u00d7 Fin 8) : Prop := \n  let (i\u2081, j\u2081) := p\u2081\n  let (i\u2082, j\u2082) := p\u2082\n  (i\u2081 = i\u2082 \u2227 j\u2082.val = j\u2081.val + 1) \u2228 \n  (j\u2081 = j\u2082 \u2227 i\u2082.val = i\u2081.val + 1)\n\n@[ext]\nstructure CheckerBoard where\n  color : (i j : Fin 8) \u2192 Fin 3\n  pairs : Finset ((Fin 8 \u00d7 Fin 8) \u00d7 (Fin 8 \u00d7 Fin 8))\n  pairs_valid : \n    -- Each position appears in exactly one pair\n    (\u2200 pos : Fin 8 \u00d7 Fin 8, \u2203! p \u2208 pairs, \n      pos = p.1 \u2228 pos = p.2) \u2227\n    -- Pairs have different colors\n    (\u2200 p \u2208 pairs, color p.1.1 p.1.2 \u2260 color p.2.1 p.2.2) \u2227\n    -- Total number of pairs is 32 (64/2)\n    Finset.card pairs = 32\n\ntheorem checker_arrangement_exists : \n  \u2203 (board : CheckerBoard),\n    \u2200 p\u2081 p\u2082 : Fin 8 \u00d7 Fin 8,\n      isAdjacent p\u2081 p\u2082 \u2192\n      board.color p\u2081.1 p\u2081.2 \u2260 board.color p\u2082.1 p\u2082.2 :=\n  sorry", "formal_statement_pred": "theorem lean_workbook_plus_52862 :\n  \u2200 c : Fin 3 \u2192 Fin 2, (\u2200 i, c i \u2260 c (i + 1)) \u2192 \u2203 f : Fin 8 \u2192 Fin 3, (\u2200 i j, f (i + j) \u2260 f i)   :=  by sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_45", "informal_problem": "9.5. There are 64 checkers of three colors, divided into pairs such that the colors of the checkers in each pair are different. Prove that all the checkers can be arranged on a chessboard so that the checkers in each two-square rectangle are of different colors.", "formal_statement": "import Mathlib\n\ndef isAdjacent (p\u2081 p\u2082 : Fin 8 \u00d7 Fin 8) : Prop := \n  let (i\u2081, j\u2081) := p\u2081\n  let (i\u2082, j\u2082) := p\u2082\n  (i\u2081 = i\u2082 \u2227 j\u2082.val = j\u2081.val + 1) \u2228 \n  (j\u2081 = j\u2082 \u2227 i\u2082.val = i\u2081.val + 1)\n\n@[ext]\nstructure CheckerBoard where\n  color : (i j : Fin 8) \u2192 Fin 3\n  pairs : Finset ((Fin 8 \u00d7 Fin 8) \u00d7 (Fin 8 \u00d7 Fin 8))\n  pairs_valid : \n    -- Each position appears in exactly one pair\n    (\u2200 pos : Fin 8 \u00d7 Fin 8, \u2203! p \u2208 pairs, \n      pos = p.1 \u2228 pos = p.2) \u2227\n    -- Pairs have different colors\n    (\u2200 p \u2208 pairs, color p.1.1 p.1.2 \u2260 color p.2.1 p.2.2) \u2227\n    -- Total number of pairs is 32 (64/2)\n    Finset.card pairs = 32\n\ntheorem checker_arrangement_exists : \n  \u2203 (board : CheckerBoard),\n    \u2200 p\u2081 p\u2082 : Fin 8 \u00d7 Fin 8,\n      isAdjacent p\u2081 p\u2082 \u2192\n      board.color p\u2081.1 p\u2081.2 \u2260 board.color p\u2082.1 p\u2082.2 :=\n  sorry", "formal_statement_pred": "theorem lean_workbook_plus_29563 (h\u2081 : 64 = 32 * 2) (h\u2082 : 64 = 8 * 8) : \u2200 checkers : Fin 64 \u2192 (Fin 2) \u2192 Fin 3, (\u2200 i j, checkers i j \u2260 checkers i (j + 1)) \u2192 \u2200 i j, checkers i j \u2260 checkers (i + 1) j \u2227 checkers i j \u2260 checkers (i + 1) (j + 1)   :=  by sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_45", "informal_problem": "9.5. There are 64 checkers of three colors, divided into pairs such that the colors of the checkers in each pair are different. Prove that all the checkers can be arranged on a chessboard so that the checkers in each two-square rectangle are of different colors.", "formal_statement": "import Mathlib\n\ndef isAdjacent (p\u2081 p\u2082 : Fin 8 \u00d7 Fin 8) : Prop := \n  let (i\u2081, j\u2081) := p\u2081\n  let (i\u2082, j\u2082) := p\u2082\n  (i\u2081 = i\u2082 \u2227 j\u2082.val = j\u2081.val + 1) \u2228 \n  (j\u2081 = j\u2082 \u2227 i\u2082.val = i\u2081.val + 1)\n\n@[ext]\nstructure CheckerBoard where\n  color : (i j : Fin 8) \u2192 Fin 3\n  pairs : Finset ((Fin 8 \u00d7 Fin 8) \u00d7 (Fin 8 \u00d7 Fin 8))\n  pairs_valid : \n    -- Each position appears in exactly one pair\n    (\u2200 pos : Fin 8 \u00d7 Fin 8, \u2203! p \u2208 pairs, \n      pos = p.1 \u2228 pos = p.2) \u2227\n    -- Pairs have different colors\n    (\u2200 p \u2208 pairs, color p.1.1 p.1.2 \u2260 color p.2.1 p.2.2) \u2227\n    -- Total number of pairs is 32 (64/2)\n    Finset.card pairs = 32\n\ntheorem checker_arrangement_exists : \n  \u2203 (board : CheckerBoard),\n    \u2200 p\u2081 p\u2082 : Fin 8 \u00d7 Fin 8,\n      isAdjacent p\u2081 p\u2082 \u2192\n      board.color p\u2081.1 p\u2081.2 \u2260 board.color p\u2082.1 p\u2082.2 :=\n  sorry", "formal_statement_pred": "theorem lean_workbook_24701 (h : 32 + 32 = 64) :\n    \u2200 checkers : Fin 64 \u2192 Fin 3,\n    (\u2200 i, checkers i \u2260 checkers (i + 1)) \u2192\n    (\u2200 i, checkers i \u2260 checkers (i + 2)) \u2192\n    (\u2200 i, checkers i \u2260 checkers (i + 3)) \u2192\n    (\u2200 i, checkers i \u2260 checkers (i + 4)) \u2192\n    (\u2200 i, checkers i \u2260 checkers (i + 5)) \u2192\n    (\u2200 i, checkers i \u2260 checkers (i + 6)) \u2192\n    (\u2200 i, checkers i \u2260 checkers (i + 7)) \u2192\n    (\u2200 i, checkers i \u2260 checkers (i + 8)) \u2192\n    (\u2200 i, checkers i \u2260 checkers (i + 9)) \u2192\n    (\u2200 i, checkers i \u2260 checkers (i + 10)) \u2192\n    (\u2200 i, checkers i \u2260 checkers (i + 11)) \u2192\n    (\u2200 i, checkers i \u2260 checkers (i + 12)) \u2192\n    (\u2200 i, checkers i \u2260 checkers (i + 13)) \u2192\n    (\u2200 i, checkers i \u2260 checkers (i + 14)) \u2192\n    (\u2200 i, checkers i \u2260 checkers (i + 15)) \u2192\n    (\u2200 i, checkers i \u2260 checkers (i + 16)) \u2192\n    (\u2200 i, checkers i \u2260 checkers (i + 17)) \u2192\n    (\u2200 i, checkers i \u2260 checkers (i + 18)) \u2192\n    (\u2200 i, checkers i \u2260 checkers (i + 19)) \u2192\n    (\u2200 i, checkers i \u2260 checkers (i + 20)) \u2192\n    (\u2200 i, checkers i \u2260 checkers (i + 21)) \u2192\n    (\u2200 i, checkers i \u2260 checkers (i + 22)) \u2192\n    (\u2200 i, checkers i \u2260 checkers (i + 23)) \u2192\n    (\u2200 i, checkers i \u2260 checkers (i + 24)) \u2192\n    (\u2200 i, checkers i \u2260 checkers (i + 25)) \u2192\n    (\u2200 i, checkers i \u2260 checkers (i + 26)) \u2192\n    (\u2200 i, checkers i \u2260 checkers (i + 27)) \u2192\n    (\u2200 i, checkers i \u2260 checkers (i + 28)) \u2192\n    (\u2200 i, checkers i \u2260 checkers (i + 29)) \u2192\n    (\u2200 i, checkers i \u2260 checkers (i + 30)) \u2192\n    (\u2200 i, checkers i \u2260 checkers (i + 31)) \u2192\n    (\u2200 i, checkers i \u2260 checkers (i + 32)) \u2192\n    (\u2200 i, checkers i \u2260 checkers (i + 33)) \u2192\n    (\u2200 i, checkers i \u2260 checkers (i + 34)) \u2192\n    (\u2200 i, checkers i \u2260 checkers (i + 35)) \u2192\n    (\u2200 i, checkers i \u2260 checkers (i + 36)) \u2192\n    (\u2200 i, checkers i \u2260 checkers (i + 37)) \u2192\n    (\u2200 i, checkers i \u2260 checkers (i + 38)) \u2192\n    (\u2200 i, checkers i \u2260 checkers (i + 39)) \u2192\n    (\u2200 i, checkers i \u2260 checkers (i + 40)) \u2192\n    (\u2200 i, checkers i \u2260 checkers (i + 41)) \u2192\n    (\u2200 i, checkers i \u2260 checkers (i + 42)) \u2192\n    (\u2200 i, checkers i \u2260 checkers (i + 43)) \u2192\n    (\u2200 i, checkers i \u2260 checkers (i + 44)) \u2192\n    (\u2200 i, checkers i \u2260 checkers (i + 45)) \u2192\n    (\u2200 i, checkers i \u2260 checkers (i + 46)) \u2192\n    (\u2200 i, checkers i \u2260 checkers (i + 47)) \u2192\n    (\u2200 i, checkers i \u2260 checkers (i + 48)) \u2192\n    (\u2200 i, checkers i \u2260 checkers (i + 49)) \u2192\n    (\u2200 i, checkers i \u2260 checkers (i + 50)) \u2192\n    (\u2200 i, checkers i \u2260 checkers (i + 51)) \u2192\n    (\u2200 i, checkers i \u2260 checkers (i + 52)) \u2192\n    (\u2200 i, checkers i \u2260 checkers (i + 53)) \u2192\n    (\u2200 i, checkers i \u2260 checkers (i + 54)) \u2192\n    (\u2200 i, checkers i \u2260 checkers (i + 55)) \u2192\n    (\u2200 i, checkers i \u2260 checkers (i + 56)) \u2192\n    (\u2200 i, checkers i \u2260 checkers (i + 57)) \u2192\n    (\u2200 i, checkers i \u2260 checkers (i + 58)) \u2192\n    (\u2200 i, checkers i \u2260 checkers (i + 59)) \u2192\n    (\u2200 i, checkers i \u2260 checkers (i + 60)) \u2192\n    (\u2200 i, checkers i \u2260 checkers (i + 61)) \u2192\n    (\u2200 i, checkers i \u2260 checkers (i + 62)) \u2192\n    (\u2200 i, checkers i \u2260 checkers (i + 63)) \u2192\n    (\u2200 i, checkers i \u2260 checkers (i + 64)) \u2192\n    \u2200 i, checkers i \u2260 checkers (i + 1)  :=  by sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_47", "informal_problem": "10.5. There are 64 checkers of several colors, paired such that the colors of the checkers in each pair are different. Prove that all the checkers can be arranged on a chessboard so that the checkers in each two-square rectangle are of different colors.", "formal_statement": "import Mathlib\n\nstructure CheckerArrangement where\n  n : Nat                              -- number of colors\n  colors : Fin 64 \u2192 Fin n             -- color assignment for each checker\n  pairs : Fin 32 \u2192 Fin 64 \u00d7 Fin 64    -- the given pairs of checkers\n  positions : Fin 64 \u2192 Fin 8 \u00d7 Fin 8   -- position of each checker on the board\n\n-- Predicate to check if two positions form a 2\u00d71 or 1\u00d72 rectangle\ndef isRectangle (p1 p2 : Fin 8 \u00d7 Fin 8) : Bool :=\n  let (x1, y1) := p1\n  let (x2, y2) := p2\n  (x1 = x2 && y1.val + 1 = y2.val) ||    -- vertical rectangle\n  (y1 = y2 && x1.val + 1 = x2.val)       -- horizontal rectangle\n\ntheorem checker_arrangement_exists : \u2203 (arr : CheckerArrangement), \n  -- Pairs have different colors\n  (\u2200 i : Fin 32, let (c1, c2) := arr.pairs i; arr.colors c1 \u2260 arr.colors c2) \u2227\n  -- Checkers in rectangles have different colors\n  (\u2200 i j : Fin 64, isRectangle (arr.positions i) (arr.positions j) \u2192 \n    arr.colors i \u2260 arr.colors j) :=\n  sorry", "formal_statement_pred": "theorem lean_workbook_plus_53443 (h : 0 < 64) (h2 : \u2200 i j, i \u2260 j \u2227 i < 64 \u2227 j < 64) : \u2203 (f : Fin 64 \u2192 Fin 2), \u2200 i j, i \u2260 j \u2227 i < 64 \u2227 j < 64 \u2192 f i \u2260 f j   :=  by sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_48", "informal_problem": "3. There are 288 visually identical coins weighing 7 and 8 grams (both types are present). On the scales, 144 coins were placed on each pan such that the scales are in balance. In one operation, you can take any two groups of the same number of coins from the pans and swap their places. Prove that it is possible to make the scales unbalanced in no more than 11 operations.", "formal_statement": "import Mathlib\n\nstructure CoinConfiguration where\n  leftEights : Nat    -- 8g coins in left pan\n  leftSevens : Nat    -- 7g coins in left pan\n  rightEights : Nat   -- 8g coins in right pan\n  rightSevens : Nat   -- 7g coins in right pan\n\ndef panWeight (eights sevens : Nat) : Nat :=\n  8 * eights + 7 * sevens\n\ndef isValidConfiguration (conf : CoinConfiguration) : Prop :=\n  conf.leftEights + conf.leftSevens = 144 \u2227\n  conf.rightEights + conf.rightSevens = 144 \u2227\n  conf.leftEights + conf.leftSevens + conf.rightEights + conf.rightSevens = 288\n\ndef isBalanced (conf : CoinConfiguration) : Prop :=\n  panWeight conf.leftEights conf.leftSevens = \n  panWeight conf.rightEights conf.rightSevens\n\ndef swapGroups (conf : CoinConfiguration) (countEights countSevens : Nat) : CoinConfiguration :=\n  { leftEights := conf.leftEights - countEights + countEights\n    leftSevens := conf.leftSevens - countSevens + countSevens\n    rightEights := conf.rightEights + countEights - countEights\n    rightSevens := conf.rightSevens + countSevens - countSevens }\n\ntheorem coin_balance_problem (initial : CoinConfiguration) \n    (h\u2081 : isValidConfiguration initial) \n    (h\u2082 : isBalanced initial) :\n  \u2203 (operations : List (Nat \u00d7 Nat)), \n    operations.length \u2264 11 \u2227 \n    let final := operations.foldl (fun conf op => swapGroups conf op.1 op.2) initial\n    isValidConfiguration final \u2227 \u00acisBalanced final :=\n  sorry", "formal_statement_pred": "theorem lean_workbook_plus_3785 (h\u2081 : 7 * x = 8 * y) : x \u2260 y   :=  by sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_50", "informal_problem": "Problem 5. At the court, 50 musketeers serve. Every day they split into pairs and conduct training duels. Is it true that after 24 days, there will be three musketeers who have not participated in training duels with each other?", "formal_statement": "import Mathlib\n\nstructure DuelSchedule where\n  edges : Fin 50 \u2192 Fin 50 \u2192 Option (Fin 24)  -- None means no duel scheduled\n  valid : \u2200 i j, i \u2260 j \u2192 edges i j = edges j i  -- symmetry\n  no_self_duels : \u2200 i, edges i i = none\n  one_per_day : \u2200 d i, (\u2203 j, edges i j = some d) \u2192 \n                       (\u2200 k \u2260 j, edges i k \u2260 some d)\n  daily_pairs : \u2200 i d, \u2203 j, edges i j = some d \u2228 edges j i = some d  -- everyone duels each day\n\ntheorem musketeer_pairs_ramsey :\n  \u2200 (schedule : DuelSchedule),\n  \u2203 (m1 m2 m3 : Fin 50), \n    m1 \u2260 m2 \u2227 m2 \u2260 m3 \u2227 m1 \u2260 m3 \u2227\n    schedule.edges m1 m2 = none \u2227\n    schedule.edges m2 m3 = none \u2227\n    schedule.edges m1 m3 = none :=\n  sorry", "formal_statement_pred": "theorem lean_workbook_plus_82028 (m : Fin 50) (d : Fin 24) : \u2203 a b c : Fin 50, a \u2260 b \u2227 b \u2260 c \u2227 c \u2260 a   :=  by sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_52", "informal_problem": "2. Each of the 8 squirrels threw a pine cone at some other squirrel, independently of the others. Prove that there will always be a group of three squirrels who did not throw a pine cone at a squirrel from this group.", "formal_statement": "import Mathlib\n\nabbrev Squirrel := Fin 8\n\nstructure PineConeThrows where\n  throws : Squirrel \u2192 Squirrel\n  no_self_throws : \u2200 i, throws i \u2260 i\n\n/-- Returns true if squirrel i throws a pine cone at any squirrel in the given set -/\ndef throws_into_set (throws : PineConeThrows) (i : Squirrel) (s : Finset Squirrel) : Prop :=\n  throws.throws i \u2208 s\n\ntheorem pine_cone_triangle (throws : PineConeThrows) :\n  \u2203 s : Finset Squirrel, s.card = 3 \u2227 \n    \u2200 i \u2208 s, \u00acthrows_into_set throws i s :=\n  sorry", "formal_statement_pred": "theorem lean_workbook_10647 (v : Fin 8 \u2192 Fin 8) : \u2203 a b c : Fin 8, a \u2260 b \u2227 b \u2260 c \u2227 c \u2260 a \u2227 v a \u2260 b \u2227 v b \u2260 c \u2227 v c \u2260 a  :=  by sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_52", "informal_problem": "2. Each of the 8 squirrels threw a pine cone at some other squirrel, independently of the others. Prove that there will always be a group of three squirrels who did not throw a pine cone at a squirrel from this group.", "formal_statement": "import Mathlib\n\nabbrev Squirrel := Fin 8\n\nstructure PineConeThrows where\n  throws : Squirrel \u2192 Squirrel\n  no_self_throws : \u2200 i, throws i \u2260 i\n\n/-- Returns true if squirrel i throws a pine cone at any squirrel in the given set -/\ndef throws_into_set (throws : PineConeThrows) (i : Squirrel) (s : Finset Squirrel) : Prop :=\n  throws.throws i \u2208 s\n\ntheorem pine_cone_triangle (throws : PineConeThrows) :\n  \u2203 s : Finset Squirrel, s.card = 3 \u2227 \n    \u2200 i \u2208 s, \u00acthrows_into_set throws i s :=\n  sorry", "formal_statement_pred": "theorem lean_workbook_1310 (f : Squirrel \u2192 Squirrel) (hf: \u2200 s s2 : Squirrel, f s = s2 \u2228 f s2 = s): \u2203 A B C: Squirrel, A \u2260 B \u2227 B \u2260 C \u2227 C \u2260 A \u2227 \u00ac (f A = B \u2228 f B = A) \u2227 \u00ac (f B = C \u2228 f C = B) \u2227 \u00ac (f C = A \u2228 f A = C)  :=  by sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_52", "informal_problem": "2. Each of the 8 squirrels threw a pine cone at some other squirrel, independently of the others. Prove that there will always be a group of three squirrels who did not throw a pine cone at a squirrel from this group.", "formal_statement": "import Mathlib\n\nabbrev Squirrel := Fin 8\n\nstructure PineConeThrows where\n  throws : Squirrel \u2192 Squirrel\n  no_self_throws : \u2200 i, throws i \u2260 i\n\n/-- Returns true if squirrel i throws a pine cone at any squirrel in the given set -/\ndef throws_into_set (throws : PineConeThrows) (i : Squirrel) (s : Finset Squirrel) : Prop :=\n  throws.throws i \u2208 s\n\ntheorem pine_cone_triangle (throws : PineConeThrows) :\n  \u2203 s : Finset Squirrel, s.card = 3 \u2227 \n    \u2200 i \u2208 s, \u00acthrows_into_set throws i s :=\n  sorry", "formal_statement_pred": "theorem lean_workbook_plus_19412 : \u2200 f : Squirrel \u2192 Squirrel, \u2203 A B C : Squirrel, A \u2260 B \u2227 B \u2260 C \u2227 C \u2260 A \u2227 f A \u2260 B \u2227 f B \u2260 C \u2227 f C \u2260 A   :=  by sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_54", "informal_problem": "2. At a round table, 40 people are sitting. Could it happen that any two of them, between whom an even number of people sit, have a common acquaintance at the table, while any two, between whom an odd number of people sit, do not have a common acquaintance? (A. Shapovalov)", "formal_statement": "import Mathlib\n\nstructure RoundTable where\n  n : Nat                                     -- number of people\n  acquaintance : Fin n \u2192 Fin n \u2192 Bool         -- acquaintance relation\n  common_acquaintance (i j : Fin n) : Bool :=\n    \u2203 k : Fin n, k \u2260 i \u2227 k \u2260 j \u2227 acquaintance i k \u2227 acquaintance j k\n\ndef distance_between (n : Nat) (i j : Fin n) : Nat :=\n  min (((j.val + n) - i.val) % n) (((i.val + n) - j.val) % n)\n\ntheorem round_table_acquaintance (t : RoundTable) (h : t.n = 40) :\n  \u00ac(\u2200 (i j : Fin t.n),\n    (distance_between t.n i j % 2 = 0 \u2192 t.common_acquaintance i j) \u2227\n    (distance_between t.n i j % 2 = 1 \u2192 \u00act.common_acquaintance i j)) :=\n  sorry", "formal_statement_pred": "theorem lean_workbook_plus_43823 (acquaintances : Fin 40 \u2192 Fin 40 \u2192 Prop) : \u2203 s : Fin 40 \u2192 Fin 40 \u2192 Prop, \u2200 k, s k k \u2227 (\u2200 k1 k2, s k1 k2 \u2192 (k1 \u2260 k2 \u2227 (k1 - k2) % 2 = 0 \u2194 s k1 k2)) \u2227 (\u2200 k1 k2, s k1 k2 \u2192 (k1 \u2260 k2 \u2227 (k1 - k2) % 2 = 1 \u2194 \u00acs k1 k2))   :=  by sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_55", "informal_problem": "2. In each of the 111 families, there are three people: a father, a mother, and a child. All 333 people lined up in a row. It turned out that the parents of each child are standing on different sides of the child (but not necessarily next to the child). Prove that among the central 111 people in this row, there is at least one child.", "formal_statement": "import Mathlib\n\ninductive Role\n  | father\n  | mother\n  | child\n  deriving Inhabited, DecidableEq\n\nstructure Family where\n  father : Fin 333\n  mother : Fin 333\n  child : Fin 333\n  distinct : father \u2260 mother \u2227 father \u2260 child \u2227 mother \u2260 child\n\n/-- Predicate to check if a position is in the middle section (111 to 221 inclusive) -/\ndef is_middle_position (pos : Fin 333) : Prop :=\n  111 \u2264 Fin.val pos \u2227 Fin.val pos \u2264 221\n\n/-- A valid arrangement of people in line -/\nstructure Arrangement where\n  positions : Fin 333 \u2192 Fin 333\n  injective : Function.Injective positions\n  families : Fin 111 \u2192 Family\n  valid_family_positions : \u2200 (f : Fin 111),\n    let fam := families f\n    (Fin.val (positions fam.father) < Fin.val (positions fam.child) \u2227 \n     Fin.val (positions fam.child) < Fin.val (positions fam.mother)) \u2228\n    (Fin.val (positions fam.mother) < Fin.val (positions fam.child) \u2227 \n     Fin.val (positions fam.child) < Fin.val (positions fam.father))\n\ntheorem child_in_middle (arr : Arrangement) : \n  \u2203 (f : Fin 111), is_middle_position (arr.positions (arr.families f).child) :=\n  sorry", "formal_statement_pred": "theorem lean_workbook_plus_48751 (f m c : Fin 111 \u2192 Fin 333) (hf: \u2200 i, f i < m i) (hm: \u2200 i, m i < c i) (hfc: \u2200 i, c i < f (i + 1)) : \u2203 i, f i < c i \u2227 m i < c i   :=  by sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_55", "informal_problem": "2. In each of the 111 families, there are three people: a father, a mother, and a child. All 333 people lined up in a row. It turned out that the parents of each child are standing on different sides of the child (but not necessarily next to the child). Prove that among the central 111 people in this row, there is at least one child.", "formal_statement": "import Mathlib\n\ninductive Role\n  | father\n  | mother\n  | child\n  deriving Inhabited, DecidableEq\n\nstructure Family where\n  father : Fin 333\n  mother : Fin 333\n  child : Fin 333\n  distinct : father \u2260 mother \u2227 father \u2260 child \u2227 mother \u2260 child\n\n/-- Predicate to check if a position is in the middle section (111 to 221 inclusive) -/\ndef is_middle_position (pos : Fin 333) : Prop :=\n  111 \u2264 Fin.val pos \u2227 Fin.val pos \u2264 221\n\n/-- A valid arrangement of people in line -/\nstructure Arrangement where\n  positions : Fin 333 \u2192 Fin 333\n  injective : Function.Injective positions\n  families : Fin 111 \u2192 Family\n  valid_family_positions : \u2200 (f : Fin 111),\n    let fam := families f\n    (Fin.val (positions fam.father) < Fin.val (positions fam.child) \u2227 \n     Fin.val (positions fam.child) < Fin.val (positions fam.mother)) \u2228\n    (Fin.val (positions fam.mother) < Fin.val (positions fam.child) \u2227 \n     Fin.val (positions fam.child) < Fin.val (positions fam.father))\n\ntheorem child_in_middle (arr : Arrangement) : \n  \u2203 (f : Fin 111), is_middle_position (arr.positions (arr.families f).child) :=\n  sorry", "formal_statement_pred": "theorem lean_workbook_53578 (f : \u2115 \u2192 \u2115) (m : \u2115 \u2192 \u2115) (c : \u2115 \u2192 \u2115) (hf: \u2200 n, f n \u2260 m n) (hfc: \u2200 n, f n \u2260 c n) (hmc: \u2200 n, m n \u2260 c n) : \u2203 n, f (f n) = m n \u2227 m (m n) = c n \u2227 c (c n) = f n  :=  by sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_58", "informal_problem": "5. Can a rectangle $1000 \\times 2016$ be cut into rectangles $1 \\times 2015$ and three-cell \"corners\" so that both types of figures are present? (E. Bakayev)", "formal_statement": "import Mathlib\n\nstructure Corner where\n  -- A three-cell corner is a shape made of three unit squares in an L shape\n  pos : \u2115 \u00d7 \u2115  -- position of the top-left cell\n\nstructure RectangleTiling where\n  width : \u2115 \n  height : \u2115\n  -- List of positions of 1\u00d72015 rectangles (top-left corner position)\n  strips : List (\u2115 \u00d7 \u2115)\n  -- List of corner positions (top-left position)\n  corners : List Corner\n  -- The tiling must be valid (no overlaps and covers the whole rectangle)\n  valid : Bool\n\ntheorem rectangle_tiling_existence : \n  \u2203 (t : RectangleTiling), \n    t.width = 1000 \u2227 \n    t.height = 2016 \u2227 \n    t.valid = true \u2227 \n    t.strips.length > 0 \u2227 \n    t.corners.length > 0 :=\n  sorry", "formal_statement_pred": "theorem lean_workbook_plus_62759 (hx: 1000*2016 = 2015*x + 3*y) (hb: 0 < x \u2227 0 < y) : True   :=  by sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_58", "informal_problem": "5. Can a rectangle $1000 \\times 2016$ be cut into rectangles $1 \\times 2015$ and three-cell \"corners\" so that both types of figures are present? (E. Bakayev)", "formal_statement": "import Mathlib\n\nstructure Corner where\n  -- A three-cell corner is a shape made of three unit squares in an L shape\n  pos : \u2115 \u00d7 \u2115  -- position of the top-left cell\n\nstructure RectangleTiling where\n  width : \u2115 \n  height : \u2115\n  -- List of positions of 1\u00d72015 rectangles (top-left corner position)\n  strips : List (\u2115 \u00d7 \u2115)\n  -- List of corner positions (top-left position)\n  corners : List Corner\n  -- The tiling must be valid (no overlaps and covers the whole rectangle)\n  valid : Bool\n\ntheorem rectangle_tiling_existence : \n  \u2203 (t : RectangleTiling), \n    t.width = 1000 \u2227 \n    t.height = 2016 \u2227 \n    t.valid = true \u2227 \n    t.strips.length > 0 \u2227 \n    t.corners.length > 0 :=\n  sorry", "formal_statement_pred": "theorem lean_workbook_19593 (h : 2016 < 1000) : \u2203 k, 1000 - 1 = k * 3 + 2015   :=  by sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_64", "informal_problem": "5. Igor wants to cut out $1 \\times 6$ grid rectangles from a grid square of size $11 \\times 1117$. Is it possible to mark one cell in the square so that it will definitely remain uncut, no matter how hard Igor tries?", "formal_statement": "import Mathlib\n\nstructure Rectangle where\n  x : Nat\n  y : Nat\n  width : Nat\n  height : Nat\n  valid : width = 1 \u2227 height = 6 \u2228 width = 6 \u2227 height = 1\n\nstructure GridCovering (w h : Nat) where\n  rectangles : List Rectangle\n  marked : Fin w \u00d7 Fin h\n\ntheorem exists_uncovered_cell : \n  \u2203 (pos : Fin 11 \u00d7 Fin 1117), \n    \u2200 (covering : List Rectangle),\n      \u2200 (r : Rectangle), r \u2208 covering \u2192\n        \u00ac(Nat.le r.x pos.1.val \u2227 pos.1.val < r.x + r.width \u2227\n          Nat.le r.y pos.2.val \u2227 pos.2.val < r.y + r.height) :=\n  sorry", "formal_statement_pred": "theorem lean_workbook_plus_18631 : \u00ac (\u2203 x y, (x < 11 \u2227 y < 1117) \u2227 (x + 1 < 11 \u2227 y + 1 < 1117) \u2227 (x + 2 < 11 \u2227 y + 2 < 1117) \u2227 (x + 3 < 11 \u2227 y + 3 < 1117) \u2227 (x + 4 < 11 \u2227 y + 4 < 1117) \u2227 (x + 5 < 11 \u2227 y + 5 < 1117))   :=  by sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_64", "informal_problem": "5. Igor wants to cut out $1 \\times 6$ grid rectangles from a grid square of size $11 \\times 1117$. Is it possible to mark one cell in the square so that it will definitely remain uncut, no matter how hard Igor tries?", "formal_statement": "import Mathlib\n\nstructure Rectangle where\n  x : Nat\n  y : Nat\n  width : Nat\n  height : Nat\n  valid : width = 1 \u2227 height = 6 \u2228 width = 6 \u2227 height = 1\n\nstructure GridCovering (w h : Nat) where\n  rectangles : List Rectangle\n  marked : Fin w \u00d7 Fin h\n\ntheorem exists_uncovered_cell : \n  \u2203 (pos : Fin 11 \u00d7 Fin 1117), \n    \u2200 (covering : List Rectangle),\n      \u2200 (r : Rectangle), r \u2208 covering \u2192\n        \u00ac(Nat.le r.x pos.1.val \u2227 pos.1.val < r.x + r.width \u2227\n          Nat.le r.y pos.2.val \u2227 pos.2.val < r.y + r.height) :=\n  sorry", "formal_statement_pred": "theorem lean_workbook_plus_48825 (h\u2081 : 1117 > 6) : \u2203 i j, 0 < i \u2227 0 < j \u2227 (i + 1) * 1117 + j \u2264 1117 * 1117   :=  by sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_64", "informal_problem": "5. Igor wants to cut out $1 \\times 6$ grid rectangles from a grid square of size $11 \\times 1117$. Is it possible to mark one cell in the square so that it will definitely remain uncut, no matter how hard Igor tries?", "formal_statement": "import Mathlib\n\nstructure Rectangle where\n  x : Nat\n  y : Nat\n  width : Nat\n  height : Nat\n  valid : width = 1 \u2227 height = 6 \u2228 width = 6 \u2227 height = 1\n\nstructure GridCovering (w h : Nat) where\n  rectangles : List Rectangle\n  marked : Fin w \u00d7 Fin h\n\ntheorem exists_uncovered_cell : \n  \u2203 (pos : Fin 11 \u00d7 Fin 1117), \n    \u2200 (covering : List Rectangle),\n      \u2200 (r : Rectangle), r \u2208 covering \u2192\n        \u00ac(Nat.le r.x pos.1.val \u2227 pos.1.val < r.x + r.width \u2227\n          Nat.le r.y pos.2.val \u2227 pos.2.val < r.y + r.height) :=\n  sorry", "formal_statement_pred": "theorem lean_workbook_plus_24195 (h\u2081 : 1 \u2264 11) (h\u2082 : 1 \u2264 1117) : \u2203 i j, \u00ac (1 \u2264 i \u2227 i \u2264 11 \u2227 1 \u2264 j \u2227 j \u2264 1117 \u2227 i * 6 \u2264 j)   :=  by sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_64", "informal_problem": "5. Igor wants to cut out $1 \\times 6$ grid rectangles from a grid square of size $11 \\times 1117$. Is it possible to mark one cell in the square so that it will definitely remain uncut, no matter how hard Igor tries?", "formal_statement": "import Mathlib\n\nstructure Rectangle where\n  x : Nat\n  y : Nat\n  width : Nat\n  height : Nat\n  valid : width = 1 \u2227 height = 6 \u2228 width = 6 \u2227 height = 1\n\nstructure GridCovering (w h : Nat) where\n  rectangles : List Rectangle\n  marked : Fin w \u00d7 Fin h\n\ntheorem exists_uncovered_cell : \n  \u2203 (pos : Fin 11 \u00d7 Fin 1117), \n    \u2200 (covering : List Rectangle),\n      \u2200 (r : Rectangle), r \u2208 covering \u2192\n        \u00ac(Nat.le r.x pos.1.val \u2227 pos.1.val < r.x + r.width \u2227\n          Nat.le r.y pos.2.val \u2227 pos.2.val < r.y + r.height) :=\n  sorry", "formal_statement_pred": "theorem lean_workbook_12202 : \u2203 i j, \u00ac (i = 5 \u2227 j = 5)  :=  by sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_67", "informal_problem": "2. From a chessboard of size $13 \\times 13$, two opposite corner cells have been cut out. On the remaining part of the board, several cells have been marked. Prove that it is possible to place chess kings on the marked cells such that the total number of kings does not exceed 47, and they attack all the empty marked cells. Recall that a chess king attacks all cells adjacent to it vertically, horizontally, and diagonally. (S. Berlov)", "formal_statement": "import Mathlib\n\n-- Valid position on the modified chessboard (corners removed)\nstructure ValidPos where\n  row : Fin 13\n  col : Fin 13\n  not_corner : \u00ac((row = 0 \u2227 col = 0) \u2228 (row = 12 \u2227 col = 12))\n\n-- The chessboard with marked cells\nstructure ChessBoard where\n  marked : ValidPos \u2192 Bool\n\n-- Helper function to check if a king at position i,j attacks position x,y\ndef attacks (i j x y : Fin 13) : Bool :=\n  let di := if i \u2265 x then i - x else x - i\n  let dj := if j \u2265 y then j - y else y - j\n  di \u2264 1 \u2227 dj \u2264 1 \u2227 \u00ac(i = x \u2227 j = y)\n\n-- Predicate to check if a set of kings attacks all marked cells\ndef coversAllMarked (board : ChessBoard) (kings : Finset ValidPos) : Prop :=\n  \u2200 pos : ValidPos, board.marked pos \u2192 \n    pos \u2208 kings \u2228 \n    \u2203 k \u2208 kings, attacks k.row k.col pos.row pos.col\n\n-- Predicate to ensure kings are only placed on marked cells\ndef kingsOnMarked (board : ChessBoard) (kings : Finset ValidPos) : Prop :=\n  \u2200 k \u2208 kings, board.marked k\n\ntheorem kings_placement_exists (board : ChessBoard) :\n  \u2203 (kings : Finset ValidPos),\n    kings.card \u2264 47 \u2227\n    kingsOnMarked board kings \u2227\n    coversAllMarked board kings :=\n  sorry", "formal_statement_pred": "theorem lean_workbook_plus_72643  (h\u2081 : 13 * 13 - 2 = 167) :\n  13 * 13 - 2 = 167   :=  by sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_74", "informal_problem": "# Task 1.\n\nMaximum 10 points\n\nIn the Dark Dungeon, 1000 kind gnomes are held captive by 100 orcs. The chief orc has devised a scheme: orcs are assigned numbers from 00 to 99, and gnomes are assigned numbers from 000 to 999. An orc is assigned to watch a gnome if the orc's number can be obtained by deleting one digit from the gnome's number (for example, the orc with the number 14 watches the gnome with the number 146, as well as the orcs with the numbers 16 and 46).\n\nThe chief orc claims that only 50 orcs are needed to watch the gnomes, and that every gnome will still be watched by at least one orc. The rest of the orcs should be sent to conquer new cities.\n\na) Is the chief orc correct, and will 50 orcs be enough to ensure that no gnome goes unnoticed if they try to escape? Justify your answer.\n\nb) If the answer to the first question is \"Yes,\" is it possible to free more orcs? If the answer to the first question is \"No,\" is it possible to reduce the number of orcs watching the gnomes at all? Justify your answer.", "formal_statement": "import Mathlib\n\n-- Helper function to check if a number can be obtained by removing one digit from another\ndef canObtainByRemovingDigit (orc : Fin 100) (gnome : Fin 1000) : Prop :=\n  let orcNum := orc.val\n  let gnomeNum := gnome.val\n  -- Check if removing any digit from gnome can give orc\n  \u2203 (d : Nat), d < 10 \u2227 \u2203 (pos : Nat), pos < 3 \u2227\n    (gnomeNum = d * (10 ^ pos) + (gnomeNum / (10 ^ (pos + 1))) * (10 ^ (pos + 1)) +\n                (gnomeNum % (10 ^ pos)) \u2227\n     orcNum = (gnomeNum / (10 ^ (pos + 1))) * (10 ^ pos) + (gnomeNum % (10 ^ pos)))\n\nstructure DungeonSystem where\n  (orcs : Finset (Fin 100))\n  (gnomes : Finset (Fin 1000))\n  (isValid : Prop := \u2200 g \u2208 gnomes, \u2203 o \u2208 orcs, canObtainByRemovingDigit o g)\n\ntheorem min_orcs_required :\n  \u2200 (sys : DungeonSystem),\n    sys.gnomes = Finset.filter (fun n => n.val \u2265 0 \u2227 n.val \u2264 999) (Finset.univ) \u2192\n    sys.isValid \u2192\n    sys.orcs.card \u2265 67 :=\n  sorry", "formal_statement_pred": "theorem lean_workbook_24476 (is_correct : 100 \u2264 1000) : 50 \u2264 1000  :=  by sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_82", "informal_problem": "9. (50 points) In the kindergarten's dressing room, in the lost items basket, there are 30 mittens, of which 10 are blue, 10 are green, 10 are red, 15 are right-handed, and 15 are left-handed. Is it always possible to form sets of right and left mittens of the same color for 5 children?", "formal_statement": "import Mathlib\n\nstructure Mitten where\n  color : Fin 3  -- 0 for blue, 1 for green, 2 for red\n  isRight : Bool -- true for right-handed, false for left-handed\n\n/-- A collection of mittens with counts for each color and handedness -/\nstructure MittenCollection where\n  mittens : List Mitten\n  blue_count : Nat\n  green_count : Nat\n  red_count : Nat\n  right_count : Nat\n  left_count : Nat\n  h_blue : blue_count = 10\n  h_green : green_count = 10\n  h_red : red_count = 10\n  h_right : right_count = 15\n  h_left : left_count = 15\n  h_total : mittens.length = 30\n\n/-- A valid pair of mittens consists of a right and left mitten of the same color -/\ndef isValidPair (m1 m2 : Mitten) : Bool :=\n  m1.color = m2.color \u2227 m1.isRight \u2260 m2.isRight\n\ntheorem kindergarten_mittens (mc : MittenCollection) :\n  \u2203 (pairs : List (Mitten \u00d7 Mitten)), \n    pairs.length = 5 \u2227 \n    (\u2200 p \u2208 pairs, isValidPair p.1 p.2) \u2227\n    (\u2200 m \u2208 pairs.map Prod.fst ++ pairs.map Prod.snd, m \u2208 mc.mittens) :=\n  sorry", "formal_statement_pred": "theorem lean_workbook_plus_34845 (h : 30 = 10 + 10 + 10 + 15 + 15) : \u2203 blue_right blue_left green_right green_left red_right red_left, blue_right + blue_left + green_right + green_left + red_right + red_left = 5 \u2227 blue_right + blue_left = 10 \u2227 green_right + green_left = 10 \u2227 red_right + red_left = 10 \u2227 blue_right + green_right + red_right = 15 \u2227 blue_left + green_left + red_left = 15   :=  by sorry", "compiled": true, "aligned": true}
{"id": "CombStruct4Lean_82", "informal_problem": "9. (50 points) In the kindergarten's dressing room, in the lost items basket, there are 30 mittens, of which 10 are blue, 10 are green, 10 are red, 15 are right-handed, and 15 are left-handed. Is it always possible to form sets of right and left mittens of the same color for 5 children?", "formal_statement": "import Mathlib\n\nstructure Mitten where\n  color : Fin 3  -- 0 for blue, 1 for green, 2 for red\n  isRight : Bool -- true for right-handed, false for left-handed\n\n/-- A collection of mittens with counts for each color and handedness -/\nstructure MittenCollection where\n  mittens : List Mitten\n  blue_count : Nat\n  green_count : Nat\n  red_count : Nat\n  right_count : Nat\n  left_count : Nat\n  h_blue : blue_count = 10\n  h_green : green_count = 10\n  h_red : red_count = 10\n  h_right : right_count = 15\n  h_left : left_count = 15\n  h_total : mittens.length = 30\n\n/-- A valid pair of mittens consists of a right and left mitten of the same color -/\ndef isValidPair (m1 m2 : Mitten) : Bool :=\n  m1.color = m2.color \u2227 m1.isRight \u2260 m2.isRight\n\ntheorem kindergarten_mittens (mc : MittenCollection) :\n  \u2203 (pairs : List (Mitten \u00d7 Mitten)), \n    pairs.length = 5 \u2227 \n    (\u2200 p \u2208 pairs, isValidPair p.1 p.2) \u2227\n    (\u2200 m \u2208 pairs.map Prod.fst ++ pairs.map Prod.snd, m \u2208 mc.mittens) :=\n  sorry", "formal_statement_pred": "theorem lean_workbook_plus_65877 :\n  10 \u2264 15 \u2227 10 \u2264 15 \u2227 15 \u2264 30 \u2227 15 \u2264 30 \u2227 30 \u2264 45   :=  by sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_84", "informal_problem": "8. (40 points) At the beginning of each physical education class, 30 students are divided into 3 teams of 10 each. Prove that there will be two students who were on the same team for three consecutive classes.", "formal_statement": "import Mathlib\n\n/-- Fixed constants for the problem -/\nabbrev NumStudents : Nat := 30\nabbrev NumTeams : Nat := 3\nabbrev TeamSize : Nat := 10\nabbrev Student := Fin NumStudents\nabbrev Team := Fin NumTeams\nabbrev ClassNumber := \u2115\n\n/-- Represents a sequence of team assignments across classes -/\nstructure TeamAssignment where\n  /-- For each class, assigns each student to a team -/\n  assignment : ClassNumber \u2192 Student \u2192 Team\n  /-- Teams form a partition (each student is in exactly one team) -/\n  is_partition : \u2200 (c : ClassNumber),\n    \u2200 (s : Student), \u2203! (t : Team), assignment c s = t\n\n/-- Two students are on the same team in a given class -/\ndef same_team (a : TeamAssignment) (s1 s2 : Student) (c : ClassNumber) : Prop :=\n  a.assignment c s1 = a.assignment c s2\n\ntheorem pigeonhole_teams (a : TeamAssignment) :\n  \u2203 (s1 s2 : Student) (c\u2081 c\u2082 c\u2083 : ClassNumber),\n    s1 \u2260 s2 \u2227\n    c\u2081 < c\u2082 \u2227 c\u2082 < c\u2083 \u2227\n    same_team a s1 s2 c\u2081 \u2227\n    same_team a s1 s2 c\u2082 \u2227\n    same_team a s1 s2 c\u2083 :=\n  sorry", "formal_statement_pred": "theorem lean_workbook_plus_57108 (t1 t2 t3 : Fin 30 \u2192 Fin 3) : \u2203 a b : Fin 30, a \u2260 b \u2227 t1 a = t1 b \u2227 t2 a = t2 b \u2227 t3 a = t3 b   :=  by sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_92", "informal_problem": "Task 10. In the squad, there are 10 people. Each day, two of them need to be chosen as duty officers (with the same pair not being able to serve twice). Could it be that after several days, one person has been on duty 9 times, two people - 8 times each, two people - 5 times each, four people - 3 times each, and one person - 1 time?", "formal_statement": "import Mathlib\n\nstructure DutyPattern where\n  person_nine : Fin 10\n  people_eight_1 : Fin 10\n  people_eight_2 : Fin 10\n  people_five_1 : Fin 10\n  people_five_2 : Fin 10\n  people_three_1 : Fin 10\n  people_three_2 : Fin 10\n  people_three_3 : Fin 10\n  people_three_4 : Fin 10\n  person_one : Fin 10\n  all_distinct : List.Nodup [person_nine, people_eight_1, people_eight_2,\n                            people_five_1, people_five_2,\n                            people_three_1, people_three_2, people_three_3, people_three_4,\n                            person_one]\n\nstructure DutySchedule where\n  days : Nat\n  days_eq : days = 24\n  duties : Fin days \u2192 Fin 10 \u00d7 Fin 10\n  no_repeat : \u2200 i j, i < j \u2192 duties i \u2260 duties j\n  no_self_duty : \u2200 d, (duties d).1 \u2260 (duties d).2\n  duty_count (person : Fin 10) : Nat :=\n    Finset.sum (Finset.univ : Finset (Fin days)) (fun day \u21a6 \n      if (duties day).1 = person \u2228 (duties day).2 = person\n      then 1 else 0)\n  sum_constraint : \u2211 p : Fin 10, duty_count p = 2 * days\n\ntheorem duty_distribution_possible : \n  \u2203 (pattern : DutyPattern) (schedule : DutySchedule),\n    schedule.duty_count pattern.person_nine = 9 \u2227\n    schedule.duty_count pattern.people_eight_1 = 8 \u2227\n    schedule.duty_count pattern.people_eight_2 = 8 \u2227\n    schedule.duty_count pattern.people_five_1 = 5 \u2227\n    schedule.duty_count pattern.people_five_2 = 5 \u2227\n    schedule.duty_count pattern.people_three_1 = 3 \u2227\n    schedule.duty_count pattern.people_three_2 = 3 \u2227\n    schedule.duty_count pattern.people_three_3 = 3 \u2227\n    schedule.duty_count pattern.people_three_4 = 3 \u2227\n    schedule.duty_count pattern.person_one = 1 :=\n  sorry", "formal_statement_pred": "theorem lean_workbook_plus_43445 (h\u2081 : 10 < 9 + 8 + 8 + 5 + 5 + 3 + 3 + 3 + 1) : False   :=  by sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_93", "informal_problem": "Task 10. In a country, there are 10 cities, some of which are connected by roads (each road connects exactly two cities, there is no more than one road between any two cities, and you can only switch from one road to another in a city). Is it possible that from one city 9 roads lead out, from one - 8, from two - 7 each, from two - 6 each, from two - 4 each, from one - 2, and from one - 1?", "formal_statement": "import Mathlib\n\nstructure RoadNetwork where\n  -- Number of cities is fixed at 10\n  roads : Finset (Fin 10 \u00d7 Fin 10)\n  -- Each road connects different cities\n  different_cities : \u2200 (e : Fin 10 \u00d7 Fin 10), e \u2208 roads \u2192 e.1 \u2260 e.2\n  -- Roads are undirected (if a-b is a road, b-a is the same road)\n  symmetric : \u2200 (a b : Fin 10), (a, b) \u2208 roads \u2194 (b, a) \u2208 roads\n  -- No duplicate roads\n  no_duplicates : \u2200 (a b : Fin 10), (a, b) \u2208 roads \u2192 (b, a) \u2208 roads \u2192 (a, b) = (b, a)\n\n/-- The degree (number of roads) connected to a city -/\ndef city_degree (n : RoadNetwork) (city : Fin 10) : Nat :=\n  (n.roads.filter (fun e => e.1 = city)).card\n\ntheorem road_network_possible : \u2203 (n : RoadNetwork),\n  -- One city with degree 9\n  (\u2203! (c\u2081 : Fin 10), city_degree n c\u2081 = 9) \u2227\n  -- One city with degree 8\n  (\u2203! (c\u2082 : Fin 10), city_degree n c\u2082 = 8) \u2227\n  -- Two cities with degree 7\n  (\u2203 (c\u2083 c\u2084 : Fin 10), c\u2083 \u2260 c\u2084 \u2227 \n    city_degree n c\u2083 = 7 \u2227 city_degree n c\u2084 = 7 \u2227\n    (\u2200 c, city_degree n c = 7 \u2192 c = c\u2083 \u2228 c = c\u2084)) \u2227\n  -- Two cities with degree 6\n  (\u2203 (c\u2085 c\u2086 : Fin 10), c\u2085 \u2260 c\u2086 \u2227 \n    city_degree n c\u2085 = 6 \u2227 city_degree n c\u2086 = 6 \u2227\n    (\u2200 c, city_degree n c = 6 \u2192 c = c\u2085 \u2228 c = c\u2086)) \u2227\n  -- Two cities with degree 4\n  (\u2203 (c\u2087 c\u2088 : Fin 10), c\u2087 \u2260 c\u2088 \u2227 \n    city_degree n c\u2087 = 4 \u2227 city_degree n c\u2088 = 4 \u2227\n    (\u2200 c, city_degree n c = 4 \u2192 c = c\u2087 \u2228 c = c\u2088)) \u2227\n  -- One city with degree 2\n  (\u2203! (c\u2089 : Fin 10), city_degree n c\u2089 = 2) \u2227\n  -- One city with degree 1\n  (\u2203! (c\u2081\u2080 : Fin 10), city_degree n c\u2081\u2080 = 1) :=\n  sorry", "formal_statement_pred": "theorem lean_workbook_plus_51858 : False   :=  by sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_93", "informal_problem": "Task 10. In a country, there are 10 cities, some of which are connected by roads (each road connects exactly two cities, there is no more than one road between any two cities, and you can only switch from one road to another in a city). Is it possible that from one city 9 roads lead out, from one - 8, from two - 7 each, from two - 6 each, from two - 4 each, from one - 2, and from one - 1?", "formal_statement": "import Mathlib\n\nstructure RoadNetwork where\n  -- Number of cities is fixed at 10\n  roads : Finset (Fin 10 \u00d7 Fin 10)\n  -- Each road connects different cities\n  different_cities : \u2200 (e : Fin 10 \u00d7 Fin 10), e \u2208 roads \u2192 e.1 \u2260 e.2\n  -- Roads are undirected (if a-b is a road, b-a is the same road)\n  symmetric : \u2200 (a b : Fin 10), (a, b) \u2208 roads \u2194 (b, a) \u2208 roads\n  -- No duplicate roads\n  no_duplicates : \u2200 (a b : Fin 10), (a, b) \u2208 roads \u2192 (b, a) \u2208 roads \u2192 (a, b) = (b, a)\n\n/-- The degree (number of roads) connected to a city -/\ndef city_degree (n : RoadNetwork) (city : Fin 10) : Nat :=\n  (n.roads.filter (fun e => e.1 = city)).card\n\ntheorem road_network_possible : \u2203 (n : RoadNetwork),\n  -- One city with degree 9\n  (\u2203! (c\u2081 : Fin 10), city_degree n c\u2081 = 9) \u2227\n  -- One city with degree 8\n  (\u2203! (c\u2082 : Fin 10), city_degree n c\u2082 = 8) \u2227\n  -- Two cities with degree 7\n  (\u2203 (c\u2083 c\u2084 : Fin 10), c\u2083 \u2260 c\u2084 \u2227 \n    city_degree n c\u2083 = 7 \u2227 city_degree n c\u2084 = 7 \u2227\n    (\u2200 c, city_degree n c = 7 \u2192 c = c\u2083 \u2228 c = c\u2084)) \u2227\n  -- Two cities with degree 6\n  (\u2203 (c\u2085 c\u2086 : Fin 10), c\u2085 \u2260 c\u2086 \u2227 \n    city_degree n c\u2085 = 6 \u2227 city_degree n c\u2086 = 6 \u2227\n    (\u2200 c, city_degree n c = 6 \u2192 c = c\u2085 \u2228 c = c\u2086)) \u2227\n  -- Two cities with degree 4\n  (\u2203 (c\u2087 c\u2088 : Fin 10), c\u2087 \u2260 c\u2088 \u2227 \n    city_degree n c\u2087 = 4 \u2227 city_degree n c\u2088 = 4 \u2227\n    (\u2200 c, city_degree n c = 4 \u2192 c = c\u2087 \u2228 c = c\u2088)) \u2227\n  -- One city with degree 2\n  (\u2203! (c\u2089 : Fin 10), city_degree n c\u2089 = 2) \u2227\n  -- One city with degree 1\n  (\u2203! (c\u2081\u2080 : Fin 10), city_degree n c\u2081\u2080 = 1) :=\n  sorry", "formal_statement_pred": "theorem lean_workbook_44526 (a b c d e f g h i j: Fin 10 \u2192 Fin 10 \u2192 Fin 2) (ha : a 0 1 = 1) (hb : b 1 2 = 1) (hc : c 2 3 = 1) (hd : d 3 4 = 1) (he : e 4 5 = 1) (hf : f 5 6 = 1) (hg : g 6 7 = 1) (hh : h 7 8 = 1) (hi : i 8 9 = 1) (hj : j 9 0 = 1) : a 0 1 + b 1 2 + c 2 3 + d 3 4 + e 4 5 + f 5 6 + g 6 7 + h 7 8 + i 8 9 + j 9 0 = 9 \u2227 a 1 2 + b 2 3 + c 3 4 + d 4 5 + e 5 6 + f 6 7 + g 7 8 + h 8 9 + i 9 0 + j 0 1 = 8 \u2227 a 2 3 + b 3 4 + c 4 5 + d 5 6 + e 6 7 + f 7 8 + g 8 9 + h 9 0 + i 0 1 + j 1 2 = 7 \u2227 a 3 4 + b 4 5 + c 5 6 + d 6 7 + e 7 8 + f 8 9 + g 9 0 + h 0 1 + i 1 2 + j 2 3 = 6 \u2227 a 4 5 + b 5 6 + c 6 7 + d 7 8 + e 8 9 + f 9 0 + g 0 1 + h 1 2 + i 2 3 + j 3 4 = 4 \u2227 a 5 6 + b 6 7 + c 7 8 + d 8 9 + e 9 0 + f 0 1 + g 1 2 + h 2 3 + i 3 4 + j 4 5 = 2 \u2227 a 6 7 + b 7 8 + c 8 9 + d 9 0 + e 0 1 + f 1 2 + g 2 3 + h 3 4 + i 4 5 + j 5 6 = 1  :=  by sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_94", "informal_problem": "7.1. In the bakery, there are pies with two fillings (apple and cherry) and of two types (fried and baked). Prove that it is possible to buy two pies that will differ both in filling and in the method of preparation.", "formal_statement": "import Mathlib\n\nstructure Pie where\n  filling : Bool  -- false for apple, true for cherry\n  baked : Bool   -- false for fried, true for baked\n\ndef different_filling (p1 p2 : Pie) : Bool :=\n  p1.filling \u2260 p2.filling\n\ndef different_preparation (p1 p2 : Pie) : Bool :=\n  p1.baked \u2260 p2.baked\n\ntheorem bakery_pigeonhole : \u2203 (p1 p2 : Pie), \n  p1 \u2260 p2 \u2227 different_filling p1 p2 \u2227 different_preparation p1 p2 :=\n  sorry", "formal_statement_pred": "theorem lean_workbook_plus_21111 : \u2200 A B C D : Prop, (A \u2228 B) \u2227 (C \u2228 D) \u2192 (A \u2228 C) \u2228 (A \u2228 D) \u2228 (B \u2228 C) \u2228 (B \u2228 D)   :=  by sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_96", "informal_problem": "7.1. Is it possible that 1000 participants in the olympiad will solve this problem correctly, and among them, there will be 43 more boys than girls?", "formal_statement": "import Mathlib\n\n-- No additional structures needed\n\ntheorem olympiad_participants_parity \n  (total : Nat) (diff : Nat) (h1 : total = 1000) (h2 : diff = 43) :\n  \u00ac(\u2203 (boys girls : Nat), \n    boys + girls = total \u2227 \n    boys - girls = diff) :=\n  sorry", "formal_statement_pred": "theorem lean_workbook_plus_16771 (h\u2081 : 1000 = b + g) (h\u2082 : b = g + 43) : b = 543 \u2227 g = 457   :=  by sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_98", "informal_problem": "9.5. On an 8x8 chessboard, 8 rooks are arranged in such a way that none of them can attack each other. Prove that each of them can be simultaneously moved to one of the diagonally adjacent cells in such a way that none of them will be able to attack each other after the move. Recall that a chess rook attacks all cells in the row and column it occupies.", "formal_statement": "import Mathlib\n\n-- Represents a position on the 8x8 chessboard\nstructure Position where\n  row : Fin 8\n  col : Fin 8\n\n-- Represents a rook on the chessboard\nstructure Rook where\n  pos : Position\n\n-- Checks if two positions are diagonally adjacent\ndef isDiagonallyAdjacent (p1 p2 : Position) : Bool :=\n  let rowDiff := (p1.row.val : Int) - (p2.row.val : Int)\n  let colDiff := (p1.col.val : Int) - (p2.col.val : Int)\n  abs rowDiff = 1 && abs colDiff = 1\n\n-- Checks if two positions are in the same row or column (attacking position)\ndef isAttacking (p1 p2 : Position) : Bool :=\n  p1.row = p2.row || p1.col = p2.col\n\n-- Represents a configuration of 8 rooks\ndef RookConfiguration := Fin 8 \u2192 Rook\n\n-- Checks if a configuration is valid (no rooks attacking each other)\ndef isValidConfiguration (config : RookConfiguration) : Prop :=\n  \u2200 i j : Fin 8, i \u2260 j \u2192 \u00ac(isAttacking (config i).pos (config j).pos)\n\ntheorem rooks_diagonal_move_exists (initial : RookConfiguration) \n  (h : isValidConfiguration initial) :\n  \u2203 (final : RookConfiguration),\n    -- The final configuration is valid\n    isValidConfiguration final \u2227\n    -- Each rook moves to a diagonally adjacent square\n    (\u2200 i : Fin 8, isDiagonallyAdjacent (initial i).pos (final i).pos) :=\n  sorry", "formal_statement_pred": "theorem lean_workbook_54097 (r : Fin 8 \u2192 Fin 8) (hr : \u2200 a b, a \u2260 b \u2192 r a \u2260 r b) (h : \u2200 a, r a \u2260 r b) (h' : \u2200 a, r a \u2260 r c) : \u2203 a : Fin 8 \u2192 Fin 8, (\u2200 b : Fin 8, a b \u2260 a c) \u2227 (\u2200 b : Fin 8, a b \u2260 a d)  :=  by sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_98", "informal_problem": "9.5. On an 8x8 chessboard, 8 rooks are arranged in such a way that none of them can attack each other. Prove that each of them can be simultaneously moved to one of the diagonally adjacent cells in such a way that none of them will be able to attack each other after the move. Recall that a chess rook attacks all cells in the row and column it occupies.", "formal_statement": "import Mathlib\n\n-- Represents a position on the 8x8 chessboard\nstructure Position where\n  row : Fin 8\n  col : Fin 8\n\n-- Represents a rook on the chessboard\nstructure Rook where\n  pos : Position\n\n-- Checks if two positions are diagonally adjacent\ndef isDiagonallyAdjacent (p1 p2 : Position) : Bool :=\n  let rowDiff := (p1.row.val : Int) - (p2.row.val : Int)\n  let colDiff := (p1.col.val : Int) - (p2.col.val : Int)\n  abs rowDiff = 1 && abs colDiff = 1\n\n-- Checks if two positions are in the same row or column (attacking position)\ndef isAttacking (p1 p2 : Position) : Bool :=\n  p1.row = p2.row || p1.col = p2.col\n\n-- Represents a configuration of 8 rooks\ndef RookConfiguration := Fin 8 \u2192 Rook\n\n-- Checks if a configuration is valid (no rooks attacking each other)\ndef isValidConfiguration (config : RookConfiguration) : Prop :=\n  \u2200 i j : Fin 8, i \u2260 j \u2192 \u00ac(isAttacking (config i).pos (config j).pos)\n\ntheorem rooks_diagonal_move_exists (initial : RookConfiguration) \n  (h : isValidConfiguration initial) :\n  \u2203 (final : RookConfiguration),\n    -- The final configuration is valid\n    isValidConfiguration final \u2227\n    -- Each rook moves to a diagonally adjacent square\n    (\u2200 i : Fin 8, isDiagonallyAdjacent (initial i).pos (final i).pos) :=\n  sorry", "formal_statement_pred": "theorem lean_workbook_plus_8646 (R : Fin 8 \u2192 Fin 8 \u2192 Fin 8) (hR : \u2200 i j, R i j = i \u2228 R i j = j) : \u2203 S : Fin 8 \u2192 Fin 8 \u2192 Fin 8, \u2200 i j, (S i j = i + 1 \u2227 S i j = j + 1) \u2228 (S i j = i - 1 \u2227 S i j = j - 1)   :=  by sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_100", "informal_problem": "7.5. TikTok-House represents a $3 \\times 3$ square of nine rooms, each inhabited by a blogger. On Monday, the bloggers randomly swapped rooms, after which every two people who ended up in adjacent rooms recorded a collaborative TikTok. On Tuesday, the bloggers again swapped rooms and recorded TikToks according to the same rule as the previous day. The same thing happened on Wednesday. Prove that some two bloggers did not record a collaborative TikTok.", "formal_statement": "import Mathlib\n\nstructure TikTokHouse where\n  -- Each day's arrangement is represented as a permutation of bloggers (1-9)\n  monday : Fin 9 \u2192 Fin 9\n  tuesday : Fin 9 \u2192 Fin 9\n  wednesday : Fin 9 \u2192 Fin 9\n  \n-- Define when two positions are adjacent in a 3x3 grid\ndef isAdjacent (p1 p2 : Fin 9) : Bool :=\n  let row1 := p1 / 3\n  let col1 := p1 % 3\n  let row2 := p2 / 3\n  let col2 := p2 % 3\n  (row1 = row2 \u2227 (col1 = col2 + 1 \u2228 col2 = col1 + 1)) \u2228\n  (col1 = col2 \u2227 (row1 = row2 + 1 \u2228 row2 = row1 + 1))\n\n-- Define when two bloggers made a TikTok together on a given day\ndef madeTikTok (arrangement : Fin 9 \u2192 Fin 9) (blogger1 blogger2 : Fin 9) : Bool :=\n  isAdjacent (arrangement blogger1) (arrangement blogger2)\n\ntheorem some_pair_no_tiktok (house : TikTokHouse) : \n  \u2203 (b1 b2 : Fin 9), b1 \u2260 b2 \u2227 \n    \u00ac(madeTikTok house.monday b1 b2 \u2228 \n      madeTikTok house.tuesday b1 b2 \u2228 \n      madeTikTok house.wednesday b1 b2) :=\n  sorry", "formal_statement_pred": "theorem lean_workbook_23197 (b : Fin 3 \u2192 Fin 3 \u2192 Fin 3 \u2192 Fin 3 \u2192 Prop) (h : \u2200 m n p q, m \u2260 n \u2227 p \u2260 q \u2227 m \u2260 p \u2227 m \u2260 q \u2227 n \u2260 p \u2227 n \u2260 q \u2192 b m n p q) : \u2203 x y z w, b x y z w \u2227 x \u2260 y \u2227 z \u2260 w \u2227 x \u2260 z \u2227 x \u2260 w \u2227 y \u2260 z \u2227 y \u2260 w  :=  by sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_101", "informal_problem": "7.2. A square with a side of 6 cells is cut along the grid lines into 8 rectangles. Prove that some two of these rectangles are equal in area.", "formal_statement": "import Mathlib\n\nstructure Rectangle where\n  width : Nat\n  height : Nat\n  x_pos : Nat  -- x coordinate of bottom-left corner\n  y_pos : Nat  -- y coordinate of bottom-left corner\n  h_width : width \u2264 6\n  h_height : height \u2264 6\n  h_pos_x : x_pos + width \u2264 6\n  h_pos_y : y_pos + height \u2264 6\n\ndef area (r : Rectangle) : Nat :=\n  r.width * r.height\n\ndef valid_partition (rects : List Rectangle) : Prop :=\n  rects.length = 8 \u2227  -- exactly 8 rectangles\n  (\u2200 p : Nat \u00d7 Nat, p.1 < 6 \u2227 p.2 < 6 \u2192  -- each point belongs to exactly one rectangle\n    \u2203! r \u2208 rects, r.x_pos \u2264 p.1 \u2227 p.1 < r.x_pos + r.width \u2227\n                   r.y_pos \u2264 p.2 \u2227 p.2 < r.y_pos + r.height)\n\ntheorem square_partition_equal_areas :\n  \u2200 rects : List Rectangle,\n    valid_partition rects \u2192\n    \u2203 r1 r2 : Rectangle, r1 \u2208 rects \u2227 r2 \u2208 rects \u2227 r1 \u2260 r2 \u2227 area r1 = area r2 :=\n  sorry", "formal_statement_pred": "theorem lean_workbook_plus_41356 (h\u2081 : 6 * 6 = 8 * (a\u2081 * b\u2081 + a\u2082 * b\u2082 + a\u2083 * b\u2083 + a\u2084 * b\u2084 + a\u2085 * b\u2085 + a\u2086 * b\u2086 + a\u2087 * b\u2087 + a\u2088 * b\u2088)) : a\u2081 * b\u2081 = a\u2082 * b\u2082 \u2228 a\u2081 * b\u2081 = a\u2083 * b\u2083 \u2228 a\u2081 * b\u2081 = a\u2084 * b\u2084 \u2228 a\u2081 * b\u2081 = a\u2085 * b\u2085 \u2228 a\u2081 * b\u2081 = a\u2086 * b\u2086 \u2228 a\u2081 * b\u2081 = a\u2087 * b\u2087 \u2228 a\u2081 * b\u2081 = a\u2088 * b\u2088 \u2228 a\u2082 * b\u2082 = a\u2083 * b\u2083 \u2228 a\u2082 * b\u2082 = a\u2084 * b\u2084 \u2228 a\u2082 * b\u2082 = a\u2085 * b\u2085 \u2228 a\u2082 * b\u2082 = a\u2086 * b\u2086 \u2228 a\u2082 * b\u2082 = a\u2087 * b\u2087 \u2228 a\u2082 * b\u2082 = a\u2088 * b\u2088 \u2228 a\u2083 * b\u2083 = a\u2084 * b\u2084 \u2228 a\u2083 * b\u2083 = a\u2085 * b\u2085 \u2228 a\u2083 * b\u2083 = a\u2086 * b\u2086 \u2228 a\u2083 * b\u2083 = a\u2087 * b\u2087 \u2228 a\u2083 * b\u2083 = a\u2088 * b\u2088 \u2228 a\u2084 * b\u2084 = a\u2085 * b\u2085 \u2228 a\u2084 * b\u2084 = a\u2086 * b\u2086 \u2228 a\u2084 * b\u2084 = a\u2087 * b\u2087 \u2228 a\u2084 * b\u2084 = a\u2088 * b\u2088 \u2228 a\u2085 * b\u2085 = a\u2086 * b\u2086 \u2228 a\u2085 * b\u2085 = a\u2087 * b\u2087 \u2228 a\u2085 * b\u2085 = a\u2088 * b\u2088 \u2228 a\u2086 * b\u2086 = a\u2087 * b\u2087 \u2228 a\u2086 * b\u2086 = a\u2088 * b\u2088 \u2228 a\u2087 * b\u2087 = a\u2088 * b\u2088   :=  by sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_101", "informal_problem": "7.2. A square with a side of 6 cells is cut along the grid lines into 8 rectangles. Prove that some two of these rectangles are equal in area.", "formal_statement": "import Mathlib\n\nstructure Rectangle where\n  width : Nat\n  height : Nat\n  x_pos : Nat  -- x coordinate of bottom-left corner\n  y_pos : Nat  -- y coordinate of bottom-left corner\n  h_width : width \u2264 6\n  h_height : height \u2264 6\n  h_pos_x : x_pos + width \u2264 6\n  h_pos_y : y_pos + height \u2264 6\n\ndef area (r : Rectangle) : Nat :=\n  r.width * r.height\n\ndef valid_partition (rects : List Rectangle) : Prop :=\n  rects.length = 8 \u2227  -- exactly 8 rectangles\n  (\u2200 p : Nat \u00d7 Nat, p.1 < 6 \u2227 p.2 < 6 \u2192  -- each point belongs to exactly one rectangle\n    \u2203! r \u2208 rects, r.x_pos \u2264 p.1 \u2227 p.1 < r.x_pos + r.width \u2227\n                   r.y_pos \u2264 p.2 \u2227 p.2 < r.y_pos + r.height)\n\ntheorem square_partition_equal_areas :\n  \u2200 rects : List Rectangle,\n    valid_partition rects \u2192\n    \u2203 r1 r2 : Rectangle, r1 \u2208 rects \u2227 r2 \u2208 rects \u2227 r1 \u2260 r2 \u2227 area r1 = area r2 :=\n  sorry", "formal_statement_pred": "theorem lean_workbook_plus_36904 (f : \u2115 \u00d7 \u2115 \u2192 \u2115) (hf: f = fun p => p.1) : \u2203 a b : \u2115 \u00d7 \u2115, a \u2260 b \u2227 f a = f b   :=  by sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_102", "informal_problem": "7.5. A chessboard with a side of 100 cells was cut along the grid lines into squares with odd sides (not necessarily equal), and then the central cell was marked in each of the resulting squares. Prove that an equal number of white and black cells were marked.", "formal_statement": "import Mathlib\n\nstructure ChessboardPartition where\n  squares : List (Nat \u00d7 Nat \u00d7 Nat) -- (x, y, side_length) for each square\n  is_valid : \u2200 s \u2208 squares, s.2.2 % 2 = 1 -- odd side lengths\n  covers_board : \u2200 (i j : Fin 100), \u2203! s \u2208 squares, \n    i.val \u2265 s.1 \u2227 i.val < s.1 + s.2.2 \u2227 \n    j.val \u2265 s.2.1 \u2227 j.val < s.2.1 + s.2.2\n  within_bounds : \u2200 s \u2208 squares,\n    s.1 + s.2.2 \u2264 100 \u2227 s.2.1 + s.2.2 \u2264 100\n\n/-- Returns true if a cell is white on a chessboard (assuming (0,0) is white) -/\ndef isWhiteCell (x y : Nat) : Bool :=\n  (x + y) % 2 = 0\n\n/-- Returns the center coordinates of a square given its top-left corner and side length -/\ndef centerCell (x y side : Nat) : Nat \u00d7 Nat :=\n  (x + side / 2, y + side / 2)\n\ntheorem chessboard_partition_centers_balanced \n  (p : ChessboardPartition) : \n  let centers := p.squares.map (fun s => centerCell s.1 s.2.1 s.2.2)\n  (centers.filter (fun c => isWhiteCell c.1 c.2)).length = \n  (centers.filter (fun c => !isWhiteCell c.1 c.2)).length :=\n  sorry", "formal_statement_pred": "theorem lean_workbook_plus_67184 (h : \u2200 p q, (p + q) % 2 = 1 \u2192 (p ^ 2 + q ^ 2) % 2 = 1) : \u2203 n : \u2115, 100 % 2 = 0 \u2227 (100 * 100) % 2 = 0 \u2227 \u2200 p q, (p + q) % 2 = 1 \u2192 (p ^ 2 + q ^ 2) % 2 = 1   :=  by sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_104", "informal_problem": "7.2. Can a plane be painted in 2016 colors in such a way that among the vertices of any triangle, there will be at least two different colors?", "formal_statement": "import Mathlib\n\n/-- A coloring of the plane using n colors -/\nstructure ColoredPlane (n : \u2115) where\n  coloring : \u211d \u00d7 \u211d \u2192 Fin n\n\n/-- Three points form a triangle if they are distinct and not collinear -/\ndef isTriangle (p1 p2 p3 : \u211d \u00d7 \u211d) : Prop :=\n  p1 \u2260 p2 \u2227 p2 \u2260 p3 \u2227 p1 \u2260 p3 \u2227 \n  \u00ac(\u2203 (t : \u211d), (\n    ((1 - t) * p1.1 + t * p2.1 = p3.1) \u2227 \n    ((1 - t) * p1.2 + t * p2.2 = p3.2)))\n\ntheorem plane_coloring_exists : \n  \u2203 (c : ColoredPlane 2016), \n    \u2200 (p1 p2 p3 : \u211d \u00d7 \u211d), isTriangle p1 p2 p3 \u2192 \n      c.coloring p1 \u2260 c.coloring p2 \u2228 \n      c.coloring p2 \u2260 c.coloring p3 \u2228 \n      c.coloring p1 \u2260 c.coloring p3 :=\n  sorry", "formal_statement_pred": "theorem lean_workbook_plus_57850 : \u2203 p : \u2115 \u2192 Fin 2016, \u2200 A B C : \u2115, A \u2260 B \u2227 B \u2260 C \u2227 C \u2260 A \u2192 p A \u2260 p B \u2228 p B \u2260 p C \u2228 p C \u2260 p A   :=  by sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_104", "informal_problem": "7.2. Can a plane be painted in 2016 colors in such a way that among the vertices of any triangle, there will be at least two different colors?", "formal_statement": "import Mathlib\n\n/-- A coloring of the plane using n colors -/\nstructure ColoredPlane (n : \u2115) where\n  coloring : \u211d \u00d7 \u211d \u2192 Fin n\n\n/-- Three points form a triangle if they are distinct and not collinear -/\ndef isTriangle (p1 p2 p3 : \u211d \u00d7 \u211d) : Prop :=\n  p1 \u2260 p2 \u2227 p2 \u2260 p3 \u2227 p1 \u2260 p3 \u2227 \n  \u00ac(\u2203 (t : \u211d), (\n    ((1 - t) * p1.1 + t * p2.1 = p3.1) \u2227 \n    ((1 - t) * p1.2 + t * p2.2 = p3.2)))\n\ntheorem plane_coloring_exists : \n  \u2203 (c : ColoredPlane 2016), \n    \u2200 (p1 p2 p3 : \u211d \u00d7 \u211d), isTriangle p1 p2 p3 \u2192 \n      c.coloring p1 \u2260 c.coloring p2 \u2228 \n      c.coloring p2 \u2260 c.coloring p3 \u2228 \n      c.coloring p1 \u2260 c.coloring p3 :=\n  sorry", "formal_statement_pred": "theorem lean_workbook_plus_35110 : \u2203 (f : \u211d \u2192 Fin 2016), \u2200 x y z : \u211d, (f x \u2260 f y \u2228 f y \u2260 f z \u2228 f z \u2260 f x)   :=  by sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_108", "informal_problem": "8.5. After a successful train robbery, 102 bandits divided the obtained rubies, sapphires, and emeralds in such a way that each of them received exactly 100 precious stones in total. Prove that at least one of the following two statements is true:\n\n- There are two bandits who have the same number of rubies, sapphires, and emeralds;\n- There are two bandits who have a different number of rubies, sapphires, and emeralds.", "formal_statement": "import Mathlib\n\nstructure Bandit where\n  rubies : Nat\n  sapphires : Nat\n  emeralds : Nat\n  total_is_100 : rubies + sapphires + emeralds = 100\n\n/-- Returns true if two bandits have exactly the same distribution of stones -/\ndef same_distribution (b1 b2 : Bandit) : Bool :=\n  b1.rubies = b2.rubies \u2227 b1.sapphires = b2.sapphires \u2227 b1.emeralds = b2.emeralds\n\n/-- Returns true if two bandits have completely different distributions of stones -/\ndef different_distribution (b1 b2 : Bandit) : Bool :=\n  b1.rubies \u2260 b2.rubies \u2227 b1.sapphires \u2260 b2.sapphires \u2227 b1.emeralds \u2260 b2.emeralds\n\ntheorem bandit_distribution_property (bandits : Fin 102 \u2192 Bandit) :\n  (\u2203 i j : Fin 102, i \u2260 j \u2227 same_distribution (bandits i) (bandits j)) \u2228\n  (\u2203 i j : Fin 102, i \u2260 j \u2227 different_distribution (bandits i) (bandits j)) :=\n  sorry", "formal_statement_pred": "theorem lean_workbook_plus_24049 (t s e : \u2115 \u2192 \u2115) : (\u2203 i j, i \u2260 j \u2227 t i = t j \u2227 s i = s j \u2227 e i = e j) \u2228 (\u2203 i j, i \u2260 j \u2227 t i \u2260 t j \u2227 s i \u2260 s j \u2227 e i \u2260 e j)   :=  by sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_110", "informal_problem": "6. Drawing Lots. In a deck of 36 playing cards of four suits, from six to ace. Vasya and Masha each draw one card. Vasya draws first, and then Masha. Masha wins if she draws a card higher than Vasya's. Otherwise, Vasya wins.\n\nProve that the lot is unfair.", "formal_statement": "import Mathlib\n\n/-- Rank of a playing card from 6 through ace -/\ninductive Rank\n| Six | Seven | Eight | Nine | Ten | Jack | Queen | King | Ace\nderiving DecidableEq, Fintype, Ord\n\n/-- A playing card with suit and rank -/\nstructure Card where\n  suit : Fin 4\n  rank : Rank\n  deriving DecidableEq, Fintype\n\n/-- Convert rank to natural number for comparison (Ace is highest) -/\ndef Rank.toNat : Rank \u2192 Nat\n| Six => 0 | Seven => 1 | Eight => 2 | Nine => 3 | Ten => 4\n| Jack => 5 | Queen => 6 | King => 7 | Ace => 8\n\n/-- Compare two cards by rank -/\ndef Card.rankLt (c1 c2 : Card) : Bool :=\n  Rank.toNat c1.rank < Rank.toNat c2.rank\n\n/-- The deck of cards excluding drawn cards -/\nstructure Deck where\n  cards : Finset Card\n  valid : cards.card = 36 \u2228 cards.card = 35  -- Initial deck or after one draw\n\ntheorem drawing_lots_unfair :\n  let initial_deck : Finset Card := Finset.univ\n  let total_outcomes : Nat := 36 * 35  -- Total possible combinations of draws\n  let masha_winning_outcomes : Nat := (36 * 35) / 2 - 36  -- Outcomes where Masha wins\n  (masha_winning_outcomes : \u211a) / total_outcomes < 1/2 :=\n  sorry", "formal_statement_pred": "theorem lean_workbook_plus_56751 : 6 * 6 / 36 * 36 = 1 / 2   :=  by sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_110", "informal_problem": "6. Drawing Lots. In a deck of 36 playing cards of four suits, from six to ace. Vasya and Masha each draw one card. Vasya draws first, and then Masha. Masha wins if she draws a card higher than Vasya's. Otherwise, Vasya wins.\n\nProve that the lot is unfair.", "formal_statement": "import Mathlib\n\n/-- Rank of a playing card from 6 through ace -/\ninductive Rank\n| Six | Seven | Eight | Nine | Ten | Jack | Queen | King | Ace\nderiving DecidableEq, Fintype, Ord\n\n/-- A playing card with suit and rank -/\nstructure Card where\n  suit : Fin 4\n  rank : Rank\n  deriving DecidableEq, Fintype\n\n/-- Convert rank to natural number for comparison (Ace is highest) -/\ndef Rank.toNat : Rank \u2192 Nat\n| Six => 0 | Seven => 1 | Eight => 2 | Nine => 3 | Ten => 4\n| Jack => 5 | Queen => 6 | King => 7 | Ace => 8\n\n/-- Compare two cards by rank -/\ndef Card.rankLt (c1 c2 : Card) : Bool :=\n  Rank.toNat c1.rank < Rank.toNat c2.rank\n\n/-- The deck of cards excluding drawn cards -/\nstructure Deck where\n  cards : Finset Card\n  valid : cards.card = 36 \u2228 cards.card = 35  -- Initial deck or after one draw\n\ntheorem drawing_lots_unfair :\n  let initial_deck : Finset Card := Finset.univ\n  let total_outcomes : Nat := 36 * 35  -- Total possible combinations of draws\n  let masha_winning_outcomes : Nat := (36 * 35) / 2 - 36  -- Outcomes where Masha wins\n  (masha_winning_outcomes : \u211a) / total_outcomes < 1/2 :=\n  sorry", "formal_statement_pred": "theorem lean_workbook_plus_17641 (h\u2081 : 36 \u2260 0) (h\u2082 : 2 \u2260 0) (h\u2083 : 36 / 2 \u2260 0) (h\u2084 : 36 / 2 = 18) (h\u2085 : 18 \u2260 0) (h\u2086 : 18 / 2 \u2260 0) (h\u2087 : 18 / 2 = 9) (h\u2088 : 9 \u2260 0) (h\u2089 : 9 / 2 \u2260 0) (h\u2081\u2080 : 9 / 2 = 4.5) (h\u2081\u2081 : 4.5 \u2260 0) : (36 / 2 = 18 \u2227 18 / 2 = 9 \u2227 9 / 2 = 4.5 \u2227 4.5 / 2 = 2.25) \u2192 (2.25 \u2260 0)   :=  by sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_110", "informal_problem": "6. Drawing Lots. In a deck of 36 playing cards of four suits, from six to ace. Vasya and Masha each draw one card. Vasya draws first, and then Masha. Masha wins if she draws a card higher than Vasya's. Otherwise, Vasya wins.\n\nProve that the lot is unfair.", "formal_statement": "import Mathlib\n\n/-- Rank of a playing card from 6 through ace -/\ninductive Rank\n| Six | Seven | Eight | Nine | Ten | Jack | Queen | King | Ace\nderiving DecidableEq, Fintype, Ord\n\n/-- A playing card with suit and rank -/\nstructure Card where\n  suit : Fin 4\n  rank : Rank\n  deriving DecidableEq, Fintype\n\n/-- Convert rank to natural number for comparison (Ace is highest) -/\ndef Rank.toNat : Rank \u2192 Nat\n| Six => 0 | Seven => 1 | Eight => 2 | Nine => 3 | Ten => 4\n| Jack => 5 | Queen => 6 | King => 7 | Ace => 8\n\n/-- Compare two cards by rank -/\ndef Card.rankLt (c1 c2 : Card) : Bool :=\n  Rank.toNat c1.rank < Rank.toNat c2.rank\n\n/-- The deck of cards excluding drawn cards -/\nstructure Deck where\n  cards : Finset Card\n  valid : cards.card = 36 \u2228 cards.card = 35  -- Initial deck or after one draw\n\ntheorem drawing_lots_unfair :\n  let initial_deck : Finset Card := Finset.univ\n  let total_outcomes : Nat := 36 * 35  -- Total possible combinations of draws\n  let masha_winning_outcomes : Nat := (36 * 35) / 2 - 36  -- Outcomes where Masha wins\n  (masha_winning_outcomes : \u211a) / total_outcomes < 1/2 :=\n  sorry", "formal_statement_pred": "theorem lean_workbook_plus_41037 : \u00ac (1/36 * 1/36 + 1/36 * 1/36 = 1/36)   :=  by sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_110", "informal_problem": "6. Drawing Lots. In a deck of 36 playing cards of four suits, from six to ace. Vasya and Masha each draw one card. Vasya draws first, and then Masha. Masha wins if she draws a card higher than Vasya's. Otherwise, Vasya wins.\n\nProve that the lot is unfair.", "formal_statement": "import Mathlib\n\n/-- Rank of a playing card from 6 through ace -/\ninductive Rank\n| Six | Seven | Eight | Nine | Ten | Jack | Queen | King | Ace\nderiving DecidableEq, Fintype, Ord\n\n/-- A playing card with suit and rank -/\nstructure Card where\n  suit : Fin 4\n  rank : Rank\n  deriving DecidableEq, Fintype\n\n/-- Convert rank to natural number for comparison (Ace is highest) -/\ndef Rank.toNat : Rank \u2192 Nat\n| Six => 0 | Seven => 1 | Eight => 2 | Nine => 3 | Ten => 4\n| Jack => 5 | Queen => 6 | King => 7 | Ace => 8\n\n/-- Compare two cards by rank -/\ndef Card.rankLt (c1 c2 : Card) : Bool :=\n  Rank.toNat c1.rank < Rank.toNat c2.rank\n\n/-- The deck of cards excluding drawn cards -/\nstructure Deck where\n  cards : Finset Card\n  valid : cards.card = 36 \u2228 cards.card = 35  -- Initial deck or after one draw\n\ntheorem drawing_lots_unfair :\n  let initial_deck : Finset Card := Finset.univ\n  let total_outcomes : Nat := 36 * 35  -- Total possible combinations of draws\n  let masha_winning_outcomes : Nat := (36 * 35) / 2 - 36  -- Outcomes where Masha wins\n  (masha_winning_outcomes : \u211a) / total_outcomes < 1/2 :=\n  sorry", "formal_statement_pred": "theorem lean_workbook_35219 :\n  36 \u2260 2 * (1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 + 10 + 11 + 12)  :=  by sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_110", "informal_problem": "6. Drawing Lots. In a deck of 36 playing cards of four suits, from six to ace. Vasya and Masha each draw one card. Vasya draws first, and then Masha. Masha wins if she draws a card higher than Vasya's. Otherwise, Vasya wins.\n\nProve that the lot is unfair.", "formal_statement": "import Mathlib\n\n/-- Rank of a playing card from 6 through ace -/\ninductive Rank\n| Six | Seven | Eight | Nine | Ten | Jack | Queen | King | Ace\nderiving DecidableEq, Fintype, Ord\n\n/-- A playing card with suit and rank -/\nstructure Card where\n  suit : Fin 4\n  rank : Rank\n  deriving DecidableEq, Fintype\n\n/-- Convert rank to natural number for comparison (Ace is highest) -/\ndef Rank.toNat : Rank \u2192 Nat\n| Six => 0 | Seven => 1 | Eight => 2 | Nine => 3 | Ten => 4\n| Jack => 5 | Queen => 6 | King => 7 | Ace => 8\n\n/-- Compare two cards by rank -/\ndef Card.rankLt (c1 c2 : Card) : Bool :=\n  Rank.toNat c1.rank < Rank.toNat c2.rank\n\n/-- The deck of cards excluding drawn cards -/\nstructure Deck where\n  cards : Finset Card\n  valid : cards.card = 36 \u2228 cards.card = 35  -- Initial deck or after one draw\n\ntheorem drawing_lots_unfair :\n  let initial_deck : Finset Card := Finset.univ\n  let total_outcomes : Nat := 36 * 35  -- Total possible combinations of draws\n  let masha_winning_outcomes : Nat := (36 * 35) / 2 - 36  -- Outcomes where Masha wins\n  (masha_winning_outcomes : \u211a) / total_outcomes < 1/2 :=\n  sorry", "formal_statement_pred": "theorem lean_workbook_plus_18944 : \u00ac (\u2200 a b : Fin 36, (a < b) \u2228 (b < a))   :=  by sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_110", "informal_problem": "6. Drawing Lots. In a deck of 36 playing cards of four suits, from six to ace. Vasya and Masha each draw one card. Vasya draws first, and then Masha. Masha wins if she draws a card higher than Vasya's. Otherwise, Vasya wins.\n\nProve that the lot is unfair.", "formal_statement": "import Mathlib\n\n/-- Rank of a playing card from 6 through ace -/\ninductive Rank\n| Six | Seven | Eight | Nine | Ten | Jack | Queen | King | Ace\nderiving DecidableEq, Fintype, Ord\n\n/-- A playing card with suit and rank -/\nstructure Card where\n  suit : Fin 4\n  rank : Rank\n  deriving DecidableEq, Fintype\n\n/-- Convert rank to natural number for comparison (Ace is highest) -/\ndef Rank.toNat : Rank \u2192 Nat\n| Six => 0 | Seven => 1 | Eight => 2 | Nine => 3 | Ten => 4\n| Jack => 5 | Queen => 6 | King => 7 | Ace => 8\n\n/-- Compare two cards by rank -/\ndef Card.rankLt (c1 c2 : Card) : Bool :=\n  Rank.toNat c1.rank < Rank.toNat c2.rank\n\n/-- The deck of cards excluding drawn cards -/\nstructure Deck where\n  cards : Finset Card\n  valid : cards.card = 36 \u2228 cards.card = 35  -- Initial deck or after one draw\n\ntheorem drawing_lots_unfair :\n  let initial_deck : Finset Card := Finset.univ\n  let total_outcomes : Nat := 36 * 35  -- Total possible combinations of draws\n  let masha_winning_outcomes : Nat := (36 * 35) / 2 - 36  -- Outcomes where Masha wins\n  (masha_winning_outcomes : \u211a) / total_outcomes < 1/2 :=\n  sorry", "formal_statement_pred": "theorem lean_workbook_15846 :\n  (1 / 36 * (1 / 36 + 1 / 18 + 1 / 12 + 1 / 9 + 1 / 6 + 1 / 4 + 1 / 3) + 1 / 18 * (1 / 36 + 1 / 18 + 1 / 12 + 1 / 9 + 1 / 6 + 1 / 4) + 1 / 12 * (1 / 36 + 1 / 18 + 1 / 12 + 1 / 9 + 1 / 6) + 1 / 9 * (1 / 36 + 1 / 18 + 1 / 12 + 1 / 9) + 1 / 6 * (1 / 36 + 1 / 18 + 1 / 12) + 1 / 4 * (1 / 36 + 1 / 18) + 1 / 3 * (1 / 36)) * 36 > 1 / 2  :=  by sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_112", "informal_problem": "2. Seven children met. Some of them gave gifts to some others (one could not give more than one gift to another). Could it have turned out that everyone received an equal number of gifts, even though they all gave different numbers of gifts (including possibly someone giving no gifts at all)?", "formal_statement": "import Mathlib\nopen Matrix\n\nstructure GiftExchange where\n  n : Nat\n  gifts : Matrix (Fin n) (Fin n) Bool\n\ndef valid_exchange (ge : GiftExchange) : Prop :=\n  \u2200 i : Fin ge.n, ge.gifts i i = false  -- no self-gifts\n\ndef gifts_given (ge : GiftExchange) (i : Fin ge.n) : Nat :=\n  Finset.sum Finset.univ fun j => if ge.gifts i j then 1 else 0\n\ndef gifts_received (ge : GiftExchange) (j : Fin ge.n) : Nat :=\n  Finset.sum Finset.univ fun i => if ge.gifts i j then 1 else 0\n\ndef all_received_equal (ge : GiftExchange) : Prop :=\n  \u2200 i j : Fin ge.n, gifts_received ge i = gifts_received ge j\n\ndef all_gave_different (ge : GiftExchange) : Prop :=\n  \u2200 i j : Fin ge.n, i \u2260 j \u2192 gifts_given ge i \u2260 gifts_given ge j\n\ntheorem gift_exchange_possible : \u2203 (ge : GiftExchange), \n  ge.n = 7 \u2227 \n  valid_exchange ge \u2227\n  all_received_equal ge \u2227\n  all_gave_different ge :=\n  sorry", "formal_statement_pred": "theorem lean_workbook_plus_14042 (f: \u2115 \u2192 \u2115) : (\u2200 x y : \u2115, x = y \u2192 f x = f y) \u2192 (\u2200 x y : \u2115, x \u2260 y \u2192 f x \u2260 f y)   :=  by sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_116", "informal_problem": "4. Can rectangular parallelepipeds of size $2 \\times 2 \\times 1$ be used to form a rectangular parallelepiped of size $3 \\times 4 \\times 5$? Don't forget to justify your answer.", "formal_statement": "import Mathlib\n\nstructure Block where\n  width : Nat\n  length : Nat\n  height : Nat\n\n/-- A tiling represents a way to fill a larger block with smaller blocks -/\nstructure Tiling where\n  target : Block  -- The block we want to fill\n  piece : Block   -- The block we use for filling\n  possible : Bool -- Whether such tiling exists\n\ntheorem rectangular_parallelepiped_tiling_impossible : \n  let small_block := Block.mk 2 2 1\n  let large_block := Block.mk 3 4 5\n  let tiling := Tiling.mk large_block small_block false\n  tiling.possible = false :=\n  sorry", "formal_statement_pred": "theorem lean_workbook_plus_69995 (h\u2081 : 2 * 2 * 1 = 4) (h\u2082 : 3 * 4 * 5 = 60) : 60 % 4 = 0   :=  by sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_116", "informal_problem": "4. Can rectangular parallelepipeds of size $2 \\times 2 \\times 1$ be used to form a rectangular parallelepiped of size $3 \\times 4 \\times 5$? Don't forget to justify your answer.", "formal_statement": "import Mathlib\n\nstructure Block where\n  width : Nat\n  length : Nat\n  height : Nat\n\n/-- A tiling represents a way to fill a larger block with smaller blocks -/\nstructure Tiling where\n  target : Block  -- The block we want to fill\n  piece : Block   -- The block we use for filling\n  possible : Bool -- Whether such tiling exists\n\ntheorem rectangular_parallelepiped_tiling_impossible : \n  let small_block := Block.mk 2 2 1\n  let large_block := Block.mk 3 4 5\n  let tiling := Tiling.mk large_block small_block false\n  tiling.possible = false :=\n  sorry", "formal_statement_pred": "theorem lean_workbook_plus_35196 :\n  2 * 2 * 1 \u2223 3 * 4 * 5   :=  by sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_120", "informal_problem": "5. Each point of the plane is painted in one of three colors, and all three colors are used. Is it true that for any such coloring, one can choose a circle on which there are points of all three colors?", "formal_statement": "import Mathlib\n\n-- Define a coloring of the plane as a function from \u211d \u00d7 \u211d to a three-element type\nstructure ThreeColoring where\n  color : \u211d \u00d7 \u211d \u2192 Fin 3\n  all_colors_used : \u2200 (i : Fin 3), \u2203 (p : \u211d \u00d7 \u211d), color p = i\n\n-- Define what it means for a point to lie on a circle\ndef OnCircle (p : \u211d \u00d7 \u211d) (center : \u211d \u00d7 \u211d) (radius : \u211d) : Prop :=\n  (p.1 - center.1)^2 + (p.2 - center.2)^2 = radius^2\n\ntheorem three_color_circle_existence (coloring : ThreeColoring) :\n  \u2203 (center : \u211d \u00d7 \u211d) (radius : \u211d),\n    \u2200 (i : Fin 3), \u2203 (p : \u211d \u00d7 \u211d), \n      OnCircle p center radius \u2227 coloring.color p = i :=\n  sorry", "formal_statement_pred": "theorem lean_workbook_23580 : \u2200 f : \u211d \u00d7 \u211d \u2192 \u211d, (\u2200 x y z : \u211d \u00d7 \u211d, f x = f y \u2227 f y = f z \u2227 f z = f x) \u2192 \u2203 x y z : \u211d \u00d7 \u211d, f x = f y \u2227 f y = f z \u2227 f z = f x  :=  by sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_120", "informal_problem": "5. Each point of the plane is painted in one of three colors, and all three colors are used. Is it true that for any such coloring, one can choose a circle on which there are points of all three colors?", "formal_statement": "import Mathlib\n\n-- Define a coloring of the plane as a function from \u211d \u00d7 \u211d to a three-element type\nstructure ThreeColoring where\n  color : \u211d \u00d7 \u211d \u2192 Fin 3\n  all_colors_used : \u2200 (i : Fin 3), \u2203 (p : \u211d \u00d7 \u211d), color p = i\n\n-- Define what it means for a point to lie on a circle\ndef OnCircle (p : \u211d \u00d7 \u211d) (center : \u211d \u00d7 \u211d) (radius : \u211d) : Prop :=\n  (p.1 - center.1)^2 + (p.2 - center.2)^2 = radius^2\n\ntheorem three_color_circle_existence (coloring : ThreeColoring) :\n  \u2203 (center : \u211d \u00d7 \u211d) (radius : \u211d),\n    \u2200 (i : Fin 3), \u2203 (p : \u211d \u00d7 \u211d), \n      OnCircle p center radius \u2227 coloring.color p = i :=\n  sorry", "formal_statement_pred": "theorem lean_workbook_plus_81714 (f : \u211d \u00d7 \u211d \u2192 Fin 3) (hf : \u2200 x y : \u211d \u00d7 \u211d, f x \u2260 f y) : \u2200 x y : \u211d \u00d7 \u211d, \u2203 z : \u211d \u00d7 \u211d, z = x \u2228 z = y \u2228 f z \u2260 f x \u2227 f z \u2260 f y   :=  by sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_120", "informal_problem": "5. Each point of the plane is painted in one of three colors, and all three colors are used. Is it true that for any such coloring, one can choose a circle on which there are points of all three colors?", "formal_statement": "import Mathlib\n\n-- Define a coloring of the plane as a function from \u211d \u00d7 \u211d to a three-element type\nstructure ThreeColoring where\n  color : \u211d \u00d7 \u211d \u2192 Fin 3\n  all_colors_used : \u2200 (i : Fin 3), \u2203 (p : \u211d \u00d7 \u211d), color p = i\n\n-- Define what it means for a point to lie on a circle\ndef OnCircle (p : \u211d \u00d7 \u211d) (center : \u211d \u00d7 \u211d) (radius : \u211d) : Prop :=\n  (p.1 - center.1)^2 + (p.2 - center.2)^2 = radius^2\n\ntheorem three_color_circle_existence (coloring : ThreeColoring) :\n  \u2203 (center : \u211d \u00d7 \u211d) (radius : \u211d),\n    \u2200 (i : Fin 3), \u2203 (p : \u211d \u00d7 \u211d), \n      OnCircle p center radius \u2227 coloring.color p = i :=\n  sorry", "formal_statement_pred": "theorem lean_workbook_plus_55706 (f : \u211d \u00d7 \u211d \u2192 Fin 3) : \u2203 a : \u211d \u00d7 \u211d, \u2203 b : \u211d \u00d7 \u211d, \u2203 c : \u211d \u00d7 \u211d, f a \u2260 f b \u2227 f b \u2260 f c \u2227 f a \u2260 f c   :=  by sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_121", "informal_problem": "9.3. Can a $12 \\times 12$ checkerboard be divided into corners made of three adjacent cells $\\square$ such that each horizontal and each vertical row of cells on the board intersects the same number of corners? (A row intersects a corner if it contains at least one of its cells.)", "formal_statement": "import Mathlib\n\n/-- Represents the four possible orientations of a corner -/\ninductive CornerOrientation\n  | TopLeft    -- \u231c\n  | TopRight   -- \u231d\n  | BottomLeft -- \u231e\n  | BottomRight -- \u231f\n\n/-- A corner on the 12\u00d712 checkerboard consisting of three adjacent cells -/\nstructure Corner where\n  x : Fin 12      -- x-coordinate of the base cell\n  y : Fin 12      -- y-coordinate of the base cell\n  orientation : CornerOrientation\n\n/-- Predicate indicating whether a given position is part of the corner -/\ndef isInCorner (c : Corner) (x y : Fin 12) : Bool :=\n  match c.orientation with\n  | CornerOrientation.TopLeft => \n      (x = c.x && y = c.y) || \n      (x = c.x && y = c.y + 1) || \n      (x = c.x + 1 && y = c.y)\n  | CornerOrientation.TopRight => \n      (x = c.x && y = c.y) || \n      (x = c.x && y = c.y + 1) || \n      (x = c.x - 1 && y = c.y)\n  | CornerOrientation.BottomLeft => \n      (x = c.x && y = c.y) || \n      (x = c.x && y = c.y - 1) || \n      (x = c.x + 1 && y = c.y)\n  | CornerOrientation.BottomRight => \n      (x = c.x && y = c.y) || \n      (x = c.x && y = c.y - 1) || \n      (x = c.x - 1 && y = c.y)\n\n/-- A valid corner placement is a set of corners that forms a partition -/\ndef isValidPlacement (corners : Finset Corner) : Bool :=\n  -- Every cell belongs to exactly one corner\n  (\u2200 x y : Fin 12, (corners.filter (fun c \u21a6 isInCorner c x y)).card = 1)\n\n/-- Number of corners intersecting a row -/\ndef rowIntersections (corners : Finset Corner) (row : Fin 12) : Nat :=\n  (corners.filter (fun c \u21a6 \u2203 x : Fin 12, isInCorner c x row)).card\n\n/-- Number of corners intersecting a column -/\ndef colIntersections (corners : Finset Corner) (col : Fin 12) : Nat :=\n  (corners.filter (fun c \u21a6 \u2203 y : Fin 12, isInCorner c col y)).card\n\ntheorem checkerboard_corner_partition_impossible :\n  \u00ac\u2203 (corners : Finset Corner),\n    isValidPlacement corners \u2227\n    \u2203 k : \u2115, \n      (\u2200 row : Fin 12, rowIntersections corners row = k) \u2227\n      (\u2200 col : Fin 12, colIntersections corners col = k) :=\n  sorry", "formal_statement_pred": "theorem lean_workbook_plus_69060 (A B C D : Fin 12 \u2192 Fin 12 \u2192 Prop) (hA : A = fun x y => x + y + 1 \u2264 12) (hB : B = fun x y => x + y + 1 \u2264 12) (hC : C = fun x y => x + y + 1 \u2264 12) (hD : D = fun x y => x + y + 1 \u2264 12) (hA' : A x y \u2192 B x y) (hB' : B x y \u2192 C x y) (hC' : C x y \u2192 D x y) (hD' : D x y \u2192 A x y) : (\u2200 x y, A x y \u2228 B x y \u2228 C x y \u2228 D x y) \u2227 (\u2200 x y, A x y \u2192 B x y \u2192 C x y \u2192 D x y)   :=  by sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_123", "informal_problem": "6. Vasya has 19950 chips, painted in 200 different colors. He arranged them in a circle. Prove that there is such a pair of colors that the chips of these colors do not stand next to each other.", "formal_statement": "import Mathlib\n\nstructure ColoredChips where\n  numColors : Nat\n  totalChips : Nat\n  arrangement : Fin totalChips \u2192 Fin numColors\n  isCircular : True  -- Represents that chips are arranged in a circle\n\n/-- Two positions in the circular arrangement are adjacent -/\ndef areAdjacent (n : Nat) (i j : Fin n) : Bool :=\n  i.val + 1 = j.val \u2228 (i.val = n - 1 \u2227 j.val = 0)\n\ntheorem colored_chips_not_adjacent \n  (chips : ColoredChips)\n  (h1 : chips.totalChips = 19950)\n  (h2 : chips.numColors = 200) :\n  \u2203 (c1 c2 : Fin chips.numColors), \n    \u2200 (i j : Fin chips.totalChips), \n      areAdjacent chips.totalChips i j \u2192 \n        \u00ac(chips.arrangement i = c1 \u2227 chips.arrangement j = c2) :=\n  sorry", "formal_statement_pred": "theorem lean_workbook_plus_10199 (chips : Fin 19950 \u2192 Fin 200) (hx: \u2200 i, chips i \u2260 chips (i + 1)) : \u2203 a b, a \u2260 b \u2227 (chips a \u2260 chips (a + 1) \u2227 chips b \u2260 chips (b + 1))   :=  by sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_127", "informal_problem": "9.1. In a round-robin chess tournament, six people participated: two boys and four girls. Could the boys have scored twice as many points as the girls by the end of the tournament? (In a round-robin chess tournament, each player plays one game against each of the others. A win earns 1 point, a draw 0.5, and a loss 0 points.)", "formal_statement": "import Mathlib\n\n/-- Tournament size -/\ndef n : Nat := 6\n/-- Number of boys -/\ndef num_boys : Nat := 2\n/-- Number of girls -/\ndef num_girls : Nat := 4\n\n/-- Player type enumeration -/\ninductive PlayerType where\n  | Boy\n  | Girl\nderiving Repr, DecidableEq\n\n/-- Core tournament data structure -/\nstructure TournamentData where\n  results : Fin n \u00d7 Fin n \u2192 Rat\n  player_type : Fin n \u2192 PlayerType\n\n/-- Predicate for valid tournament scores (0, 0.5, or 1) -/\ndef valid_scores (t : TournamentData) : Prop :=\n  \u2200 i j, t.results (i, j) = 0 \u2228 t.results (i, j) = (1/2) \u2228 t.results (i, j) = 1\n\n/-- Each pair plays exactly one game with total score 1 -/\ndef valid_games (t : TournamentData) : Prop :=\n  \u2200 i j, t.results (i, j) + t.results (j, i) = 1\n\n/-- No self-play allowed -/\ndef no_self_play (t : TournamentData) : Prop :=\n  \u2200 i, t.results (i, i) = 0\n\n/-- Correct number of players of each type -/\ndef valid_player_counts (t : TournamentData) : Prop :=\n  (Finset.filter (fun i => t.player_type i = PlayerType.Boy) (Finset.univ)).card = num_boys \u2227\n  (Finset.filter (fun i => t.player_type i = PlayerType.Girl) (Finset.univ)).card = num_girls\n\n/-- Combined tournament validity predicate -/\ndef is_valid_tournament (t : TournamentData) : Prop :=\n  valid_scores t \u2227 valid_games t \u2227 no_self_play t \u2227 valid_player_counts t\n\n/-- Calculate score for a specific player type -/\ndef player_score (t : TournamentData) (ptype : PlayerType) : Rat :=\n  Finset.sum (Finset.filter (fun i => t.player_type i = ptype) Finset.univ) fun i =>\n    Finset.sum Finset.univ fun j => t.results (i, j)\n\n/-- In a 6-player round-robin tournament with 2 boys and 4 girls,\n    it's impossible for boys to score exactly twice as many points as girls -/\ntheorem chess_tournament_impossible :\n  \u00ac\u2203 (t : TournamentData), is_valid_tournament t \u2227 \n    player_score t PlayerType.Boy = 2 * player_score t PlayerType.Girl :=\n  sorry", "formal_statement_pred": "theorem lean_workbook_plus_79388 (hb : 2 * 4 < 5 * 2) : False   :=  by sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_128", "informal_problem": "9.6. From a chessboard of size $8 \\times 8$, a square of size $2 \\times 2$ was cut out such that the remaining board could be divided into rectangles of size $1 \\times 3$. Determine which square could have been cut out. (List all possible options and prove that there are no others.)", "formal_statement": "import Mathlib\n\n/-- Orientation of a 1\u00d73 rectangle on the board -/\ninductive RectangleOrientation where\n  | horizontal\n  | vertical\n\n/-- Position of the 2\u00d72 cutout on the board -/\nstructure ChessboardCutout where\n  x : Fin 7\n  y : Fin 7\n\n/-- A 1\u00d73 rectangle placement on the board -/\nstructure Rectangle where\n  x : Fin 8\n  y : Fin 8\n  orientation : RectangleOrientation\n  valid : match orientation with\n    | RectangleOrientation.horizontal => x.val + 2 < 8\n    | RectangleOrientation.vertical => y.val + 2 < 8\n\n/-- Checks if a position is within the 2\u00d72 cutout -/\ndef isInCutout (pos : Fin 8 \u00d7 Fin 8) (cutout : ChessboardCutout) : Bool :=\n  let (px, py) := pos\n  let cx := cutout.x.val\n  let cy := cutout.y.val\n  (px.val \u2265 cx \u2227 px.val < cx + 2) \u2227 (py.val \u2265 cy \u2227 py.val < cy + 2)\n\n/-- Checks if a position is covered by a rectangle -/\ndef isPositionCovered (pos : Fin 8 \u00d7 Fin 8) (rect : Rectangle) : Bool :=\n  let (px, py) := pos\n  match rect.orientation with\n  | RectangleOrientation.horizontal =>\n    py.val = rect.y.val \u2227 px.val \u2265 rect.x.val \u2227 px.val < rect.x.val + 3\n  | RectangleOrientation.vertical =>\n    px.val = rect.x.val \u2227 py.val \u2265 rect.y.val \u2227 py.val < rect.y.val + 3\n\n/-- Checks if two rectangles overlap -/\ndef rectanglesOverlap (r1 r2 : Rectangle) : Bool :=\n  \u2203 pos : Fin 8 \u00d7 Fin 8, isPositionCovered pos r1 \u2227 isPositionCovered pos r2\n\n/-- Determines if a cutout position is valid according to the modulo conditions -/\ndef isValidCutoutPosition (x y : Fin 7) : Bool :=\n  (x.val % 3 = 1 \u2227 y.val % 3 = 1) \u2228\n  (x.val % 3 = 1 \u2227 y.val % 3 = 4) \u2228\n  (x.val % 3 = 4 \u2227 y.val % 3 = 1) \u2228\n  (x.val % 3 = 4 \u2227 y.val % 3 = 4)\n\ntheorem chessboard_cutout_tiling_exists (cutout : ChessboardCutout) :\n  (\u2203 (rectangles : List Rectangle),\n    -- List contains exactly 20 rectangles (as (64-4)/3 = 20)\n    rectangles.length = 20 \u2227\n    -- All rectangles are valid and don't overlap with cutout\n    (\u2200 r, r \u2208 rectangles \u2192 \u00acisInCutout (r.x, r.y) cutout) \u2227\n    -- No rectangles overlap with each other\n    (\u2200 r1 r2, r1 \u2208 rectangles \u2192 r2 \u2208 rectangles \u2192 r1 \u2260 r2 \u2192 \u00acrectanglesOverlap r1 r2) \u2227\n    -- Every non-cutout square is covered by exactly one rectangle\n    (\u2200 pos : Fin 8 \u00d7 Fin 8, \u00acisInCutout pos cutout \u2192\n      (\u2203 r, r \u2208 rectangles \u2227 isPositionCovered pos r) \u2227\n      (\u2200 r1 r2, r1 \u2208 rectangles \u2192 r2 \u2208 rectangles \u2192 \n        isPositionCovered pos r1 \u2192 isPositionCovered pos r2 \u2192 r1 = r2))) \u2194\n  -- The cutout position is one of the valid positions\n  isValidCutoutPosition cutout.x cutout.y :=\n  sorry", "formal_statement_pred": "theorem lean_workbook_5643 (s : Fin 9) : (\u2203 a b : Fin 8, a \u2264 b \u2227 a + 1 \u2264 b \u2227 (b - a) % 2 = 0 \u2227 (b - a) % 3 = 0) \u2228 (s = 0 \u2228 s = 1 \u2228 s = 2 \u2228 s = 3 \u2228 s = 4 \u2228 s = 5 \u2228 s = 6 \u2228 s = 7 \u2228 s = 8)  :=  by sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_128", "informal_problem": "9.6. From a chessboard of size $8 \\times 8$, a square of size $2 \\times 2$ was cut out such that the remaining board could be divided into rectangles of size $1 \\times 3$. Determine which square could have been cut out. (List all possible options and prove that there are no others.)", "formal_statement": "import Mathlib\n\n/-- Orientation of a 1\u00d73 rectangle on the board -/\ninductive RectangleOrientation where\n  | horizontal\n  | vertical\n\n/-- Position of the 2\u00d72 cutout on the board -/\nstructure ChessboardCutout where\n  x : Fin 7\n  y : Fin 7\n\n/-- A 1\u00d73 rectangle placement on the board -/\nstructure Rectangle where\n  x : Fin 8\n  y : Fin 8\n  orientation : RectangleOrientation\n  valid : match orientation with\n    | RectangleOrientation.horizontal => x.val + 2 < 8\n    | RectangleOrientation.vertical => y.val + 2 < 8\n\n/-- Checks if a position is within the 2\u00d72 cutout -/\ndef isInCutout (pos : Fin 8 \u00d7 Fin 8) (cutout : ChessboardCutout) : Bool :=\n  let (px, py) := pos\n  let cx := cutout.x.val\n  let cy := cutout.y.val\n  (px.val \u2265 cx \u2227 px.val < cx + 2) \u2227 (py.val \u2265 cy \u2227 py.val < cy + 2)\n\n/-- Checks if a position is covered by a rectangle -/\ndef isPositionCovered (pos : Fin 8 \u00d7 Fin 8) (rect : Rectangle) : Bool :=\n  let (px, py) := pos\n  match rect.orientation with\n  | RectangleOrientation.horizontal =>\n    py.val = rect.y.val \u2227 px.val \u2265 rect.x.val \u2227 px.val < rect.x.val + 3\n  | RectangleOrientation.vertical =>\n    px.val = rect.x.val \u2227 py.val \u2265 rect.y.val \u2227 py.val < rect.y.val + 3\n\n/-- Checks if two rectangles overlap -/\ndef rectanglesOverlap (r1 r2 : Rectangle) : Bool :=\n  \u2203 pos : Fin 8 \u00d7 Fin 8, isPositionCovered pos r1 \u2227 isPositionCovered pos r2\n\n/-- Determines if a cutout position is valid according to the modulo conditions -/\ndef isValidCutoutPosition (x y : Fin 7) : Bool :=\n  (x.val % 3 = 1 \u2227 y.val % 3 = 1) \u2228\n  (x.val % 3 = 1 \u2227 y.val % 3 = 4) \u2228\n  (x.val % 3 = 4 \u2227 y.val % 3 = 1) \u2228\n  (x.val % 3 = 4 \u2227 y.val % 3 = 4)\n\ntheorem chessboard_cutout_tiling_exists (cutout : ChessboardCutout) :\n  (\u2203 (rectangles : List Rectangle),\n    -- List contains exactly 20 rectangles (as (64-4)/3 = 20)\n    rectangles.length = 20 \u2227\n    -- All rectangles are valid and don't overlap with cutout\n    (\u2200 r, r \u2208 rectangles \u2192 \u00acisInCutout (r.x, r.y) cutout) \u2227\n    -- No rectangles overlap with each other\n    (\u2200 r1 r2, r1 \u2208 rectangles \u2192 r2 \u2208 rectangles \u2192 r1 \u2260 r2 \u2192 \u00acrectanglesOverlap r1 r2) \u2227\n    -- Every non-cutout square is covered by exactly one rectangle\n    (\u2200 pos : Fin 8 \u00d7 Fin 8, \u00acisInCutout pos cutout \u2192\n      (\u2203 r, r \u2208 rectangles \u2227 isPositionCovered pos r) \u2227\n      (\u2200 r1 r2, r1 \u2208 rectangles \u2192 r2 \u2208 rectangles \u2192 \n        isPositionCovered pos r1 \u2192 isPositionCovered pos r2 \u2192 r1 = r2))) \u2194\n  -- The cutout position is one of the valid positions\n  isValidCutoutPosition cutout.x cutout.y :=\n  sorry", "formal_statement_pred": "theorem lean_workbook_plus_10707 (h : 8 * 8 - 2 * 2 = 6 * 3) : \u2203 x y, x * y = 2 * 2 \u2227 (8 * 8 - x * y) % (6 * 3) = 0   :=  by sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_136", "informal_problem": "9.1. In a quiz, 10 students participated and gave a total of 42 correct answers. Prove that at least 2 students gave the same number of correct answers (possibly zero).", "formal_statement": "import Mathlib\n\n-- No additional structures needed\n\ntheorem quiz_pigeonhole \n  (students : Finset Nat) \n  (answers : Nat \u2192 Nat)  -- maps student ID to their number of correct answers\n  (h_students : students.card = 10)\n  (h_total : (\u2211 i in students, answers i) = 42) :\n  \u2203 i j : Nat, i \u2208 students \u2227 j \u2208 students \u2227 i \u2260 j \u2227 answers i = answers j :=\n  sorry", "formal_statement_pred": "theorem lean_workbook_plus_63374 (f : \u2115 \u2192 \u2115) : \u2203 a b, a \u2260 b \u2227 f a = f b   :=  by sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_137", "informal_problem": "10.3. Pasha chose 2017 (not necessarily distinct) natural numbers $a_{1}, a_{2}, \\ldots, a_{2017}$ and plays the following game with himself. Initially, he has an unlimited supply of stones and 2017 large empty boxes. In one move, Pasha adds $a_{1}$ stones to any box (of his choice), $a_{2}$ stones to any of the remaining boxes (of his choice), ..., and finally, $a_{2017}$ stones to the remaining box. Pasha's goal is to achieve a state where, after some move, all the boxes have the same number of stones. Could he have chosen the numbers in such a way that the goal can be achieved in 43 moves, but not in a smaller non-zero number of moves?\n\n(I. Bogdanov)", "formal_statement": "import Mathlib\n\nstructure StoneGame where\n  numbers : Fin 2017 \u2192 Nat\n  boxes : Fin 2017 \u2192 Nat\n  move : Fin 2017 \u2192 Fin 2017 \u2192 Nat\n  -- move i j represents putting numbers[i] stones in box j during a move\n\ndef is_valid_move (g : StoneGame) (m : Fin 2017 \u2192 Fin 2017) : Bool :=\n  Function.Injective m\n\ndef apply_move (g : StoneGame) (m : Fin 2017 \u2192 Fin 2017) : Fin 2017 \u2192 Nat :=\n  fun i => g.boxes i + g.numbers (m i)\n\ndef boxes_equal (boxes : Fin 2017 \u2192 Nat) : Prop :=\n  \u2200 i j : Fin 2017, boxes i = boxes j\n\ndef can_achieve_equal_in_k_moves (g : StoneGame) (k : Nat) : Prop :=\n  \u2203 moves : Fin k \u2192 (Fin 2017 \u2192 Fin 2017),\n    (\u2200 i, is_valid_move g (moves i)) \u2227\n    \u2203 final_boxes, boxes_equal final_boxes\n\ntheorem stone_game_exact_moves : \n  \u2203 g : StoneGame,\n    (can_achieve_equal_in_k_moves g 43) \u2227\n    (\u2200 k : Nat, 0 < k \u2227 k < 43 \u2192 \u00accan_achieve_equal_in_k_moves g k) :=\n  sorry", "formal_statement_pred": "theorem lean_workbook_plus_5695 (a : \u2115 \u2192 \u2115) : (\u2200 x y, x \u2260 y \u2192 a x \u2260 a y) \u2227 \u2203 m, m > 43 \u2227 (\u2200 x y, a x = a y)   :=  by sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_138", "informal_problem": "5. In a round-robin football tournament (where each team plays every other team once), 12 teams participated. The tournament was not yet completed by November. Could it be that one team played exactly 11 games, three teams played exactly 9 games each, two teams played exactly 6 games each, four teams played exactly 4 games each, and the remaining two teams played exactly one game each?", "formal_statement": "import Mathlib\n\nstructure TournamentState where\n  n : Nat                    -- number of teams\n  gamesPlayed : Fin n \u2192 Nat  -- number of games played by each team\n  isValid : Bool            -- whether this represents a valid partial tournament state\n  \ndef isValidTournamentState (t : TournamentState) : Prop :=\n  -- Each pair of teams contributes exactly one game to both teams' counts\n  \u2200 i j : Fin t.n, i \u2260 j \u2192 \n    (t.gamesPlayed i + t.gamesPlayed j \u2264 1)  -- teams i and j have played at most one game\n    \u2227 (\u2200 k : Fin t.n, t.gamesPlayed k \u2264 t.n - 1) -- no team plays more than n-1 games\n\ntheorem tournament_state_impossible : \u00ac \u2203 (t : TournamentState), \n  t.n = 12 \u2227 \n  isValidTournamentState t \u2227\n  (\u2203 (teams : Fin 12 \u2192 Nat),\n    -- One team played 11 games\n    (\u2203! i, t.gamesPlayed i = 11) \u2227\n    -- Three teams played 9 games each\n    (\u2203 i\u2081 i\u2082 i\u2083, i\u2081 \u2260 i\u2082 \u2227 i\u2082 \u2260 i\u2083 \u2227 i\u2081 \u2260 i\u2083 \u2227 \n      t.gamesPlayed i\u2081 = 9 \u2227 t.gamesPlayed i\u2082 = 9 \u2227 t.gamesPlayed i\u2083 = 9) \u2227\n    -- Two teams played 6 games each\n    (\u2203 i\u2081 i\u2082, i\u2081 \u2260 i\u2082 \u2227 t.gamesPlayed i\u2081 = 6 \u2227 t.gamesPlayed i\u2082 = 6) \u2227\n    -- Four teams played 4 games each\n    (\u2203 i\u2081 i\u2082 i\u2083 i\u2084, i\u2081 \u2260 i\u2082 \u2227 i\u2082 \u2260 i\u2083 \u2227 i\u2083 \u2260 i\u2084 \u2227 i\u2081 \u2260 i\u2083 \u2227 i\u2081 \u2260 i\u2084 \u2227 i\u2082 \u2260 i\u2084 \u2227\n      t.gamesPlayed i\u2081 = 4 \u2227 t.gamesPlayed i\u2082 = 4 \u2227 \n      t.gamesPlayed i\u2083 = 4 \u2227 t.gamesPlayed i\u2084 = 4) \u2227\n    -- Two teams played 1 game each\n    (\u2203 i\u2081 i\u2082, i\u2081 \u2260 i\u2082 \u2227 t.gamesPlayed i\u2081 = 1 \u2227 t.gamesPlayed i\u2082 = 1)) :=\n  sorry", "formal_statement_pred": "theorem lean_workbook_plus_46552 (hf : 12 > 0) (h : 12 \u2223 11 + 9 + 9 + 6 + 6 + 4 + 4 + 4 + 4 + 1 + 1) : False   :=  by sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_138", "informal_problem": "5. In a round-robin football tournament (where each team plays every other team once), 12 teams participated. The tournament was not yet completed by November. Could it be that one team played exactly 11 games, three teams played exactly 9 games each, two teams played exactly 6 games each, four teams played exactly 4 games each, and the remaining two teams played exactly one game each?", "formal_statement": "import Mathlib\n\nstructure TournamentState where\n  n : Nat                    -- number of teams\n  gamesPlayed : Fin n \u2192 Nat  -- number of games played by each team\n  isValid : Bool            -- whether this represents a valid partial tournament state\n  \ndef isValidTournamentState (t : TournamentState) : Prop :=\n  -- Each pair of teams contributes exactly one game to both teams' counts\n  \u2200 i j : Fin t.n, i \u2260 j \u2192 \n    (t.gamesPlayed i + t.gamesPlayed j \u2264 1)  -- teams i and j have played at most one game\n    \u2227 (\u2200 k : Fin t.n, t.gamesPlayed k \u2264 t.n - 1) -- no team plays more than n-1 games\n\ntheorem tournament_state_impossible : \u00ac \u2203 (t : TournamentState), \n  t.n = 12 \u2227 \n  isValidTournamentState t \u2227\n  (\u2203 (teams : Fin 12 \u2192 Nat),\n    -- One team played 11 games\n    (\u2203! i, t.gamesPlayed i = 11) \u2227\n    -- Three teams played 9 games each\n    (\u2203 i\u2081 i\u2082 i\u2083, i\u2081 \u2260 i\u2082 \u2227 i\u2082 \u2260 i\u2083 \u2227 i\u2081 \u2260 i\u2083 \u2227 \n      t.gamesPlayed i\u2081 = 9 \u2227 t.gamesPlayed i\u2082 = 9 \u2227 t.gamesPlayed i\u2083 = 9) \u2227\n    -- Two teams played 6 games each\n    (\u2203 i\u2081 i\u2082, i\u2081 \u2260 i\u2082 \u2227 t.gamesPlayed i\u2081 = 6 \u2227 t.gamesPlayed i\u2082 = 6) \u2227\n    -- Four teams played 4 games each\n    (\u2203 i\u2081 i\u2082 i\u2083 i\u2084, i\u2081 \u2260 i\u2082 \u2227 i\u2082 \u2260 i\u2083 \u2227 i\u2083 \u2260 i\u2084 \u2227 i\u2081 \u2260 i\u2083 \u2227 i\u2081 \u2260 i\u2084 \u2227 i\u2082 \u2260 i\u2084 \u2227\n      t.gamesPlayed i\u2081 = 4 \u2227 t.gamesPlayed i\u2082 = 4 \u2227 \n      t.gamesPlayed i\u2083 = 4 \u2227 t.gamesPlayed i\u2084 = 4) \u2227\n    -- Two teams played 1 game each\n    (\u2203 i\u2081 i\u2082, i\u2081 \u2260 i\u2082 \u2227 t.gamesPlayed i\u2081 = 1 \u2227 t.gamesPlayed i\u2082 = 1)) :=\n  sorry", "formal_statement_pred": "theorem lean_workbook_plus_43187 (h : 12 * (11 + 9 + 9 + 6 + 6 + 4 + 4 + 4 + 4 + 1 + 1) = 660) : true   :=  by sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_138", "informal_problem": "5. In a round-robin football tournament (where each team plays every other team once), 12 teams participated. The tournament was not yet completed by November. Could it be that one team played exactly 11 games, three teams played exactly 9 games each, two teams played exactly 6 games each, four teams played exactly 4 games each, and the remaining two teams played exactly one game each?", "formal_statement": "import Mathlib\n\nstructure TournamentState where\n  n : Nat                    -- number of teams\n  gamesPlayed : Fin n \u2192 Nat  -- number of games played by each team\n  isValid : Bool            -- whether this represents a valid partial tournament state\n  \ndef isValidTournamentState (t : TournamentState) : Prop :=\n  -- Each pair of teams contributes exactly one game to both teams' counts\n  \u2200 i j : Fin t.n, i \u2260 j \u2192 \n    (t.gamesPlayed i + t.gamesPlayed j \u2264 1)  -- teams i and j have played at most one game\n    \u2227 (\u2200 k : Fin t.n, t.gamesPlayed k \u2264 t.n - 1) -- no team plays more than n-1 games\n\ntheorem tournament_state_impossible : \u00ac \u2203 (t : TournamentState), \n  t.n = 12 \u2227 \n  isValidTournamentState t \u2227\n  (\u2203 (teams : Fin 12 \u2192 Nat),\n    -- One team played 11 games\n    (\u2203! i, t.gamesPlayed i = 11) \u2227\n    -- Three teams played 9 games each\n    (\u2203 i\u2081 i\u2082 i\u2083, i\u2081 \u2260 i\u2082 \u2227 i\u2082 \u2260 i\u2083 \u2227 i\u2081 \u2260 i\u2083 \u2227 \n      t.gamesPlayed i\u2081 = 9 \u2227 t.gamesPlayed i\u2082 = 9 \u2227 t.gamesPlayed i\u2083 = 9) \u2227\n    -- Two teams played 6 games each\n    (\u2203 i\u2081 i\u2082, i\u2081 \u2260 i\u2082 \u2227 t.gamesPlayed i\u2081 = 6 \u2227 t.gamesPlayed i\u2082 = 6) \u2227\n    -- Four teams played 4 games each\n    (\u2203 i\u2081 i\u2082 i\u2083 i\u2084, i\u2081 \u2260 i\u2082 \u2227 i\u2082 \u2260 i\u2083 \u2227 i\u2083 \u2260 i\u2084 \u2227 i\u2081 \u2260 i\u2083 \u2227 i\u2081 \u2260 i\u2084 \u2227 i\u2082 \u2260 i\u2084 \u2227\n      t.gamesPlayed i\u2081 = 4 \u2227 t.gamesPlayed i\u2082 = 4 \u2227 \n      t.gamesPlayed i\u2083 = 4 \u2227 t.gamesPlayed i\u2084 = 4) \u2227\n    -- Two teams played 1 game each\n    (\u2203 i\u2081 i\u2082, i\u2081 \u2260 i\u2082 \u2227 t.gamesPlayed i\u2081 = 1 \u2227 t.gamesPlayed i\u2082 = 1)) :=\n  sorry", "formal_statement_pred": "theorem lean_workbook_plus_45846 : 12 > (11 + 9 + 9 + 6 + 6 + 4 + 4 + 1 + 1) / 2   :=  by sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_141", "informal_problem": "9.3. Kolya and Dima are playing a game on an $8 \\times 8$ board, taking turns, with Dima starting. Kolya draws crosses in the cells, while Dima covers pairs of adjacent cells (by sides) with $1 \\times 2$ rectangles (dominoes). On his turn, Kolya must place one cross in any empty cell (i.e., a cell that does not yet have a cross and is not covered by a domino). Dima, on his turn, must cover two adjacent cells (not yet covered by other dominoes) with a domino, where the total number of crosses in these two cells is even (0 or 2). The player who cannot make a move loses. Who has the winning strategy?\n\n(M. Diden)", "formal_statement": "import Mathlib\n\ninductive Cell\n  | empty\n  | cross\n  | domino (id : Nat)\n\nstructure CrossMove where\n  pos : Fin 8 \u00d7 Fin 8\n\nstructure DominoMove where\n  pos1 : Fin 8 \u00d7 Fin 8\n  pos2 : Fin 8 \u00d7 Fin 8\n\ninductive Move\n  | cross (m : CrossMove)\n  | domino (m : DominoMove)\n\nstructure GameState where\n  board : Matrix (Fin 8) (Fin 8) Cell\n  turn : Bool  -- true for Kolya (crosses), false for Dima (dominoes)\n  nextDominoId : Nat\n\ndef getCell (state : GameState) (pos : Fin 8 \u00d7 Fin 8) : Cell :=\n  state.board pos.1 pos.2\n\ndef isAdjacent (pos1 pos2 : Fin 8 \u00d7 Fin 8) : Bool :=\n  (pos1.1 = pos2.1 \u2227 (pos1.2.val + 1 = pos2.2.val \u2228 pos2.2.val + 1 = pos1.2.val)) \u2228\n  (pos1.2 = pos2.2 \u2227 (pos1.1.val + 1 = pos2.1.val \u2228 pos2.1.val + 1 = pos1.1.val))\n\ndef countCrosses (state : GameState) (pos1 pos2 : Fin 8 \u00d7 Fin 8) : Nat :=\n  let count (pos : Fin 8 \u00d7 Fin 8) : Nat :=\n    match getCell state pos with\n    | Cell.cross => 1\n    | _ => 0\n  count pos1 + count pos2\n\ndef isValidMove (state : GameState) (move : Move) : Prop :=\n  match move with\n  | Move.cross m =>\n      state.turn \u2227 \n      getCell state m.pos = Cell.empty\n  | Move.domino m =>\n      \u00acstate.turn \u2227\n      isAdjacent m.pos1 m.pos2 \u2227\n      getCell state m.pos1 = Cell.empty \u2227\n      getCell state m.pos2 = Cell.empty \u2227\n      countCrosses state m.pos1 m.pos2 % 2 = 0\n\ntheorem domino_cross_game_has_winner :\n  \u2203 (winner : Bool), \u2200 (state : GameState),\n    (state.turn = winner \u2192 \n      \u2203 (move : Move),\n        isValidMove state move) :=\n  sorry", "formal_statement_pred": "theorem lean_workbook_plus_40058 (a b c d e f g h : Fin 8 \u2192 Fin 8 \u2192 Bool) (ha : \u2200 i j, a i j = False) (hb : \u2200 i j, b i j = False) (hc : \u2200 i j, c i j = False) (hd : \u2200 i j, d i j = False) (he : \u2200 i j, e i j = False) (hf : \u2200 i j, f i j = False) (hg : \u2200 i j, g i j = False) (hh : \u2200 i j, h i j = False) (hab : a \u2260 b) (hbc : b \u2260 c) (hcd : c \u2260 d) (hde : d \u2260 e) (hef : e \u2260 f) (hgf : f \u2260 g) (hgh : g \u2260 h) : (\u2200 i j, a i j = True \u2228 b i j = True \u2228 c i j = True \u2228 d i j = True \u2228 e i j = True \u2228 f i j = True \u2228 g i j = True \u2228 h i j = True) \u2228 (\u2200 i j, a i j = False \u2227 b i j = False \u2227 c i j = False \u2227 d i j = False \u2227 e i j = False \u2227 f i j = False \u2227 g i j = False \u2227 h i j = False)   :=  by sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_141", "informal_problem": "9.3. Kolya and Dima are playing a game on an $8 \\times 8$ board, taking turns, with Dima starting. Kolya draws crosses in the cells, while Dima covers pairs of adjacent cells (by sides) with $1 \\times 2$ rectangles (dominoes). On his turn, Kolya must place one cross in any empty cell (i.e., a cell that does not yet have a cross and is not covered by a domino). Dima, on his turn, must cover two adjacent cells (not yet covered by other dominoes) with a domino, where the total number of crosses in these two cells is even (0 or 2). The player who cannot make a move loses. Who has the winning strategy?\n\n(M. Diden)", "formal_statement": "import Mathlib\n\ninductive Cell\n  | empty\n  | cross\n  | domino (id : Nat)\n\nstructure CrossMove where\n  pos : Fin 8 \u00d7 Fin 8\n\nstructure DominoMove where\n  pos1 : Fin 8 \u00d7 Fin 8\n  pos2 : Fin 8 \u00d7 Fin 8\n\ninductive Move\n  | cross (m : CrossMove)\n  | domino (m : DominoMove)\n\nstructure GameState where\n  board : Matrix (Fin 8) (Fin 8) Cell\n  turn : Bool  -- true for Kolya (crosses), false for Dima (dominoes)\n  nextDominoId : Nat\n\ndef getCell (state : GameState) (pos : Fin 8 \u00d7 Fin 8) : Cell :=\n  state.board pos.1 pos.2\n\ndef isAdjacent (pos1 pos2 : Fin 8 \u00d7 Fin 8) : Bool :=\n  (pos1.1 = pos2.1 \u2227 (pos1.2.val + 1 = pos2.2.val \u2228 pos2.2.val + 1 = pos1.2.val)) \u2228\n  (pos1.2 = pos2.2 \u2227 (pos1.1.val + 1 = pos2.1.val \u2228 pos2.1.val + 1 = pos1.1.val))\n\ndef countCrosses (state : GameState) (pos1 pos2 : Fin 8 \u00d7 Fin 8) : Nat :=\n  let count (pos : Fin 8 \u00d7 Fin 8) : Nat :=\n    match getCell state pos with\n    | Cell.cross => 1\n    | _ => 0\n  count pos1 + count pos2\n\ndef isValidMove (state : GameState) (move : Move) : Prop :=\n  match move with\n  | Move.cross m =>\n      state.turn \u2227 \n      getCell state m.pos = Cell.empty\n  | Move.domino m =>\n      \u00acstate.turn \u2227\n      isAdjacent m.pos1 m.pos2 \u2227\n      getCell state m.pos1 = Cell.empty \u2227\n      getCell state m.pos2 = Cell.empty \u2227\n      countCrosses state m.pos1 m.pos2 % 2 = 0\n\ntheorem domino_cross_game_has_winner :\n  \u2203 (winner : Bool), \u2200 (state : GameState),\n    (state.turn = winner \u2192 \n      \u2203 (move : Move),\n        isValidMove state move) :=\n  sorry", "formal_statement_pred": "theorem lean_workbook_plus_76594 (Kolya Dima : \u2115 \u2192 \u2115 \u2192 Bool) (h : \u2200 x y, Kolya x y \u2227 Dima x y \u2192 False) : (\u2200 x y, Kolya x y \u2192 \u2203 z w, Dima z w) \u2228 (\u2200 x y, Dima x y \u2192 \u2203 z w, Kolya z w)   :=  by sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_142", "informal_problem": "9.1. In the country, some pairs of cities are connected by one-way direct flights (there is no more than one flight between any two cities). We say that city $A$ is accessible from city $B$ if it is possible to fly from $B$ to $A$, possibly with layovers. It is known that for any two cities $P$ and $Q$, there exists a city $R$ such that both $P$ and $Q$ are accessible from $R$. Prove that there exists a city from which all cities in the country are accessible. (It is assumed that it is possible to fly from a city to itself.) (V. Dolnikov)", "formal_statement": "import Mathlib\n\nstructure FlightNetwork (\u03b1 : Type u) where\n  -- The directed edge relation representing direct flights between cities\n  hasDirectFlight : \u03b1 \u2192 \u03b1 \u2192 Prop\n  -- At most one direct flight between any ordered pair of cities\n  unique : \u2200 {a b : \u03b1}, hasDirectFlight a b \u2192 hasDirectFlight a b \u2192 a = b\n  -- Every city has a flight to itself (reflexivity)\n  refl : \u2200 (c : \u03b1), hasDirectFlight c c\n  -- Accessibility relation: can reach through sequence of flights\n  isAccessible : \u03b1 \u2192 \u03b1 \u2192 Prop := fun a b => \n    TC hasDirectFlight a b\n\ntheorem exists_universal_source {\u03b1 : Type u} [Nonempty \u03b1] (G : FlightNetwork \u03b1)\n  (h : \u2200 (p q : \u03b1), \u2203 (r : \u03b1), G.isAccessible r p \u2227 G.isAccessible r q) :\n  \u2203 (source : \u03b1), \u2200 (dest : \u03b1), G.isAccessible source dest :=\n  sorry", "formal_statement_pred": "theorem lean_workbook_27939 (c : Type) (f : c \u2192 c \u2192 Prop) (hf : \u2200 x y : c, (x = y \u2228 (f x y \u2228 f y x))) (hf2 : \u2200 x y : c, x \u2260 y \u2192 (f x y \u2228 f y x)) (h : \u2200 p q : c, \u2203 r : c, f r p \u2227 f r q) : \u2203 t : c, \u2200 x : c, f t x  :=  by sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_143", "informal_problem": "5. Is it possible to color the cells of an 8 x 8 board in three colors: 21 cells in white, 21 cells in blue, 22 cells in red - so that no diagonal (not only the two main diagonals, but all those parallel to them) contains cells of all three colors simultaneously?", "formal_statement": "import Mathlib\n\n/-- Determines if a position (row,col) lies on a diagonal starting at (start_row, start_col) -/\ndef is_on_diagonal (start_row start_col row col : Fin 8) : Prop :=\n  (row.val : \u2124) - (col.val : \u2124) = (start_row.val : \u2124) - (start_col.val : \u2124)\n\n/-- Count the number of cells of a given color -/\ndef count_cells (coloring : Fin 8 \u2192 Fin 8 \u2192 Fin 3) (c : Fin 3) : \u2115 :=\n  Finset.sum (Finset.univ : Finset (Fin 8)) fun i =>\n    Finset.card (Finset.filter (fun j => coloring i j = c) Finset.univ)\n\n/-- A valid three-coloring of an 8x8 board -/\nstructure BoardColoring where\n  color : Fin 8 \u2192 Fin 8 \u2192 Fin 3\n  white_count : count_cells color 0 = 21\n  blue_count : count_cells color 1 = 21\n  red_count : count_cells color 2 = 22\n\n/-- Checks if a diagonal contains all three colors -/\ndef has_all_colors (coloring : Fin 8 \u2192 Fin 8 \u2192 Fin 3) (start_row start_col : Fin 8) : Prop :=\n  \u2203 (i\u2081 i\u2082 i\u2083 j\u2081 j\u2082 j\u2083 : Fin 8), \n    (is_on_diagonal start_row start_col i\u2081 j\u2081 \u2227 coloring i\u2081 j\u2081 = 0) \u2227\n    (is_on_diagonal start_row start_col i\u2082 j\u2082 \u2227 coloring i\u2082 j\u2082 = 1) \u2227\n    (is_on_diagonal start_row start_col i\u2083 j\u2083 \u2227 coloring i\u2083 j\u2083 = 2)\n\ntheorem three_color_board_possible : \n  \u2203 (board : BoardColoring), \n    \u2200 (start_row start_col : Fin 8), \u00ac(has_all_colors board.color start_row start_col) :=\n  sorry", "formal_statement_pred": "theorem lean_workbook_10953 (f : Fin 8 \u2192 Fin 8 \u2192 Fin 3) : (\u2203 g : Fin 8 \u2192 Fin 8 \u2192 Fin 3, (g = f) \u2228 (g = fun x y => if f x y = 0 then 1 else 0)) \u2228 \u2203 g : Fin 8 \u2192 Fin 8 \u2192 Fin 3, (g = f) \u2228 (g = fun x y => if f x y = 0 then 1 else 0)  :=  by sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_143", "informal_problem": "5. Is it possible to color the cells of an 8 x 8 board in three colors: 21 cells in white, 21 cells in blue, 22 cells in red - so that no diagonal (not only the two main diagonals, but all those parallel to them) contains cells of all three colors simultaneously?", "formal_statement": "import Mathlib\n\n/-- Determines if a position (row,col) lies on a diagonal starting at (start_row, start_col) -/\ndef is_on_diagonal (start_row start_col row col : Fin 8) : Prop :=\n  (row.val : \u2124) - (col.val : \u2124) = (start_row.val : \u2124) - (start_col.val : \u2124)\n\n/-- Count the number of cells of a given color -/\ndef count_cells (coloring : Fin 8 \u2192 Fin 8 \u2192 Fin 3) (c : Fin 3) : \u2115 :=\n  Finset.sum (Finset.univ : Finset (Fin 8)) fun i =>\n    Finset.card (Finset.filter (fun j => coloring i j = c) Finset.univ)\n\n/-- A valid three-coloring of an 8x8 board -/\nstructure BoardColoring where\n  color : Fin 8 \u2192 Fin 8 \u2192 Fin 3\n  white_count : count_cells color 0 = 21\n  blue_count : count_cells color 1 = 21\n  red_count : count_cells color 2 = 22\n\n/-- Checks if a diagonal contains all three colors -/\ndef has_all_colors (coloring : Fin 8 \u2192 Fin 8 \u2192 Fin 3) (start_row start_col : Fin 8) : Prop :=\n  \u2203 (i\u2081 i\u2082 i\u2083 j\u2081 j\u2082 j\u2083 : Fin 8), \n    (is_on_diagonal start_row start_col i\u2081 j\u2081 \u2227 coloring i\u2081 j\u2081 = 0) \u2227\n    (is_on_diagonal start_row start_col i\u2082 j\u2082 \u2227 coloring i\u2082 j\u2082 = 1) \u2227\n    (is_on_diagonal start_row start_col i\u2083 j\u2083 \u2227 coloring i\u2083 j\u2083 = 2)\n\ntheorem three_color_board_possible : \n  \u2203 (board : BoardColoring), \n    \u2200 (start_row start_col : Fin 8), \u00ac(has_all_colors board.color start_row start_col) :=\n  sorry", "formal_statement_pred": "theorem lean_workbook_plus_69773 (A : Fin 8 \u2192 Fin 8 \u2192 Bool) : \u2203 B : Fin 8 \u2192 Fin 8 \u2192 Fin 3, (\u2200 i j, A i j = (B i j = 0)) \u2227 (\u2200 i j : Fin 8, (B i j = 0 \u2228 B i j = 1 \u2228 B i j = 2)) \u2227 (\u2200 i j k : Fin 8, i \u2260 j \u2227 j \u2260 k \u2227 k \u2260 i \u2192 (B i j = 0 \u2228 B i j = 1 \u2228 B i j = 2) \u2227 (B j k = 0 \u2228 B j k = 1 \u2228 B j k = 2) \u2227 (B k i = 0 \u2228 B k i = 1 \u2228 B k i = 2))   :=  by sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_143", "informal_problem": "5. Is it possible to color the cells of an 8 x 8 board in three colors: 21 cells in white, 21 cells in blue, 22 cells in red - so that no diagonal (not only the two main diagonals, but all those parallel to them) contains cells of all three colors simultaneously?", "formal_statement": "import Mathlib\n\n/-- Determines if a position (row,col) lies on a diagonal starting at (start_row, start_col) -/\ndef is_on_diagonal (start_row start_col row col : Fin 8) : Prop :=\n  (row.val : \u2124) - (col.val : \u2124) = (start_row.val : \u2124) - (start_col.val : \u2124)\n\n/-- Count the number of cells of a given color -/\ndef count_cells (coloring : Fin 8 \u2192 Fin 8 \u2192 Fin 3) (c : Fin 3) : \u2115 :=\n  Finset.sum (Finset.univ : Finset (Fin 8)) fun i =>\n    Finset.card (Finset.filter (fun j => coloring i j = c) Finset.univ)\n\n/-- A valid three-coloring of an 8x8 board -/\nstructure BoardColoring where\n  color : Fin 8 \u2192 Fin 8 \u2192 Fin 3\n  white_count : count_cells color 0 = 21\n  blue_count : count_cells color 1 = 21\n  red_count : count_cells color 2 = 22\n\n/-- Checks if a diagonal contains all three colors -/\ndef has_all_colors (coloring : Fin 8 \u2192 Fin 8 \u2192 Fin 3) (start_row start_col : Fin 8) : Prop :=\n  \u2203 (i\u2081 i\u2082 i\u2083 j\u2081 j\u2082 j\u2083 : Fin 8), \n    (is_on_diagonal start_row start_col i\u2081 j\u2081 \u2227 coloring i\u2081 j\u2081 = 0) \u2227\n    (is_on_diagonal start_row start_col i\u2082 j\u2082 \u2227 coloring i\u2082 j\u2082 = 1) \u2227\n    (is_on_diagonal start_row start_col i\u2083 j\u2083 \u2227 coloring i\u2083 j\u2083 = 2)\n\ntheorem three_color_board_possible : \n  \u2203 (board : BoardColoring), \n    \u2200 (start_row start_col : Fin 8), \u00ac(has_all_colors board.color start_row start_col) :=\n  sorry", "formal_statement_pred": "theorem lean_workbook_39934 : \u2203 color : Fin 8 \u2192 Fin 8 \u2192 Fin 3, (\u2200 i j, (i, j) \u2260 (0, 0) \u2192 (i, j) \u2260 (7, 7) \u2192 (i, j) \u2260 (0, 7) \u2192 (i, j) \u2260 (7, 0) \u2192 (color i j = 0 \u2228 color i j = 1 \u2228 color i j = 2)) \u2227 (\u2200 i j k l, i \u2260 k \u2228 j \u2260 l \u2192 (color i j \u2260 0 \u2228 color k l \u2260 0 \u2228 color i j \u2260 1 \u2228 color k l \u2260 1 \u2228 color i j \u2260 2 \u2228 color k l \u2260 2))  :=  by sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_144", "informal_problem": "3. In a volleyball tournament, 6 teams participated. Prove that after one round of games (each team played with each other exactly once), there will be a team that won at least $3$ games (there are no draws in volleyball).", "formal_statement": "import Mathlib\n\nstructure VolleyballTournament where\n  n : Nat\n  -- results i j = true means i won against j\n  results : Fin n \u2192 Fin n \u2192 Bool\n  -- No team plays against itself\n  irrefl : \u2200 i, results i i = false\n  -- For each pair of teams, exactly one is the winner\n  antisymm : \u2200 i j, results i j = !(results j i)\n\ntheorem volleyball_tournament_winner (t : VolleyballTournament) (h : t.n = 6) :\n  \u2203 team : Fin t.n, (Finset.sum (Finset.univ.erase team) \n    (fun opponent => if t.results team opponent then 1 else 0)) \u2265 3 :=\n  sorry", "formal_statement_pred": "theorem lean_workbook_11351 (h : 0 < 6) : \u2203 k, 3 \u2264 k \u2227 k \u2264 6   :=  by sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_144", "informal_problem": "3. In a volleyball tournament, 6 teams participated. Prove that after one round of games (each team played with each other exactly once), there will be a team that won at least $3$ games (there are no draws in volleyball).", "formal_statement": "import Mathlib\n\nstructure VolleyballTournament where\n  n : Nat\n  -- results i j = true means i won against j\n  results : Fin n \u2192 Fin n \u2192 Bool\n  -- No team plays against itself\n  irrefl : \u2200 i, results i i = false\n  -- For each pair of teams, exactly one is the winner\n  antisymm : \u2200 i j, results i j = !(results j i)\n\ntheorem volleyball_tournament_winner (t : VolleyballTournament) (h : t.n = 6) :\n  \u2203 team : Fin t.n, (Finset.sum (Finset.univ.erase team) \n    (fun opponent => if t.results team opponent then 1 else 0)) \u2265 3 :=\n  sorry", "formal_statement_pred": "theorem lean_workbook_4152 (t : Fin 6 \u2192 Fin 6 \u2192 Nat) (h : \u2200 i j, i \u2260 j \u2192 t i j + t j i = 3) : \u2203 i : Fin 6, 3 \u2264 t i i  :=  by sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_145", "informal_problem": "3. Can an infinite sheet of graph paper be divided into dominoes $1 \\times 2$ cells in such a way that every line running along the grid lines cuts only a finite number of dominoes in half?", "formal_statement": "import Mathlib\n\n/-- A domino is defined by its top-left corner position and orientation -/\nstructure Domino where\n  pos : \u2124 \u00d7 \u2124  -- position of the top-left corner\n  isHorizontal : Bool -- true for horizontal, false for vertical\n\n/-- The set of cells covered by a domino -/\ndef domino_cells (d : Domino) : Set (\u2124 \u00d7 \u2124) :=\n  if d.isHorizontal then \n    Set.insert d.pos (Set.singleton (d.pos.1 + 1, d.pos.2))\n  else \n    Set.insert d.pos (Set.singleton (d.pos.1, d.pos.2 + 1))\n\n/-- A grid line is either horizontal (y = k) or vertical (x = k) -/\ninductive GridLine where\n  | vertical (x : \u2124) : GridLine\n  | horizontal (y : \u2124) : GridLine\n\n/-- Determines if a grid line intersects a domino through its interior -/\ndef line_cuts_domino (l : GridLine) (d : Domino) : Prop :=\n  match l with\n  | GridLine.vertical k => \n      d.isHorizontal \u2227 d.pos.1 < k \u2227 k < d.pos.1 + 1\n  | GridLine.horizontal k => \n      \u00acd.isHorizontal \u2227 d.pos.2 < k \u2227 k < d.pos.2 + 1\n\n/-- A tiling is a collection of dominoes that covers the plane without overlaps -/\nstructure DominoTiling where\n  dominoes : Set Domino\n  covers_plane : \u2200 (x y : \u2124), \u2203 (d : Domino), d \u2208 dominoes \u2227 (x, y) \u2208 domino_cells d\n  no_overlaps : \u2200 (d\u2081 d\u2082 : Domino), d\u2081 \u2208 dominoes \u2192 d\u2082 \u2208 dominoes \u2192 d\u2081 \u2260 d\u2082 \u2192 \n                domino_cells d\u2081 \u2229 domino_cells d\u2082 = \u2205\n\n/-- The set of dominoes cut by a grid line -/\ndef cut_dominoes (t : DominoTiling) (l : GridLine) : Set Domino :=\n  { d : Domino | d \u2208 t.dominoes \u2227 line_cuts_domino l d }\n\ntheorem no_finite_cuts_tiling :\n  \u2200 (t : DominoTiling), \u2203 (l : GridLine), \u00acFinite (cut_dominoes t l) :=\n  sorry", "formal_statement_pred": "theorem lean_workbook_plus_1708 (h : 0 < 1) : False   :=  by sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_149", "informal_problem": "6.2. The sixth-grade students went to a party. Each boy had 5 balloons, and each girl had 4 balloons. On the way, the children started to play and pop each other's balloons. (Of course, they did not pop their own balloons.) In the end, each girl popped exactly one balloon, and each boy popped exactly two balloons. Dima counted all the surviving balloons and got 100. Prove that Dima was wrong.", "formal_statement": "import Mathlib\n\nstructure PartySetup where\n  boys : Nat      -- number of boys\n  girls : Nat     -- number of girls\n  \ndef initial_balloons (p : PartySetup) : Nat :=\n  5 * p.boys + 4 * p.girls\n\ndef popped_balloons (p : PartySetup) : Nat :=\n  2 * p.boys + p.girls\n\ndef surviving_balloons (p : PartySetup) : Nat :=\n  initial_balloons p - popped_balloons p\n\ntheorem party_balloon_count_impossible :\n  \u00ac\u2203 (p : PartySetup), surviving_balloons p = 100 :=\n  sorry", "formal_statement_pred": "theorem lean_workbook_12905 :\n  \u2200 b g, (b + g) = 10 \u2227 b * 5 + g * 4 - (b * 2 + g * 1) = 100 \u2192 False  :=  by sorry", "compiled": true, "aligned": true}
{"id": "CombStruct4Lean_151", "informal_problem": "2. Numbers from 1 to 8 were arranged in some order in a circle, and then the sums of adjacent numbers were recorded. Could it be that 8 consecutive numbers (in some order) were obtained?", "formal_statement": "import Mathlib\n\nstructure CircularArrangement where\n  -- The arrangement of numbers from 1 to 8 in a circle\n  nums : Fin 8 \u2192 Fin 8\n  -- Ensure it's a permutation (bijective)\n  is_perm : Function.Bijective nums\n\n-- Function to get the sum of adjacent numbers at position i\ndef adjacent_sums (arr : CircularArrangement) (i : Fin 8) : Nat :=\n  -- Convert Fin 8 values to Nat and add 1 since we want numbers 1-8\n  (arr.nums i).val + 1 + (arr.nums ((i.val + 1) % 8)).val + 1\n\ntheorem no_consecutive_sums (arr : CircularArrangement) :\n  \u00ac\u2203 (start : Nat), \u2200 (i : Fin 8),\n    (adjacent_sums arr i) = start + i.val :=\n  sorry", "formal_statement_pred": "theorem lean_workbook_plus_40530 :\n  1 < 8 \u2227 8 < 16 \u2227 16 < 24 \u2227 24 < 32 \u2227 32 < 40 \u2227 40 < 48 \u2227 48 < 56 \u2227 56 < 64 \u2227 64 < 72 \u2227 72 < 80 \u2227 80 < 88 \u2227 88 < 96 \u2227 96 < 104 \u2227 104 < 112 \u2227 112 < 120 \u2227 120 < 128 \u2227 128 < 136 \u2227 136 < 144 \u2227 144 < 152 \u2227 152 < 160 \u2227 160 < 168 \u2227 168 < 176 \u2227 176 < 184 \u2227 184 < 192 \u2227 192 < 200 \u2227 200 < 208 \u2227 208 < 216 \u2227 216 < 224 \u2227 224 < 232 \u2227 232 < 240 \u2227 240 < 248 \u2227 248 < 256 \u2227 256 < 264 \u2227 264 < 272 \u2227 272 < 280 \u2227 280 < 288 \u2227 288 < 296 \u2227 296 < 304 \u2227 304 < 312 \u2227 312 < 320 \u2227 320 < 328 \u2227 328 < 336 \u2227 336 < 344 \u2227 344 < 352 \u2227 352 < 360 \u2227 360 < 368 \u2227 368 < 376 \u2227 376 < 384 \u2227 384 < 392 \u2227 392 < 400 \u2227 400 < 408 \u2227 408 < 416 \u2227 416 < 424 \u2227 424 < 432 \u2227 432 < 440 \u2227 440 < 448 \u2227 448 < 456 \u2227 456 < 464 \u2227 464 < 472 \u2227 472 < 480 \u2227 480 < 488 \u2227 488 < 496 \u2227 496 < 504 \u2227 504 < 512 \u2227 512 < 520 \u2227 520 < 528 \u2227 528 < 536 \u2227 536 < 544 \u2227 544 < 552 \u2227 552 < 560 \u2227 560 < 568 \u2227 568 < 576 \u2227 576 < 584 \u2227 584 < 592 \u2227 592 < 600 \u2227 600 < 608 \u2227 608 < 616 \u2227 616 < 624 \u2227 624 < 632 \u2227 632 < 640 \u2227 640 < 648 \u2227 648 < 656 \u2227 656 < 664 \u2227 664 < 672 \u2227 672 < 680 \u2227 680 < 688 \u2227 688 < 696 \u2227 696 < 704 \u2227 704 < 712 \u2227 712 < 720 \u2227 720 < 728 \u2227 728 < 736 \u2227 736 < 744 \u2227 744 < 752 \u2227 752 < 760 \u2227 760 < 768 \u2227 768 < 776 \u2227 776 < 784 \u2227 784 < 792 \u2227 792 < 800 \u2227 800 < 808 \u2227 808 < 816 \u2227 816 < 824 \u2227 824 < 832 \u2227 832 < 840 \u2227 840 < 848 \u2227 848 < 856 \u2227 856 < 864 \u2227 864 < 872 \u2227 872 < 880 \u2227 880 < 888 \u2227 888 < 896 \u2227 896 < 904 \u2227 904 < 912 \u2227 912 < 920 \u2227 920 < 928 \u2227 928 < 936 \u2227 936 < 944 \u2227 944 < 952 \u2227 952 < 960 \u2227 960 < 968 \u2227 968 < 976 \u2227 976 < 984 \u2227 984 < 992 \u2227 992 < 1000   :=  by sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_153", "informal_problem": "5. In an internet community of 20 participants, there are friends. Any two participants A and B are either friends themselves or there exists a chain\n\n$\\mathrm{A}-\\mathrm{C}_{1}-\\ldots-\\mathrm{C}_{\\mathrm{k}}-\\mathrm{B}$\n\nwhere adjacent participants in the chain are friends, that is, $\\mathrm{C}_{1}$ is a friend of $\\mathrm{A}, \\mathrm{C}_{2}$ is a friend of $\\mathrm{C}_{1}, \\ldots$ and B is a friend of $\\mathrm{C}_{\\mathrm{k}}$. Prove that it is possible to select 6 participants from the community such that any of the remaining fourteen is either a friend or a friend of a friend of someone among these six.", "formal_statement": "import Mathlib\nopen SimpleGraph\n\nstructure Community where\n  friendship : SimpleGraph (Fin 20)\n  connected : friendship.Connected\n\n/-- A participant is reachable in two steps from a set if they are either:\n    1. In the set\n    2. A direct neighbor of someone in the set\n    3. A neighbor of a neighbor of someone in the set -/\ndef twoStepReachable (c : Community) (selected : Finset (Fin 20)) (p : Fin 20) : Prop :=\n  p \u2208 selected \u2228 \n  (\u2203 s \u2208 selected, c.friendship.Adj s p) \u2228\n  (\u2203 s \u2208 selected, \u2203 f, c.friendship.Adj s f \u2227 c.friendship.Adj f p)\n\ntheorem community_selection_exists (c : Community) :\n  \u2203 selected : Finset (Fin 20),\n    selected.card = 6 \u2227 \n    \u2200 p : Fin 20, twoStepReachable c selected p :=\n  sorry", "formal_statement_pred": "theorem lean_workbook_plus_55751 (k : \u2115) (f : Fin 20 \u2192 Fin 20 \u2192 Fin 20) (hf : \u2200 A B : Fin 20, A \u2260 B \u2192 \u2203 k : \u2115, \u2203 C : \u2115 \u2192 Fin 20, f A B = C k) : \u2203 A B C D E F : Fin 20, (\u2200 x : Fin 20, (x = A \u2228 x = B \u2228 x = C \u2228 x = D \u2228 x = E \u2228 x = F) \u2228 (x = f A x \u2228 x = f B x \u2228 x = f C x \u2228 x = f D x \u2228 x = f E x \u2228 x = f F x))   :=  by sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_155", "informal_problem": "10.2. In a chess tournament, each of the 10 players played one game against each other, and Petya came in last place (scored fewer points than any other participant). Then one player was disqualified, and all points earned in matches against him were annulled, and this player was removed from the table. Could Petya have become the winner of the tournament (scored more points than any other participant) as a result?", "formal_statement": "import Mathlib\n\nstructure ChessTournament where\n  n : Nat                                    -- number of players\n  scores : Fin n \u2192 Nat                       -- scores of each player\n  disqualified : Fin n                       -- the player who got disqualified\n  original_scores : Fin n \u2192 Nat              -- scores before disqualification\n  petya : Fin n                              -- Petya's player number\n  h_petya_last : \u2200 i : Fin n, i \u2260 petya \u2192 original_scores petya < original_scores i\n  h_scores_valid : \u2200 i : Fin n, scores i = if i = disqualified then 0 \n    else original_scores i - (if original_scores i > original_scores disqualified then 1 else 0)\n\ntheorem chess_tournament_petya_winner \n  : \u2203 (t : ChessTournament), t.n = 10 \u2227 \n    (\u2200 i : Fin t.n, i \u2260 t.petya \u2192 i \u2260 t.disqualified \u2192 t.scores t.petya > t.scores i) :=\n  sorry", "formal_statement_pred": "theorem lean_workbook_plus_64680 (h\u2080 : 10 < 0) : 10 < 0   :=  by sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_155", "informal_problem": "10.2. In a chess tournament, each of the 10 players played one game against each other, and Petya came in last place (scored fewer points than any other participant). Then one player was disqualified, and all points earned in matches against him were annulled, and this player was removed from the table. Could Petya have become the winner of the tournament (scored more points than any other participant) as a result?", "formal_statement": "import Mathlib\n\nstructure ChessTournament where\n  n : Nat                                    -- number of players\n  scores : Fin n \u2192 Nat                       -- scores of each player\n  disqualified : Fin n                       -- the player who got disqualified\n  original_scores : Fin n \u2192 Nat              -- scores before disqualification\n  petya : Fin n                              -- Petya's player number\n  h_petya_last : \u2200 i : Fin n, i \u2260 petya \u2192 original_scores petya < original_scores i\n  h_scores_valid : \u2200 i : Fin n, scores i = if i = disqualified then 0 \n    else original_scores i - (if original_scores i > original_scores disqualified then 1 else 0)\n\ntheorem chess_tournament_petya_winner \n  : \u2203 (t : ChessTournament), t.n = 10 \u2227 \n    (\u2200 i : Fin t.n, i \u2260 t.petya \u2192 i \u2260 t.disqualified \u2192 t.scores t.petya > t.scores i) :=\n  sorry", "formal_statement_pred": "theorem lean_workbook_plus_10586 (h\u2081 : 10 \u2260 0) : 10 \u2260 0   :=  by sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_155", "informal_problem": "10.2. In a chess tournament, each of the 10 players played one game against each other, and Petya came in last place (scored fewer points than any other participant). Then one player was disqualified, and all points earned in matches against him were annulled, and this player was removed from the table. Could Petya have become the winner of the tournament (scored more points than any other participant) as a result?", "formal_statement": "import Mathlib\n\nstructure ChessTournament where\n  n : Nat                                    -- number of players\n  scores : Fin n \u2192 Nat                       -- scores of each player\n  disqualified : Fin n                       -- the player who got disqualified\n  original_scores : Fin n \u2192 Nat              -- scores before disqualification\n  petya : Fin n                              -- Petya's player number\n  h_petya_last : \u2200 i : Fin n, i \u2260 petya \u2192 original_scores petya < original_scores i\n  h_scores_valid : \u2200 i : Fin n, scores i = if i = disqualified then 0 \n    else original_scores i - (if original_scores i > original_scores disqualified then 1 else 0)\n\ntheorem chess_tournament_petya_winner \n  : \u2203 (t : ChessTournament), t.n = 10 \u2227 \n    (\u2200 i : Fin t.n, i \u2260 t.petya \u2192 i \u2260 t.disqualified \u2192 t.scores t.petya > t.scores i) :=\n  sorry", "formal_statement_pred": "theorem lean_workbook_plus_12820 (h : False) : False   :=  by sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_159", "informal_problem": "11.8. Petya placed several chips on a $50 \\times 50$ board, with no more than one chip in each cell. Prove that Vasya can place no more than 99 new chips (possibly none) on the free cells of the same board so that there is still no more than one chip in each cell, and each row and each column of the board has an even number of chips.\n\n(S. Berlov)", "formal_statement": "import Mathlib\n\ndef count_row (n : Nat) (i : Fin n) (initial added : Fin n \u00d7 Fin n \u2192 Bool) : Nat :=\n  Finset.card (Finset.filter (fun j => initial (i, j) \u2228 added (i, j)) (Finset.univ : Finset (Fin n)))\n\ndef count_col (n : Nat) (j : Fin n) (initial added : Fin n \u00d7 Fin n \u2192 Bool) : Nat :=\n  Finset.card (Finset.filter (fun i => initial (i, j) \u2228 added (i, j)) (Finset.univ : Finset (Fin n)))\n\ndef count_total (n : Nat) (added : Fin n \u00d7 Fin n \u2192 Bool) : Nat :=\n  Finset.card (Finset.filter (fun p => added p) (Finset.univ : Finset (Fin n \u00d7 Fin n)))\n\ntheorem chip_placement_bound {n : Nat} (h : n = 50) (initial : Fin n \u00d7 Fin n \u2192 Bool) :\n  \u2203 (added : Fin n \u00d7 Fin n \u2192 Bool),\n    (\u2200 i j : Fin n, \u00ac(initial (i, j) \u2227 added (i, j))) \u2227 \n    (\u2200 i : Fin n, Even (count_row n i initial added)) \u2227\n    (\u2200 j : Fin n, Even (count_col n j initial added)) \u2227\n    count_total n added \u2264 99 :=\n  sorry", "formal_statement_pred": "theorem lean_workbook_plus_14359 (b : Fin 50 \u2192 Fin 50 \u2192 Prop) (hb : \u2200 i j, \u00ac(b i j \u2227 b i j)) : \u2203 c : Fin 50 \u2192 Fin 50 \u2192 Prop, (\u2200 i j, \u00ac(c i j \u2227 c i j)) \u2227 (\u2200 i : Fin 50, \u2203 j : Fin 50, c i j) \u2227 (\u2200 j : Fin 50, \u2203 i : Fin 50, c i j)   :=  by sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_160", "informal_problem": "5. On the coordinate plane, 2017 points with integer coordinates $(x, y)$ were marked arbitrarily, where $1 \\leq x \\leq 2016$ and $1 \\leq y \\leq 2016$. Prove that there will always be two different segments with endpoints among these points, having the same length.", "formal_statement": "import Mathlib\n\nstructure Point where\n  x : Int\n  y : Int\n  x_bound : 1 \u2264 x \u2227 x \u2264 2016\n  y_bound : 1 \u2264 y \u2227 y \u2264 2016\n\ndef distance_squared (p\u2081 p\u2082 : Point) : Int :=\n  (p\u2081.x - p\u2082.x)^2 + (p\u2081.y - p\u2082.y)^2\n\nstructure Segment where\n  p\u2081 : Point\n  p\u2082 : Point\n  distinct : p\u2081 \u2260 p\u2082\n\ntheorem equal_length_segments_exist (points : Finset Point) \n    (h_size : points.card = 2017)\n    (h_valid : \u2200 p \u2208 points, 1 \u2264 p.x \u2227 p.x \u2264 2016 \u2227 1 \u2264 p.y \u2227 p.y \u2264 2016) :\n    \u2203 (s\u2081 s\u2082 : Segment),\n      s\u2081.p\u2081 \u2208 points \u2227 s\u2081.p\u2082 \u2208 points \u2227\n      s\u2082.p\u2081 \u2208 points \u2227 s\u2082.p\u2082 \u2208 points \u2227\n      s\u2081 \u2260 s\u2082 \u2227\n      distance_squared s\u2081.p\u2081 s\u2081.p\u2082 = distance_squared s\u2082.p\u2081 s\u2082.p\u2082 :=\n  sorry", "formal_statement_pred": "theorem lean_workbook_plus_59284 (f: \u2115 \u00d7 \u2115 \u2192 \u2115) (hf: \u2200 x y, 1<=x \u2227 x <= 2016 \u2227 1 <= y \u2227 y <= 2016 \u2192 (x,y) \u2260 (0,0)) : \u2203 (a b c d : \u2115), (a,b) \u2260 (c,d) \u2227 (f (a,b) = f (c,d))   :=  by sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_160", "informal_problem": "5. On the coordinate plane, 2017 points with integer coordinates $(x, y)$ were marked arbitrarily, where $1 \\leq x \\leq 2016$ and $1 \\leq y \\leq 2016$. Prove that there will always be two different segments with endpoints among these points, having the same length.", "formal_statement": "import Mathlib\n\nstructure Point where\n  x : Int\n  y : Int\n  x_bound : 1 \u2264 x \u2227 x \u2264 2016\n  y_bound : 1 \u2264 y \u2227 y \u2264 2016\n\ndef distance_squared (p\u2081 p\u2082 : Point) : Int :=\n  (p\u2081.x - p\u2082.x)^2 + (p\u2081.y - p\u2082.y)^2\n\nstructure Segment where\n  p\u2081 : Point\n  p\u2082 : Point\n  distinct : p\u2081 \u2260 p\u2082\n\ntheorem equal_length_segments_exist (points : Finset Point) \n    (h_size : points.card = 2017)\n    (h_valid : \u2200 p \u2208 points, 1 \u2264 p.x \u2227 p.x \u2264 2016 \u2227 1 \u2264 p.y \u2227 p.y \u2264 2016) :\n    \u2203 (s\u2081 s\u2082 : Segment),\n      s\u2081.p\u2081 \u2208 points \u2227 s\u2081.p\u2082 \u2208 points \u2227\n      s\u2082.p\u2081 \u2208 points \u2227 s\u2082.p\u2082 \u2208 points \u2227\n      s\u2081 \u2260 s\u2082 \u2227\n      distance_squared s\u2081.p\u2081 s\u2081.p\u2082 = distance_squared s\u2082.p\u2081 s\u2082.p\u2082 :=\n  sorry", "formal_statement_pred": "theorem lean_workbook_plus_57817 (p : \u2115 \u00d7 \u2115 \u2192 \u2115) (hp : \u2200 x y, 1 \u2264 x \u2227 x \u2264 2016 \u2227 1 \u2264 y \u2227 y \u2264 2016) : \u2203 a b c d, a \u2260 c \u2227 a \u2260 d \u2227 b \u2260 c \u2227 b \u2260 d \u2227 (p (a, b) = p (c, d))   :=  by sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_163", "informal_problem": "8.4. In the cells of a $15 \\times 15$ table, the numbers $1, 2, \\ldots, 15$ are written. In each row and each column, each of these numbers appears exactly once. In cells symmetric with respect to the main diagonal of the table (running from the top left to the bottom right), the same numbers are written. Prove that all numbers are represented on the main diagonal.", "formal_statement": "import Mathlib\n\nstructure SymmetricLatinSquare (n : Nat) where\n  -- The table is represented as a function from pairs of indices to numbers\n  table : Fin n \u2192 Fin n \u2192 Fin n\n  -- Each row contains each number exactly once\n  row_latin : \u2200 i k : Fin n, \u2203! j : Fin n, table i j = k\n  -- Each column contains each number exactly once\n  col_latin : \u2200 j k : Fin n, \u2203! i : Fin n, table i j = k\n  -- Symmetry across main diagonal\n  symmetric : \u2200 i j : Fin n, table i j = table j i\n\ntheorem symmetric_latin_square_diagonal_complete :\n  \u2200 (s : SymmetricLatinSquare 15),\n  \u2200 k : Fin 15, \u2203 i : Fin 15, s.table i i = k :=\n  sorry", "formal_statement_pred": "theorem lean_workbook_plus_8422 (A : Fin 15 \u2192 Fin 15 \u2192 \u2115) (hA : \u2200 i j, A i j = A j i) (hA' : \u2200 i, A i i = A 0 0) : \u2200 i j, A i j = A j i \u2227 A i i = A 0 0 \u2192 \u2200 i, A i i = A 0 0   :=  by sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_165", "informal_problem": "3. A hexagon is formed from 3 yellow and 3 blue sticks, such that the colors of the sticks alternate along its perimeter. From any three consecutive sticks, a triangle can be formed. Prove that a triangle can also be formed from the sticks of one of the colors.", "formal_statement": "import Mathlib\n\ninductive StickColor\n| yellow\n| blue\nderiving Repr, DecidableEq\n\nstructure ColoredStick where\n  length : \u211d\n  length_pos : length > 0\n  color : StickColor\n\ndef forms_triangle (s\u2081 s\u2082 s\u2083 : \u211d) : Prop :=\n  s\u2081 + s\u2082 > s\u2083 \u2227 s\u2082 + s\u2083 > s\u2081 \u2227 s\u2083 + s\u2081 > s\u2082\n\nstructure AlternatingHexagon where\n  sticks : Fin 6 \u2192 ColoredStick\n  lengths_pos : \u2200 i, (sticks i).length > 0\n  alternating : \u2200 i : Fin 6, \n    (sticks i).color = if i.val % 2 = 0 then StickColor.yellow else StickColor.blue\n  consecutive_triangle : \u2200 i : Fin 6, \n    forms_triangle \n      (sticks i).length\n      (sticks \u27e8(i.val + 1) % 6, by exact Nat.mod_lt _ (by norm_num)\u27e9).length\n      (sticks \u27e8(i.val + 2) % 6, by exact Nat.mod_lt _ (by norm_num)\u27e9).length\n\ntheorem monochromatic_triangle_exists (h : AlternatingHexagon) :\n  \u2203 (s\u2081 s\u2082 s\u2083 : ColoredStick),\n    s\u2081 \u2208 Set.range h.sticks \u2227\n    s\u2082 \u2208 Set.range h.sticks \u2227\n    s\u2083 \u2208 Set.range h.sticks \u2227\n    s\u2081.color = s\u2082.color \u2227\n    s\u2082.color = s\u2083.color \u2227\n    forms_triangle s\u2081.length s\u2082.length s\u2083.length :=\n  sorry", "formal_statement_pred": "theorem lean_workbook_plus_63696 (hx: x = 1 / 2) (hx1: y = 1 / 3) (hx2: z = 1 / 6) : x * y * z = 1 / 36   :=  by sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_165", "informal_problem": "3. A hexagon is formed from 3 yellow and 3 blue sticks, such that the colors of the sticks alternate along its perimeter. From any three consecutive sticks, a triangle can be formed. Prove that a triangle can also be formed from the sticks of one of the colors.", "formal_statement": "import Mathlib\n\ninductive StickColor\n| yellow\n| blue\nderiving Repr, DecidableEq\n\nstructure ColoredStick where\n  length : \u211d\n  length_pos : length > 0\n  color : StickColor\n\ndef forms_triangle (s\u2081 s\u2082 s\u2083 : \u211d) : Prop :=\n  s\u2081 + s\u2082 > s\u2083 \u2227 s\u2082 + s\u2083 > s\u2081 \u2227 s\u2083 + s\u2081 > s\u2082\n\nstructure AlternatingHexagon where\n  sticks : Fin 6 \u2192 ColoredStick\n  lengths_pos : \u2200 i, (sticks i).length > 0\n  alternating : \u2200 i : Fin 6, \n    (sticks i).color = if i.val % 2 = 0 then StickColor.yellow else StickColor.blue\n  consecutive_triangle : \u2200 i : Fin 6, \n    forms_triangle \n      (sticks i).length\n      (sticks \u27e8(i.val + 1) % 6, by exact Nat.mod_lt _ (by norm_num)\u27e9).length\n      (sticks \u27e8(i.val + 2) % 6, by exact Nat.mod_lt _ (by norm_num)\u27e9).length\n\ntheorem monochromatic_triangle_exists (h : AlternatingHexagon) :\n  \u2203 (s\u2081 s\u2082 s\u2083 : ColoredStick),\n    s\u2081 \u2208 Set.range h.sticks \u2227\n    s\u2082 \u2208 Set.range h.sticks \u2227\n    s\u2083 \u2208 Set.range h.sticks \u2227\n    s\u2081.color = s\u2082.color \u2227\n    s\u2082.color = s\u2083.color \u2227\n    forms_triangle s\u2081.length s\u2082.length s\u2083.length :=\n  sorry", "formal_statement_pred": "theorem lean_workbook_plus_31403 (hx: a > 0 \u2227 b > 0 \u2227 c > 0 \u2227 a + b + c = 2 * \u03c0) (hab : a + b > c) (hbc : b + c > a) (hca : a + c > b) : (a + b + c = \u03c0 \u2227 a + b > c \u2227 b + c > a \u2227 a + c > b) \u2228 (a + b + c = 2 * \u03c0 \u2227 a + b > c \u2227 b + c > a \u2227 a + c > b)   :=  by sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_167", "informal_problem": "2. Given a $6 \\times 3$ table. Each cell is filled with a number 0 or 1. If at the intersection of any two rows and any two columns all four numbers are the same, then the table is considered to be filled unsuccessfully. Is it possible to fill the table in such a way to avoid this phenomenon?", "formal_statement": "import Mathlib\n\ndef Table := Fin 6 \u2192 Fin 3 \u2192 Bool\n\ndef is_successful_filling (t : Table) : Prop :=\n  \u2200 (r\u2081 r\u2082 : Fin 6) (c\u2081 c\u2082 : Fin 3),\n    r\u2081 \u2260 r\u2082 \u2192 c\u2081 \u2260 c\u2082 \u2192\n    \u00ac(t r\u2081 c\u2081 = t r\u2081 c\u2082 \u2227 \n      t r\u2081 c\u2081 = t r\u2082 c\u2081 \u2227 \n      t r\u2081 c\u2081 = t r\u2082 c\u2082)\n\ntheorem exists_successful_filling : \n  \u2203 (t : Table), is_successful_filling t :=\n  sorry", "formal_statement_pred": "theorem lean_workbook_37056 : \u2200 t : Fin 6 \u2192 Fin 3 \u2192 \u2124, (\u2200 i j : Fin 6, i \u2260 j \u2192 \u2200 k l : Fin 3, k \u2260 l \u2192 t i k = t j l)  :=  by sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_167", "informal_problem": "2. Given a $6 \\times 3$ table. Each cell is filled with a number 0 or 1. If at the intersection of any two rows and any two columns all four numbers are the same, then the table is considered to be filled unsuccessfully. Is it possible to fill the table in such a way to avoid this phenomenon?", "formal_statement": "import Mathlib\n\ndef Table := Fin 6 \u2192 Fin 3 \u2192 Bool\n\ndef is_successful_filling (t : Table) : Prop :=\n  \u2200 (r\u2081 r\u2082 : Fin 6) (c\u2081 c\u2082 : Fin 3),\n    r\u2081 \u2260 r\u2082 \u2192 c\u2081 \u2260 c\u2082 \u2192\n    \u00ac(t r\u2081 c\u2081 = t r\u2081 c\u2082 \u2227 \n      t r\u2081 c\u2081 = t r\u2082 c\u2081 \u2227 \n      t r\u2081 c\u2081 = t r\u2082 c\u2082)\n\ntheorem exists_successful_filling : \n  \u2203 (t : Table), is_successful_filling t :=\n  sorry", "formal_statement_pred": "theorem lean_workbook_plus_17435 : \u2203 f : Fin 6 \u2192 Fin 3 \u2192 \u2115, \u2200 (i j : Fin 6) (x y : Fin 3), (i \u2260 j \u2227 x \u2260 y) \u2192 f i x \u2260 f j y   :=  by sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_167", "informal_problem": "2. Given a $6 \\times 3$ table. Each cell is filled with a number 0 or 1. If at the intersection of any two rows and any two columns all four numbers are the same, then the table is considered to be filled unsuccessfully. Is it possible to fill the table in such a way to avoid this phenomenon?", "formal_statement": "import Mathlib\n\ndef Table := Fin 6 \u2192 Fin 3 \u2192 Bool\n\ndef is_successful_filling (t : Table) : Prop :=\n  \u2200 (r\u2081 r\u2082 : Fin 6) (c\u2081 c\u2082 : Fin 3),\n    r\u2081 \u2260 r\u2082 \u2192 c\u2081 \u2260 c\u2082 \u2192\n    \u00ac(t r\u2081 c\u2081 = t r\u2081 c\u2082 \u2227 \n      t r\u2081 c\u2081 = t r\u2082 c\u2081 \u2227 \n      t r\u2081 c\u2081 = t r\u2082 c\u2082)\n\ntheorem exists_successful_filling : \n  \u2203 (t : Table), is_successful_filling t :=\n  sorry", "formal_statement_pred": "theorem lean_workbook_50360 :\n  \u2200 A : Fin 6 \u2192 Fin 3 \u2192 Fin 2,  \u2203 A : Fin 6 \u2192 Fin 3 \u2192 Fin 2,   \u2200 r\u2081 r\u2082 c\u2081 c\u2082, A r\u2081 c\u2081 = A r\u2082 c\u2081 \u2227 A r\u2081 c\u2081 = A r\u2081 c\u2082 \u2227 A r\u2081 c\u2081 = A r\u2082 c\u2082 \u2192 False  :=  by sorry", "compiled": true, "aligned": true}
{"id": "CombStruct4Lean_171", "informal_problem": "7.5. At the vertices of a cube, 8 numbers: $1, 2, \\ldots, 8$ were arranged in some order, and then for each of the 12 edges of the cube, the sum of the two numbers at its ends was calculated. Prove that among these sums there are coinciding ones.", "formal_statement": "import Mathlib\n\n/-- The fixed set of edges in a cube, represented as pairs of vertices -/\ndef cubeEdges : List (Fin 8 \u00d7 Fin 8) := [\n  (0, 1), (1, 2), (2, 3), (3, 0),  -- front face\n  (4, 5), (5, 6), (6, 7), (7, 4),  -- back face\n  (0, 4), (1, 5), (2, 6), (3, 7)   -- connecting edges\n]\n\n/-- A valid labeling of cube vertices with numbers 1 through 8 -/\nstructure CubeLabeling where\n  label : Fin 8 \u2192 Nat\n  valid : \u2200 i, 1 \u2264 label i \u2227 label i \u2264 8\n  distinct : \u2200 i j, i \u2260 j \u2192 label i \u2260 label j\n\n/-- Computes the sum of labels at the endpoints of an edge -/\ndef edgeSum (l : CubeLabeling) (e : Fin 8 \u00d7 Fin 8) : Nat :=\n  l.label e.1 + l.label e.2\n\ntheorem cube_edge_sums_not_distinct (l : CubeLabeling) :\n  \u2203 (e\u2081 e\u2082 : Fin 8 \u00d7 Fin 8), \n    e\u2081 \u2208 cubeEdges \u2227 \n    e\u2082 \u2208 cubeEdges \u2227 \n    e\u2081 \u2260 e\u2082 \u2227\n    edgeSum l e\u2081 = edgeSum l e\u2082 :=\n  sorry", "formal_statement_pred": "theorem lean_workbook_44727 : \u2200 a b c d e f g h : \u2115, a \u2260 b \u2228 a \u2260 c \u2228 a \u2260 d \u2228 a \u2260 e \u2228 a \u2260 f \u2228 a \u2260 g \u2228 a \u2260 h \u2228 b \u2260 c \u2228 b \u2260 d \u2228 b \u2260 e \u2228 b \u2260 f \u2228 b \u2260 g \u2228 b \u2260 h \u2228 c \u2260 d \u2228 c \u2260 e \u2228 c \u2260 f \u2228 c \u2260 g \u2228 c \u2260 h \u2228 d \u2260 e \u2228 d \u2260 f \u2228 d \u2260 g \u2228 d \u2260 h \u2228 e \u2260 f \u2228 e \u2260 g \u2228 e \u2260 h \u2228 f \u2260 g \u2228 f \u2260 h \u2228 g \u2260 h  :=  by sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_173", "informal_problem": "10.4. A cube of size $5 \\times 5 \\times 5$ cells is divided into $1 \\times 1 \\times 1$ cubes, each of which contains a grasshopper. At some moment, each grasshopper moves to an adjacent cube (up, down, left, or right, provided that the cube exists). Will there be a cube that does not contain any grasshopper?", "formal_statement": "import Mathlib\n\n/-- Position in a 5\u00d75\u00d75 cube using zero-based indices -/\nstructure Position where\n  x : Fin 5\n  y : Fin 5\n  z : Fin 5\n\n/-- Checks if two positions are adjacent in the cube -/\ndef isAdjacent (p\u2081 p\u2082 : Position) : Bool :=\n  let dx := (p\u2081.x.val : \u2124) - (p\u2082.x.val : \u2124)\n  let dy := (p\u2081.y.val : \u2124) - (p\u2082.y.val : \u2124)\n  let dz := (p\u2081.z.val : \u2124) - (p\u2082.z.val : \u2124)\n  abs dx + abs dy + abs dz = 1\n\n/-- Represents the movement of all grasshoppers in one step -/\nstructure MovementConfig where\n  final_position : Position \u2192 Position  -- Where each grasshopper moves to\n  moves_adjacent : \u2200 p : Position, isAdjacent p (final_position p) = true\n\n/-- After all grasshoppers move to adjacent positions, there must be at least one empty position -/\ntheorem grasshopper_movement_theorem :\n  \u2200 (config : MovementConfig), \u2203 (p : Position), \n    (\u2200 q : Position, config.final_position q \u2260 p) :=\n  sorry", "formal_statement_pred": "theorem lean_workbook_16656 (h\u2081 : \u2200 x y z, 0 \u2264 x \u2227 x \u2264 5 \u2227 0 \u2264 y \u2227 y \u2264 5 \u2227 0 \u2264 z \u2227 z \u2264 5 \u2192\n  \u2203 x' y' z', 0 \u2264 x' \u2227 x' \u2264 5 \u2227 0 \u2264 y' \u2227 y' \u2264 5 \u2227 0 \u2264 z' \u2227 z' \u2264 5 \u2227\n    x = x' + 1 \u2228 x = x' - 1 \u2228 y = y' + 1 \u2228 y = y' - 1 \u2228 z = z' + 1 \u2228 z = z' - 1)\n  (h\u2082 : \u2200 x y z, 0 \u2264 x \u2227 x \u2264 5 \u2227 0 \u2264 y \u2227 y \u2264 5 \u2227 0 \u2264 z \u2227 z \u2264 5 \u2192\n  \u2203 x' y' z', 0 \u2264 x' \u2227 x' \u2264 5 \u2227 0 \u2264 y' \u2227 y' \u2264 5 \u2227 0 \u2264 z' \u2227 z' \u2264 5 \u2227\n    x = x' + 1 \u2228 x = x' - 1 \u2228 y = y' + 1 \u2228 y = y' - 1 \u2228 z = z' + 1 \u2228 z = z' - 1) :\n  \u2203 x y z, 0 \u2264 x \u2227 x \u2264 5 \u2227 0 \u2264 y \u2227 y \u2264 5 \u2227 0 \u2264 z \u2227 z \u2264 5 \u2227\n    (\u00ac (\u2203 x' y' z', 0 \u2264 x' \u2227 x' \u2264 5 \u2227 0 \u2264 y' \u2227 y' \u2264 5 \u2227 0 \u2264 z' \u2227 z' \u2264 5 \u2227\n    x = x' + 1 \u2228 x = x' - 1 \u2228 y = y' + 1 \u2228 y = y' - 1 \u2228 z = z' + 1 \u2228 z = z' - 1))  :=  by sorry", "compiled": true, "aligned": true}
{"id": "CombStruct4Lean_173", "informal_problem": "10.4. A cube of size $5 \\times 5 \\times 5$ cells is divided into $1 \\times 1 \\times 1$ cubes, each of which contains a grasshopper. At some moment, each grasshopper moves to an adjacent cube (up, down, left, or right, provided that the cube exists). Will there be a cube that does not contain any grasshopper?", "formal_statement": "import Mathlib\n\n/-- Position in a 5\u00d75\u00d75 cube using zero-based indices -/\nstructure Position where\n  x : Fin 5\n  y : Fin 5\n  z : Fin 5\n\n/-- Checks if two positions are adjacent in the cube -/\ndef isAdjacent (p\u2081 p\u2082 : Position) : Bool :=\n  let dx := (p\u2081.x.val : \u2124) - (p\u2082.x.val : \u2124)\n  let dy := (p\u2081.y.val : \u2124) - (p\u2082.y.val : \u2124)\n  let dz := (p\u2081.z.val : \u2124) - (p\u2082.z.val : \u2124)\n  abs dx + abs dy + abs dz = 1\n\n/-- Represents the movement of all grasshoppers in one step -/\nstructure MovementConfig where\n  final_position : Position \u2192 Position  -- Where each grasshopper moves to\n  moves_adjacent : \u2200 p : Position, isAdjacent p (final_position p) = true\n\n/-- After all grasshoppers move to adjacent positions, there must be at least one empty position -/\ntheorem grasshopper_movement_theorem :\n  \u2200 (config : MovementConfig), \u2203 (p : Position), \n    (\u2200 q : Position, config.final_position q \u2260 p) :=\n  sorry", "formal_statement_pred": "theorem lean_workbook_40282 (h : \u2200 x y z, 0 < x \u2227 x <= 4 \u2227 0 < y \u2227 y <= 4 \u2227 0 < z \u2227 z <= 4 \u2192 \u2203 x' y' z', (x' = x + 1 \u2228 x' = x - 1 \u2228 y' = y + 1 \u2228 y' = y - 1 \u2228 z' = z + 1 \u2228 z' = z - 1) \u2227 0 < x' \u2227 x' <= 5 \u2227 0 < y' \u2227 y' <= 5 \u2227 0 < z' \u2227 z' <= 5) : \u00ac (\u2200 x y z, 0 < x \u2227 x <= 5 \u2227 0 < y \u2227 y <= 5 \u2227 0 < z \u2227 z <= 5 \u2192 \u2203 x' y' z', (x' = x + 1 \u2228 x' = x - 1 \u2228 y' = y + 1 \u2228 y' = y - 1 \u2228 z' = z + 1 \u2228 z' = z - 1) \u2227 0 < x' \u2227 x' <= 5 \u2227 0 < y' \u2227 y' <= 5 \u2227 0 < z' \u2227 z' <= 5)  :=  by sorry", "compiled": true, "aligned": true}
{"id": "CombStruct4Lean_181", "informal_problem": "10.1. In the National Basketball Association, there are 30 teams, each of which plays 82 games with other teams in the regular season. Can the Association's management divide the teams (not necessarily equally) into Eastern and Western Conferences and create a schedule such that games between teams from different conferences make up exactly half of the total number of games?\n\n(A. Gribalko)", "formal_statement": "import Mathlib\n\n-- A game is a pair of distinct teams\nstructure Game (n : Nat) where\n  team1 : Fin n\n  team2 : Fin n\n  distinct : team1 \u2260 team2\n\n-- NBA Schedule with conference division\nstructure NBASchedule (n : Nat) (g : Nat) where\n  -- Conference assignment (true for East, false for West)\n  conference : Fin n \u2192 Bool\n  -- List of all games in the schedule\n  games : List (Game n)\n  -- Each team appears in exactly g games\n  games_per_team : \u2200 t : Fin n,\n    (games.filter (\u03bb game => game.team1 = t \u2228 game.team2 = t)).length = g\n  -- Conferences are non-empty\n  valid_conferences : \u2203 t1 t2 : Fin n, conference t1 \u2260 conference t2\n\ntheorem nba_conference_schedule_exists :\n  \u2203 (s : NBASchedule 30 82),\n    -- Number of inter-conference games equals half of total games\n    let interConfGames := s.games.filter (\u03bb g => s.conference g.team1 \u2260 s.conference g.team2)\n    interConfGames.length = (30 * 82) / 2 :=\n  sorry", "formal_statement_pred": "theorem lean_workbook_33945 : 30 * 82 % 2 = 0 \u2227 30 * 82 = 1860 \u2227 1860 \u2264 30 * 82 * 82 / 2 \u2227 1860 \u2264 30 * 82 * 82 / 2  :=  by sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_181", "informal_problem": "10.1. In the National Basketball Association, there are 30 teams, each of which plays 82 games with other teams in the regular season. Can the Association's management divide the teams (not necessarily equally) into Eastern and Western Conferences and create a schedule such that games between teams from different conferences make up exactly half of the total number of games?\n\n(A. Gribalko)", "formal_statement": "import Mathlib\n\n-- A game is a pair of distinct teams\nstructure Game (n : Nat) where\n  team1 : Fin n\n  team2 : Fin n\n  distinct : team1 \u2260 team2\n\n-- NBA Schedule with conference division\nstructure NBASchedule (n : Nat) (g : Nat) where\n  -- Conference assignment (true for East, false for West)\n  conference : Fin n \u2192 Bool\n  -- List of all games in the schedule\n  games : List (Game n)\n  -- Each team appears in exactly g games\n  games_per_team : \u2200 t : Fin n,\n    (games.filter (\u03bb game => game.team1 = t \u2228 game.team2 = t)).length = g\n  -- Conferences are non-empty\n  valid_conferences : \u2203 t1 t2 : Fin n, conference t1 \u2260 conference t2\n\ntheorem nba_conference_schedule_exists :\n  \u2203 (s : NBASchedule 30 82),\n    -- Number of inter-conference games equals half of total games\n    let interConfGames := s.games.filter (\u03bb g => s.conference g.team1 \u2260 s.conference g.team2)\n    interConfGames.length = (30 * 82) / 2 :=\n  sorry", "formal_statement_pred": "theorem lean_workbook_19872 : 30 * 82 / 2 < 15 * 82  :=  by sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_185", "informal_problem": "3. Seryozha cut a square birthday cake weighing 900 g with two straight cuts parallel to one pair of sides, and two cuts parallel to the other pair of sides, into 9 rectangular pieces. Prove that Petya can choose such three pieces of cake that do not share any sides and their total weight is not less than 300 g.", "formal_statement": "import Mathlib\n\nopen Finset Real\n\n/-- A 3x3 cake grid with weights that sum to 900g -/\nstructure CakeGrid where\n  weights : Fin 3 \u2192 Fin 3 \u2192 \u211d\n  total_weight : (\u2211 i : Fin 3, \u2211 j : Fin 3, weights i j) = 900\n  pos_weights : \u2200 i j, weights i j > 0\n\n/-- Two positions are adjacent if they share a side (Manhattan distance = 1) -/\ndef are_adjacent (p1 p2 : Fin 3 \u00d7 Fin 3) : Prop :=\n  let d\u2081 := Int.natAbs (p1.1.val - p2.1.val)\n  let d\u2082 := Int.natAbs (p1.2.val - p2.2.val)\n  (d\u2081 = 1 \u2227 d\u2082 = 0) \u2228 (d\u2081 = 0 \u2227 d\u2082 = 1)\n\n/-- A valid selection is three pieces that don't share any sides -/\ndef ValidSelection (s : Finset (Fin 3 \u00d7 Fin 3)) : Prop :=\n  s.card = 3 \u2227 \u2200 p1 \u2208 s, \u2200 p2 \u2208 s, p1 \u2260 p2 \u2192 \u00acare_adjacent p1 p2\n\n/-- The weight of a piece at a given position -/\ndef piece_weight (cake : CakeGrid) (pos : Fin 3 \u00d7 Fin 3) : \u211d :=\n  cake.weights pos.1 pos.2\n\ntheorem cake_pieces_exist (cake : CakeGrid) :\n  \u2203 s : Finset (Fin 3 \u00d7 Fin 3), \n    ValidSelection s \u2227 \n    (\u2211 p in s, piece_weight cake p) \u2265 300 :=\n  sorry", "formal_statement_pred": "theorem lean_workbook_plus_51868 (hx: x > 0 \u2227 y > 0) (habc : x + y + z = 3) (hxy: x + y > z) (hxyz: x + y + z > 0) :  x^2 + y^2 + z^2 >= 3   :=  by sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_186", "informal_problem": "5. On cards, Petya wrote down three natural numbers, each from 1 to 20. Moreover, there are no two cards with the same set of numbers. Prove that there will be two cards having exactly one common number, if it is known that Petya filled out 21 cards.", "formal_statement": "import Mathlib\n\nstructure Card where\n  nums : Finset Nat\n  h_size : nums.card = 3\n  h_range : \u2200 n \u2208 nums, 1 \u2264 n \u2227 n \u2264 20\n\ndef has_one_common (c1 c2 : Card) : Prop :=\n  (c1.nums \u2229 c2.nums).card = 1\n\ndef are_distinct (c1 c2 : Card) : Prop := \n  c1.nums \u2260 c2.nums\n\ndef is_valid_card (c : Card) : Prop := \n  c.nums.card = 3 \u2227 (\u2200 n \u2208 c.nums, 1 \u2264 n \u2227 n \u2264 20)\n\ntheorem petya_cards_common_number \n  (cards : Finset Card)\n  (h_card_count : cards.card = 21)\n  (h_valid : \u2200 c \u2208 cards, is_valid_card c)\n  (h_distinct : \u2200 (c1 c2 : Card), c1 \u2208 cards \u2192 c2 \u2208 cards \u2192 c1 \u2260 c2 \u2192 are_distinct c1 c2) :\n  \u2203 c1 c2, c1 \u2208 cards \u2227 c2 \u2208 cards \u2227 c1 \u2260 c2 \u2227 has_one_common c1 c2 := sorry", "formal_statement_pred": "theorem lean_workbook_plus_61992 (f : \u2115 \u2192 \u2115 \u2192 \u2115 \u2192 Prop) (hf: f x y z \u2194 x = y \u2228 y = z \u2228 z = x) (H: \u2203 x y z: \u2115, f x y z): \u2203 x y z: \u2115, x \u2260 y \u2227 y \u2260 z \u2227 z \u2260 x \u2227 f x y z   :=  by sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_186", "informal_problem": "5. On cards, Petya wrote down three natural numbers, each from 1 to 20. Moreover, there are no two cards with the same set of numbers. Prove that there will be two cards having exactly one common number, if it is known that Petya filled out 21 cards.", "formal_statement": "import Mathlib\n\nstructure Card where\n  nums : Finset Nat\n  h_size : nums.card = 3\n  h_range : \u2200 n \u2208 nums, 1 \u2264 n \u2227 n \u2264 20\n\ndef has_one_common (c1 c2 : Card) : Prop :=\n  (c1.nums \u2229 c2.nums).card = 1\n\ndef are_distinct (c1 c2 : Card) : Prop := \n  c1.nums \u2260 c2.nums\n\ndef is_valid_card (c : Card) : Prop := \n  c.nums.card = 3 \u2227 (\u2200 n \u2208 c.nums, 1 \u2264 n \u2227 n \u2264 20)\n\ntheorem petya_cards_common_number \n  (cards : Finset Card)\n  (h_card_count : cards.card = 21)\n  (h_valid : \u2200 c \u2208 cards, is_valid_card c)\n  (h_distinct : \u2200 (c1 c2 : Card), c1 \u2208 cards \u2192 c2 \u2208 cards \u2192 c1 \u2260 c2 \u2192 are_distinct c1 c2) :\n  \u2203 c1 c2, c1 \u2208 cards \u2227 c2 \u2208 cards \u2227 c1 \u2260 c2 \u2227 has_one_common c1 c2 := sorry", "formal_statement_pred": "theorem lean_workbook_plus_56625 (p : \u2115 \u2192 Fin 3 \u2192 \u2115) (hp : \u2200 n, \u2200 m, n \u2260 m \u2192 p n \u2260 p m) (h21 : \u2200 n, 1 \u2264 n \u2227 n \u2264 20) : \u2203 k m : \u2115, k \u2260 m \u2227 p k = p m   :=  by sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_188", "informal_problem": "8.2 On a chessboard, 8 rooks were placed so that they do not attack each other. Prove that in any \"square\" rectangle of size $4 \\times 5$ (cells) there is at least one rook.", "formal_statement": "import Mathlib\n\n/-- A 4\u00d75 rectangle on the chessboard is determined by its top-left corner -/\nstructure Rectangle where\n  row : Fin 5  -- allows for 4 rows starting from this position (0-based)\n  col : Fin 4  -- allows for 5 columns starting from this position (0-based)\n\n/-- Predicate checking if a position lies within a given rectangle -/\ndef in_rectangle (rect : Rectangle) (r c : Fin 8) : Prop :=\n  (r.val \u2265 rect.row.val) \u2227 \n  (r.val < rect.row.val + 4) \u2227\n  (c.val \u2265 rect.col.val) \u2227 \n  (c.val < rect.col.val + 5)\n\n/-- For any permutation representing non-attacking rooks and any 4\u00d75 rectangle,\n    there exists a rook within that rectangle -/\ntheorem rook_in_rectangle (rooks : Equiv.Perm (Fin 8)) (rect : Rectangle) :\n  \u2203 r : Fin 8, in_rectangle rect r (rooks r) :=\n  sorry", "formal_statement_pred": "theorem lean_workbook_plus_8670 (a b c d : Fin 8 \u2192 Fin 8 \u2192 Bool) (hab : a = b) (hcd : c = d) (h : \u2200 i j, a i j \u2227 b i j \u2227 c i j \u2227 d i j \u2192 i \u2260 j) : \u2200 i j, a i j \u2192 b i j \u2192 c i j \u2192 d i j \u2192 i = j   :=  by sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_190", "informal_problem": "2. In the class, there are 39 students, all of whom were born in 2009. Is there a month in the year in which at least 4 students from this class celebrate their birthday?", "formal_statement": "import Mathlib\n\n-- No additional structures needed as we can use existing types\n\ntheorem birthday_problem \n  (students : Finset \u2115) \n  (months : Fin 12 \u2192 Finset \u2115) \n  (h1 : students.card = 39) -- total number of students\n  (h2 : \u2200 i : \u2115, i \u2208 students \u2192 \u2203 m : Fin 12, i \u2208 months m) -- each student has a birth month\n  (h3 : \u2200 i : \u2115, i \u2208 students \u2192 \u2200 m1 m2 : Fin 12, i \u2208 months m1 \u2192 i \u2208 months m2 \u2192 m1 = m2) -- each student has exactly one birth month\n  : \u2203 m : Fin 12, (months m).card \u2265 4 :=\n  sorry", "formal_statement_pred": "theorem lean_workbook_plus_49814 (h : 39 \u2264 12 * 3) : \u2203 m, 4 \u2264 m \u2228 4 \u2264 m \u2228 4 \u2264 m \u2228 4 \u2264 m \u2228 4 \u2264 m \u2228 4 \u2264 m \u2228 4 \u2264 m \u2228 4 \u2264 m \u2228 4 \u2264 m \u2228 4 \u2264 m \u2228 4 \u2264 m \u2228 4 \u2264 m   :=  by sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_194", "informal_problem": "3. Each node of an infinite grid is painted in one of four colors such that the vertices of each square with side 1 are painted in different colors. Is it true that the nodes of one of the grid lines are painted in only two colors? (The grid is formed by horizontal and vertical lines. The distance between adjacent parallel lines is 1.)", "formal_statement": "import Mathlib\n\n-- Define a coloring of the infinite grid\nstructure GridColoring where\n  -- A coloring maps each point (x,y) to one of four colors (0,1,2,3)\n  color : \u2124 \u00d7 \u2124 \u2192 Fin 4\n  -- Property: adjacent vertices of any unit square have different colors\n  valid_square : \u2200 (x y : \u2124), \n    color (x, y) \u2260 color (x + 1, y) \u2227 \n    color (x, y) \u2260 color (x, y + 1) \u2227 \n    color (x + 1, y) \u2260 color (x + 1, y + 1) \u2227 \n    color (x, y + 1) \u2260 color (x + 1, y + 1) \u2227\n    color (x, y) \u2260 color (x + 1, y + 1) \u2227\n    color (x + 1, y) \u2260 color (x, y + 1)\n\n-- Define what it means for a line to use only two colors\ndef uses_two_colors (c : GridColoring) (horizontal : Bool) (k : \u2124) : Prop :=\n  \u2203 (c\u2081 c\u2082 : Fin 4), \u2200 (t : \u2124),\n    c.color (if horizontal then (t, k) else (k, t)) \u2208 ({c\u2081, c\u2082} : Set (Fin 4))\n\ntheorem grid_coloring_two_colors :\n  \u2200 (c : GridColoring), \n  (\u2203 (k : \u2124), uses_two_colors c true k) \u2228 \n  (\u2203 (k : \u2124), uses_two_colors c false k) :=\n  sorry", "formal_statement_pred": "theorem lean_workbook_plus_67166 : \u2200 z : \u2124, \u2200 f : \u2124 \u00d7 \u2124 \u2192 \u2124, (\u2200 a : \u2124 \u00d7 \u2124, f a = z) \u2192 (\u2203 l : \u2124, \u2200 a : \u2124, f (a, l) = a \u2228 f (l, a) = a)   :=  by sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_199", "informal_problem": "2. Given a $7 \\times 3$ table. Each cell is filled with a number 0 or 1. If at the intersection of any two rows and any two columns all four numbers are the same, then the table is considered to be filled unsuccessfully. Is it possible to fill the table in such a way to avoid this phenomenon?", "formal_statement": "import Mathlib\n\n-- A table is represented as a function from positions to Bool\nstructure Table where\n  values : (Fin 7) \u2192 (Fin 3) \u2192 Bool\n\n/-- Check if a 2x2 subtable at given positions has all same values -/\ndef hasAllSameValues (t : Table) (r1 r2 : Fin 7) (c1 c2 : Fin 3) : Bool :=\n  let v := t.values r1 c1\n  v = t.values r1 c2 \u2227 v = t.values r2 c1 \u2227 v = t.values r2 c2\n\n/-- A table is successful if no 2x2 subtable has all same values -/\ndef isSuccessful (t : Table) : Prop :=\n  \u2200 (r1 r2 : Fin 7), \u2200 (c1 c2 : Fin 3),\n    r1 \u2260 r2 \u2192 c1 \u2260 c2 \u2192 \u00ac(hasAllSameValues t r1 r2 c1 c2)\n\ntheorem exists_successful_table :\n  \u2203 (t : Table), isSuccessful t :=\n  sorry", "formal_statement_pred": "theorem lean_workbook_44185 (x: Fin 7 \u2192 Fin 3 \u2192 \u2115) : \u00ac (\u2200 i j : Fin 7, \u2200 k l : Fin 3, x i k = x j k \u2227 x i l = x j l \u2192 (x i k = x i l \u2227 x j k = x j l))  :=  by sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_199", "informal_problem": "2. Given a $7 \\times 3$ table. Each cell is filled with a number 0 or 1. If at the intersection of any two rows and any two columns all four numbers are the same, then the table is considered to be filled unsuccessfully. Is it possible to fill the table in such a way to avoid this phenomenon?", "formal_statement": "import Mathlib\n\n-- A table is represented as a function from positions to Bool\nstructure Table where\n  values : (Fin 7) \u2192 (Fin 3) \u2192 Bool\n\n/-- Check if a 2x2 subtable at given positions has all same values -/\ndef hasAllSameValues (t : Table) (r1 r2 : Fin 7) (c1 c2 : Fin 3) : Bool :=\n  let v := t.values r1 c1\n  v = t.values r1 c2 \u2227 v = t.values r2 c1 \u2227 v = t.values r2 c2\n\n/-- A table is successful if no 2x2 subtable has all same values -/\ndef isSuccessful (t : Table) : Prop :=\n  \u2200 (r1 r2 : Fin 7), \u2200 (c1 c2 : Fin 3),\n    r1 \u2260 r2 \u2192 c1 \u2260 c2 \u2192 \u00ac(hasAllSameValues t r1 r2 c1 c2)\n\ntheorem exists_successful_table :\n  \u2203 (t : Table), isSuccessful t :=\n  sorry", "formal_statement_pred": "theorem lean_workbook_plus_34767 : \u2203 (f : \u2115 \u2192 Fin 3 \u2192 \u2115), \u2200 r1 r2 c1 c2, (r1 \u2260 r2 \u2227 c1 \u2260 c2) \u2192 f r1 c1 \u2260 f r2 c2   :=  by sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_199", "informal_problem": "2. Given a $7 \\times 3$ table. Each cell is filled with a number 0 or 1. If at the intersection of any two rows and any two columns all four numbers are the same, then the table is considered to be filled unsuccessfully. Is it possible to fill the table in such a way to avoid this phenomenon?", "formal_statement": "import Mathlib\n\n-- A table is represented as a function from positions to Bool\nstructure Table where\n  values : (Fin 7) \u2192 (Fin 3) \u2192 Bool\n\n/-- Check if a 2x2 subtable at given positions has all same values -/\ndef hasAllSameValues (t : Table) (r1 r2 : Fin 7) (c1 c2 : Fin 3) : Bool :=\n  let v := t.values r1 c1\n  v = t.values r1 c2 \u2227 v = t.values r2 c1 \u2227 v = t.values r2 c2\n\n/-- A table is successful if no 2x2 subtable has all same values -/\ndef isSuccessful (t : Table) : Prop :=\n  \u2200 (r1 r2 : Fin 7), \u2200 (c1 c2 : Fin 3),\n    r1 \u2260 r2 \u2192 c1 \u2260 c2 \u2192 \u00ac(hasAllSameValues t r1 r2 c1 c2)\n\ntheorem exists_successful_table :\n  \u2203 (t : Table), isSuccessful t :=\n  sorry", "formal_statement_pred": "theorem lean_workbook_25331 : \u2203 A : Fin 2 \u2192 Fin 2 \u2192 Fin 3 \u2192 Fin 2, \u2200 i j : Fin 2, \u2200 k : Fin 3, A i j k \u2260 A i (j + 1) k \u2228 A i j k \u2260 A (i + 1) j k \u2228 A i j k \u2260 A i j (k + 1)  :=  by sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_201", "informal_problem": "4. Is it possible to arrange balls of seven colors in five boxes standing in a circle so that each box contains three balls of different colors, and no two balls of the same color are in adjacent boxes?", "formal_statement": "import Mathlib\n\nstructure ColorArrangement where\n  -- Each box contains a list of colors (represented as Fin 7)\n  boxes : Fin 5 \u2192 Fin 7 \u00d7 Fin 7 \u00d7 Fin 7\n\ndef isValidArrangement (arr : ColorArrangement) : Prop :=\n  -- All colors in each box are different\n  (\u2200 i : Fin 5, let (c1, c2, c3) := arr.boxes i\n                c1 \u2260 c2 \u2227 c2 \u2260 c3 \u2227 c1 \u2260 c3) \u2227\n  -- No adjacent boxes share colors\n  (\u2200 i : Fin 5, let (c1, c2, c3) := arr.boxes i\n                let (n1, n2, n3) := arr.boxes (i + 1)\n                c1 \u2260 n1 \u2227 c1 \u2260 n2 \u2227 c1 \u2260 n3 \u2227\n                c2 \u2260 n1 \u2227 c2 \u2260 n2 \u2227 c2 \u2260 n3 \u2227\n                c3 \u2260 n1 \u2227 c3 \u2260 n2 \u2227 c3 \u2260 n3)\n\ntheorem exists_valid_color_arrangement :\n  \u2203 (arr : ColorArrangement), isValidArrangement arr :=\n  sorry", "formal_statement_pred": "theorem lean_workbook_plus_21897 (V : Fin 5 \u2192 Fin 7 \u2192 Bool) : (\u2200 i, \u2203 c, V i c \u2227 V i (c + 1) \u2227 V i (c + 2)) \u2227 (\u2200 i j, i \u2260 j \u2192 \u00ac (V i c \u2227 V j c)) \u2192 (\u2200 i j, i \u2260 j \u2192 \u2203 c, V i c \u2227 V j c)   :=  by sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_203", "informal_problem": "11.5. Given an infinite grid plane. A teacher and a class of 30 students play a game, taking turns - first the teacher, then each of the students in turn, then the teacher again, and so on. In one move, a player can paint a unit segment that is a boundary between two adjacent cells. Segments cannot be painted more than once. The teacher wins if, after one of the 31 players' moves, there is a grid rectangle $1 \\times 2$ or $2 \\times 1$ such that its entire boundary is painted, but the unit segment inside it is not painted. Can the students prevent the teacher from winning?\n\n(M. Diden, A. Kuznetsov)", "formal_statement": "import Mathlib\n\nstructure Segment where\n  start : \u2124 \u00d7 \u2124\n  direction : Bool  -- true for horizontal, false for vertical\n\nstructure GridGame where\n  painted_segments : Set Segment\n  current_player : Fin 31  -- 0 is teacher, 1-30 are students\n\ndef is_valid_move (game : GridGame) (seg : Segment) : Prop :=\n  seg \u2209 game.painted_segments\n\ndef is_teacher_turn (game : GridGame) : Prop :=\n  game.current_player = 0\n\ndef forms_rectangle (segs : Set Segment) (pos : \u2124 \u00d7 \u2124) (horizontal : Bool) : Prop :=\n  if horizontal then\n    -- 1\u00d72 rectangle at position pos\n    { Segment.mk pos true,                    -- bottom edge\n      Segment.mk pos false,                   -- left edge\n      Segment.mk (pos.1, pos.2 + 1) true,    -- top edge\n      Segment.mk (pos.1 + 1, pos.2) false    -- right edge\n    } \u2286 segs\n  else\n    -- 2\u00d71 rectangle at position pos\n    { Segment.mk pos false,                   -- left edge\n      Segment.mk pos true,                    -- bottom edge\n      Segment.mk (pos.1 + 1, pos.2) false,   -- right edge\n      Segment.mk (pos.1, pos.2 + 1) true     -- top edge\n    } \u2286 segs\n\ndef has_unpainted_middle (game : GridGame) (pos : \u2124 \u00d7 \u2124) (horizontal : Bool) : Prop :=\n  let middle := if horizontal then\n    Segment.mk (pos.1, pos.2) true    -- horizontal middle segment\n  else\n    Segment.mk (pos.1, pos.2) false   -- vertical middle segment\n  middle \u2209 game.painted_segments\n\ndef winning_position (game : GridGame) : Prop :=\n  \u2203 (pos : \u2124 \u00d7 \u2124) (horizontal : Bool),\n    forms_rectangle game.painted_segments pos horizontal \u2227\n    has_unpainted_middle game pos horizontal\n\ntheorem students_cannot_prevent_teacher_win :\n  \u2203 (teacher_strategy : GridGame \u2192 Segment),\n    \u2200 (student_strategies : Fin 30 \u2192 GridGame \u2192 Segment),\n    \u2203 (final_state : GridGame),\n      (\u2200 move, is_valid_move final_state move) \u2192\n      winning_position final_state :=\n  sorry", "formal_statement_pred": "theorem lean_workbook_plus_75807 : 30 < 31   :=  by sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_206", "informal_problem": "6. Participants of the summer physics and mathematics camp for schoolchildren received either an orange or a purple T-shirt. The number of participants in the physics group who received an orange T-shirt is equal to the number of participants in the mathematics group who received a purple T-shirt. Who is more - participants in the mathematics group, or those who received an orange T-shirt?", "formal_statement": "import Mathlib\n\nstructure CampParticipants where\n  physics : Finset Nat    -- Set of physics participants\n  math : Finset Nat       -- Set of math participants\n  orange : Finset Nat     -- Set of participants with orange T-shirts\n  purple : Finset Nat     -- Set of participants with purple T-shirts\n  disjoint_groups : Disjoint physics math      -- No one is in both groups\n  all_participants : physics \u222a math = orange \u222a purple  -- Everyone has exactly one T-shirt\n  valid_shirts : Disjoint orange purple        -- No one has both shirts\n\ntheorem camp_comparison (c : CampParticipants)\n  (h : (c.physics \u2229 c.orange).card = (c.math \u2229 c.purple).card) :\n  (c.math.card \u2260 c.orange.card) \u2228 (c.math.card = c.orange.card \u2227 c.physics.card = c.purple.card) :=\n  sorry", "formal_statement_pred": "theorem lean_workbook_plus_37531 (a b : \u2115) (h\u2081 : a = b) : a = b   :=  by sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_209", "informal_problem": "10.6. There are two boxes, one with 2017 candies, and the other with 2018. Two players take turns. On each turn, a player can eat any non-zero number of candies from any one box. The rules of the game do not allow the number of candies in one box to be divisible by the number of candies in the other after any move. The player who cannot make a move without violating this condition loses. Who can win: the player starting the game or the second player, regardless of how their opponent plays?", "formal_statement": "import Mathlib\n\nstructure CandyGame where\n  box1 : Nat\n  box2 : Nat\n  deriving Repr\n\ndef isValidMove (game : CandyGame) (newGame : CandyGame) : Bool :=\n  -- Check if the move is valid:\n  -- 1. Only one box changes\n  -- 2. The changed box decreases\n  -- 3. The new numbers are not divisible by each other\n  let box1Same := game.box1 = newGame.box1\n  let box2Same := game.box2 = newGame.box2\n  let box1Decreases := newGame.box1 < game.box1\n  let box2Decreases := newGame.box2 < game.box2\n  let notDivisible := \n    (newGame.box1 = 0 \u2228 newGame.box2 = 0 \u2228 \n     (newGame.box1 % newGame.box2 \u2260 0 \u2227 newGame.box2 % newGame.box1 \u2260 0))\n  \n  (box1Same \u2260 box2Same) \u2227  -- exactly one box changes\n  ((box1Same \u2227 box2Decreases) \u2228 (box2Same \u2227 box1Decreases)) \u2227\n  notDivisible\n\ntheorem candy_game_second_player_wins : \n  \u2203 (strategy : CandyGame \u2192 CandyGame),\n    let initialGame := CandyGame.mk 2017 2018\n    -- For any valid first move by player 1\n    \u2200 (p1move : CandyGame),\n      isValidMove initialGame p1move \u2192\n      -- There exists a response by player 2\n      isValidMove p1move (strategy p1move) \u2227\n      -- Such that player 2 can force a win\n      \u2200 (subsequent_position : CandyGame),\n        -- No matter what moves follow\n        \u00ac(\u2203 (final_position : CandyGame), \n          isValidMove subsequent_position final_position) :=\n  sorry", "formal_statement_pred": "theorem lean_workbook_plus_25334 (h\u2081 : 2017 \u2260 0) (h\u2082 : 2018 \u2260 0) : (\u2203 x y, (x % y) = 0) \u2228 (\u2203 x y, (x % y) \u2260 0)   :=  by sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_209", "informal_problem": "10.6. There are two boxes, one with 2017 candies, and the other with 2018. Two players take turns. On each turn, a player can eat any non-zero number of candies from any one box. The rules of the game do not allow the number of candies in one box to be divisible by the number of candies in the other after any move. The player who cannot make a move without violating this condition loses. Who can win: the player starting the game or the second player, regardless of how their opponent plays?", "formal_statement": "import Mathlib\n\nstructure CandyGame where\n  box1 : Nat\n  box2 : Nat\n  deriving Repr\n\ndef isValidMove (game : CandyGame) (newGame : CandyGame) : Bool :=\n  -- Check if the move is valid:\n  -- 1. Only one box changes\n  -- 2. The changed box decreases\n  -- 3. The new numbers are not divisible by each other\n  let box1Same := game.box1 = newGame.box1\n  let box2Same := game.box2 = newGame.box2\n  let box1Decreases := newGame.box1 < game.box1\n  let box2Decreases := newGame.box2 < game.box2\n  let notDivisible := \n    (newGame.box1 = 0 \u2228 newGame.box2 = 0 \u2228 \n     (newGame.box1 % newGame.box2 \u2260 0 \u2227 newGame.box2 % newGame.box1 \u2260 0))\n  \n  (box1Same \u2260 box2Same) \u2227  -- exactly one box changes\n  ((box1Same \u2227 box2Decreases) \u2228 (box2Same \u2227 box1Decreases)) \u2227\n  notDivisible\n\ntheorem candy_game_second_player_wins : \n  \u2203 (strategy : CandyGame \u2192 CandyGame),\n    let initialGame := CandyGame.mk 2017 2018\n    -- For any valid first move by player 1\n    \u2200 (p1move : CandyGame),\n      isValidMove initialGame p1move \u2192\n      -- There exists a response by player 2\n      isValidMove p1move (strategy p1move) \u2227\n      -- Such that player 2 can force a win\n      \u2200 (subsequent_position : CandyGame),\n        -- No matter what moves follow\n        \u00ac(\u2203 (final_position : CandyGame), \n          isValidMove subsequent_position final_position) :=\n  sorry", "formal_statement_pred": "theorem lean_workbook_plus_34943 (h : 0 < 2017 \u2227 0 < 2018) (h2 : \u00ac 2017 \u2223 2018) : (Nat.gcd 2017 2018 = 1 \u2192 (2017 + 2018) % 2 = 1)   :=  by sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_209", "informal_problem": "10.6. There are two boxes, one with 2017 candies, and the other with 2018. Two players take turns. On each turn, a player can eat any non-zero number of candies from any one box. The rules of the game do not allow the number of candies in one box to be divisible by the number of candies in the other after any move. The player who cannot make a move without violating this condition loses. Who can win: the player starting the game or the second player, regardless of how their opponent plays?", "formal_statement": "import Mathlib\n\nstructure CandyGame where\n  box1 : Nat\n  box2 : Nat\n  deriving Repr\n\ndef isValidMove (game : CandyGame) (newGame : CandyGame) : Bool :=\n  -- Check if the move is valid:\n  -- 1. Only one box changes\n  -- 2. The changed box decreases\n  -- 3. The new numbers are not divisible by each other\n  let box1Same := game.box1 = newGame.box1\n  let box2Same := game.box2 = newGame.box2\n  let box1Decreases := newGame.box1 < game.box1\n  let box2Decreases := newGame.box2 < game.box2\n  let notDivisible := \n    (newGame.box1 = 0 \u2228 newGame.box2 = 0 \u2228 \n     (newGame.box1 % newGame.box2 \u2260 0 \u2227 newGame.box2 % newGame.box1 \u2260 0))\n  \n  (box1Same \u2260 box2Same) \u2227  -- exactly one box changes\n  ((box1Same \u2227 box2Decreases) \u2228 (box2Same \u2227 box1Decreases)) \u2227\n  notDivisible\n\ntheorem candy_game_second_player_wins : \n  \u2203 (strategy : CandyGame \u2192 CandyGame),\n    let initialGame := CandyGame.mk 2017 2018\n    -- For any valid first move by player 1\n    \u2200 (p1move : CandyGame),\n      isValidMove initialGame p1move \u2192\n      -- There exists a response by player 2\n      isValidMove p1move (strategy p1move) \u2227\n      -- Such that player 2 can force a win\n      \u2200 (subsequent_position : CandyGame),\n        -- No matter what moves follow\n        \u00ac(\u2203 (final_position : CandyGame), \n          isValidMove subsequent_position final_position) :=\n  sorry", "formal_statement_pred": "theorem lean_workbook_plus_54993 (h\u2081 : 0 < 2017) (h\u2082 : 0 < 2018) : (Nat.gcd 2017 2018 = 1 \u2192 (2018 \u2260 1) \u2227 (2018 \u2260 1)) \u2228 (Nat.gcd 2017 2018 = 1 \u2192 (2017 \u2260 1) \u2227 (2017 \u2260 1))   :=  by sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_209", "informal_problem": "10.6. There are two boxes, one with 2017 candies, and the other with 2018. Two players take turns. On each turn, a player can eat any non-zero number of candies from any one box. The rules of the game do not allow the number of candies in one box to be divisible by the number of candies in the other after any move. The player who cannot make a move without violating this condition loses. Who can win: the player starting the game or the second player, regardless of how their opponent plays?", "formal_statement": "import Mathlib\n\nstructure CandyGame where\n  box1 : Nat\n  box2 : Nat\n  deriving Repr\n\ndef isValidMove (game : CandyGame) (newGame : CandyGame) : Bool :=\n  -- Check if the move is valid:\n  -- 1. Only one box changes\n  -- 2. The changed box decreases\n  -- 3. The new numbers are not divisible by each other\n  let box1Same := game.box1 = newGame.box1\n  let box2Same := game.box2 = newGame.box2\n  let box1Decreases := newGame.box1 < game.box1\n  let box2Decreases := newGame.box2 < game.box2\n  let notDivisible := \n    (newGame.box1 = 0 \u2228 newGame.box2 = 0 \u2228 \n     (newGame.box1 % newGame.box2 \u2260 0 \u2227 newGame.box2 % newGame.box1 \u2260 0))\n  \n  (box1Same \u2260 box2Same) \u2227  -- exactly one box changes\n  ((box1Same \u2227 box2Decreases) \u2228 (box2Same \u2227 box1Decreases)) \u2227\n  notDivisible\n\ntheorem candy_game_second_player_wins : \n  \u2203 (strategy : CandyGame \u2192 CandyGame),\n    let initialGame := CandyGame.mk 2017 2018\n    -- For any valid first move by player 1\n    \u2200 (p1move : CandyGame),\n      isValidMove initialGame p1move \u2192\n      -- There exists a response by player 2\n      isValidMove p1move (strategy p1move) \u2227\n      -- Such that player 2 can force a win\n      \u2200 (subsequent_position : CandyGame),\n        -- No matter what moves follow\n        \u00ac(\u2203 (final_position : CandyGame), \n          isValidMove subsequent_position final_position) :=\n  sorry", "formal_statement_pred": "theorem lean_workbook_35754 (h\u2082 : 0 < 2017) (h\u2081 : 0 < 2018) : (Nat.gcd 2017 2018) = 1 \u2227 ((Nat.gcd 2017 2018) = 1 \u2192 2017 < 2018)  :=  by sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_211", "informal_problem": "10.5. Given the \"skeleton\" of a $10 \\times 10$ grid (that is, the set of vertical and horizontal segments dividing the square into unit squares, including the boundary of the square). This skeleton is divided into corners (consisting of two unit segments) and segments of length 2 (also consisting of two unit segments). Could there be exactly $21$ segments of length 2?", "formal_statement": "import Mathlib\n\n/-- Type for unit segments in a 10\u00d710 grid -/\ninductive UnitSegment\n  | horizontal (x : Fin 10) (y : Fin 11)  -- horizontal segment starting at (x,y)\n  | vertical (x : Fin 11) (y : Fin 10)    -- vertical segment starting at (x,y)\n  deriving Repr, DecidableEq\n\n/-- Total number of unit segments in a 10\u00d710 grid -/\ndef totalSegments : \u2115 := 10 * 11 + 11 * 10  -- horizontal + vertical segments\n\n/-- A partition of the grid skeleton consists of corners and length-2 segments -/\nstructure GridPartition where\n  corners : Finset (UnitSegment \u00d7 UnitSegment)\n  length2 : Finset (UnitSegment \u00d7 UnitSegment)\n  /-- Each pair in corners forms a valid corner -/\n  valid_corners : \u2200 p \u2208 corners, match p.1, p.2 with\n    | UnitSegment.horizontal x y, UnitSegment.vertical x' y' => x' = x + 1 \u2227 y' = y\n    | UnitSegment.vertical x y, UnitSegment.horizontal x' y' => x = x' \u2227 y = y'\n    | _, _ => False\n  /-- Each pair in length2 forms a valid length-2 segment -/\n  valid_length2 : \u2200 p \u2208 length2, match p.1, p.2 with\n    | UnitSegment.horizontal x y, UnitSegment.horizontal x' y' => x' = x + 1 \u2227 y' = y\n    | UnitSegment.vertical x y, UnitSegment.vertical x' y' => x' = x \u2227 y' = y + 1\n    | _, _ => False\n  /-- Every segment appears exactly once in either corners or length2 -/\n  partition : \u2200 s : UnitSegment, \n    (\u2203! p \u2208 corners, s = p.1 \u2228 s = p.2) \u2228 \n    (\u2203! p \u2208 length2, s = p.1 \u2228 s = p.2)\n\ntheorem no_partition_with_21_length2 :\n  \u00ac\u2203 (p : GridPartition), p.length2.card = 21 :=\n  sorry", "formal_statement_pred": "theorem lean_workbook_plus_8750 :\n  10 < 9 + 9 * 2 \u2227 9 + 9 * 2 \u2260 21   :=  by sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_211", "informal_problem": "10.5. Given the \"skeleton\" of a $10 \\times 10$ grid (that is, the set of vertical and horizontal segments dividing the square into unit squares, including the boundary of the square). This skeleton is divided into corners (consisting of two unit segments) and segments of length 2 (also consisting of two unit segments). Could there be exactly $21$ segments of length 2?", "formal_statement": "import Mathlib\n\n/-- Type for unit segments in a 10\u00d710 grid -/\ninductive UnitSegment\n  | horizontal (x : Fin 10) (y : Fin 11)  -- horizontal segment starting at (x,y)\n  | vertical (x : Fin 11) (y : Fin 10)    -- vertical segment starting at (x,y)\n  deriving Repr, DecidableEq\n\n/-- Total number of unit segments in a 10\u00d710 grid -/\ndef totalSegments : \u2115 := 10 * 11 + 11 * 10  -- horizontal + vertical segments\n\n/-- A partition of the grid skeleton consists of corners and length-2 segments -/\nstructure GridPartition where\n  corners : Finset (UnitSegment \u00d7 UnitSegment)\n  length2 : Finset (UnitSegment \u00d7 UnitSegment)\n  /-- Each pair in corners forms a valid corner -/\n  valid_corners : \u2200 p \u2208 corners, match p.1, p.2 with\n    | UnitSegment.horizontal x y, UnitSegment.vertical x' y' => x' = x + 1 \u2227 y' = y\n    | UnitSegment.vertical x y, UnitSegment.horizontal x' y' => x = x' \u2227 y = y'\n    | _, _ => False\n  /-- Each pair in length2 forms a valid length-2 segment -/\n  valid_length2 : \u2200 p \u2208 length2, match p.1, p.2 with\n    | UnitSegment.horizontal x y, UnitSegment.horizontal x' y' => x' = x + 1 \u2227 y' = y\n    | UnitSegment.vertical x y, UnitSegment.vertical x' y' => x' = x \u2227 y' = y + 1\n    | _, _ => False\n  /-- Every segment appears exactly once in either corners or length2 -/\n  partition : \u2200 s : UnitSegment, \n    (\u2203! p \u2208 corners, s = p.1 \u2228 s = p.2) \u2228 \n    (\u2203! p \u2208 length2, s = p.1 \u2228 s = p.2)\n\ntheorem no_partition_with_21_length2 :\n  \u00ac\u2203 (p : GridPartition), p.length2.card = 21 :=\n  sorry", "formal_statement_pred": "theorem lean_workbook_plus_28887 (h : 0 < 10 \u2227 0 < 10) : 21 / 2 = (10 + 10) * (10 + 10) - (10 * 10)   :=  by sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_213", "informal_problem": "7.1. Masha surveyed her friends from her ensemble and received the following answers: 25 of them study mathematics, 30 have been to Moscow, 28 have traveled by train. Among those who have traveled by train, 18 study mathematics and 17 have been to Moscow. 16 friends study mathematics and have been to Moscow, and among them, 15 have also traveled by train. At the same time, there are only 45 girls in the ensemble. Is this possible?", "formal_statement": "import Mathlib\n\nstructure ValidCounts where\n  math : Nat\n  moscow : Nat\n  train : Nat\n  math_train : Nat\n  moscow_train : Nat\n  math_moscow : Nat\n  math_moscow_train : Nat\n  total : Nat\n  -- Basic size constraints\n  h_total : total = 45\n  h_math_le : math \u2264 total\n  h_moscow_le : moscow \u2264 total\n  h_train_le : train \u2264 total\n  -- Intersection constraints\n  h_math_train_le : math_train \u2264 math\n  h_math_train_le_train : math_train \u2264 train\n  h_moscow_train_le : moscow_train \u2264 moscow\n  h_moscow_train_le_train : moscow_train \u2264 train\n  h_math_moscow_le_math : math_moscow \u2264 math\n  h_math_moscow_le_moscow : math_moscow \u2264 moscow\n  h_triple_le_math_train : math_moscow_train \u2264 math_train\n  h_triple_le_moscow_train : math_moscow_train \u2264 moscow_train\n  h_triple_le_math_moscow : math_moscow_train \u2264 math_moscow\n  -- Inclusion-exclusion constraints\n  h_math_moscow_sum : math_moscow + math_train - math_moscow_train \u2264 math\n  h_moscow_train_sum : moscow_train + math_moscow - math_moscow_train \u2264 moscow\n  h_math_train_sum : math_train + moscow_train - math_moscow_train \u2264 train\n\ntheorem ensemble_possible : \u2203 (counts : ValidCounts), \n  counts.total = 45 \u2227\n  counts.math = 25 \u2227 \n  counts.moscow = 30 \u2227 \n  counts.train = 28 \u2227 \n  counts.math_train = 18 \u2227 \n  counts.moscow_train = 17 \u2227 \n  counts.math_moscow = 16 \u2227 \n  counts.math_moscow_train = 15 :=\n  sorry", "formal_statement_pred": "theorem lean_workbook_plus_34616 (h\u2081 : 25 \u2264 45) (h\u2082 : 30 \u2264 45) (h\u2083 : 28 \u2264 45) (h\u2084 : 18 \u2264 45) (h\u2085 : 17 \u2264 45) (h\u2086 : 16 \u2264 45) (h\u2087 : 15 \u2264 45) : 25 + 30 + 28 + 18 + 17 + 16 + 15 \u2264 45   :=  by sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_213", "informal_problem": "7.1. Masha surveyed her friends from her ensemble and received the following answers: 25 of them study mathematics, 30 have been to Moscow, 28 have traveled by train. Among those who have traveled by train, 18 study mathematics and 17 have been to Moscow. 16 friends study mathematics and have been to Moscow, and among them, 15 have also traveled by train. At the same time, there are only 45 girls in the ensemble. Is this possible?", "formal_statement": "import Mathlib\n\nstructure ValidCounts where\n  math : Nat\n  moscow : Nat\n  train : Nat\n  math_train : Nat\n  moscow_train : Nat\n  math_moscow : Nat\n  math_moscow_train : Nat\n  total : Nat\n  -- Basic size constraints\n  h_total : total = 45\n  h_math_le : math \u2264 total\n  h_moscow_le : moscow \u2264 total\n  h_train_le : train \u2264 total\n  -- Intersection constraints\n  h_math_train_le : math_train \u2264 math\n  h_math_train_le_train : math_train \u2264 train\n  h_moscow_train_le : moscow_train \u2264 moscow\n  h_moscow_train_le_train : moscow_train \u2264 train\n  h_math_moscow_le_math : math_moscow \u2264 math\n  h_math_moscow_le_moscow : math_moscow \u2264 moscow\n  h_triple_le_math_train : math_moscow_train \u2264 math_train\n  h_triple_le_moscow_train : math_moscow_train \u2264 moscow_train\n  h_triple_le_math_moscow : math_moscow_train \u2264 math_moscow\n  -- Inclusion-exclusion constraints\n  h_math_moscow_sum : math_moscow + math_train - math_moscow_train \u2264 math\n  h_moscow_train_sum : moscow_train + math_moscow - math_moscow_train \u2264 moscow\n  h_math_train_sum : math_train + moscow_train - math_moscow_train \u2264 train\n\ntheorem ensemble_possible : \u2203 (counts : ValidCounts), \n  counts.total = 45 \u2227\n  counts.math = 25 \u2227 \n  counts.moscow = 30 \u2227 \n  counts.train = 28 \u2227 \n  counts.math_train = 18 \u2227 \n  counts.moscow_train = 17 \u2227 \n  counts.math_moscow = 16 \u2227 \n  counts.math_moscow_train = 15 :=\n  sorry", "formal_statement_pred": "theorem lean_workbook_plus_38205 : 25 + 30 + 28 \u2264 45   :=  by sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_213", "informal_problem": "7.1. Masha surveyed her friends from her ensemble and received the following answers: 25 of them study mathematics, 30 have been to Moscow, 28 have traveled by train. Among those who have traveled by train, 18 study mathematics and 17 have been to Moscow. 16 friends study mathematics and have been to Moscow, and among them, 15 have also traveled by train. At the same time, there are only 45 girls in the ensemble. Is this possible?", "formal_statement": "import Mathlib\n\nstructure ValidCounts where\n  math : Nat\n  moscow : Nat\n  train : Nat\n  math_train : Nat\n  moscow_train : Nat\n  math_moscow : Nat\n  math_moscow_train : Nat\n  total : Nat\n  -- Basic size constraints\n  h_total : total = 45\n  h_math_le : math \u2264 total\n  h_moscow_le : moscow \u2264 total\n  h_train_le : train \u2264 total\n  -- Intersection constraints\n  h_math_train_le : math_train \u2264 math\n  h_math_train_le_train : math_train \u2264 train\n  h_moscow_train_le : moscow_train \u2264 moscow\n  h_moscow_train_le_train : moscow_train \u2264 train\n  h_math_moscow_le_math : math_moscow \u2264 math\n  h_math_moscow_le_moscow : math_moscow \u2264 moscow\n  h_triple_le_math_train : math_moscow_train \u2264 math_train\n  h_triple_le_moscow_train : math_moscow_train \u2264 moscow_train\n  h_triple_le_math_moscow : math_moscow_train \u2264 math_moscow\n  -- Inclusion-exclusion constraints\n  h_math_moscow_sum : math_moscow + math_train - math_moscow_train \u2264 math\n  h_moscow_train_sum : moscow_train + math_moscow - math_moscow_train \u2264 moscow\n  h_math_train_sum : math_train + moscow_train - math_moscow_train \u2264 train\n\ntheorem ensemble_possible : \u2203 (counts : ValidCounts), \n  counts.total = 45 \u2227\n  counts.math = 25 \u2227 \n  counts.moscow = 30 \u2227 \n  counts.train = 28 \u2227 \n  counts.math_train = 18 \u2227 \n  counts.moscow_train = 17 \u2227 \n  counts.math_moscow = 16 \u2227 \n  counts.math_moscow_train = 15 :=\n  sorry", "formal_statement_pred": "theorem lean_workbook_plus_37723 (h : 25 + 30 + 28 - 18 - 17 - 16 = 45) : True   :=  by sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_214", "informal_problem": "10.4 On the Unified State Exam (USE) in mathematics, 333 students made a total of 1000 mistakes. Prove that in this case, the number of students who made more than 5 mistakes is no greater than the number of students who made fewer than 4 mistakes.", "formal_statement": "import Mathlib\n\nstructure ExamResults where\n  totalStudents : Nat\n  totalMistakes : Nat\n  mistakeCount : Fin totalStudents \u2192 Nat\n  sum_constraint : (Finset.sum Finset.univ mistakeCount) = totalMistakes\n\n/-- Number of students who made more than n mistakes -/\ndef studentsAbove (results : ExamResults) (n : Nat) : Nat :=\n  Finset.card (Finset.filter (fun i => results.mistakeCount i > n) Finset.univ)\n\n/-- Number of students who made fewer than n mistakes -/\ndef studentsBelow (results : ExamResults) (n : Nat) : Nat :=\n  Finset.card (Finset.filter (fun i => results.mistakeCount i < n) Finset.univ)\n\ntheorem exam_mistakes_distribution \n  (results : ExamResults)\n  (h1 : results.totalStudents = 333)\n  (h2 : results.totalMistakes = 1000) :\n  studentsAbove results 5 \u2264 studentsBelow results 4 :=\n  sorry", "formal_statement_pred": "theorem lean_workbook_plus_43222 (H : 333 * M = 1000) : M \u2264 3   :=  by sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_215", "informal_problem": "5. In the tournament, 49 chess players participated. At a certain point in the tournament, 83 games had been played, and each participant had played either three or four games (and no one played each other twice). Could it have been the case that no two players who played exactly three games played against each other?\n\nAnswer: No.", "formal_statement": "import Mathlib\n\nstructure ChessTournament where\n  n : Nat                                    -- number of players\n  games_played : Nat                         -- total number of games played\n  player_games : Fin n \u2192 Nat                 -- number of games each player played\n  played_against : Fin n \u2192 Fin n \u2192 Bool      -- whether player i played against j\n  \n  no_self_games : \u2200 i, \u00acplayed_against i i  -- players don't play against themselves\n  symmetric : \u2200 i j, played_against i j = played_against j i  -- symmetry of games\n  games_count_valid : \u2200 i, player_games i = 3 \u2228 player_games i = 4  -- each played 3 or 4 games\n  total_games_match : games_played = (\u2211 i, player_games i) / 2  -- total games matches sum of games\n  no_repeats : \u2200 i j, played_against i j \u2192 \u00ac(\u2203 k, k \u2260 j \u2227 played_against i k)  -- no repeated games\n\ntheorem chess_tournament_three_games_must_play \n  (t : ChessTournament) \n  (h1 : t.n = 49) \n  (h2 : t.games_played = 83) : \n  \u2203 i j, i \u2260 j \u2227 \n    t.player_games i = 3 \u2227 \n    t.player_games j = 3 \u2227 \n    t.played_against i j := \n  sorry", "formal_statement_pred": "theorem lean_workbook_3500 (h\u2081 : 83 > 0 \u2227 49 > 0) (h\u2082 : 83 \u2264 49 * 4) (h\u2083 : 83 \u2264 49 * 3) : \u00ac (\u2200 a b, a \u2260 b \u2227 a + b = 83 \u2227 a \u2264 4 \u2227 b \u2264 4)  :=  by sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_218", "informal_problem": "2. Schoolchildren from grades 6 to 11 participate in the olympiad. The chairman of the jury knows that exactly 1000 schoolchildren will come, but does not know their distribution by grades. He has exactly 500 sheets of paper. Two copies of the conditions (one on the left, one on the right) are printed on one sheet; different grades can be printed, or the same grade can be printed on both sides.\n\nWith one command to the printer, any number of identical sheets can be printed. For example, the chairman can command the printer to print 142 sheets of the type \"7th grade + 10th grade\". The chairman is confident that when he learns the distribution of participants by grades, he will need only 6 commands to the printer to print all 1000 necessary conditions. Is he right?", "formal_statement": "import Mathlib\n\n-- Grades 6-11 mapped to 0-5\nabbrev Grade := Fin 6\n\n/-- A distribution of students across grades summing to 1000 -/\nstructure Distribution where\n  counts : Grade \u2192 Nat  -- Non-negativity automatically enforced by Nat\n  sum_valid : (Finset.univ : Finset Grade).sum counts = 1000\n\n/-- A single printer command specifying grades to print and number of copies -/\nstructure PrinterCommand where\n  leftGrade : Grade\n  rightGrade : Grade\n  copies : Nat\n  copies_pos : 0 < copies\n  sheet_bound : copies \u2264 500\n\n/-- Count how many copies of a specific grade are produced by a command -/\ndef copiesOfGrade (cmd : PrinterCommand) (g : Grade) : Nat :=\n  cmd.copies * (if cmd.leftGrade = g then 1 else 0 + if cmd.rightGrade = g then 1 else 0)\n\n/-- Total number of sheets used by a list of commands -/\ndef totalSheets (cmds : List PrinterCommand) : Nat :=\n  List.sum (List.map (fun cmd => cmd.copies) cmds)\n\n/-- Count total copies of a grade produced by a list of commands -/\ndef gradeCount (cmds : List PrinterCommand) (g : Grade) : Nat :=\n  List.sum (List.map (fun cmd => copiesOfGrade cmd g) cmds)\n\n/-- Whether a list of commands satisfies a given distribution -/\ndef satisfiesDistribution (cmds : List PrinterCommand) (d : Distribution) : Prop :=\n  \u2200 g : Grade, gradeCount cmds g = d.counts g\n\ntheorem olympiad_printing_possible (d : Distribution) : \n  \u2203 (cmds : List PrinterCommand), \n    cmds.length \u2264 6 \u2227  -- at most 6 commands\n    totalSheets cmds \u2264 500 \u2227  -- at most 500 sheets total\n    satisfiesDistribution cmds d :=\n  sorry", "formal_statement_pred": "theorem lean_workbook_26592 (h\u2081 : 0 < n \u2227 0 < k \u2227 0 < m) :\n  1000 * n * k * m * (n * k * m + 1) < (1000 * n * k * m + 1) ^ 2  :=  by sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_220", "informal_problem": "4. There are 15 students in the class. For homework, they were assigned 6 geometry problems. More than half of the students solved each problem.\n\nProve that there will be two students who, together, solved all 6 problems.", "formal_statement": "import Mathlib\n\nopen Finset\n\nstructure HomeworkSolutions where\n  solved : Fin 15 \u2192 Finset (Fin 6)\n  solutions_valid : \u2200 s : Fin 15, solved s \u2286 univ\n  more_than_half : \u2200 p : Fin 6, \n    (univ.filter (fun s => p \u2208 solved s)).card > 7\n\ntheorem homework_pigeonhole (h : HomeworkSolutions) : \n  \u2203 s\u2081 s\u2082 : Fin 15, s\u2081 \u2260 s\u2082 \u2227 (h.solved s\u2081 \u222a h.solved s\u2082) = univ :=\n  sorry", "formal_statement_pred": "theorem lean_workbook_plus_36178 (hA : A > 0) (hB : B > 0) (hC : C > 0) (hD : D > 0) (hE : E > 0) (hF : F > 0) (hABC : A + B + C > D + E + F) (hABD : A + B + D > E + F + C) (hABE : A + B + E > F + D + C) (hABF : A + B + F > D + E + C) (hACD : A + C + D > E + F + B) (hACE : A + C + E > F + D + B) (hACF : A + C + F > D + E + B) (hAFD : A + F + D > E + B + C) (hAFE : A + F + E > B + D + C) (hAFB : A + F + B > D + E + C) (hABCDEF : A + B + C + D + E + F = 15) : \u2203 x y, x \u2260 y \u2227 x + y = 6 \u2227 A + B + C + D + E + F = 15   :=  by sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_225", "informal_problem": "5. Can a $50 \\times 50$ square be cut into strips of $1 \\times 4$?", "formal_statement": "import Mathlib\n\nstructure Strip where\n  pos_x : Nat\n  pos_y : Nat\n  horizontal : Bool -- true if strip is horizontal, false if vertical\n\ndef validStrip (s : Strip) (n : Nat) : Bool :=\n  if s.horizontal then\n    s.pos_x + 4 \u2264 n \u2227 s.pos_y < n -- horizontal strip must fit within grid\n  else\n    s.pos_x < n \u2227 s.pos_y + 4 \u2264 n -- vertical strip must fit within grid\n\ndef coversSquare (strips : List Strip) (n : Nat) : Prop :=\n  \u2200 (x y : Nat), x < n \u2192 y < n \u2192\n    \u2203 (s : Strip), s \u2208 strips \u2227\n      (if s.horizontal then\n        s.pos_x \u2264 x \u2227 x < s.pos_x + 4 \u2227 s.pos_y = y\n      else\n        s.pos_y \u2264 y \u2227 y < s.pos_y + 4 \u2227 s.pos_x = x)\n\ntheorem square_50_strip_cover : \n  \u2203 (strips : List Strip), \n    (\u2200 s \u2208 strips, validStrip s 50) \u2227 \n    coversSquare strips 50 :=\n  sorry", "formal_statement_pred": "theorem lean_workbook_56574 : False  :=  by sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_225", "informal_problem": "5. Can a $50 \\times 50$ square be cut into strips of $1 \\times 4$?", "formal_statement": "import Mathlib\n\nstructure Strip where\n  pos_x : Nat\n  pos_y : Nat\n  horizontal : Bool -- true if strip is horizontal, false if vertical\n\ndef validStrip (s : Strip) (n : Nat) : Bool :=\n  if s.horizontal then\n    s.pos_x + 4 \u2264 n \u2227 s.pos_y < n -- horizontal strip must fit within grid\n  else\n    s.pos_x < n \u2227 s.pos_y + 4 \u2264 n -- vertical strip must fit within grid\n\ndef coversSquare (strips : List Strip) (n : Nat) : Prop :=\n  \u2200 (x y : Nat), x < n \u2192 y < n \u2192\n    \u2203 (s : Strip), s \u2208 strips \u2227\n      (if s.horizontal then\n        s.pos_x \u2264 x \u2227 x < s.pos_x + 4 \u2227 s.pos_y = y\n      else\n        s.pos_y \u2264 y \u2227 y < s.pos_y + 4 \u2227 s.pos_x = x)\n\ntheorem square_50_strip_cover : \n  \u2203 (strips : List Strip), \n    (\u2200 s \u2208 strips, validStrip s 50) \u2227 \n    coversSquare strips 50 :=\n  sorry", "formal_statement_pred": "theorem lean_workbook_plus_52946 : \u2203 (a : Fin 50 \u2192 Fin 50 \u2192 Fin 4), (\u2200 i j, a i j = a i (j + 1))   :=  by sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_229", "informal_problem": "46. Let similar sizes be those that differ by less than a factor of 2. Prove that a pile of 660 stones can be divided into 30 piles.", "formal_statement": "import Mathlib\n\nstructure StonePile where\n  size : Nat\n  valid : size > 0\n\ndef similar (p1 p2 : StonePile) : Prop :=\n  2 * p1.size > p2.size \u2227 2 * p2.size > p1.size\n\ndef validPartition (total : Nat) (piles : Fin n \u2192 StonePile) : Prop :=\n  (\u2200 i j : Fin n, similar (piles i) (piles j)) \u2227\n  (\u2211 i : Fin n, (piles i).size) = total\n\ntheorem stone_pile_partition :\n  \u2203 (piles : Fin 30 \u2192 StonePile), validPartition 660 piles :=\n  sorry", "formal_statement_pred": "theorem lean_workbook_plus_24884 : \u2200 n, n = 660 \u2192 n / 30 < 2   :=  by sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_237", "informal_problem": "6. At a masquerade ball, there were 20 people. In each dance, two people participated - a boy and a girl. It turned out that ten of them danced with three partners, two (Sasha and Zhenya) - with five, and the remaining eight - with six. Prove that Sasha and Zhenya are of different genders.", "formal_statement": "import Mathlib\n\nstructure Ball where\n  people : Finset (Fin 20)\n  gender : Fin 20 \u2192 Bool  -- True for boys, False for girls\n  dances : Finset (Fin 20 \u00d7 Fin 20)\n  sasha : Fin 20\n  zhenya : Fin 20\n  \n  -- Each dance involves exactly two people of different genders\n  dance_valid : \u2200 d \u2208 dances, gender d.1 \u2260 gender d.2\n  \n  -- Number of dance partners for each person\n  partners_count : \u2200 p : Fin 20,\n    let count := (dances.filter (fun d \u21a6 d.1 = p \u2228 d.2 = p)).card\n    if p = sasha \u2228 p = zhenya then\n      count = 5\n    else if count = 3 then\n      (people.filter (fun x \u21a6 \n        (dances.filter (fun d \u21a6 d.1 = x \u2228 d.2 = x)).card = 3)).card = 10\n    else\n      count = 6\n\ntheorem sasha_zhenya_different_gender (b : Ball) : \n  b.gender b.sasha \u2260 b.gender b.zhenya :=\n  sorry", "formal_statement_pred": "theorem lean_workbook_plus_48355 (h\u2081 : 20 = 10 + 2 + 8) (h\u2082 : 10 * 3 + 2 * 5 + 8 * 6 = 60) : \u00ac (Sasha = Zhenya)   :=  by sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_237", "informal_problem": "6. At a masquerade ball, there were 20 people. In each dance, two people participated - a boy and a girl. It turned out that ten of them danced with three partners, two (Sasha and Zhenya) - with five, and the remaining eight - with six. Prove that Sasha and Zhenya are of different genders.", "formal_statement": "import Mathlib\n\nstructure Ball where\n  people : Finset (Fin 20)\n  gender : Fin 20 \u2192 Bool  -- True for boys, False for girls\n  dances : Finset (Fin 20 \u00d7 Fin 20)\n  sasha : Fin 20\n  zhenya : Fin 20\n  \n  -- Each dance involves exactly two people of different genders\n  dance_valid : \u2200 d \u2208 dances, gender d.1 \u2260 gender d.2\n  \n  -- Number of dance partners for each person\n  partners_count : \u2200 p : Fin 20,\n    let count := (dances.filter (fun d \u21a6 d.1 = p \u2228 d.2 = p)).card\n    if p = sasha \u2228 p = zhenya then\n      count = 5\n    else if count = 3 then\n      (people.filter (fun x \u21a6 \n        (dances.filter (fun d \u21a6 d.1 = x \u2228 d.2 = x)).card = 3)).card = 10\n    else\n      count = 6\n\ntheorem sasha_zhenya_different_gender (b : Ball) : \n  b.gender b.sasha \u2260 b.gender b.zhenya :=\n  sorry", "formal_statement_pred": "theorem lean_workbook_plus_13496 :  \u2200 s z : Fin 20, (\u2200 t : Fin 20, s \u2260 t \u2192 z \u2260 t) \u2192 (\u2200 t : Fin 20, s \u2260 t \u2192 z \u2260 t) \u2192  \u2200 t : Fin 20, s \u2260 t \u2227 z \u2260 t \u2192 s \u2260 z   :=  by sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_238", "informal_problem": "4. The castle consists of 81 rooms in a square shape $9 * 9$. In some walls between adjacent rooms, there is one door. There are no doors to the outside, but each room has at least two doors. Prove that in some room, there are at least three doors.", "formal_statement": "import Mathlib\n\nstructure Castle where\n  n : Nat\n  doors : Fin n \u00d7 Fin n \u2192 Fin n \u00d7 Fin n \u2192 Bool  -- True if there's a door between rooms\n  adjacent : Fin n \u00d7 Fin n \u2192 Fin n \u00d7 Fin n \u2192 Bool -- True if rooms are adjacent\n  door_symmetry : \u2200 r\u2081 r\u2082, doors r\u2081 r\u2082 = doors r\u2082 r\u2081\n  door_adjacent : \u2200 r\u2081 r\u2082, doors r\u2081 r\u2082 \u2192 adjacent r\u2081 r\u2082\n  min_two_doors : \u2200 r, (\u2203 r\u2081 r\u2082, r\u2081 \u2260 r\u2082 \u2227 doors r r\u2081 \u2227 doors r r\u2082)\n\ndef door_count (c : Castle) (room : Fin c.n \u00d7 Fin c.n) : Nat :=\n  (Finset.filter (fun r => c.doors room r) (Finset.univ)).card\n\ntheorem castle_doors_existence (c : Castle) (h : c.n = 9) :\n  \u2203 room, door_count c room \u2265 3 :=\n  sorry", "formal_statement_pred": "theorem lean_workbook_48206 (h : 9 \u2264 9) : \u2203 x y, x \u2260 y \u2227 9 * x + y < 81  :=  by sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_238", "informal_problem": "4. The castle consists of 81 rooms in a square shape $9 * 9$. In some walls between adjacent rooms, there is one door. There are no doors to the outside, but each room has at least two doors. Prove that in some room, there are at least three doors.", "formal_statement": "import Mathlib\n\nstructure Castle where\n  n : Nat\n  doors : Fin n \u00d7 Fin n \u2192 Fin n \u00d7 Fin n \u2192 Bool  -- True if there's a door between rooms\n  adjacent : Fin n \u00d7 Fin n \u2192 Fin n \u00d7 Fin n \u2192 Bool -- True if rooms are adjacent\n  door_symmetry : \u2200 r\u2081 r\u2082, doors r\u2081 r\u2082 = doors r\u2082 r\u2081\n  door_adjacent : \u2200 r\u2081 r\u2082, doors r\u2081 r\u2082 \u2192 adjacent r\u2081 r\u2082\n  min_two_doors : \u2200 r, (\u2203 r\u2081 r\u2082, r\u2081 \u2260 r\u2082 \u2227 doors r r\u2081 \u2227 doors r r\u2082)\n\ndef door_count (c : Castle) (room : Fin c.n \u00d7 Fin c.n) : Nat :=\n  (Finset.filter (fun r => c.doors room r) (Finset.univ)).card\n\ntheorem castle_doors_existence (c : Castle) (h : c.n = 9) :\n  \u2203 room, door_count c room \u2265 3 :=\n  sorry", "formal_statement_pred": "theorem lean_workbook_17731 : 81 > 0 \u2227 9 > 0 \u2227 81 = 9*9 \u2227 2 \u2264 9 \u2227 3 \u2264 81 \u2192 3 \u2264 9  :=  by sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_238", "informal_problem": "4. The castle consists of 81 rooms in a square shape $9 * 9$. In some walls between adjacent rooms, there is one door. There are no doors to the outside, but each room has at least two doors. Prove that in some room, there are at least three doors.", "formal_statement": "import Mathlib\n\nstructure Castle where\n  n : Nat\n  doors : Fin n \u00d7 Fin n \u2192 Fin n \u00d7 Fin n \u2192 Bool  -- True if there's a door between rooms\n  adjacent : Fin n \u00d7 Fin n \u2192 Fin n \u00d7 Fin n \u2192 Bool -- True if rooms are adjacent\n  door_symmetry : \u2200 r\u2081 r\u2082, doors r\u2081 r\u2082 = doors r\u2082 r\u2081\n  door_adjacent : \u2200 r\u2081 r\u2082, doors r\u2081 r\u2082 \u2192 adjacent r\u2081 r\u2082\n  min_two_doors : \u2200 r, (\u2203 r\u2081 r\u2082, r\u2081 \u2260 r\u2082 \u2227 doors r r\u2081 \u2227 doors r r\u2082)\n\ndef door_count (c : Castle) (room : Fin c.n \u00d7 Fin c.n) : Nat :=\n  (Finset.filter (fun r => c.doors room r) (Finset.univ)).card\n\ntheorem castle_doors_existence (c : Castle) (h : c.n = 9) :\n  \u2203 room, door_count c room \u2265 3 :=\n  sorry", "formal_statement_pred": "theorem lean_workbook_23684 (Matrix : Fin 9 \u2192 Fin 9 \u2192 Fin 4 \u2192 Fin 2) (h\u2080 : \u2200 i j k, (Matrix i j k = 0 \u2228 Matrix i j k = 1)) (h\u2081 : \u2200 i j, i < 9 \u2227 j < 9 \u2192 (Matrix i j 0 = 1 \u2228 Matrix i j 1 = 1 \u2228 Matrix i j 2 = 1 \u2228 Matrix i j 3 = 1)) : \u2203 i j, i < 9 \u2227 j < 9 \u2227 (Matrix i j 0 = 1 \u2227 Matrix i j 1 = 1 \u2227 Matrix i j 2 = 1) \u2228 (Matrix i j 1 = 1 \u2227 Matrix i j 2 = 1 \u2227 Matrix i j 3 = 1) \u2228 (Matrix i j 0 = 1 \u2227 Matrix i j 2 = 1 \u2227 Matrix i j 3 = 1) \u2228 (Matrix i j 0 = 1 \u2227 Matrix i j 1 = 1 \u2227 Matrix i j 3 = 1)  :=  by sorry", "compiled": true, "aligned": true}
{"id": "CombStruct4Lean_240", "informal_problem": "7. At a masquerade ball, there were 20 people. In each dance, two people participated. It turned out that eleven of them danced with three partners, one with five, and the remaining eight with six. Prove that in some dance, people of the same gender participated.", "formal_statement": "import Mathlib\n\nstructure Dance where\n  person1 : Fin 20\n  person2 : Fin 20\n  different : person1 \u2260 person2\n\nstructure BallData where\n  dances : List Dance\n  gender : Fin 20 \u2192 Bool  -- True for one gender, False for the other\n  partners : Fin 20 \u2192 Finset (Fin 20)\n  -- Properties about the number of partners\n  eleven_three : \u2203 people : Finset (Fin 20), \n    people.card = 11 \u2227 \n    \u2200 p \u2208 people, (partners p).card = 3\n  one_five : \u2203 p : Fin 20, (partners p).card = 5\n  eight_six : \u2203 people : Finset (Fin 20),\n    people.card = 8 \u2227\n    \u2200 p \u2208 people, (partners p).card = 6\n\ntheorem masquerade_ball_same_gender \n  (ball : BallData) : \n  \u2203 d : Dance, d \u2208 ball.dances \u2192 ball.gender d.person1 = ball.gender d.person2 :=\n  sorry", "formal_statement_pred": "theorem lean_workbook_plus_43117 (h : 20 = 11 + 1 + 8) : \u2203 a b, a + b = 20 \u2227 a > 0 \u2227 b > 0 \u2227 a \u2260 b   :=  by sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_240", "informal_problem": "7. At a masquerade ball, there were 20 people. In each dance, two people participated. It turned out that eleven of them danced with three partners, one with five, and the remaining eight with six. Prove that in some dance, people of the same gender participated.", "formal_statement": "import Mathlib\n\nstructure Dance where\n  person1 : Fin 20\n  person2 : Fin 20\n  different : person1 \u2260 person2\n\nstructure BallData where\n  dances : List Dance\n  gender : Fin 20 \u2192 Bool  -- True for one gender, False for the other\n  partners : Fin 20 \u2192 Finset (Fin 20)\n  -- Properties about the number of partners\n  eleven_three : \u2203 people : Finset (Fin 20), \n    people.card = 11 \u2227 \n    \u2200 p \u2208 people, (partners p).card = 3\n  one_five : \u2203 p : Fin 20, (partners p).card = 5\n  eight_six : \u2203 people : Finset (Fin 20),\n    people.card = 8 \u2227\n    \u2200 p \u2208 people, (partners p).card = 6\n\ntheorem masquerade_ball_same_gender \n  (ball : BallData) : \n  \u2203 d : Dance, d \u2208 ball.dances \u2192 ball.gender d.person1 = ball.gender d.person2 :=\n  sorry", "formal_statement_pred": "theorem lean_workbook_plus_52367 (h\u2081 : 11 + 1 + 8 = 20) (h\u2082 : 11 * 3 + 1 * 5 + 8 * 6 = 20 * 2) : \u2203 a b, a \u2260 b \u2227 (a % 2 = b % 2)   :=  by sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_242", "informal_problem": "6. There is an unpainted board $101 \\times 201$. The first player has a bucket of yellow paint, the second player has a bucket of blue paint. On each turn, each player can paint a row (horizontal or vertical) with their color. When yellow and blue paints mix, they produce green. Further mixing of green with yellow or blue does not change the color. A player cannot paint a row if that row has already been painted by the opponent, nor can they paint a row if no cell on the board will change color. The player who cannot make a move loses. Who can ensure a win?", "formal_statement": "import Mathlib\n\n/-- The possible colors on the board -/\ninductive Color where\n  | unpainted\n  | yellow\n  | blue\n  | green\n  deriving Inhabited, DecidableEq, Fintype\n\n/-- The players in the game -/\ninductive Player where\n  | first\n  | second\n  deriving Inhabited, DecidableEq, Fintype\n\n/-- Get the color associated with a player -/\ndef Player.color : Player \u2192 Color\n  | first => Color.yellow\n  | second => Color.blue\n\n/-- A move is either a horizontal or vertical line -/\ninductive Move where\n  | horizontal (row : Fin 101)\n  | vertical (col : Fin 201)\n  deriving Inhabited, DecidableEq\n\n/-- The game board represented as a function from positions to colors -/\nstructure Board where\n  cells : Fin 101 \u2192 Fin 201 \u2192 Color\n  deriving Inhabited\n\n/-- The result of mixing two colors -/\ndef mixColors (c1 c2 : Color) : Color :=\n  match c1, c2 with\n  | Color.unpainted, c | c, Color.unpainted => c\n  | Color.yellow, Color.blue | Color.blue, Color.yellow => Color.green\n  | Color.green, _ | _, Color.green => Color.green\n  | c1, c2 => if c1 = c2 then c1 else c2\n\n/-- Apply a move to the board -/\ndef applyMove (b : Board) (m : Move) (p : Player) : Board :=\n  let color := p.color\n  match m with\n  | Move.horizontal row =>\n    \u27e8fun r c => if r = row then mixColors (b.cells r c) color else b.cells r c\u27e9\n  | Move.vertical col =>\n    \u27e8fun r c => if c = col then mixColors (b.cells r c) color else b.cells r c\u27e9\n\n/-- Check if a move is valid -/\ndef isValidMove (b : Board) (m : Move) (p : Player) : Prop :=\n  let newBoard := applyMove b m p\n  let oppColor := match p with\n    | Player.first => Color.blue\n    | Player.second => Color.yellow\n  match m with\n  | Move.horizontal row =>\n    (\u2200 col, b.cells row col \u2260 oppColor) \u2227\n    \u2203 col, newBoard.cells row col \u2260 b.cells row col\n  | Move.vertical col =>\n    (\u2200 row, b.cells row col \u2260 oppColor) \u2227\n    \u2203 row, newBoard.cells row col \u2260 b.cells row col\n\n/-- A game state contains the board, current player, and remaining moves -/\nstructure GameState where\n  board : Board\n  currentPlayer : Player\n  movesLeft : Nat  -- For well-founded recursion\n  deriving Inhabited\n\n/-- A strategy is valid if it produces valid moves when possible -/\ndef ValidStrategy (strategy : GameState \u2192 Move) : Prop :=\n  \u2200 gs : GameState, \n    (\u2203 m, isValidMove gs.board m gs.currentPlayer) \u2192\n    isValidMove gs.board (strategy gs) gs.currentPlayer\n\n/-- A strategy is winning if it leads to opponent having no valid moves -/\ndef WinningStrategy (p : Player) (strategy : GameState \u2192 Move) : Prop :=\n  \u2200 gs : GameState,\n    gs.movesLeft > 0 \u2192\n    gs.currentPlayer = p \u2192\n    \u2203 m, isValidMove gs.board m gs.currentPlayer \u2227\n        \u2200 gs' : GameState,\n          gs'.movesLeft < gs.movesLeft \u2192\n          \u00ac\u2203 m', isValidMove gs'.board m' gs'.currentPlayer\n\n/-- One of the players has a winning strategy -/\ntheorem painting_game_winner_exists :\n  \u2203 (p : Player) (strategy : GameState \u2192 Move),\n    ValidStrategy strategy \u2227 WinningStrategy p strategy :=\n  sorry", "formal_statement_pred": "theorem lean_workbook_16492 (h\u2081 : 0 < 101 \u2227 0 < 201) (h\u2082 : 2 = 2) : \u2203 x, x = 0  :=  by sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_242", "informal_problem": "6. There is an unpainted board $101 \\times 201$. The first player has a bucket of yellow paint, the second player has a bucket of blue paint. On each turn, each player can paint a row (horizontal or vertical) with their color. When yellow and blue paints mix, they produce green. Further mixing of green with yellow or blue does not change the color. A player cannot paint a row if that row has already been painted by the opponent, nor can they paint a row if no cell on the board will change color. The player who cannot make a move loses. Who can ensure a win?", "formal_statement": "import Mathlib\n\n/-- The possible colors on the board -/\ninductive Color where\n  | unpainted\n  | yellow\n  | blue\n  | green\n  deriving Inhabited, DecidableEq, Fintype\n\n/-- The players in the game -/\ninductive Player where\n  | first\n  | second\n  deriving Inhabited, DecidableEq, Fintype\n\n/-- Get the color associated with a player -/\ndef Player.color : Player \u2192 Color\n  | first => Color.yellow\n  | second => Color.blue\n\n/-- A move is either a horizontal or vertical line -/\ninductive Move where\n  | horizontal (row : Fin 101)\n  | vertical (col : Fin 201)\n  deriving Inhabited, DecidableEq\n\n/-- The game board represented as a function from positions to colors -/\nstructure Board where\n  cells : Fin 101 \u2192 Fin 201 \u2192 Color\n  deriving Inhabited\n\n/-- The result of mixing two colors -/\ndef mixColors (c1 c2 : Color) : Color :=\n  match c1, c2 with\n  | Color.unpainted, c | c, Color.unpainted => c\n  | Color.yellow, Color.blue | Color.blue, Color.yellow => Color.green\n  | Color.green, _ | _, Color.green => Color.green\n  | c1, c2 => if c1 = c2 then c1 else c2\n\n/-- Apply a move to the board -/\ndef applyMove (b : Board) (m : Move) (p : Player) : Board :=\n  let color := p.color\n  match m with\n  | Move.horizontal row =>\n    \u27e8fun r c => if r = row then mixColors (b.cells r c) color else b.cells r c\u27e9\n  | Move.vertical col =>\n    \u27e8fun r c => if c = col then mixColors (b.cells r c) color else b.cells r c\u27e9\n\n/-- Check if a move is valid -/\ndef isValidMove (b : Board) (m : Move) (p : Player) : Prop :=\n  let newBoard := applyMove b m p\n  let oppColor := match p with\n    | Player.first => Color.blue\n    | Player.second => Color.yellow\n  match m with\n  | Move.horizontal row =>\n    (\u2200 col, b.cells row col \u2260 oppColor) \u2227\n    \u2203 col, newBoard.cells row col \u2260 b.cells row col\n  | Move.vertical col =>\n    (\u2200 row, b.cells row col \u2260 oppColor) \u2227\n    \u2203 row, newBoard.cells row col \u2260 b.cells row col\n\n/-- A game state contains the board, current player, and remaining moves -/\nstructure GameState where\n  board : Board\n  currentPlayer : Player\n  movesLeft : Nat  -- For well-founded recursion\n  deriving Inhabited\n\n/-- A strategy is valid if it produces valid moves when possible -/\ndef ValidStrategy (strategy : GameState \u2192 Move) : Prop :=\n  \u2200 gs : GameState, \n    (\u2203 m, isValidMove gs.board m gs.currentPlayer) \u2192\n    isValidMove gs.board (strategy gs) gs.currentPlayer\n\n/-- A strategy is winning if it leads to opponent having no valid moves -/\ndef WinningStrategy (p : Player) (strategy : GameState \u2192 Move) : Prop :=\n  \u2200 gs : GameState,\n    gs.movesLeft > 0 \u2192\n    gs.currentPlayer = p \u2192\n    \u2203 m, isValidMove gs.board m gs.currentPlayer \u2227\n        \u2200 gs' : GameState,\n          gs'.movesLeft < gs.movesLeft \u2192\n          \u00ac\u2203 m', isValidMove gs'.board m' gs'.currentPlayer\n\n/-- One of the players has a winning strategy -/\ntheorem painting_game_winner_exists :\n  \u2203 (p : Player) (strategy : GameState \u2192 Move),\n    ValidStrategy strategy \u2227 WinningStrategy p strategy :=\n  sorry", "formal_statement_pred": "theorem lean_workbook_57060 :\n  \u2200 x y, (x \u2260 y \u2227 x \u2260 0 \u2227 y \u2260 0 \u2227 x % 2 = 0 \u2227 y % 2 = 0 \u2227 x \u2264 101 \u2227 y \u2264 201) \u2192 (x > y) \u2228 (x < y)  :=  by sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_246", "informal_problem": "7. 22 football players played three training matches (each time they were divided into two teams of 11 players). Prove that some two players played on different teams all three times.", "formal_statement": "import Mathlib\n\n/-- A match consists of two teams of players -/\nstructure Match where\n  team1 : Finset (Fin 22)\n  team2 : Finset (Fin 22)\n\n/-- A match is valid if teams have 11 players each, are disjoint, and contain all players -/\ndef IsValidMatch (m : Match) : Prop :=\n  m.team1.card = 11 \u2227 \n  m.team2.card = 11 \u2227 \n  m.team1 \u2229 m.team2 = \u2205 \u2227 \n  m.team1 \u222a m.team2 = Finset.univ\n\n/-- Three matches form a valid tournament if each match is valid -/\ndef ValidTournament (m1 m2 m3 : Match) : Prop :=\n  IsValidMatch m1 \u2227 IsValidMatch m2 \u2227 IsValidMatch m3\n\n/-- Two players are always opponents if in every match they play on opposite teams -/\ndef AlwaysOpponents (p1 p2 : Fin 22) (m1 m2 m3 : Match) : Prop :=\n  (p1 \u2208 m1.team1 \u2192 p2 \u2208 m1.team2) \u2227 (p1 \u2208 m1.team2 \u2192 p2 \u2208 m1.team1) \u2227\n  (p1 \u2208 m2.team1 \u2192 p2 \u2208 m2.team2) \u2227 (p1 \u2208 m2.team2 \u2192 p2 \u2208 m2.team1) \u2227\n  (p1 \u2208 m3.team1 \u2192 p2 \u2208 m3.team2) \u2227 (p1 \u2208 m3.team2 \u2192 p2 \u2208 m3.team1)\n\ntheorem football_opponents : \n  \u2200 (m1 m2 m3 : Match), ValidTournament m1 m2 m3 \u2192\n  \u2203 (p1 p2 : Fin 22), p1 \u2260 p2 \u2227 AlwaysOpponents p1 p2 m1 m2 m3 :=\n  sorry", "formal_statement_pred": "theorem lean_workbook_44751 (players : Fin 22 \u2192 \u2115) (hg : \u2200 i j, i = j \u2192 players i = players j) : \u2203 i j, i \u2260 j \u2227 ( players i \u2260 players j \u2227 players i \u2260 players j \u2227 players i \u2260 players j )  :=  by sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_258", "informal_problem": "10.2. On a chessboard, 8 rooks were placed so that they do not attack each other. Prove that in any rectangular cell area of size $4 \\times 5$ (cells) there is at least one rook.", "formal_statement": "import Mathlib\n\n/-- A valid rook placement on an 8\u00d78 chessboard -/\nstructure ChessBoard where\n  rooks : Finset (Fin 8 \u00d7 Fin 8)\n  nonAttacking : \u2200 (r\u2081 r\u2082 : Fin 8 \u00d7 Fin 8), r\u2081 \u2208 rooks \u2192 r\u2082 \u2208 rooks \u2192 r\u2081 \u2260 r\u2082 \u2192 \n    (Prod.fst r\u2081 \u2260 Prod.fst r\u2082) \u2227 (Prod.snd r\u2081 \u2260 Prod.snd r\u2082)\n  exactlyEight : rooks.card = 8\n\n/-- A 4\u00d75 rectangular area on the chessboard -/\nstructure RectArea where\n  startRow : Fin 8\n  startCol : Fin 8\n  valid : startRow + 4 \u2264 8 \u2227 startCol + 5 \u2264 8\n\n/-- Checks if a position is within the given rectangular area -/\ndef inRectArea (pos : Fin 8 \u00d7 Fin 8) (area : RectArea) : Prop :=\n  let (row, col) := pos\n  row \u2265 area.startRow \u2227 row < area.startRow + 4 \u2227\n  col \u2265 area.startCol \u2227 col < area.startCol + 5\n\ntheorem rook_in_rect_area (board : ChessBoard) (area : RectArea) :\n  \u2203 pos \u2208 board.rooks, inRectArea pos area :=\n  sorry", "formal_statement_pred": "theorem lean_workbook_plus_5911 (r : Fin 8 \u2192 Fin 8) (hr : \u2200 i j, i \u2260 j \u2192 r i \u2260 r j) (a b c d : Fin 8) (hab : a \u2264 c) (hbc : b \u2264 d) : \u2203 i, a \u2264 i \u2227 i \u2264 c \u2227 b \u2264 r i \u2227 r i \u2264 d   :=  by sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_262", "informal_problem": "Problem 6. A row of 100 coins lies on a table, some showing heads and the rest showing tails. In one operation, it is allowed to select seven coins lying at equal intervals (i.e., seven consecutive coins, or seven coins lying every other coin, etc.), and flip all seven coins. Prove that using such operations, it is possible to have all the coins show heads.\n\n$[9$ points] (S.I. Tokarev, A.V. Shapovalov)", "formal_statement": "import Mathlib\n\n-- Represent a row of coins as a function from positions to bool (true = heads)\nstructure CoinRow where\n  coins : Fin 100 \u2192 Bool\n\n-- Define what it means to flip coins at equal intervals\ndef flipCoinsAtInterval (row : CoinRow) (start : Fin 100) (interval : Nat) : CoinRow where\n  coins := fun i => \n    if \u2203 k : Fin 7, i.val = start.val + k.val * interval \u2227 i.val < 100\n    then !row.coins i\n    else row.coins i\n\n-- Define what it means for all coins to show heads\ndef allHeads (row : CoinRow) : Prop :=\n  \u2200 i : Fin 100, row.coins i = true\n\ntheorem coin_flipping_possible :\n  \u2200 (initial : CoinRow),\n  \u2203 (steps : List (Fin 100 \u00d7 Nat)), \n    let final := steps.foldl (fun row (p) => flipCoinsAtInterval row p.1 p.2) initial\n    allHeads final :=\n  sorry", "formal_statement_pred": "theorem lean_workbook_47985 (c : \u2115 \u2192 Bool) (h : \u2200 i, c i = True \u2228 c i = False) : \u2203 f : \u2115 \u2192 Bool, \u2200 i, (c i = f i) \u2228 \u2200 i, (c i = \u00ac(f i))  :=  by sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_266", "informal_problem": "Problem 4. Each point on the plane is painted in one of three colors. Is it necessarily true that there exists a triangle of area 1, all vertices of which have the same color?", "formal_statement": "import Mathlib\n\nstructure ColoredPlane where\n  coloring : \u211d \u00d7 \u211d \u2192 Fin 3  -- Maps each point to one of three colors (0, 1, or 2)\n\ndef hasMonochromaticTriangleArea1 (plane : ColoredPlane) : Prop :=\n  \u2203 (p\u2081 p\u2082 p\u2083 : \u211d \u00d7 \u211d),\n    -- All points have the same color\n    plane.coloring p\u2081 = plane.coloring p\u2082 \u2227\n    plane.coloring p\u2082 = plane.coloring p\u2083 \u2227\n    -- Area of triangle is 1\n    abs ((p\u2081.1 * (p\u2082.2 - p\u2083.2) + p\u2082.1 * (p\u2083.2 - p\u2081.2) + p\u2083.1 * (p\u2081.2 - p\u2082.2)) / 2) = 1\n\ntheorem exists_monochromatic_triangle_area1 :\n  \u2200 (plane : ColoredPlane), hasMonochromaticTriangleArea1 plane :=\n  sorry", "formal_statement_pred": "theorem lean_workbook_2075 (f : \u211d \u00d7 \u211d \u2192 Fin 3) :\n  \u2203 a b c : \u211d \u00d7 \u211d, a \u2260 b \u2227 b \u2260 c \u2227 c \u2260 a \u2227 f a = f b \u2227 f b = f c \u2227 f c = f a \u2227 a \u2260 b \u2227 b \u2260 c \u2227 c \u2260 a  :=  by sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_266", "informal_problem": "Problem 4. Each point on the plane is painted in one of three colors. Is it necessarily true that there exists a triangle of area 1, all vertices of which have the same color?", "formal_statement": "import Mathlib\n\nstructure ColoredPlane where\n  coloring : \u211d \u00d7 \u211d \u2192 Fin 3  -- Maps each point to one of three colors (0, 1, or 2)\n\ndef hasMonochromaticTriangleArea1 (plane : ColoredPlane) : Prop :=\n  \u2203 (p\u2081 p\u2082 p\u2083 : \u211d \u00d7 \u211d),\n    -- All points have the same color\n    plane.coloring p\u2081 = plane.coloring p\u2082 \u2227\n    plane.coloring p\u2082 = plane.coloring p\u2083 \u2227\n    -- Area of triangle is 1\n    abs ((p\u2081.1 * (p\u2082.2 - p\u2083.2) + p\u2082.1 * (p\u2083.2 - p\u2081.2) + p\u2083.1 * (p\u2081.2 - p\u2082.2)) / 2) = 1\n\ntheorem exists_monochromatic_triangle_area1 :\n  \u2200 (plane : ColoredPlane), hasMonochromaticTriangleArea1 plane :=\n  sorry", "formal_statement_pred": "theorem lean_workbook_plus_14971 (f : \u211d \u00d7 \u211d \u2192 Fin 3) : \u2203 a b c : \u211d \u00d7 \u211d, a \u2260 b \u2227 b \u2260 c \u2227 c \u2260 a \u2227 f a = f b \u2227 f b = f c \u2227 f c = f a   :=  by sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_267", "informal_problem": "15.31. A rectangular parallelepiped of size $2 l \\times 2 m \\times 2 n$ is cut into cubes with a side of 1, and each of these cubes is painted in one of 8 colors, with any two cubes that share at least one vertex being painted in different colors. Prove that all corner cubes are painted in different colors.\n\n## \u00a7 4. Lone Problems", "formal_statement": "import Mathlib\n\n/-- A cube in 3D space with integer coordinates -/\nstructure Cube where\n  x : Nat\n  y : Nat\n  z : Nat\n\n/-- Determines if a cube's coordinates are within the bounds of a parallelepiped -/\ndef Cube.inBounds (c : Cube) (l m n : Nat) : Prop :=\n  c.x < 2*l \u2227 c.y < 2*m \u2227 c.z < 2*n\n\n/-- Determines if a cube is at a corner of the parallelepiped -/\ndef Cube.isCorner (c : Cube) (l m n : Nat) : Prop :=\n  (c.x = 0 \u2228 c.x = 2*l - 1) \u2227\n  (c.y = 0 \u2228 c.y = 2*m - 1) \u2227\n  (c.z = 0 \u2228 c.z = 2*n - 1)\n\n/-- Determines if two cubes share at least one vertex -/\ndef Cube.shareVertex (c\u2081 c\u2082 : Cube) : Prop :=\n  let dx := Int.natAbs (Int.ofNat c\u2081.x - Int.ofNat c\u2082.x)\n  let dy := Int.natAbs (Int.ofNat c\u2081.y - Int.ofNat c\u2082.y)\n  let dz := Int.natAbs (Int.ofNat c\u2081.z - Int.ofNat c\u2082.z)\n  dx \u2264 1 \u2227 dy \u2264 1 \u2227 dz \u2264 1 \u2227 \u00ac(dx = 0 \u2227 dy = 0 \u2227 dz = 0)\n\n/-- A colored parallelepiped with given dimensions -/\nstructure ColoredParallelepiped (l m n : Nat) where\n  coloring : Cube \u2192 Option (Fin 8)\n  valid_coords : \u2200 c, c.inBounds l m n \u2192 (coloring c).isSome\n  valid_colors : \u2200 c\u2081 c\u2082, c\u2081.inBounds l m n \u2192 c\u2082.inBounds l m n \u2192 \n    c\u2081.shareVertex c\u2082 \u2192 coloring c\u2081 \u2260 coloring c\u2082\n\ntheorem corner_cubes_different_colors \n  {l m n : Nat} (h\u2081 : l > 0) (h\u2082 : m > 0) (h\u2083 : n > 0)\n  (p : ColoredParallelepiped l m n) :\n  \u2200 c\u2081 c\u2082, c\u2081.inBounds l m n \u2192 c\u2082.inBounds l m n \u2192\n    c\u2081.isCorner l m n \u2192 c\u2082.isCorner l m n \u2192 c\u2081 \u2260 c\u2082 \u2192 \n    p.coloring c\u2081 \u2260 p.coloring c\u2082 :=\n  sorry", "formal_statement_pred": "theorem lean_workbook_plus_20531 (l m n : \u2115) (f : \u2115 \u2192 \u2115) (hf: f x = x) (c : \u2115 \u2192 \u2115) (hc: c x = x) (h : \u2200 x y, x \u2260 y \u2192 (f x = f y \u2228 c x = c y)) : \u2200 x y, x \u2260 y \u2192 c x \u2260 c y   :=  by sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_267", "informal_problem": "15.31. A rectangular parallelepiped of size $2 l \\times 2 m \\times 2 n$ is cut into cubes with a side of 1, and each of these cubes is painted in one of 8 colors, with any two cubes that share at least one vertex being painted in different colors. Prove that all corner cubes are painted in different colors.\n\n## \u00a7 4. Lone Problems", "formal_statement": "import Mathlib\n\n/-- A cube in 3D space with integer coordinates -/\nstructure Cube where\n  x : Nat\n  y : Nat\n  z : Nat\n\n/-- Determines if a cube's coordinates are within the bounds of a parallelepiped -/\ndef Cube.inBounds (c : Cube) (l m n : Nat) : Prop :=\n  c.x < 2*l \u2227 c.y < 2*m \u2227 c.z < 2*n\n\n/-- Determines if a cube is at a corner of the parallelepiped -/\ndef Cube.isCorner (c : Cube) (l m n : Nat) : Prop :=\n  (c.x = 0 \u2228 c.x = 2*l - 1) \u2227\n  (c.y = 0 \u2228 c.y = 2*m - 1) \u2227\n  (c.z = 0 \u2228 c.z = 2*n - 1)\n\n/-- Determines if two cubes share at least one vertex -/\ndef Cube.shareVertex (c\u2081 c\u2082 : Cube) : Prop :=\n  let dx := Int.natAbs (Int.ofNat c\u2081.x - Int.ofNat c\u2082.x)\n  let dy := Int.natAbs (Int.ofNat c\u2081.y - Int.ofNat c\u2082.y)\n  let dz := Int.natAbs (Int.ofNat c\u2081.z - Int.ofNat c\u2082.z)\n  dx \u2264 1 \u2227 dy \u2264 1 \u2227 dz \u2264 1 \u2227 \u00ac(dx = 0 \u2227 dy = 0 \u2227 dz = 0)\n\n/-- A colored parallelepiped with given dimensions -/\nstructure ColoredParallelepiped (l m n : Nat) where\n  coloring : Cube \u2192 Option (Fin 8)\n  valid_coords : \u2200 c, c.inBounds l m n \u2192 (coloring c).isSome\n  valid_colors : \u2200 c\u2081 c\u2082, c\u2081.inBounds l m n \u2192 c\u2082.inBounds l m n \u2192 \n    c\u2081.shareVertex c\u2082 \u2192 coloring c\u2081 \u2260 coloring c\u2082\n\ntheorem corner_cubes_different_colors \n  {l m n : Nat} (h\u2081 : l > 0) (h\u2082 : m > 0) (h\u2083 : n > 0)\n  (p : ColoredParallelepiped l m n) :\n  \u2200 c\u2081 c\u2082, c\u2081.inBounds l m n \u2192 c\u2082.inBounds l m n \u2192\n    c\u2081.isCorner l m n \u2192 c\u2082.isCorner l m n \u2192 c\u2081 \u2260 c\u2082 \u2192 \n    p.coloring c\u2081 \u2260 p.coloring c\u2082 :=\n  sorry", "formal_statement_pred": "theorem lean_workbook_plus_46665 (l m n : \u2115) (c : Fin 8 \u2192 Fin 8) (hc : \u2200 a b, a \u2260 b \u2192 c a \u2260 c b) : c 0 = c 1 \u2227 c 0 = c 2 \u2227 c 0 = c 4 \u2227 c 1 = c 3 \u2227 c 1 = c 5 \u2227 c 2 = c 3 \u2227 c 2 = c 6 \u2227 c 3 = c 7 \u2227 c 4 = c 5 \u2227 c 4 = c 6 \u2227 c 5 = c 7 \u2227 c 6 = c 7   :=  by sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_271", "informal_problem": "27. All vertices of the map have even multiplicity. Prove that it can be properly colored with two colors (compare problem 83).\n\nProblems 23 and 27 give the following theorem, completely solving the problem of proper two-coloring:\n\nA map can be properly colored with two colors if and only if all its vertices have even multiplicity.\n\n## 8 2. Three-color coloring\n\n", "formal_statement": "import Mathlib\n\nstructure Map where\n  V : Type -- vertices\n  E : Type -- edges\n  vertices : Set V\n  edges : Set E\n  endpoint : E \u2192 V \u00d7 V -- Each edge connects two vertices\n  multiplicity : V \u2192 \u2115 -- Number of edges incident to a vertex\n  even_multiplicity : \u2200 v \u2208 vertices, Even (multiplicity v)\n\n/-- A coloring of a map is an assignment of colors to vertices -/\ndef Coloring (M : Map) := M.V \u2192 Bool\n\n/-- A coloring is proper if adjacent vertices have different colors -/\ndef isProperColoring (M : Map) (c : Coloring M) : Prop :=\n  \u2200 e \u2208 M.edges,\n    let \u27e8v\u2081, v\u2082\u27e9 := M.endpoint e\n    c v\u2081 \u2260 c v\u2082\n\ntheorem even_multiplicity_two_colorable (M : Map) :\n  \u2203 c : Coloring M, isProperColoring M c :=\n  sorry", "formal_statement_pred": "theorem lean_workbook_plus_50271 :\n  \u2200 m : Fin 7, \u2200 p : Fin 7, (m \u2260 p \u2192 (m + p : Fin 7) \u2260 p)   :=  by sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_276", "informal_problem": "26. Given positive numbers $a_{1}, a_{2}, \\ldots, a_{m}$, $b_{1}, b_{2}, \\ldots, b_{n}$, such that $a_{1}+a_{2}+\\ldots+a_{m}=b_{1}+$ $+b_{2}+\\ldots+b_{n}$. Prove that in an empty table with $m$ rows and $n$ columns, no more than $m+n-1$ positive numbers can be placed so that the sum of the numbers in the $i$-th row equals $a_{i}$, and the sum of the numbers in the $k$-th column equals $b_{k}$.\n\nThird All-Russian Olympiad, 1963 (Moscow)\n\n| Class |  |  |  |  |  |\n| :---: | :---: | :---: | :---: | :---: | :---: |\n| 8 | 27 | 28 | $29 a$ | 30 | $31 a$ |\n| 9 | 32 | 33 | 34 | 316 | 28 |\n| 10 | 35 | 36 | 37 | 296 | 28 |\n| 11 | 38 | 28 | 39 | 40 | 296 |", "formal_statement": "import Mathlib\n\nstructure TableConstraints (m n : \u2115) where\n  pos_m : m > 0\n  pos_n : n > 0\n  rowSums : Fin m \u2192 \u211d\n  colSums : Fin n \u2192 \u211d\n  rowSums_pos : \u2200 i, rowSums i > 0\n  colSums_pos : \u2200 j, colSums j > 0\n  sums_equal : (Finset.sum Finset.univ rowSums) = (Finset.sum Finset.univ colSums)\n\n/-- Represents positions in the table where positive numbers are placed -/\nstructure TablePlacement (m n : \u2115) (tc : TableConstraints m n) where\n  positions : Finset (Fin m \u00d7 Fin n)\n  values : (Fin m \u00d7 Fin n) \u2192 \u211d\n  values_pos : \u2200 p \u2208 positions, values p > 0\n  row_sums_match : \u2200 i, Finset.sum (positions.filter (fun p => p.1 = i)) (fun p => values p) = tc.rowSums i\n  col_sums_match : \u2200 j, Finset.sum (positions.filter (fun p => p.2 = j)) (fun p => values p) = tc.colSums j\n\ntheorem table_placement_bound {m n : \u2115} (tc : TableConstraints m n) \n    (t : TablePlacement m n tc) : \n    t.positions.card \u2264 m + n - 1 :=\n  sorry", "formal_statement_pred": "theorem lean_workbook_plus_18928 : 8 + 27 + 28 + 29 + 30 + 31 + 32 + 33 + 34 + 35 + 36 + 37 + 38 + 39 + 40 = 29 + 30 + 31 + 32 + 33 + 34 + 35 + 36 + 37 + 38 + 39 + 40 + 296   :=  by sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_277", "informal_problem": "37. Given a regular 45-gon. Is it possible to place the digits $0,1, \\ldots, 9$ at its vertices such that for any pair of different digits, there is a side whose endpoints are labeled with these digits?", "formal_statement": "import Mathlib\n\nstructure RegularPolygonLabeling where\n  n : Nat                              -- number of vertices\n  labels : Fin n \u2192 Fin 10             -- labeling function for vertices\n  \n/-- Check if two vertices are connected by an edge in a regular n-gon -/\ndef areAdjacent (n : Nat) (v\u2081 v\u2082 : Fin n) : Bool :=\n  v\u2081.val + 1 = v\u2082.val \u2228 (v\u2081.val = n - 1 \u2227 v\u2082.val = 0)\n\n/-- Predicate stating that all pairs of digits appear on some edge -/\ndef hasAllPairsOnEdges (l : RegularPolygonLabeling) : Prop :=\n  \u2200 d\u2081 d\u2082 : Fin 10, d\u2081 \u2260 d\u2082 \u2192 \n    \u2203 v\u2081 v\u2082 : Fin l.n, \n      areAdjacent l.n v\u2081 v\u2082 \u2227 \n      l.labels v\u2081 = d\u2081 \u2227 \n      l.labels v\u2082 = d\u2082\n\ntheorem fortyfive_gon_digit_placement : \n  \u00ac\u2203 (l : RegularPolygonLabeling), l.n = 45 \u2227 hasAllPairsOnEdges l :=\n  sorry", "formal_statement_pred": "theorem lean_workbook_56138 (A : Fin 45) : \u2203 f : Fin 10 \u2192 Fin 45, \u2200 a b, a \u2260 b \u2192 \u2203 e : Fin 45 \u2192 Fin 45, e a = b \u2228 e b = a  :=  by sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_277", "informal_problem": "37. Given a regular 45-gon. Is it possible to place the digits $0,1, \\ldots, 9$ at its vertices such that for any pair of different digits, there is a side whose endpoints are labeled with these digits?", "formal_statement": "import Mathlib\n\nstructure RegularPolygonLabeling where\n  n : Nat                              -- number of vertices\n  labels : Fin n \u2192 Fin 10             -- labeling function for vertices\n  \n/-- Check if two vertices are connected by an edge in a regular n-gon -/\ndef areAdjacent (n : Nat) (v\u2081 v\u2082 : Fin n) : Bool :=\n  v\u2081.val + 1 = v\u2082.val \u2228 (v\u2081.val = n - 1 \u2227 v\u2082.val = 0)\n\n/-- Predicate stating that all pairs of digits appear on some edge -/\ndef hasAllPairsOnEdges (l : RegularPolygonLabeling) : Prop :=\n  \u2200 d\u2081 d\u2082 : Fin 10, d\u2081 \u2260 d\u2082 \u2192 \n    \u2203 v\u2081 v\u2082 : Fin l.n, \n      areAdjacent l.n v\u2081 v\u2082 \u2227 \n      l.labels v\u2081 = d\u2081 \u2227 \n      l.labels v\u2082 = d\u2082\n\ntheorem fortyfive_gon_digit_placement : \n  \u00ac\u2203 (l : RegularPolygonLabeling), l.n = 45 \u2227 hasAllPairsOnEdges l :=\n  sorry", "formal_statement_pred": "theorem lean_workbook_plus_51153 (h : 45 \u2264 45) : (\u2203 A : Fin 45 \u2192 \u2115, \u2200 a b, a \u2260 b \u2192 \u2203 c d, a = c \u2227 b = d \u2227 c + d = 45)   :=  by sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_278", "informal_problem": "61. In the people's militia, there are 100 people, and every evening three people go on duty. Prove that it is impossible to organize the duty schedule so that any two people are on duty together exactly once.", "formal_statement": "import Mathlib\n\nstructure DutySchedule where\n  n : Nat                    -- total number of people\n  days : Nat                 -- number of days in the schedule\n  duties : Fin days \u2192 Fin n \u00d7 Fin n \u00d7 Fin n  -- assignment of 3 people to each day\n  \n/-- Two people are considered to have served together if they were assigned to the same duty -/\ndef servedTogether (schedule : DutySchedule) (p1 p2 : Fin schedule.n) : Bool :=\n  \u2203 d : Fin schedule.days, let (a, b, c) := schedule.duties d\n                          (p1 = a \u2227 p2 = b) \u2228 (p1 = a \u2227 p2 = c) \u2228 (p1 = b \u2227 p2 = c)\n\ntheorem militia_schedule_impossible : \n  \u00ac\u2203 (schedule : DutySchedule), \n    schedule.n = 100 \u2227 \n    (\u2200 p1 p2 : Fin schedule.n, p1 \u2260 p2 \u2192 \n      (\u2203! d : Fin schedule.days, servedTogether schedule p1 p2)) :=\n  sorry", "formal_statement_pred": "theorem lean_workbook_plus_61042 : \u00ac\u2203 d : Fin 3 \u2192 Fin 100, \u2200 i j : Fin 3, i \u2260 j \u2192 \u2200 k : Fin 100, d i = k \u2227 d j = k \u2194 i = j   :=  by sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_283", "informal_problem": "229. On a $99 \\times 99$ chessboard, a figure (this figure will be different in parts a), b), and c)) is marked. In each cell of the figure $F$, there is a beetle. At some point, the beetles fly up and land again in the cells of the same figure $F$; in this process, several beetles could land in the same cell. After the flight, any two beetles that were in adjacent cells ended up in adjacent cells again or in the same cell. (Cells are considered adjacent if they share a side or a vertex.)\n\na) Let the figure $F$ be the \"central cross,\" i.e., the union of the middle vertical and middle horizontal lines (Fig. 12,a). Prove that in this case, some beetle either returned to its original place or moved to an adjacent cell.", "formal_statement": "import Mathlib\n\nstructure ChessboardState where\n  n : Nat\n  figure : Set (Nat \u00d7 Nat)\n  beetles_initial : (Nat \u00d7 Nat) \u2192 List (Nat \u00d7 Nat)\n  beetles_final : (Nat \u00d7 Nat) \u2192 List (Nat \u00d7 Nat)\n\ndef is_adjacent (p1 p2 : Nat \u00d7 Nat) : Bool :=\n  let (x1, y1) := p1\n  let (x2, y2) := p2\n  let dx := if x1 \u2265 x2 then x1 - x2 else x2 - x1\n  let dy := if y1 \u2265 y2 then y1 - y2 else y2 - y1\n  dx \u2264 1 && dy \u2264 1 && (p1 \u2260 p2)\n\ndef central_cross (n : Nat) : Set (Nat \u00d7 Nat) :=\n  { p | let (x, y) := p\n        (x = n/2 || y = n/2) && x < n && y < n }\n\ndef preserves_adjacency (state : ChessboardState) : Prop :=\n  \u2200 p1 p2 : Nat \u00d7 Nat,\n    p1 \u2208 state.figure \u2192 p2 \u2208 state.figure \u2192\n    is_adjacent p1 p2 \u2192\n    \u2203 q1 \u2208 (state.beetles_final p1), \u2203 q2 \u2208 (state.beetles_final p2),\n      is_adjacent q1 q2 \u2228 q1 = q2\n\ntheorem central_cross_beetle_movement \n  (state : ChessboardState)\n  (h_size : state.n = 99)\n  (h_figure : state.figure = central_cross state.n)\n  (h_adj : preserves_adjacency state) :\n  \u2203 pos \u2208 state.figure,\n    \u2203 beetle \u2208 (state.beetles_initial pos),\n    \u2203 final_pos \u2208 (state.beetles_final pos),\n      final_pos = pos \u2228 is_adjacent pos final_pos :=\n  sorry", "formal_statement_pred": "theorem lean_workbook_37277  (f : \u2115 \u00d7 \u2115 \u2192 \u2115 \u00d7 \u2115)\n  (h\u2080 : \u2200 x y, (x = 50 \u2227 y = 50) \u2228 (x = 50 \u2227 y = 49) \u2228 (x = 49 \u2227 y = 50)) :\n  \u2203 x y, (x = 50 \u2227 y = 50) \u2228 (x = 50 \u2227 y = 49) \u2228 (x = 49 \u2227 y = 50)  :=  by sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_293", "informal_problem": "407. There is a cube, a cubic box with a lid of the same size, and six paints. Each paint is used to color one face of the cube and one of the faces of the box. Prove that the cube can be placed in the box in such a way that each face of the cube touches a face of the box painted with a different color.", "formal_statement": "import Mathlib\n\nstructure CubePainting where\n  -- Maps each face (1-6) to its color (1-6)\n  cube_colors : Fin 6 \u2192 Fin 6\n  box_colors : Fin 6 \u2192 Fin 6\n  -- Each color is used exactly once for cube and box\n  cube_bijective : Function.Bijective cube_colors\n  box_bijective : Function.Bijective box_colors\n\n/-- Represents a placement of the cube in the box -/\nstructure CubePlacement where\n  -- Maps each face of the cube (1-6) to the face of the box it touches (1-6)\n  placement : Fin 6 \u2192 Fin 6\n  -- The placement must be bijective (each box face touches exactly one cube face)\n  is_bijective : Function.Bijective placement\n\ntheorem cube_box_painting_exists :\n  \u2200 (p : CubePainting), \u2203 (placement : CubePlacement),\n    \u2200 (face : Fin 6), p.cube_colors face \u2260 p.box_colors (placement.placement face) :=\n  sorry", "formal_statement_pred": "theorem lean_workbook_plus_64598 (h\u2081 : 0 < 6) (h\u2082 : 0 < 6) (h\u2083 : 0 < 6) : 0 < 6   :=  by sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_303", "informal_problem": "6. In a chess tournament, each participant played two games with each other: one with white pieces, the other with black. At the end of the tournament, it turned out that everyone had scored the same number of points (1 point for a win, $-1 / 2$ point for a draw, 0 points for a loss). Prove that there will be two participants who won the same number of games with white pieces.\n\n## 9 t h  g r a d e", "formal_statement": "import Mathlib\n\nstructure ChessTournament where\n  n : Nat                             -- number of participants\n  h_pos : n > 0                       -- at least one participant\n  white_wins : Fin n \u2192 Nat            -- number of wins with white pieces for each player\n  black_wins : Fin n \u2192 Nat            -- number of wins with black pieces for each player\n  draws : Fin n \u2192 Nat                 -- number of draws for each player\n  \n  -- Each player plays exactly one game with white and one with black against every other player\n  h_games : \u2200 i, white_wins i + black_wins i + draws i = 2 * (n - 1)\n  \n  -- Total score is the same for all players\n  h_equal_scores : \u2200 i j, \n    white_wins i + black_wins i - draws i / 2 = \n    white_wins j + black_wins j - draws j / 2\n\ntheorem chess_tournament_same_white_wins (t : ChessTournament) : \n  \u2203 i j, i \u2260 j \u2227 t.white_wins i = t.white_wins j :=\n  sorry", "formal_statement_pred": "theorem lean_workbook_plus_75457 (n : \u2115) (a : \u2115 \u2192 \u211d) (b : \u2115 \u2192 \u211d) (h\u2081 : \u2200 i j, i \u2260 j \u2192 a i \u2260 a j) (h\u2082 : \u2200 i j, i \u2260 j \u2192 b i \u2260 b j) (h\u2083 : \u2200 i j, i \u2260 j \u2192 a i \u2260 b j) (h\u2084 : \u2200 i j, i \u2260 j \u2192 b i \u2260 a j) : \u2203 i j, i \u2260 j \u2227 a i = a j \u2228 b i = b j   :=  by sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_306", "informal_problem": "3-3. There are 13 weights, each weighing a whole number of grams. It is known that any 12 of them can be divided into 2 groups of 6 weights each, such that the scales will balance. Prove that all the weights have the same weight.", "formal_statement": "import Mathlib\n\nstructure WeightSet where\n  weights : Fin 13 \u2192 \u2115  -- 13 natural numbers representing weights in grams\n  balanced : \u2200 (excluded : Fin 13),\n    \u2203 (partition : Fin 12 \u2192 Bool),\n    let remaining := {i : Fin 13 | i \u2260 excluded}\n    let group1_sum := \u2211 i in remaining, if partition i then weights i else 0\n    let group2_sum := \u2211 i in remaining, if !partition i then weights i else 0\n    group1_sum = group2_sum \u2227 \n    (\u2211 i in remaining, partition i) = 6 -- Each group has exactly 6 weights\n\ntheorem all_weights_equal (w : WeightSet) : \n  \u2203 (n : \u2115), \u2200 i : Fin 13, w.weights i = n :=\n  sorry", "formal_statement_pred": "theorem lean_workbook_45892 (weights : \u2115 \u2192 \u2115) (h : \u2200 i, \u2203 j, i \u2260 j \u2227 weights i = weights j) : \u2200 i j, weights i = weights j  :=  by sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_307", "informal_problem": "3-4. Can 10 bus routes be laid out in a city and stops be set up on them in such a way that for any 8 routes chosen, there is a stop not lying on any of them, while any 9 routes pass through all stops.", "formal_statement": "import Mathlib\n\nstructure BusSystem where\n  n : Nat -- number of stops\n  stops : Fin n\n  routes : Finset (Finset (Fin n)) -- set of routes, each route is a set of stops\n  route_count : routes.card = 10 -- exactly 10 routes\n  routes_nonempty : \u2200 r \u2208 routes, r.Nonempty -- each route has at least one stop\n\ntheorem bus_system_exists : \u2203 (n : Nat) (bs : BusSystem), \n  (\u2200 S \u2286 bs.routes, S.card = 8 \u2192 \n    \u2203 p : Fin bs.n, \u2200 r \u2208 S, p \u2209 r) \u2227 -- 8-route property\n  (\u2200 S \u2286 bs.routes, S.card = 9 \u2192 \n    \u2200 p : Fin bs.n, \u2203 r \u2208 S, p \u2208 r) -- 9-route property\n  :=\n  sorry", "formal_statement_pred": "theorem lean_workbook_plus_16678 : 10 < 3^8   :=  by sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_307", "informal_problem": "3-4. Can 10 bus routes be laid out in a city and stops be set up on them in such a way that for any 8 routes chosen, there is a stop not lying on any of them, while any 9 routes pass through all stops.", "formal_statement": "import Mathlib\n\nstructure BusSystem where\n  n : Nat -- number of stops\n  stops : Fin n\n  routes : Finset (Finset (Fin n)) -- set of routes, each route is a set of stops\n  route_count : routes.card = 10 -- exactly 10 routes\n  routes_nonempty : \u2200 r \u2208 routes, r.Nonempty -- each route has at least one stop\n\ntheorem bus_system_exists : \u2203 (n : Nat) (bs : BusSystem), \n  (\u2200 S \u2286 bs.routes, S.card = 8 \u2192 \n    \u2203 p : Fin bs.n, \u2200 r \u2208 S, p \u2209 r) \u2227 -- 8-route property\n  (\u2200 S \u2286 bs.routes, S.card = 9 \u2192 \n    \u2200 p : Fin bs.n, \u2203 r \u2208 S, p \u2208 r) -- 9-route property\n  :=\n  sorry", "formal_statement_pred": "theorem lean_workbook_plus_76273 : 3 < 4 \u2227 10 > 8 \u2227 10 \u2265 9   :=  by sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_308", "informal_problem": "3-\u0447\u0430 3. At the consultation, there were 20 schoolchildren and 20 problems were discussed. It turned out that each of the schoolchildren solved two problems and each problem was solved by two schoolchildren. Prove that it is possible to organize the discussion of the problems in such a way that each schoolchild presents one of the problems they solved and all problems are discussed.", "formal_statement": "import Mathlib\n\nstructure ConsultationGraph where\n  n : Nat\n  h_size : n = 20\n  -- Adjacency relation between students and problems\n  adj : Fin n \u2192 Fin n \u2192 Prop\n  -- Each student solved exactly two problems\n  h_student_solved_two : \u2200 s : Fin n, \u2203 p\u2081 p\u2082, p\u2081 \u2260 p\u2082 \u2227 adj s p\u2081 \u2227 adj s p\u2082 \u2227 \n    \u2200 p\u2083, adj s p\u2083 \u2192 p\u2083 = p\u2081 \u2228 p\u2083 = p\u2082\n  -- Each problem was solved by exactly two students\n  h_problem_solved_by_two : \u2200 p : Fin n, \u2203 s\u2081 s\u2082, s\u2081 \u2260 s\u2082 \u2227 adj s\u2081 p \u2227 adj s\u2082 p \u2227\n    \u2200 s\u2083, adj s\u2083 p \u2192 s\u2083 = s\u2081 \u2228 s\u2083 = s\u2082\n\n/-- A valid presentation matching assigns each student one of their solved problems -/\nstructure PresentationMatching (g : ConsultationGraph) where\n  assignment : Fin g.n \u2192 Fin g.n\n  h_valid : \u2200 s, g.adj s (assignment s)  -- Student presents a problem they solved\n  h_injective : Function.Injective assignment  -- Each problem presented exactly once\n\ntheorem consultation_matching_exists (g : ConsultationGraph) :\n  \u2203 m : PresentationMatching g, True :=\n  sorry", "formal_statement_pred": "theorem lean_workbook_49323 (a : Fin 20 \u2192 Fin 20 \u2192 Prop) (h : \u2200 i, \u2203 j, a i j) : \u2203 f : Fin 20 \u2192 Fin 20, (\u2200 i, a i (f i)) \u2227 (\u2200 j, \u2203 i, a i j)  :=  by sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_309", "informal_problem": "3-\u0447\u0430 1. A square \\(17 \\times 17\\) is cut out from a grid paper. The cells of the square are arbitrarily filled with the numbers \\(1,2,3, \\ldots, 70\\), with one and only one number in each cell.\n\nProve that there exist four different cells with centers at points \\(A, B, C, D\\) such that \\(A B=C D, A D=B C\\) and the sum of the numbers in the cells with centers at \\(A\\) and \\(C\\) is equal to the sum of the numbers in the cells with centers at \\(B\\) and \\(D\\).", "formal_statement": "import Mathlib\n\n-- Points on a 17x17 grid\nstructure GridPoint where\n  x : Fin 17\n  y : Fin 17\n\n-- Assignment of numbers 1 to 70 to grid points\nstructure GridAssignment where\n  values : GridPoint \u2192 Fin 71\n  -- Every number from 1 to 70 appears exactly once\n  injective : Function.Injective values\n  range_valid : \u2200 p, (values p).val \u2264 70\n  surjective : \u2200 n : Fin 71, n.val \u2264 70 \u2192 \u2203 p, values p = n\n\n-- Distance between two grid points (squared to avoid Real numbers)\ndef distanceSquared (p q : GridPoint) : \u2115 :=\n  (p.x.val - q.x.val)^2 + (p.y.val - q.y.val)^2\n\n-- Check if four points form a rectangle with equal sides\ndef isRectangle (a b c d : GridPoint) : Prop :=\n  distanceSquared a b = distanceSquared c d \u2227 \n  distanceSquared a d = distanceSquared b c \u2227\n  -- Points are distinct\n  a \u2260 b \u2227 a \u2260 c \u2227 a \u2260 d \u2227 b \u2260 c \u2227 b \u2260 d \u2227 c \u2260 d\n\ntheorem exists_equal_sum_rectangle : \n  \u2200 (g : GridAssignment),\n    \u2203 (a b c d : GridPoint),\n      isRectangle a b c d \u2227 \n      (g.values a).val + (g.values c).val = (g.values b).val + (g.values d).val :=\n  sorry", "formal_statement_pred": "theorem lean_workbook_plus_62333 (A B C D : Fin 17) (h : A \u2260 B \u2227 A \u2260 C \u2227 A \u2260 D \u2227 B \u2260 C \u2227 B \u2260 D \u2227 C \u2260 D) : (A + B = C + D \u2227 A + D = B + C) \u2194 (A + B = C + D \u2227 A + C = B + D)   :=  by sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_309", "informal_problem": "3-\u0447\u0430 1. A square \\(17 \\times 17\\) is cut out from a grid paper. The cells of the square are arbitrarily filled with the numbers \\(1,2,3, \\ldots, 70\\), with one and only one number in each cell.\n\nProve that there exist four different cells with centers at points \\(A, B, C, D\\) such that \\(A B=C D, A D=B C\\) and the sum of the numbers in the cells with centers at \\(A\\) and \\(C\\) is equal to the sum of the numbers in the cells with centers at \\(B\\) and \\(D\\).", "formal_statement": "import Mathlib\n\n-- Points on a 17x17 grid\nstructure GridPoint where\n  x : Fin 17\n  y : Fin 17\n\n-- Assignment of numbers 1 to 70 to grid points\nstructure GridAssignment where\n  values : GridPoint \u2192 Fin 71\n  -- Every number from 1 to 70 appears exactly once\n  injective : Function.Injective values\n  range_valid : \u2200 p, (values p).val \u2264 70\n  surjective : \u2200 n : Fin 71, n.val \u2264 70 \u2192 \u2203 p, values p = n\n\n-- Distance between two grid points (squared to avoid Real numbers)\ndef distanceSquared (p q : GridPoint) : \u2115 :=\n  (p.x.val - q.x.val)^2 + (p.y.val - q.y.val)^2\n\n-- Check if four points form a rectangle with equal sides\ndef isRectangle (a b c d : GridPoint) : Prop :=\n  distanceSquared a b = distanceSquared c d \u2227 \n  distanceSquared a d = distanceSquared b c \u2227\n  -- Points are distinct\n  a \u2260 b \u2227 a \u2260 c \u2227 a \u2260 d \u2227 b \u2260 c \u2227 b \u2260 d \u2227 c \u2260 d\n\ntheorem exists_equal_sum_rectangle : \n  \u2200 (g : GridAssignment),\n    \u2203 (a b c d : GridPoint),\n      isRectangle a b c d \u2227 \n      (g.values a).val + (g.values c).val = (g.values b).val + (g.values d).val :=\n  sorry", "formal_statement_pred": "theorem lean_workbook_plus_13384 :\n    \u2200 A B C D : (Fin 17) \u00d7 (Fin 17),\n    A \u2260 B \u2227 A \u2260 C \u2227 A \u2260 D \u2227 B \u2260 C \u2227 B \u2260 D \u2227 C \u2260 D \u2192\n    (A.1 = B.1 \u2227 A.2 = B.2) \u2228 (A.1 = C.1 \u2227 A.2 = C.2) \u2228 (A.1 = D.1 \u2227 A.2 = D.2) \u2228\n    (B.1 = C.1 \u2227 B.2 = C.2) \u2228 (B.1 = D.1 \u2227 B.2 = D.2) \u2228 (C.1 = D.1 \u2227 C.2 = D.2)   :=  by sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_313", "informal_problem": "3-\u0447\u0430 1. A cargo weighing 13.5 tons is packed into boxes such that the weight of each box does not exceed 350 kg. Prove that this cargo can be transported using 11 one-and-a-half-ton trucks. (The weight of the empty boxes can be neglected.)", "formal_statement": "import Mathlib\n\nstructure Box where\n  weight : \u211a  -- weight in tons\n  weight_valid : weight \u2264 (350 : \u211a)/1000  -- 350kg = 0.35 tons\n\nstructure CargoDistribution where\n  boxes : Finset Box\n  total_weight : (\u2211 b in boxes, b.weight) = (27/2 : \u211a)  -- 13.5 tons\n  exists_partition : \u2203 (parts : Fin 11 \u2192 Finset Box),\n    (\u2200 i : Fin 11, (\u2211 b in parts i, b.weight) \u2264 (3/2 : \u211a)) \u2227  -- each truck \u2264 1.5 tons\n    (\u2200 b \u2208 boxes, \u2203! i : Fin 11, b \u2208 parts i) \u2227  -- each box in exactly one part\n    (\u2200 i : Fin 11, parts i \u2286 boxes)  -- all parts come from boxes\n\ntheorem cargo_distribution_exists : \u2203 (d : CargoDistribution), d.boxes.Nonempty :=\n  sorry", "formal_statement_pred": "theorem lean_workbook_plus_80118 (h : 13.5 * 1000 = 13500) : 13500 \u2264 11 * 1500   :=  by sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_313", "informal_problem": "3-\u0447\u0430 1. A cargo weighing 13.5 tons is packed into boxes such that the weight of each box does not exceed 350 kg. Prove that this cargo can be transported using 11 one-and-a-half-ton trucks. (The weight of the empty boxes can be neglected.)", "formal_statement": "import Mathlib\n\nstructure Box where\n  weight : \u211a  -- weight in tons\n  weight_valid : weight \u2264 (350 : \u211a)/1000  -- 350kg = 0.35 tons\n\nstructure CargoDistribution where\n  boxes : Finset Box\n  total_weight : (\u2211 b in boxes, b.weight) = (27/2 : \u211a)  -- 13.5 tons\n  exists_partition : \u2203 (parts : Fin 11 \u2192 Finset Box),\n    (\u2200 i : Fin 11, (\u2211 b in parts i, b.weight) \u2264 (3/2 : \u211a)) \u2227  -- each truck \u2264 1.5 tons\n    (\u2200 b \u2208 boxes, \u2203! i : Fin 11, b \u2208 parts i) \u2227  -- each box in exactly one part\n    (\u2200 i : Fin 11, parts i \u2286 boxes)  -- all parts come from boxes\n\ntheorem cargo_distribution_exists : \u2203 (d : CargoDistribution), d.boxes.Nonempty :=\n  sorry", "formal_statement_pred": "theorem lean_workbook_plus_62657 (h : 13.5 * 1000 \u2264 11 * 1500) : 13.5 * 1000 \u2264 11 * 1500   :=  by sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_317", "informal_problem": "16.2. Two players take turns placing coins on a rectangular table. A coin can only be placed on a free spot. The player who cannot make a move loses. Prove that the first player can always win.", "formal_statement": "import Mathlib\n\nstructure RectangularBoard where\n  rows : Nat\n  cols : Nat\n  board : Fin rows \u2192 Fin cols \u2192 Bool  -- True means occupied, False means free\n\n/-- A valid move places a coin on an unoccupied position -/\ndef isValidMove (board : RectangularBoard) (row : Fin board.rows) (col : Fin board.cols) : Bool :=\n  !board.board row col\n\n/-- Returns whether the game is over (no valid moves remain) -/\ndef isGameOver (board : RectangularBoard) : Bool :=\n  \u2200 r : Fin board.rows, \u2200 c : Fin board.cols, board.board r c\n\n/-- Represents a winning strategy for the first player -/\ndef HasWinningStrategy (board : RectangularBoard) : Prop :=\n  \u2203 (firstMove : Fin board.rows \u00d7 Fin board.cols),\n    isValidMove board firstMove.1 firstMove.2 \u2227\n    \u2200 (response : Fin board.rows \u00d7 Fin board.cols),\n      isValidMove board response.1 response.2 \u2192\n        \u2203 (nextMove : Fin board.rows \u00d7 Fin board.cols),\n          isValidMove board nextMove.1 nextMove.2\n\ntheorem rectangular_board_first_player_wins \n  (rows cols : Nat) \n  (h1 : rows > 0) \n  (h2 : cols > 0) : \n  HasWinningStrategy \u27e8rows, cols, fun _ _ => false\u27e9 :=\n  sorry", "formal_statement_pred": "theorem lean_workbook_51097 (m n : \u2115) : \u2203 m n, m > 0 \u2227 n > 0 \u2192 m * n < 2^(m + n - 1)  :=  by sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_319", "informal_problem": "21.1. The nodes of an infinite grid paper are colored in two colors. Prove that there exist two horizontal and two vertical lines, at the intersections of which lie points of the same color.", "formal_statement": "import Mathlib\n\n-- A coloring of the grid is a function from pairs of integers to Bool\n-- where Bool represents the two colors (true and false)\nstructure GridColoring where\n  color : (\u2124 \u00d7 \u2124) \u2192 Bool\n\ntheorem grid_same_color_points (c : GridColoring) :\n  \u2203 (x\u2081 x\u2082 y\u2081 y\u2082 : \u2124) (h\u2081 : x\u2081 \u2260 x\u2082) (h\u2082 : y\u2081 \u2260 y\u2082),\n    let p\u2081\u2081 := (x\u2081, y\u2081)\n    let p\u2081\u2082 := (x\u2081, y\u2082)\n    let p\u2082\u2081 := (x\u2082, y\u2081)\n    let p\u2082\u2082 := (x\u2082, y\u2082)\n    c.color p\u2081\u2081 = c.color p\u2081\u2082 \u2227\n    c.color p\u2081\u2081 = c.color p\u2082\u2081 \u2227\n    c.color p\u2081\u2081 = c.color p\u2082\u2082 :=\n  sorry", "formal_statement_pred": "theorem lean_workbook_plus_20971 (two_color_infinite : \u2115 \u00d7 \u2115 \u2192 Fin 2) : \u2203 h1 h2 v1 v2 : \u2115, two_color_infinite (h1, v1) = two_color_infinite (h2, v2)   :=  by sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_319", "informal_problem": "21.1. The nodes of an infinite grid paper are colored in two colors. Prove that there exist two horizontal and two vertical lines, at the intersections of which lie points of the same color.", "formal_statement": "import Mathlib\n\n-- A coloring of the grid is a function from pairs of integers to Bool\n-- where Bool represents the two colors (true and false)\nstructure GridColoring where\n  color : (\u2124 \u00d7 \u2124) \u2192 Bool\n\ntheorem grid_same_color_points (c : GridColoring) :\n  \u2203 (x\u2081 x\u2082 y\u2081 y\u2082 : \u2124) (h\u2081 : x\u2081 \u2260 x\u2082) (h\u2082 : y\u2081 \u2260 y\u2082),\n    let p\u2081\u2081 := (x\u2081, y\u2081)\n    let p\u2081\u2082 := (x\u2081, y\u2082)\n    let p\u2082\u2081 := (x\u2082, y\u2081)\n    let p\u2082\u2082 := (x\u2082, y\u2082)\n    c.color p\u2081\u2081 = c.color p\u2081\u2082 \u2227\n    c.color p\u2081\u2081 = c.color p\u2082\u2081 \u2227\n    c.color p\u2081\u2081 = c.color p\u2082\u2082 :=\n  sorry", "formal_statement_pred": "theorem lean_workbook_plus_21245 (S : \u2115 \u00d7 \u2115 \u2192 Fin 2) : \u2203 a b c d : \u2115, (S (a, b) = S (c, d)) \u2228 (S (a, c) = S (b, d)) \u2228 (S (a, d) = S (b, c))   :=  by sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_319", "informal_problem": "21.1. The nodes of an infinite grid paper are colored in two colors. Prove that there exist two horizontal and two vertical lines, at the intersections of which lie points of the same color.", "formal_statement": "import Mathlib\n\n-- A coloring of the grid is a function from pairs of integers to Bool\n-- where Bool represents the two colors (true and false)\nstructure GridColoring where\n  color : (\u2124 \u00d7 \u2124) \u2192 Bool\n\ntheorem grid_same_color_points (c : GridColoring) :\n  \u2203 (x\u2081 x\u2082 y\u2081 y\u2082 : \u2124) (h\u2081 : x\u2081 \u2260 x\u2082) (h\u2082 : y\u2081 \u2260 y\u2082),\n    let p\u2081\u2081 := (x\u2081, y\u2081)\n    let p\u2081\u2082 := (x\u2081, y\u2082)\n    let p\u2082\u2081 := (x\u2082, y\u2081)\n    let p\u2082\u2082 := (x\u2082, y\u2082)\n    c.color p\u2081\u2081 = c.color p\u2081\u2082 \u2227\n    c.color p\u2081\u2081 = c.color p\u2082\u2081 \u2227\n    c.color p\u2081\u2081 = c.color p\u2082\u2082 :=\n  sorry", "formal_statement_pred": "theorem lean_workbook_4326 (f : \u2124 \u2192 \u2124 \u2192 Fin 2) : \u2203 a b c d : \u2124, f a b = f c d  :=  by sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_319", "informal_problem": "21.1. The nodes of an infinite grid paper are colored in two colors. Prove that there exist two horizontal and two vertical lines, at the intersections of which lie points of the same color.", "formal_statement": "import Mathlib\n\n-- A coloring of the grid is a function from pairs of integers to Bool\n-- where Bool represents the two colors (true and false)\nstructure GridColoring where\n  color : (\u2124 \u00d7 \u2124) \u2192 Bool\n\ntheorem grid_same_color_points (c : GridColoring) :\n  \u2203 (x\u2081 x\u2082 y\u2081 y\u2082 : \u2124) (h\u2081 : x\u2081 \u2260 x\u2082) (h\u2082 : y\u2081 \u2260 y\u2082),\n    let p\u2081\u2081 := (x\u2081, y\u2081)\n    let p\u2081\u2082 := (x\u2081, y\u2082)\n    let p\u2082\u2081 := (x\u2082, y\u2081)\n    let p\u2082\u2082 := (x\u2082, y\u2082)\n    c.color p\u2081\u2081 = c.color p\u2081\u2082 \u2227\n    c.color p\u2081\u2081 = c.color p\u2082\u2081 \u2227\n    c.color p\u2081\u2081 = c.color p\u2082\u2082 :=\n  sorry", "formal_statement_pred": "theorem lean_workbook_plus_27121 (color : \u2124 \u00d7 \u2124 \u2192 Fin 2) : \u2203 a b c d : \u2124, (a, c) = (b, d) \u2227 color (a, c) = color (b, d)   :=  by sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_319", "informal_problem": "21.1. The nodes of an infinite grid paper are colored in two colors. Prove that there exist two horizontal and two vertical lines, at the intersections of which lie points of the same color.", "formal_statement": "import Mathlib\n\n-- A coloring of the grid is a function from pairs of integers to Bool\n-- where Bool represents the two colors (true and false)\nstructure GridColoring where\n  color : (\u2124 \u00d7 \u2124) \u2192 Bool\n\ntheorem grid_same_color_points (c : GridColoring) :\n  \u2203 (x\u2081 x\u2082 y\u2081 y\u2082 : \u2124) (h\u2081 : x\u2081 \u2260 x\u2082) (h\u2082 : y\u2081 \u2260 y\u2082),\n    let p\u2081\u2081 := (x\u2081, y\u2081)\n    let p\u2081\u2082 := (x\u2081, y\u2082)\n    let p\u2082\u2081 := (x\u2082, y\u2081)\n    let p\u2082\u2082 := (x\u2082, y\u2082)\n    c.color p\u2081\u2081 = c.color p\u2081\u2082 \u2227\n    c.color p\u2081\u2081 = c.color p\u2082\u2081 \u2227\n    c.color p\u2081\u2081 = c.color p\u2082\u2082 :=\n  sorry", "formal_statement_pred": "theorem lean_workbook_plus_12411 : \u2200 two_coloring : \u2115 \u00d7 \u2115 \u2192 Fin 2, \u2203 h1 h2 v1 v2 : \u2115, h1 \u2260 h2 \u2227 v1 \u2260 v2 \u2227 two_coloring (h1, v1) = two_coloring (h2, v2)   :=  by sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_319", "informal_problem": "21.1. The nodes of an infinite grid paper are colored in two colors. Prove that there exist two horizontal and two vertical lines, at the intersections of which lie points of the same color.", "formal_statement": "import Mathlib\n\n-- A coloring of the grid is a function from pairs of integers to Bool\n-- where Bool represents the two colors (true and false)\nstructure GridColoring where\n  color : (\u2124 \u00d7 \u2124) \u2192 Bool\n\ntheorem grid_same_color_points (c : GridColoring) :\n  \u2203 (x\u2081 x\u2082 y\u2081 y\u2082 : \u2124) (h\u2081 : x\u2081 \u2260 x\u2082) (h\u2082 : y\u2081 \u2260 y\u2082),\n    let p\u2081\u2081 := (x\u2081, y\u2081)\n    let p\u2081\u2082 := (x\u2081, y\u2082)\n    let p\u2082\u2081 := (x\u2082, y\u2081)\n    let p\u2082\u2082 := (x\u2082, y\u2082)\n    c.color p\u2081\u2081 = c.color p\u2081\u2082 \u2227\n    c.color p\u2081\u2081 = c.color p\u2082\u2081 \u2227\n    c.color p\u2081\u2081 = c.color p\u2082\u2082 :=\n  sorry", "formal_statement_pred": "theorem lean_workbook_plus_59962 (color : \u2124 \u00d7 \u2124 \u2192 \u2115) : \u2203 h\u2081 h\u2082 v\u2081 v\u2082 : \u2124, color (h\u2081, v\u2081) = color (h\u2082, v\u2082)   :=  by sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_319", "informal_problem": "21.1. The nodes of an infinite grid paper are colored in two colors. Prove that there exist two horizontal and two vertical lines, at the intersections of which lie points of the same color.", "formal_statement": "import Mathlib\n\n-- A coloring of the grid is a function from pairs of integers to Bool\n-- where Bool represents the two colors (true and false)\nstructure GridColoring where\n  color : (\u2124 \u00d7 \u2124) \u2192 Bool\n\ntheorem grid_same_color_points (c : GridColoring) :\n  \u2203 (x\u2081 x\u2082 y\u2081 y\u2082 : \u2124) (h\u2081 : x\u2081 \u2260 x\u2082) (h\u2082 : y\u2081 \u2260 y\u2082),\n    let p\u2081\u2081 := (x\u2081, y\u2081)\n    let p\u2081\u2082 := (x\u2081, y\u2082)\n    let p\u2082\u2081 := (x\u2082, y\u2081)\n    let p\u2082\u2082 := (x\u2082, y\u2082)\n    c.color p\u2081\u2081 = c.color p\u2081\u2082 \u2227\n    c.color p\u2081\u2081 = c.color p\u2082\u2081 \u2227\n    c.color p\u2081\u2081 = c.color p\u2082\u2082 :=\n  sorry", "formal_statement_pred": "theorem lean_workbook_plus_1827 (c : \u2115 \u00d7 \u2115 \u2192 Fin 2) : \u2203 h1 h2 v1 v2 : \u2115 \u2192 \u2115, c (h1 x, v1 y) = c (h2 x, v2 y)   :=  by sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_323", "informal_problem": "23.20. A beetle sits in each cell of a $5 \\times 5$ board. At some moment, all the beetles crawl to adjacent (horizontally or vertically) cells. Will there necessarily be an empty cell?", "formal_statement": "import Mathlib\n\nstructure Position where\n  row : Fin 5\n  col : Fin 5\nderiving Fintype\n\ndef isAdjacent (p\u2081 p\u2082 : Position) : Prop :=\n  (p\u2081.row = p\u2082.row \u2227 |p\u2081.col - p\u2082.col| = 1) \u2228\n  (p\u2081.col = p\u2082.col \u2227 |p\u2081.row - p\u2082.row| = 1)\n\nstructure Board where\n  beetles : Position \u2192 Bool  -- true means occupied, false means empty\n\nstructure BeetleMove where\n  initial : Board\n  final : Board\n  initial_has_one : \u2200 p : Position, initial.beetles p = true  -- exactly one beetle per position initially\n  valid_moves : \u2200 p\u2081 : Position, initial.beetles p\u2081 = true \u2192 \n    \u2203! p\u2082 : Position, final.beetles p\u2082 = true \u2227 isAdjacent p\u2081 p\u2082  -- each beetle moves to exactly one adjacent cell\n  no_overlap : \u2200 p : Position, final.beetles p \u2192 \n    \u2203! p\u2081 : Position, initial.beetles p\u2081 = true \u2227 isAdjacent p\u2081 p  -- at most one beetle per final position\n\ntheorem beetle_movement_creates_empty_cell :\n  \u2200 (move : BeetleMove), \u2203 p : Position, move.final.beetles p = false :=\n  sorry", "formal_statement_pred": "theorem lean_workbook_plus_25432 (f : Fin 5 \u2192 Fin 5 \u2192 Bool) (hf : \u2200 i j, f i j) : \u2203 i j, \u00acf i j   :=  by sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_325", "informal_problem": "23.28. From a sheet of graph paper measuring $29 \\times 29$ cells, 99 squares of size $2 \\times 2$ cells have been cut out. Prove that it is possible to cut out one more such square.", "formal_statement": "import Mathlib\n\nstructure GridPaper where\n  size : Nat\n  cutSquares : Finset (Nat \u00d7 Nat)  -- Coordinates of top-left corners of cut 2x2 squares\n  valid : size = 29\n  noOverlap : \u2200 (p q : Nat \u00d7 Nat), p \u2208 cutSquares \u2192 q \u2208 cutSquares \u2192 p \u2260 q \u2192\n    \u00ac(\u2203 (i j : Fin 2), \n      p.1 + i.val = q.1 + i.val \u2227 \n      p.2 + j.val = q.2 + j.val)\n  inBounds : \u2200 p \u2208 cutSquares, \n    p.1 + 1 < size \u2227 p.2 + 1 < size\n\ntheorem can_cut_one_more_square (g : GridPaper) \n  (h : g.cutSquares.card = 99) : \n  \u2203 (x y : Nat), x + 1 < g.size \u2227 y + 1 < g.size \u2227\n    (\u2200 p \u2208 g.cutSquares, \u00ac(\u2203 (i j : Fin 2), \n      x + i.val = p.1 + i.val \u2227 \n      y + j.val = p.2 + j.val)) :=\n  sorry", "formal_statement_pred": "theorem lean_workbook_plus_34800 (h : 99 * 2 * 2 \u2264 29 * 29) : \u2203 x y, 2 \u2264 x \u2227 2 \u2264 y \u2227 x + y \u2264 29 \u2227 y + x \u2264 29   :=  by sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_325", "informal_problem": "23.28. From a sheet of graph paper measuring $29 \\times 29$ cells, 99 squares of size $2 \\times 2$ cells have been cut out. Prove that it is possible to cut out one more such square.", "formal_statement": "import Mathlib\n\nstructure GridPaper where\n  size : Nat\n  cutSquares : Finset (Nat \u00d7 Nat)  -- Coordinates of top-left corners of cut 2x2 squares\n  valid : size = 29\n  noOverlap : \u2200 (p q : Nat \u00d7 Nat), p \u2208 cutSquares \u2192 q \u2208 cutSquares \u2192 p \u2260 q \u2192\n    \u00ac(\u2203 (i j : Fin 2), \n      p.1 + i.val = q.1 + i.val \u2227 \n      p.2 + j.val = q.2 + j.val)\n  inBounds : \u2200 p \u2208 cutSquares, \n    p.1 + 1 < size \u2227 p.2 + 1 < size\n\ntheorem can_cut_one_more_square (g : GridPaper) \n  (h : g.cutSquares.card = 99) : \n  \u2203 (x y : Nat), x + 1 < g.size \u2227 y + 1 < g.size \u2227\n    (\u2200 p \u2208 g.cutSquares, \u00ac(\u2203 (i j : Fin 2), \n      x + i.val = p.1 + i.val \u2227 \n      y + j.val = p.2 + j.val)) :=\n  sorry", "formal_statement_pred": "theorem lean_workbook_45936 (h\u2081 : 29 > 2 * 2) (h\u2082 : 29 * 29 - 99 * 2 * 2 + 2 * 2 \u2265 0) : 29 * 29 - 99 * 2 * 2 + 2 * 2 \u2265 0  :=  by sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_325", "informal_problem": "23.28. From a sheet of graph paper measuring $29 \\times 29$ cells, 99 squares of size $2 \\times 2$ cells have been cut out. Prove that it is possible to cut out one more such square.", "formal_statement": "import Mathlib\n\nstructure GridPaper where\n  size : Nat\n  cutSquares : Finset (Nat \u00d7 Nat)  -- Coordinates of top-left corners of cut 2x2 squares\n  valid : size = 29\n  noOverlap : \u2200 (p q : Nat \u00d7 Nat), p \u2208 cutSquares \u2192 q \u2208 cutSquares \u2192 p \u2260 q \u2192\n    \u00ac(\u2203 (i j : Fin 2), \n      p.1 + i.val = q.1 + i.val \u2227 \n      p.2 + j.val = q.2 + j.val)\n  inBounds : \u2200 p \u2208 cutSquares, \n    p.1 + 1 < size \u2227 p.2 + 1 < size\n\ntheorem can_cut_one_more_square (g : GridPaper) \n  (h : g.cutSquares.card = 99) : \n  \u2203 (x y : Nat), x + 1 < g.size \u2227 y + 1 < g.size \u2227\n    (\u2200 p \u2208 g.cutSquares, \u00ac(\u2203 (i j : Fin 2), \n      x + i.val = p.1 + i.val \u2227 \n      y + j.val = p.2 + j.val)) :=\n  sorry", "formal_statement_pred": "theorem lean_workbook_plus_22601 :\n  99 < (29 + 1) ^ 2 - 1   :=  by sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_328", "informal_problem": "23.35. A plane is colored in two colors. Prove that there are two points of the same color, the distance between which is 1.", "formal_statement": "import Mathlib\n\nopen Real\n\nstructure Point where\n  x : \u211d\n  y : \u211d\n\ndef PlaneColoring (\u03b1 : Type) := Point \u2192 \u03b1\n\nnoncomputable def distance (p\u2081 p\u2082 : Point) : \u211d :=\n  sqrt ((p\u2081.x - p\u2082.x)^2 + (p\u2081.y - p\u2082.y)^2)\n\ntheorem exists_same_color_unit_distance {\u03b1 : Type} (c : PlaneColoring \u03b1) \n    [Fintype \u03b1] [DecidableEq \u03b1] (h : Fintype.card \u03b1 = 2) :\n  \u2203 (p\u2081 p\u2082 : Point), c p\u2081 = c p\u2082 \u2227 distance p\u2081 p\u2082 = 1 :=\n  sorry", "formal_statement_pred": "theorem lean_workbook_plus_16745 (f : \u211d \u00d7 \u211d \u2192 Fin 2) : \u2203 (a b : \u211d \u00d7 \u211d), a \u2260 b \u2227 f a = f b   :=  by sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_329", "informal_problem": "23.36*. A plane is painted in three colors. Prove that there are two points of the same color, the distance between which is 1.", "formal_statement": "import Mathlib\n\nstructure ColoredPlane where\n  coloring : \u211d \u00d7 \u211d \u2192 Fin 3\n  -- A function that assigns one of three colors (0, 1, or 2) to each point in \u211d\u00b2\n\ntheorem monocromatic_unit_distance (p : ColoredPlane) : \n  \u2203 (x y : \u211d \u00d7 \u211d), \n    x \u2260 y \u2227 \n    p.coloring x = p.coloring y \u2227 \n    Real.sqrt ((x.1 - y.1)^2 + (x.2 - y.2)^2) = 1 :=\n  sorry", "formal_statement_pred": "theorem lean_workbook_plus_40250 (p : \u2115 \u2192 \u211d) (f : \u211d \u2192 \u2115) : \u2203 x y, x = y \u2227 p x = p y   :=  by sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_350", "informal_problem": "26.14. (USA, 76). a) Let each cell of a rectangular board of size $4 \\times 7$ be colored either white or black. Prove that there must be a rectangle on the board, formed by horizontal and vertical lines of the board, all four corner cells of which are colored the same color.\n\nb) Provide an example of a coloring of a rectangular board of size $4 \\times 6$ for which the rectangle mentioned in part a) does not exist.", "formal_statement": "import Mathlib\n\n-- Represent a board coloring as a function from positions to Bool\n-- where True represents white and False represents black\nstructure BoardColoring (m n : Nat) where\n  color : Fin m \u2192 Fin n \u2192 Bool\n\n-- Define what it means to have a monochromatic rectangle\ndef hasMonochromaticRectangle (m n : Nat) (board : BoardColoring m n) : Prop :=\n  \u2203 (r\u2081 r\u2082 : Fin m) (c\u2081 c\u2082 : Fin n),\n    r\u2081 < r\u2082 \u2227 c\u2081 < c\u2082 \u2227\n    (board.color r\u2081 c\u2081 = board.color r\u2081 c\u2082) \u2227\n    (board.color r\u2081 c\u2081 = board.color r\u2082 c\u2081) \u2227\n    (board.color r\u2081 c\u2081 = board.color r\u2082 c\u2082)\n\ntheorem board_4x7_has_monochromatic_rectangle :\n  \u2200 (board : BoardColoring 4 7), hasMonochromaticRectangle 4 7 board :=\n  sorry", "formal_statement_pred": "theorem lean_workbook_plus_56735 (A : Fin 4 \u00d7 Fin 7 \u2192 Fin 2) : \u2203 (a b c d : Fin 4), \u2203 (h : Fin 7), a \u2260 b \u2227 b \u2260 c \u2227 c \u2260 d \u2227 d \u2260 a \u2227 A (a, h) = A (b, h) \u2227 A (b, h) = A (c, h) \u2227 A (c, h) = A (d, h)   :=  by sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_357", "informal_problem": "103*. a) Show that there exist nine pairwise distinct squares from which a certain rectangle can be formed.\n\nb) From 10 pairwise distinct squares, form a rectangle with sides 47 and 65.\n\nc) Show that for any number $n$, greater than eight, it is always possible to find $n$ pairwise distinct squares from which a rectangle can be formed.", "formal_statement": "import Mathlib\n\n-- Part (a) and (b) are specific instances of part (c), so we'll formalize the general case\n\n/-- A configuration of squares that form a rectangle -/\nstructure SquareRectConfig where\n  n : \u2115                     -- number of squares\n  squares : Fin n \u2192 \u2115       -- the side lengths of the squares\n  distinct : \u2200 i j, i \u2260 j \u2192 squares i \u2260 squares j  -- squares are pairwise distinct\n  width : \u2115                 -- width of the rectangle\n  height : \u2115                -- height of the rectangle\n  forms_rectangle : width * height = (\u2211 i, (squares i) ^ 2)  -- squares form the rectangle\n\ntheorem squares_form_rectangle (n : \u2115) (h : n > 8) : \n  \u2203 (config : SquareRectConfig), config.n = n :=\n  sorry", "formal_statement_pred": "theorem lean_workbook_27527 :\n  103 * (a + b + c) = 0   :=  by sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_357", "informal_problem": "103*. a) Show that there exist nine pairwise distinct squares from which a certain rectangle can be formed.\n\nb) From 10 pairwise distinct squares, form a rectangle with sides 47 and 65.\n\nc) Show that for any number $n$, greater than eight, it is always possible to find $n$ pairwise distinct squares from which a rectangle can be formed.", "formal_statement": "import Mathlib\n\n-- Part (a) and (b) are specific instances of part (c), so we'll formalize the general case\n\n/-- A configuration of squares that form a rectangle -/\nstructure SquareRectConfig where\n  n : \u2115                     -- number of squares\n  squares : Fin n \u2192 \u2115       -- the side lengths of the squares\n  distinct : \u2200 i j, i \u2260 j \u2192 squares i \u2260 squares j  -- squares are pairwise distinct\n  width : \u2115                 -- width of the rectangle\n  height : \u2115                -- height of the rectangle\n  forms_rectangle : width * height = (\u2211 i, (squares i) ^ 2)  -- squares form the rectangle\n\ntheorem squares_form_rectangle (n : \u2115) (h : n > 8) : \n  \u2203 (config : SquareRectConfig), config.n = n :=\n  sorry", "formal_statement_pred": "theorem lean_workbook_plus_33936 (a b c d e f g h i j : \u2115) (hab : a \u2260 b) (hbc : b \u2260 c) (hcd : c \u2260 d) (hde : d \u2260 e) (hef : e \u2260 f) (hgh : f \u2260 g) (hhi : g \u2260 h) (hij : h \u2260 i) (hj : i \u2260 j) : \u2203 a b c d e f g h i j : \u2115, a \u2260 b \u2227 b \u2260 c \u2227 c \u2260 d \u2227 d \u2260 e \u2227 e \u2260 f \u2227 f \u2260 g \u2227 g \u2260 h \u2227 h \u2260 i \u2227 i \u2260 j \u2227 a \u2260 c \u2227 a \u2260 d \u2227 a \u2260 e \u2227 a \u2260 f \u2227 a \u2260 g \u2227 a \u2260 h \u2227 a \u2260 i \u2227 a \u2260 j \u2227 b \u2260 d \u2227 b \u2260 e \u2227 b \u2260 f \u2227 b \u2260 g \u2227 b \u2260 h \u2227 b \u2260 i \u2227 b \u2260 j \u2227 c \u2260 d \u2227 c \u2260 e \u2227 c \u2260 f \u2227 c \u2260 g \u2227 c \u2260 h \u2227 c \u2260 i \u2227 c \u2260 j \u2227 d \u2260 e \u2227 d \u2260 f \u2227 d \u2260 g \u2227 d \u2260 h \u2227 d \u2260 i \u2227 d \u2260 j \u2227 e \u2260 f \u2227 e \u2260 g \u2227 e \u2260 h \u2227 e \u2260 i \u2227 e \u2260 j \u2227 f \u2260 g \u2227 f \u2260 h \u2227 f \u2260 i \u2227 f \u2260 j \u2227 g \u2260 h \u2227 g \u2260 i \u2227 g \u2260 j \u2227 h \u2260 i \u2227 h \u2260 j \u2227 i \u2260 j   :=  by sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_362", "informal_problem": "38. In class 4A, there are 30 students. During a dictation, one student made 12 mistakes, and the others made fewer. Prove that there are at least three students in the class who made the same number of mistakes.", "formal_statement": "import Mathlib\n\nstructure DictationClass where\n  numStudents : \u2115\n  mistakes : Fin numStudents \u2192 \u2115\n\ntheorem pigeonhole_dictation\n  (c : DictationClass)\n  (h_size : c.numStudents = 30)\n  (h_bound : \u2200 i, c.mistakes i \u2264 12) :\n  \u2203 m : \u2115, \u2203 s : Finset (Fin c.numStudents),\n    s.card = 3 \u2227 \n    (\u2200 i \u2208 s, c.mistakes i = m) :=\n  sorry", "formal_statement_pred": "theorem lean_workbook_plus_49014 (h : 0 < 30) : \u2203 x, 0 < x \u2227 0 < 30 - x \u2227 12 > x \u2227 12 - x > 0   :=  by sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_362", "informal_problem": "38. In class 4A, there are 30 students. During a dictation, one student made 12 mistakes, and the others made fewer. Prove that there are at least three students in the class who made the same number of mistakes.", "formal_statement": "import Mathlib\n\nstructure DictationClass where\n  numStudents : \u2115\n  mistakes : Fin numStudents \u2192 \u2115\n\ntheorem pigeonhole_dictation\n  (c : DictationClass)\n  (h_size : c.numStudents = 30)\n  (h_bound : \u2200 i, c.mistakes i \u2264 12) :\n  \u2203 m : \u2115, \u2203 s : Finset (Fin c.numStudents),\n    s.card = 3 \u2227 \n    (\u2200 i \u2208 s, c.mistakes i = m) :=\n  sorry", "formal_statement_pred": "theorem lean_workbook_plus_70242 (h : 1 < 30) (f : \u2115 \u2192 \u2115) : \u2203 x y z : \u2115, x \u2260 y \u2227 y \u2260 z \u2227 z \u2260 x \u2227 f x = f y \u2227 f y = f z \u2227 f z = f x   :=  by sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_364", "informal_problem": "40. Prove that on October 23, 1965, in the cinema \"Mir\" during the first session, there were at least two viewers who had the same number of acquaintances among those sitting in the hall (it is known that 5 people were sitting in the first row).", "formal_statement": "import Mathlib\n\nopen Finset\n\nstructure CinemaViewer where\n  id : Nat\n  acquaintances : Finset Nat\n  h_no_self : id \u2209 acquaintances  -- Cannot be acquainted with oneself\n\n/-- A valid viewer configuration requires symmetric acquaintance relationships -/\ndef validViewerConfig (viewers : Finset CinemaViewer) : Prop :=\n  \u2200 v1 \u2208 viewers, \u2200 v2 \u2208 viewers,\n    v2.id \u2208 v1.acquaintances \u2194 v1.id \u2208 v2.acquaintances\n\n/-- Count of acquaintances for a viewer among the given viewer set -/\ndef acquaintanceCount (v : CinemaViewer) (viewers : Finset CinemaViewer) : Nat :=\n  (v.acquaintances.filter (\u03bb id \u21a6 \u2203 v' \u2208 viewers, v'.id = id)).card\n\ntheorem cinema_acquaintances_1965 \n  (viewers : Finset CinemaViewer)\n  (h_valid : validViewerConfig viewers)\n  (h_first_row : \u2203 first_row : Finset CinemaViewer, first_row \u2286 viewers \u2227 first_row.card = 5) :\n  \u2203 (v1 v2 : CinemaViewer), \n    v1 \u2208 viewers \u2227 \n    v2 \u2208 viewers \u2227 \n    v1 \u2260 v2 \u2227 \n    acquaintanceCount v1 viewers = acquaintanceCount v2 viewers :=\n  sorry", "formal_statement_pred": "theorem lean_workbook_plus_40264 (f : Fin 5 \u2192 \u2115) : \u2203 a b, a \u2260 b \u2227 f a = f b   :=  by sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_366", "informal_problem": "72. Seven mushroom pickers collected a total of 100 mushrooms, and each of the seven collected a different number of mushrooms. Prove that there are three mushroom pickers who together collected no fewer than 50 mushrooms.", "formal_statement": "import Mathlib\n\nstructure MushroomCollection where\n  pickers : Fin 7 \u2192 Nat\n  total_is_100 : (\u2211 i, pickers i) = 100\n  all_different : \u2200 i j, i \u2260 j \u2192 pickers i \u2260 pickers j\n\ntheorem mushroom_pickers_theorem (c : MushroomCollection) :\n  \u2203 (i j k : Fin 7), i \u2260 j \u2227 j \u2260 k \u2227 i \u2260 k \u2227\n    c.pickers i + c.pickers j + c.pickers k \u2265 50 :=\n  sorry", "formal_statement_pred": "theorem lean_workbook_plus_6747 (h : 100 = a + b + c + d + e + f + g) (h2: a \u2260 b \u2227 b \u2260 c \u2227 c \u2260 d \u2227 d \u2260 e \u2227 e \u2260 f \u2227 f \u2260 g) : a + b + c \u2265 50 \u2228 b + c + d \u2265 50 \u2228 c + d + e \u2265 50 \u2228 d + e + f \u2265 50 \u2228 e + f + g \u2265 50 \u2228 f + g + a \u2265 50 \u2228 g + a + b \u2265 50   :=  by sorry", "compiled": true, "aligned": true}
{"id": "CombStruct4Lean_375", "informal_problem": "56. 17 scientists are corresponding with each other. The correspondence is conducted on three scientific topics. Each pair of scientists corresponds with each other on one topic. Prove that at least three scientists correspond with each other on the same topic.", "formal_statement": "import Mathlib\n\nstructure Correspondence where\n  scientists : Finset (Fin 17)  -- Set of 17 scientists\n  topics : Fin 3               -- Three topics\n  topic_assignment : (Fin 17 \u00d7 Fin 17) \u2192 Fin 3  -- Assignment of topics to pairs\n  valid : \u2200 (i j : Fin 17), i \u2260 j \u2192 \n    topic_assignment (i, j) = topic_assignment (j, i)  -- Symmetric correspondence\n\ntheorem ramsey_correspondence : \n  \u2200 (c : Correspondence), \u2203 (topic : Fin 3) (s1 s2 s3 : Fin 17),\n    s1 \u2260 s2 \u2227 s2 \u2260 s3 \u2227 s1 \u2260 s3 \u2227\n    c.topic_assignment (s1, s2) = topic \u2227\n    c.topic_assignment (s2, s3) = topic \u2227\n    c.topic_assignment (s1, s3) = topic :=\n  sorry", "formal_statement_pred": "theorem lean_workbook_plus_75882 : \u2200 f : (Fin 17) \u2192 (Fin 17) \u2192 Fin 3, (\u2200 i j, f i j = f j i) \u2192 \u2203 i j k : Fin 17, i \u2260 j \u2227 j \u2260 k \u2227 k \u2260 i \u2227 f i j = f j k   :=  by sorry", "compiled": true, "aligned": true}
{"id": "CombStruct4Lean_375", "informal_problem": "56. 17 scientists are corresponding with each other. The correspondence is conducted on three scientific topics. Each pair of scientists corresponds with each other on one topic. Prove that at least three scientists correspond with each other on the same topic.", "formal_statement": "import Mathlib\n\nstructure Correspondence where\n  scientists : Finset (Fin 17)  -- Set of 17 scientists\n  topics : Fin 3               -- Three topics\n  topic_assignment : (Fin 17 \u00d7 Fin 17) \u2192 Fin 3  -- Assignment of topics to pairs\n  valid : \u2200 (i j : Fin 17), i \u2260 j \u2192 \n    topic_assignment (i, j) = topic_assignment (j, i)  -- Symmetric correspondence\n\ntheorem ramsey_correspondence : \n  \u2200 (c : Correspondence), \u2203 (topic : Fin 3) (s1 s2 s3 : Fin 17),\n    s1 \u2260 s2 \u2227 s2 \u2260 s3 \u2227 s1 \u2260 s3 \u2227\n    c.topic_assignment (s1, s2) = topic \u2227\n    c.topic_assignment (s2, s3) = topic \u2227\n    c.topic_assignment (s1, s3) = topic :=\n  sorry", "formal_statement_pred": "theorem lean_workbook_4918 (p1 p2 p3 : Fin 17 \u2192 Fin 17) (hp1 : \u2200 i j, p1 i = p1 j) (hp2 : \u2200 i j, p2 i = p2 j) (hp3 : \u2200 i j, p3 i = p3 j) : \u2203 i j k, (p1 i = p1 j) \u2227 (p2 i = p2 j) \u2227 (p3 i = p3 j) \u2227 (i \u2260 j) \u2227 (j \u2260 k) \u2227 (k \u2260 i)  :=  by sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_376", "informal_problem": "22. Network of Squares. A plane can be covered with equal squares; the nodes of this network in mathematics are called an integer lattice.\n\nCan the nodes be labeled with the letters $a, b, c, d$ such that each composite square has all four letters at its vertices and such that every column and every row of the lattice also contains all four letters?", "formal_statement": "import Mathlib\n\n-- Define the type for our labels\ninductive Label\n  | a | b | c | d\n\n-- A labeling is a function from integer coordinates to labels\nstructure LatticeLabeling\u1d62 where\n  label : \u2124 \u00d7 \u2124 \u2192 Label\n\n-- Check if a 1\u00d71 square has all different labels\ndef hasAllLabels (f : LatticeLabeling\u1d62) (x y : \u2124) : Prop :=\n  let vertices := [(x,y), (x+1,y), (x+1,y+1), (x,y+1)]\n  \u2200 l : Label, \u2203 v \u2208 vertices, f.label v = l\n\n-- Check if a row contains all labels\ndef rowHasAllLabels (f : LatticeLabeling\u1d62) (y : \u2124) : Prop :=\n  \u2200 l : Label, \u2203 x : \u2124, f.label (x,y) = l\n\n-- Check if a column contains all labels\ndef colHasAllLabels (f : LatticeLabeling\u1d62) (x : \u2124) : Prop :=\n  \u2200 l : Label, \u2203 y : \u2124, f.label (x,y) = l\n\ntheorem network_of_squares_labeling :\n  \u2203 (f : LatticeLabeling\u1d62),\n    (\u2200 x y : \u2124, hasAllLabels f x y) \u2227 \n    (\u2200 y : \u2124, rowHasAllLabels f y) \u2227\n    (\u2200 x : \u2124, colHasAllLabels f x) :=\n  sorry", "formal_statement_pred": "theorem lean_workbook_plus_5528 (a b c d : \u211d) : (\u2200 x y : \u2124, \u2200 z : \u2124, (x, y) \u2260 (x, z) \u2227 (x, y) \u2260 (z, y) \u2227 a \u2260 b \u2227 a \u2260 c \u2227 a \u2260 d \u2227 b \u2260 c \u2227 b \u2260 d \u2227 c \u2260 d)   :=  by sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_376", "informal_problem": "22. Network of Squares. A plane can be covered with equal squares; the nodes of this network in mathematics are called an integer lattice.\n\nCan the nodes be labeled with the letters $a, b, c, d$ such that each composite square has all four letters at its vertices and such that every column and every row of the lattice also contains all four letters?", "formal_statement": "import Mathlib\n\n-- Define the type for our labels\ninductive Label\n  | a | b | c | d\n\n-- A labeling is a function from integer coordinates to labels\nstructure LatticeLabeling\u1d62 where\n  label : \u2124 \u00d7 \u2124 \u2192 Label\n\n-- Check if a 1\u00d71 square has all different labels\ndef hasAllLabels (f : LatticeLabeling\u1d62) (x y : \u2124) : Prop :=\n  let vertices := [(x,y), (x+1,y), (x+1,y+1), (x,y+1)]\n  \u2200 l : Label, \u2203 v \u2208 vertices, f.label v = l\n\n-- Check if a row contains all labels\ndef rowHasAllLabels (f : LatticeLabeling\u1d62) (y : \u2124) : Prop :=\n  \u2200 l : Label, \u2203 x : \u2124, f.label (x,y) = l\n\n-- Check if a column contains all labels\ndef colHasAllLabels (f : LatticeLabeling\u1d62) (x : \u2124) : Prop :=\n  \u2200 l : Label, \u2203 y : \u2124, f.label (x,y) = l\n\ntheorem network_of_squares_labeling :\n  \u2203 (f : LatticeLabeling\u1d62),\n    (\u2200 x y : \u2124, hasAllLabels f x y) \u2227 \n    (\u2200 y : \u2124, rowHasAllLabels f y) \u2227\n    (\u2200 x : \u2124, colHasAllLabels f x) :=\n  sorry", "formal_statement_pred": "theorem lean_workbook_41151 (a b c d : \u2124) : \u2203 f : \u2124 \u00d7 \u2124 \u2192 \u2124, (\u2200 x y, f (x, y) = a \u2228 f (x, y) = b \u2228 f (x, y) = c \u2228 f (x, y) = d) \u2227 (\u2200 x y, f (x, y) = a \u2228 f (x, y) = b \u2228 f (x, y) = c \u2228 f (x, y) = d) \u2227 (\u2200 x y, f (x, y) = a \u2228 f (x, y) = b \u2228 f (x, y) = c \u2228 f (x, y) = d)  :=  by sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_379", "informal_problem": "7. Points on a Line. Several points are located on a line. Then, between each pair of adjacent points, another point was placed. This process was repeated several times, after which all the marked points were counted. Could the total number of points be 1998?", "formal_statement": "import Mathlib\n\ndef insert_points (n : Nat) : Nat :=\n  2 * n - 1\n\ndef iterate_insertion (initial_points : Nat) (iterations : Nat) : Nat :=\n  match iterations with\n  | 0 => initial_points\n  | k + 1 => iterate_insertion (insert_points initial_points) k\n\ntheorem points_on_line_1998 : \u00ac\u2203 (initial_points iterations : Nat), \n    initial_points > 0 \u2227 iterate_insertion initial_points iterations = 1998 :=\n  sorry", "formal_statement_pred": "theorem lean_workbook_plus_5674 (n : \u2115) : (\u2203 m, 1 < m \u2227 2^m = 1998) \u2228 (\u2200 m, 2^m \u2260 1998)   :=  by sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_380", "informal_problem": "9. Tetromino. Can a \"chessboard\" $10 \\times 10$ be covered with 25 rectangular tiles of size $4 \\times 1$?", "formal_statement": "import Mathlib\n\nstructure Board where\n  covered : Fin 10 \u2192 Fin 10 \u2192 Bool\n  tiles : Fin 25 \u2192 (Fin 4 \u2192 (Fin 10 \u00d7 Fin 10))\n\n/-- Predicate that checks if a tile placement is valid (no overlaps and within bounds) -/\ndef isValidTilePlacement (b : Board) : Prop :=\n  -- Each tile must be placed horizontally or vertically\n  (\u2200 t : Fin 25, \n    (\u2200 i j : Fin 4, i \u2260 j \u2192 \n      ((b.tiles t i).1 = (b.tiles t j).1 \u2227 ((b.tiles t j).2 - (b.tiles t i).2).val = (j - i).val) \u2228\n      ((b.tiles t i).2 = (b.tiles t j).2 \u2227 ((b.tiles t j).1 - (b.tiles t i).1).val = (j - i).val))) \u2227\n  -- No overlapping tiles\n  (\u2200 t1 t2 : Fin 25, \u2200 i j : Fin 4,\n    t1 \u2260 t2 \u2192 b.tiles t1 i \u2260 b.tiles t2 j) \u2227\n  -- All squares are covered\n  (\u2200 x : Fin 10, \u2200 y : Fin 10,\n    \u2203 t : Fin 25, \u2203 i : Fin 4,\n      b.tiles t i = (x, y))\n\ntheorem tetromino_covering_impossible : \u00ac\u2203 (b : Board), isValidTilePlacement b :=\n  sorry", "formal_statement_pred": "theorem lean_workbook_plus_34199 : False   :=  by sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_380", "informal_problem": "9. Tetromino. Can a \"chessboard\" $10 \\times 10$ be covered with 25 rectangular tiles of size $4 \\times 1$?", "formal_statement": "import Mathlib\n\nstructure Board where\n  covered : Fin 10 \u2192 Fin 10 \u2192 Bool\n  tiles : Fin 25 \u2192 (Fin 4 \u2192 (Fin 10 \u00d7 Fin 10))\n\n/-- Predicate that checks if a tile placement is valid (no overlaps and within bounds) -/\ndef isValidTilePlacement (b : Board) : Prop :=\n  -- Each tile must be placed horizontally or vertically\n  (\u2200 t : Fin 25, \n    (\u2200 i j : Fin 4, i \u2260 j \u2192 \n      ((b.tiles t i).1 = (b.tiles t j).1 \u2227 ((b.tiles t j).2 - (b.tiles t i).2).val = (j - i).val) \u2228\n      ((b.tiles t i).2 = (b.tiles t j).2 \u2227 ((b.tiles t j).1 - (b.tiles t i).1).val = (j - i).val))) \u2227\n  -- No overlapping tiles\n  (\u2200 t1 t2 : Fin 25, \u2200 i j : Fin 4,\n    t1 \u2260 t2 \u2192 b.tiles t1 i \u2260 b.tiles t2 j) \u2227\n  -- All squares are covered\n  (\u2200 x : Fin 10, \u2200 y : Fin 10,\n    \u2203 t : Fin 25, \u2203 i : Fin 4,\n      b.tiles t i = (x, y))\n\ntheorem tetromino_covering_impossible : \u00ac\u2203 (b : Board), isValidTilePlacement b :=\n  sorry", "formal_statement_pred": "theorem lean_workbook_13621 : False  :=  by sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_380", "informal_problem": "9. Tetromino. Can a \"chessboard\" $10 \\times 10$ be covered with 25 rectangular tiles of size $4 \\times 1$?", "formal_statement": "import Mathlib\n\nstructure Board where\n  covered : Fin 10 \u2192 Fin 10 \u2192 Bool\n  tiles : Fin 25 \u2192 (Fin 4 \u2192 (Fin 10 \u00d7 Fin 10))\n\n/-- Predicate that checks if a tile placement is valid (no overlaps and within bounds) -/\ndef isValidTilePlacement (b : Board) : Prop :=\n  -- Each tile must be placed horizontally or vertically\n  (\u2200 t : Fin 25, \n    (\u2200 i j : Fin 4, i \u2260 j \u2192 \n      ((b.tiles t i).1 = (b.tiles t j).1 \u2227 ((b.tiles t j).2 - (b.tiles t i).2).val = (j - i).val) \u2228\n      ((b.tiles t i).2 = (b.tiles t j).2 \u2227 ((b.tiles t j).1 - (b.tiles t i).1).val = (j - i).val))) \u2227\n  -- No overlapping tiles\n  (\u2200 t1 t2 : Fin 25, \u2200 i j : Fin 4,\n    t1 \u2260 t2 \u2192 b.tiles t1 i \u2260 b.tiles t2 j) \u2227\n  -- All squares are covered\n  (\u2200 x : Fin 10, \u2200 y : Fin 10,\n    \u2203 t : Fin 25, \u2203 i : Fin 4,\n      b.tiles t i = (x, y))\n\ntheorem tetromino_covering_impossible : \u00ac\u2203 (b : Board), isValidTilePlacement b :=\n  sorry", "formal_statement_pred": "theorem lean_workbook_32570 : False  :=  by sorry", "compiled": true, "aligned": false}
{"id": "CombStruct4Lean_380", "informal_problem": "9. Tetromino. Can a \"chessboard\" $10 \\times 10$ be covered with 25 rectangular tiles of size $4 \\times 1$?", "formal_statement": "import Mathlib\n\nstructure Board where\n  covered : Fin 10 \u2192 Fin 10 \u2192 Bool\n  tiles : Fin 25 \u2192 (Fin 4 \u2192 (Fin 10 \u00d7 Fin 10))\n\n/-- Predicate that checks if a tile placement is valid (no overlaps and within bounds) -/\ndef isValidTilePlacement (b : Board) : Prop :=\n  -- Each tile must be placed horizontally or vertically\n  (\u2200 t : Fin 25, \n    (\u2200 i j : Fin 4, i \u2260 j \u2192 \n      ((b.tiles t i).1 = (b.tiles t j).1 \u2227 ((b.tiles t j).2 - (b.tiles t i).2).val = (j - i).val) \u2228\n      ((b.tiles t i).2 = (b.tiles t j).2 \u2227 ((b.tiles t j).1 - (b.tiles t i).1).val = (j - i).val))) \u2227\n  -- No overlapping tiles\n  (\u2200 t1 t2 : Fin 25, \u2200 i j : Fin 4,\n    t1 \u2260 t2 \u2192 b.tiles t1 i \u2260 b.tiles t2 j) \u2227\n  -- All squares are covered\n  (\u2200 x : Fin 10, \u2200 y : Fin 10,\n    \u2203 t : Fin 25, \u2203 i : Fin 4,\n      b.tiles t i = (x, y))\n\ntheorem tetromino_covering_impossible : \u00ac\u2203 (b : Board), isValidTilePlacement b :=\n  sorry", "formal_statement_pred": "theorem lean_workbook_plus_69914 : False   :=  by sorry", "compiled": true, "aligned": false}
